#===============================================================================
#
# Device Config Builder
#
# GENERAL DESCRIPTION
#    Contains builder(s) defenitions
#
# Copyright (c) 2015 by Qualcomm Technologies Incorporated.
# All Rights Reserved.
# QUALCOMM Proprietary/GTDR
#
#-------------------------------------------------------------------------------
#
#  $Header: //components/rel/rpm.bf/2.1.3/core/bsp/build/scripts/devcfg_builder.py#1 $
#  $DateTime: 2018/12/26 21:36:05 $
#  $Author: pwbldsvc $
#  $Change: 17934472 $
#                      EDIT HISTORY FOR FILE
#                      
#  This section contains comments describing changes made to the module.
#  Notice that changes are listed in reverse chronological order.
#  
# when       who     what, where, why
# --------   ---     ----------------------------------------------------------------
# 01/27/15   sg      creating env text file for adding path for included header files. 
# 11/14/11   jay     Device Configuration builder implementation
#===============================================================================

import os
import subprocess
import string
import re
import xml.dom.minidom
from SCons.Script import *

#------------------------------------------------------------------------------
# Globals
#------------------------------------------------------------------------------
DEVCFG_ENV_DESCRIPTOR = 'DEVCFG_INFO_COLLECTOR'
DEVCFG_XML = 'devcfg_xml'
DALCFG_DEV_ID = 'dalcfg_id'
PP_XML = 'pp_xml'
H_FILE = 'h_file'


#------------------------------------------------------------------------------
# Hooks for Scons
#------------------------------------------------------------------------------
def exists(env):
    return True

def generate(env):

    rootenv = env.get('IMAGE_ENV')
    rootenv[DEVCFG_ENV_DESCRIPTOR] = []
    
    #Add Builder to generate master xml in env
    devcfg_master_xml_generate(env)
    
    return
    
#===============================================================================
# DEVCFG Master XML build rules
#===============================================================================
def devcfg_master_xml_generate(env):
    
    """
    Generate function for devcfg builder. 
    Sets up the action, scanner and builder function to be called by clients to
    pass xml, devId details to the builder.
    """

    rootenv = env.get('IMAGE_ENV')

    rootenv[DEVCFG_ENV_DESCRIPTOR] = []
    
    # load builder into enviroment
    # Add method to enviroment. 
    # AddDevCfgInfo is the function that needs to be called by the clients to pass
    # dev cfg xml file name with location, devID is needed to be added, APIs needed
    # to compile any .h files included in the xml file.
    rootenv.AddMethod(add_devcfg_info, "AddDevCfgInfo")
    
    # load builder into enviroment
    # Set action_source to None as there are no sources passed into the action function. 
    # If this isn't set explicitly, then build command with verbose=2 fails.
    devcfg_act = env.GetBuilderAction(devcfg_xml_builder, action_source=None)
    devcfg_target_scan = env.Scanner(devcfg_target_scan_func, name='DevCfgTargetScanner')
    devcfg_bld = env.Builder(action = devcfg_act,
                             target_scanner = devcfg_target_scan,
                             suffix = '.xml')
    rootenv.Append(BUILDERS = {'DevcfgBuilder' : devcfg_bld})
    
    return

#===============================================================================
# Scanner for DEVCFG Master XML builder
#===============================================================================    
def devcfg_target_scan_func(node, env, path):
    """
    Scanner adds the include paths to dal config environment which will 
    be used to compile autogenerated c files while rebuilding. This gets
    called from the dal config scons environment.
    """
    rootenv = env.get('IMAGE_ENV')

    #Instead of returning any nodes just add the PP XMLs and H_FILE as deps
    #Before building master xml, define rules to build preprocess and structure header
    [env.Depends(node, sub_dict.get(PP_XML, [])) for sub_dict in  rootenv.get('DEVCFG_INFO_COLLECTOR', [])]
    [env.Depends(node, sub_dict.get(H_FILE, [])) for sub_dict in  rootenv.get('DEVCFG_INFO_COLLECTOR', [])]

    return []

#===============================================================================
# Method exposed by DEV Config Master XML Builder for scanning xml files
#===============================================================================    
def add_devcfg_info(env, targets, thread_input_dict):
    """
    When AddDevCfgInfo is called by the client, this add_devcfg_xml gets invoked in the
    devcfg builder env & the details passed by the clients are stored in a dictionary here.
    """
    #import pdb;pdb.set_trace()
    rootenv = env.get('IMAGE_ENV')
    if rootenv.GetUsesFlag('USES_DEVCFG') is False:
        return
        
    # Dictionary to hold dal device id and device config xml locations
    newDict = {}
    
    # DEVCFG_XML needs to be passed whenever AddDevCfgInfo is called from the client scons file.
    if DEVCFG_XML not in thread_input_dict:
        devcfg_error(env, DEVCFG_XML + 'required')

    # Devcfg xml filename along with the path is stored in the dictionary
    newDict[DEVCFG_XML] = thread_input_dict[DEVCFG_XML]
    # Check to see if the xml file passed through scons exists
    if env.PathExists(newDict[DEVCFG_XML]) is False:
        errStr = 'File not found: ' + str(newDict[DEVCFG_XML])
        devcfg_error(env, errStr)
    
    # Check for duplicates in the xml files passed in
    for grpList in rootenv[DEVCFG_ENV_DESCRIPTOR]:
        if newDict[DEVCFG_XML] == grpList.get(DEVCFG_XML, "BADXMLFILE"):
           # If its a duplicate, do not process
           env.PrintWarning("Duplicate Device Configuration Input File Specified " + str(newDict[DEVCFG_XML]))
           return           
    
    #Full path to the XML file
    xml_fullpath = env.RealPath(newDict.get(DEVCFG_XML))
    #Obtain just the file name + ext
    xml_fname = os.path.basename(xml_fullpath)
    #Preprocess the XML
    pp_xml = env.PreProcess('${BUILDPATH}/' + xml_fname + '.pp', newDict.get(DEVCFG_XML))
    #Cleanup the Preprocessed XML
    pp_xml_cl = env.PreProcessClean('${BUILDPATH}/' + xml_fname + '.i', pp_xml)
    newDict[PP_XML] = pp_xml_cl

    # Add the user supplied info to the rootenv dictionary
    rootenv[DEVCFG_ENV_DESCRIPTOR].append(newDict)
    #print 'rootenv[DEVCFG_ENV_DESCRIPTOR]: ', rootenv[DEVCFG_ENV_DESCRIPTOR]
        
    return
    

def devcfg_xml_builder(target, source, env):
    """
    devcfg_xml_builder gets invoked as its a rule in dal\config\SConscript to create the master xml file
    and DALDeviceId_autogen.h.
    The master xml file will be the #includes of all the xml files passed by the clients.
    DALDeviceId_autogen.h will have #define for all the dal device ids passed thro' the drivers' scons file.
    target[0] will have the master xml location & name.
    target[1] will have the location & name for DALDeviceId_autogen.h.
    """
    rootenv = env.get('IMAGE_ENV')
    
    # Save the caller environment as the APIs for the include files need to be added to
    # the dal config build environment
    caller_env = env
    
    if rootenv.GetUsesFlag('USES_DEVCFG') is False:
        return None
        
    # Creation of master dal xml file
    target_full = env.RealPath(str(target[0]))
    target_env_full = env.RealPath(str(target[1]))
    master_xml = devcfg_create_master_xml_file(rootenv, target_full, target_env_full, env)
    
    return

#===============================================================================
# Internal Module to create master dal xml that include all xml files passed 
# in by various scons files. Invoked from Master XML builder.
#===============================================================================     
def devcfg_create_master_xml_file(env, filepathname, env_filepathname, dalenv):
    """
    devcfg_create_master_xml_file creates the master dal xml file that includes all the 
    xml files passed in by various scons files
    """
    # Determine the module name that needs to be added to the module tag in the xml file
    moduleName = ''
    proc_name = env.get('PROC_CONFIG')
    
    if proc_name == 'wcn':
        moduleName = 'wcn'
    elif proc_name == 'modem':
        moduleName = 'modem'
    elif env.has_key('CORE_SPS'):
        moduleName = 'dsps'
    elif env.has_key('CORE_RPM') or env.has_key('RPM_IMAGE'):
        moduleName = 'rpm'
    elif env.has_key('TZOS_IMAGE'):
        moduleName = 'tz'
    elif env.has_key('BUILD_BOOT_CHAIN') or env.has_key('BUILD_TOOL_CHAIN'):
        moduleName = 'boot'
    elif env.has_key('APPS_PROC'):
        moduleName = 'apps'
    else:
        # If none of the above are applicable, then throw an error to indicate 
        # that a proper build env needs to be present for module name
        devcfg_error(env, 'Need image definition for determining module name for dal master cfg file')
    moduleNameStr = '<module name="' + moduleName + '">\n'
    
    # Create the master xml file and open for writing
    try:
        devcfg_xml_file = open(filepathname, 'w')
        devcfg_env_file = open(env_filepathname, 'w')
    except IOError:
        errStr = 'Could not create dal master XML file' + filepathname
        devcfg_error(env, errStr)

    HeaderList = []
    HeaderPath = []
    
    # Add the include files and the xml header tags
    devcfg_xml_file.write('#include "DALPropDef.h"\n')
    devcfg_xml_file.write('#include "DALDeviceId.h"\n')
    devcfg_xml_file.write('#include "dalconfig.h"\n\n')
    devcfg_xml_file.write('<?xml version="1.0"?>\n')
    devcfg_xml_file.write('<dal>\n')
    devcfg_xml_file.write(moduleNameStr)
    
    # Write all the xml files as #includes in the xml file
    for xml_loc in env[DEVCFG_ENV_DESCRIPTOR]:
        #devcfg_xml_file.write('#include "' + os.path.normpath(xml_loc[DEVCFG_XML]) + '"\n')
        if(xml_loc.has_key(PP_XML)):
            
            pp_cl_file_node = xml_loc[PP_XML][0]
            path_pp_cl_file = xml_loc[PP_XML][0].path
            path_pp_file = re.sub(r'\.i$','.pp',path_pp_cl_file)
            #get Header information (Header files and their Paths) from the corresponding .pp files
            pp_xml_file_fp = open(str(path_pp_file),"r")
            hdr_path_line = ""
            for line in pp_xml_file_fp:
                if line.startswith('#') and (line.find('"') != -1):
                    hdr_path_line = line.split('"')[1]
                    build_root = str(env.get('BUILD_ROOT')).replace('\\', '/')
                    hdr_path_line_new = re.sub('\\\\+','/',hdr_path_line)
                    hdr_path, hdr_file = os.path.split(hdr_path_line_new)
                    if '.h' in hdr_file.lower() and build_root.lower() in hdr_path_line_new.lower() :
                        hdr_file = 'enum_header_path "' + hdr_file + '"\n'
                        if hdr_file not in HeaderList:
                            HeaderList.append(hdr_file)
                            devcfg_xml_file.write(hdr_file)
                        if hdr_path not in HeaderPath:
                            HeaderPath.append(hdr_path)
                            devcfg_env_file.write(hdr_path + "\n")
                            
            pp_xml_file_fp.close()
            devcfg_xml_file.write(pp_cl_file_node.get_contents())
            devcfg_xml_file.write('\n')
    
    # Write the closing tags
    devcfg_xml_file.write('</module>' + '\n')
    devcfg_xml_file.write('</dal>\n')        
        
    # Close the file
    devcfg_xml_file.close()
    devcfg_env_file.close()

    #Store Header Paths extracted to environment
    dalenv.get('CPPPATH').extend(HeaderPath)
    return
    


def devcfg_error(env, Info, Info1=None):
    """
    Error handler for devcfg framework. Info can be a string that describes the error and
    Info1 can be any data that needs to be printed along with the error message.
    """
    env.PrintError("DevCfg error found: " + Info)
    env.PrintError(Info1)
    raise Exception(Info)