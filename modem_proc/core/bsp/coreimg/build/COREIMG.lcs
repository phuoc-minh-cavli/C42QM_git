/*=====================================================================================*/
/* DO NOT EDIT THIS FILE. THIS IS JUST A TEMPLATE USED TO GENERATE DEVCFG_IMG.lcs file */
/*=====================================================================================*/

/* Default linker script, for normal executables */
OUTPUT_FORMAT("elf32-littleqdsp6",
              "elf32-bigqdsp6",
	      "elf32-littleqdsp6")
OUTPUT_ARCH(hexagon)

/* __image_addr_base__ = 0xD1000000;  */
__uncompressed_VA_Clade2__ = 0xD1000000;


/* CLADE2 params */
OUTPUT_ARCH_OPTION(num_16B_entries = 2300)
OUTPUT_ARCH_OPTION(num_32B_entries = 2300)
OUTPUT_ARCH_OPTION(num_48B_entries = 2300)
OUTPUT_ARCH_OPTION(num_64B_entries = 2300)
OUTPUT_ARCH_OPTION(num_16B_freelist_entries = 2300)
OUTPUT_ARCH_OPTION(num_32B_freelist_entries = 2300)
OUTPUT_ARCH_OPTION(num_48B_freelist_entries = 2300)
OUTPUT_ARCH_OPTION(num_64B_freelist_entries = 2300)

/*Anchors must be unique*/
OUTPUT_ARCH_OPTION(anchor0 = 0x20000000)
OUTPUT_ARCH_OPTION(anchor1 = 0xFFFFFFFF)
OUTPUT_ARCH_OPTION(anchor2 = 0xF8F8F8F8)
OUTPUT_ARCH_OPTION(anchor3 = 0x00000001)

ENTRY(start)
SEARCH_DIR("/prj/dsp/qdsp6/austin/builds/hexbuild/branch-3.0/hexframe/16759/linux64/install/BT_201108251930_lnx64/gnu/qdsp6/lib");
  
PHDRS
{
  /* Some SW tools assume the first segment is for debug info. Don't move INIT */
  INIT        PT_LOAD;
  qurt_start   PT_LOAD;
    ukernel_island   PT_LOAD;
    island_data   PT_LOAD;
    island_rodata   PT_LOAD;
    island_text   PT_LOAD;
    ukernel_main   PT_LOAD;
  CODE        PT_LOAD;  
  CONST       PT_LOAD; 
  DATA        PT_LOAD; 
  BSS         PT_LOAD;
  sdata       PT_LOAD;
  clade1_sections               PT_LOAD;  
  candidate_compress_rw			PT_NULL;
  clade2_section				PT_LOAD;
  qsr_string  PT_LOAD;  
  qsr_4_0_msg               PT_LOAD;  

}

SECTIONS
{
    .qurtstart : {} : qurt_start
 . = ADDR(.qurtstart);
  /* Read-only sections, merged into text segment: */
  /*PROVIDE (__executable_start = SEGMENT_START("text-segment", 0)); . = SEGMENT_START("text-segment", 0);*/
/* Start EBI memory. */
  .interp         :
                             { *(.interp) }
  .note.gnu.build-id : { *(.note.gnu.build-id) }
  .hash           :  { *(.hash) }
  .gnu.hash       :  { *(.gnu.hash) }
  .dynsym         :  { *(.dynsym) }
  .dynstr         :  { *(.dynstr) }
  .gnu.version    :  { *(.gnu.version) }
  .gnu.version_d  :  { *(.gnu.version_d) }
  .gnu.version_r  :  { *(.gnu.version_r) }
  .rela.init      :  { *(.rela.init) }
  .rela.text      :  { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }
  .rela.fini      :  { *(.rela.fini) }
  .rela.rodata    :  { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }
  .rela.data.rel.ro   :  { *(.rela.data.rel.ro* .rela.gnu.linkonce.d.rel.ro.*) }
  .rela.data      :  { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }
  .rela.tdata	  :  { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }
  .rela.tbss	  :  { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }
  .rela.ctors     :  { *(.rela.ctors) }
  .rela.dtors     :  { *(.rela.dtors) }
  .rela.got       :  { *(.rela.got) }
  .rela.sdata     :  { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }
  .rela.sbss      :  { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }
  .rela.sdata2    :  { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }
  .rela.sbss2     :  { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }
  .rela.bss       :  { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }
  .rela.iplt      :
    {
      PROVIDE_HIDDEN (__rela_iplt_start = .);
      *(.rela.iplt)
      PROVIDE_HIDDEN (__rela_iplt_end = .);
    }
  .rela.plt       :
    {
      *(.rela.plt)
    }

/*  . = __image_addr_base__; */

  /* QURT_ISLAND_UKERNEL */
  . = ALIGN(4K);
  .data.island : {
    /* ISLAND_BSS */
    /* ISLAND_DATA */
  } : island_data
  /* ISLAND_RW_SECTIONS */
  . = ALIGN(4K);
  .rodata.island : {
    /* ISLAND_RODATA */
  } : island_rodata
  . = ALIGN(64);
  . = MAX(., (ADDR(.rodata.island)+0xFFF) & (-0x1000));
  . = ALIGN(4K);
  .text.island : {
    /* ISLAND_TEXT */
  } : island_text 
  /* ISLAND_RO_SECTIONS */
  .end.island : { . = ALIGN(4K); } : island_text
  . = ALIGN(1M);

/* Code starts. */
  . = ALIGN (DEFINED (TEXTALIGN)? (TEXTALIGN * 1K) : CONSTANT (MAXPAGESIZE));
  .BOOTUP : {} :INIT
  .start          :
  {
    KEEP (*(.start))
  } =0x00c0007f
  .CODE : {}
   . = ALIGN(4K);
  .ukernel.main : { *(*.ukernel.main *.export.main *.ukernel.island *.export.island) }  : ukernel_main  /* Defines .ukernel.main section */
  . = ALIGN(4K);  
  .init           :
  {
    KEEP (*(.init))
    . = ALIGN(4K);
  } =0x00c0007f
  .plt            :   { *(.plt) }
  .iplt           :  { *(.iplt) }
  .text           :
  {
    *(.text.unlikely .text.*_unlikely)
    *(.text.hot .text.hot.* .gnu.linkonce.t.hot.*)
    *(.text .stub .text.* .gnu.linkonce.t.*)
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
  } =0x00c0007f
  .fini           :
  {
    KEEP (*(.fini))
  } =0x00c0007f
  PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
/* Constants start. */

  . = ALIGN(4K);

  __restore_clade2_uncomp_va__ = .;
  . = __uncompressed_VA_Clade2__;
  __clade2_region_pd0_start__ = .;
  .region_clade2 (COMPRESS_RW) :
  {
	__uncached_data_segment_start__ = .;
	*(.uncached.data)
	. = ALIGN(4K);
	__uncached_data_segment_end__ = .;
	*stdiomain.o (.rodata* .data* .bss*)
    *rex_init.o (.rodata* .data* .bss*)
    *qurt_daltf_clade2_rw.o (.rodata* .data* .bss*)
    . = ALIGN(4K);	
  }  : candidate_compress_rw =0x0
  __clade2_region_pd0_end__ = .;
  . = __restore_clade2_uncomp_va__;
  
  /* Definitions for AMSS pool and MODEM pool for heap allocation */
  .pool.space: {*(.pool.space)}
   
  .CONST : {} :CONST
  . = ALIGN (8);
  .rodata         :
        {
          *(.rodata.hot .rodata.hot.* .gnu.linkonce.r.hot.*)
          *(.qsr.*)
          *(.fatal.file.rodata .fatal.file.rodata.*)
          *(.rodata .rodata.* .gnu.linkonce.r.*)
          *(fatal.struct.rodata fatal.struct.rodata. fatal.struct.rodata.*)
          *(fatal.fmt.rodata fatal.fmt.rodata. fatal.fmt.rodata.*)  
        }
  .rodata1        :  { *(.rodata1) }
  .eh_frame_hdr :  { *(.eh_frame_hdr) }
  .eh_frame       :  ONLY_IF_RO { KEEP (*(.eh_frame)) }
  .gcc_except_table   :  ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }
/* Data start. */
  .DATA : {} :DATA
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1));
  . = ALIGN (DEFINED (DATAALIGN)? (DATAALIGN * 1K) : CONSTANT (MAXPAGESIZE));
  /* Exception handling  */
  .eh_frame       :  ONLY_IF_RW { KEEP (*(.eh_frame)) }
  .gcc_except_table   :  ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }
  /* Thread Local Storage sections  */
  .tdata	  :  { *(.tdata .tdata.* .gnu.linkonce.td.*) }
  .tbss		  :  { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }
  .preinit_array     :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  }
  .init_array     :
  {
     PROVIDE_HIDDEN (__init_array_start = .);
     KEEP (*(SORT(.init_array.*)))
     KEEP (*(.init_array))
     PROVIDE_HIDDEN (__init_array_end = .);
  }
  .fini_array     :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(.fini_array))
    KEEP (*(SORT(.fini_array.*)))
    PROVIDE_HIDDEN (__fini_array_end = .);
  }

  .9205_DEVCFG_DATA		:
  {
    *(.9205_DEVCFG_DATA)
  }
  
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP (*crtbegin.o(.ctors))
    KEEP (*crtbegin?.o(.ctors))
    /* We don't want to include the .ctor section from
       the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o fini.o) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*(.ctors))
  }
  .dtors          :
  {
    KEEP (*crtbegin.o(.dtors))
    KEEP (*crtbegin?.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o fini.o) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*(.dtors))
  }
  .jcr            :  { KEEP (*(.jcr)) }
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro* .gnu.linkonce.d.rel.ro.*) }
  .dynamic        :  { *(.dynamic) }
  .got            :  { *(.got) *(.igot) }
  .got.plt        :  { *(.got.plt)  *(.igot.plt) }
  .data           :
  {
    *(.data.hot .data.hot.* .gnu.linkonce.d.hot.*)
    *(.data .data.* .gnu.linkonce.d.*)
    SORT(CONSTRUCTORS)
    KEEP(*(.keep_uncached))
  }
  .data1          :  { *(.data1) }
  _edata = .; PROVIDE (edata = .);
  . = ALIGN (64);
  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss.hot .bss.hot.* .gnu.linkonce.b.hot.*)
   *(.bss .bss.* .gnu.linkonce.b.*)
   *(COMMON)

  /*
   * place the kernel TCM dump into a hallowed out area of the BSS
   *
   * we must specify a user-mode tcm dump area, since bringup builds use both
   * the following flavours:
   *  1) CHIPID.core
   *  2) CHIPID.gen.test image=core,mba
   *
   * Splitting the cust_config.xml/qurt_config.xml will only cover the first
   * case, not the second
   */
  qurt_tcm_dump = .;
  . += 512K; /* occasionally check that this value matches qurt_tcm_dump_size */

   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections. */
   . = ALIGN(. != 0 ? 64 : 1);
  } :BSS
  . = ALIGN(64);
  _end = .;
/* Small data start. */
  . = ALIGN (DEFINED (DATAALIGN)? (DATAALIGN * 1K) : 512K);
  . = ALIGN (64);
  .SDATA : {} : sdata
  .sdata          :
  {
    __default_sda_base__ = .;
    PROVIDE (_SDA_BASE_ = .);
    *(.sdata.1 .sdata.1.* .gnu.linkonce.s.1.*)
    *(.sbss.1 .sbss.1.* .gnu.linkonce.sb.1.*)
    *(.scommon.1 .scommon.1.*)
    *(.sdata.2 .sdata.2.* .gnu.linkonce.s.2.*)
    *(.sbss.2 .sbss.2.* .gnu.linkonce.sb.2.*)
    *(.scommon.2 .scommon.2.*)
    *(.sdata.4 .sdata.4.* .gnu.linkonce.s.4.*)
    *(.sbss.4 .sbss.4.* .gnu.linkonce.sb.4.*)
    *(.scommon.4 .scommon.4.*)
    *(.lit[a4] .lit[a4].* .gnu.linkonce.l[a4].*)
    *(.sdata.8 .sdata.8.* .gnu.linkonce.s.8.*)
    *(.sbss.8 .sbss.8.* .gnu.linkonce.sb.8.*)
    *(.scommon.8 .scommon.8.*)
    *(.lit8 .lit8.* .gnu.linkonce.l8.*)
    *(.sdata.hot .sdata.hot.* .gnu.linkonce.s.hot.*)
    *(.sdata .sdata.* .gnu.linkonce.s.*)
  }
  . = ALIGN (64);
  .sbss           :
  {
    PROVIDE (__sbss_start = .);
    PROVIDE (___sbss_start = .);
    *(.dynsbss)
    *(.sbss.hot .sbss.hot.* .gnu.linkonce.sb.hot.*)
    *(.sbss .sbss.* .gnu.linkonce.sb.*)
    *(.scommon .scommon.*)
    . = ALIGN (. != 0 ? 64 : 1);
    PROVIDE (__sbss_end = .);
    PROVIDE (___sbss_end = .);
    . = ALIGN(0x1000);
  }

  . = ALIGN(4096);
  /* Used for qshrink version 2.0/3.0 */
  QSR_STRING :
  {
   *(QSR_STR.fmt.rodata.*)
  } : qsr_string

  . = ALIGN(0x1000);
  __save_qshrink_addr = .;
  INCLUDE ../../core/bsp/coreimg/build/qshrink_MODEM_PROC.lcs
  . = __save_qshrink_addr;

  .clade.comp : {
    __clade_comp_pd0_start__ = .;
    *(.clade.comp)
    . = ALIGN(64K);
    __clade_comp_pd0_end__ = .;
  } :clade1_sections

  /* CLADE2 compress section rules -- START */
  . = ALIGN (64K);
  .clade2.comp : {
    __clade2_comp_start__ = .;
    *(.clade2.comp)
    . = ALIGN(4K);
    __clade2_comp_end__ = .;
  } :clade2_section

  . = ALIGN (64K);
  .clade2.metadata : {
    __clade2_metadata_pd0_start__ = .;
    *(.clade2.metadata)
    __clade2_metadata_pd0_end__ = .;
  } :clade2_section

  . = ALIGN(64);
  .clade2.16B_free_list : {
    __clade2_16B_free_list_start__ = .;
    *(.clade2.16B_free_list)
    . = ALIGN(64);
    __clade2_16B_free_list_end__ = .;
  } :clade2_section
  . = ALIGN(64);
  .clade2.32B_free_list : {
    __clade2_32B_free_list_start__ = .;
    *(.clade2.32B_free_list)
    . = ALIGN(64);
    __clade2_32B_free_list_end__ = .;
  } :clade2_section
  . = ALIGN(64);
  .clade2.48B_free_list : {
    __clade2_48B_free_list_start__ = .;
    *(.clade2.48B_free_list)
    . = ALIGN(64);
    __clade2_48B_free_list_end__ = .;
  } :clade2_section
  . = ALIGN(64);
  .clade2.64B_free_list : {
    __clade2_64B_free_list_start__ = .;
    *(.clade2.64B_free_list)
    . = ALIGN(64);
    __clade2_64B_free_list_end__ = .;
  } :clade2_section
  . = ALIGN(4);
  .clade2.regs : {
   __clade2_regs_start__ = .;
   *(.clade2.regs)
   __clade2_regs_end__ = .;
  } :clade2_section

  /* CLADE2 compress section rules -- END */

  PROVIDE (end = .); 


  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* DWARF 3 */
  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges   0 : { *(.debug_ranges) }
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }
}
