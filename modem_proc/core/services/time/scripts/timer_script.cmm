;============================================================================
;============================================================================
;  Name:
;    TIMER_SCRIPT.CMM
;
;  Description:
;    This script is used to help with the development 
;     and debugging of timers and timer clients.
;
; Copyright (c) 2013 QUALCOMM Technologies Incorporated.  
; All Rights Reserved.
; Qualcomm Confidential and Proprietary
;----------------------------------------------------------------------------
;============================================================================
;
;                        EDIT HISTORY FOR MODULE
;
; when        who       what, where, why
; ----------  --------  -----------------------------------------------------
; 12/11/2013  c_adubey  Added some additional checks
; 04/14/2013  cpaulo    Created.
;============================================================================;

GLOBAL &is_b_family
GLOBAL &ret_get_timer_index
GLOBAL &processing_duration_entered
GLOBAL &next_expiry_val
GLOBAL &output_directory
GLOBAL &output_to_csv
GLOBAL &current_time
GLOBAL &current_time_from_str
GLOBAL &arg1
GLOBAL &arg2
GLOBAL &timer_group_list_check_ret
GLOBAL &check_timetick_internal_ret
GLOBAL &check_bin_in_list_ret
GLOBAL &get_IFH_ret_cid
GLOBAL &get_IFH_ret_timer_idx
GLOBAL &tt_from_interrupts
GLOBAL &tt_from_intr_str
GLOBAL &num_index_ret
GLOBAL &index_iterator_ret
GLOBAL &get_next_timetick_val_ret
GLOBAL &check_partial_log_ret
GLOBAL &check_if_tt_is_offset_ret
GLOBAL &list_loop_check_ret
GLOBAL &check_for_ptr_in_arr_ret
GLOBAL &check_for_ptr_in_list_ret
GLOBAL &get_merged_logs_filename_ret
GLOBAL &timer_check_timer_handle_mapping_ret

;============================================================================
; Global Defines

&FALSE=0x0
&TRUE=0x1

;============================================================================
; Variables for getting the debug variable informations into merged logs

&debug_var0x1="timer_sets"								
&debug_var0x2="timers_expired_slave1"
&debug_var0x3="timers_expired_slave2"
&debug_var0x4="timers_expired_slave3"
&debug_var0x5="timer_expired_debug"
&debug_var0x6="timers_expired"
&debug_var0x7="timer_trace"
&debug_var0x8="record_match_val"
&debug_var0x9="timer_api_calls"
&debug_var0x0A="timer_defer_undefer_reference_count_log"
&debug_var0x0B="timers_remote_expired"
&debug_var0x0C="timer_clr_log"

&debug_var_tt_name0x1="ts"
&debug_var_tt_name0x2="processing_started"
&debug_var_tt_name0x3="processing_started"
&debug_var_tt_name0x4="processing_started"
&debug_var_tt_name0x5="ts"
&debug_var_tt_name0x6="processing_started"
&debug_var_tt_name0x7="ts"
&debug_var_tt_name0x8="timer_now_supplied"
&debug_var_tt_name0x9="ts"
&debug_var_tt_name0x0A="ts"
&debug_var_tt_name0x0B="processing_started"
&debug_var_tt_name0x0C="ts"

&debug_var_extra0x1=0x0
&debug_var_extra0x2=0x0
&debug_var_extra0x3=0x0
&debug_var_extra0x4=0x0
&debug_var_extra0x5=0x0
&debug_var_extra0x6=0x0
&debug_var_extra0x7="events"
&debug_var_extra0x8=0x0
&debug_var_extra0x9=0x0
&debug_var_extra0x0A=0x0
&debug_var_extra0x0B=0x0
&debug_var_extra0x0C=0x0

&number_of_debug_vars=0x0C

&len_timer_sets=0
&index_timer_sets=0
&iterator_timer_sets=0
&first_traversal_timer_sets=0
&IS_THERE_timer_sets=&FALSE
&timetick_jump_timer_sets=&TRUE

&len_timers_expired=0
&index_timers_expired=0
&iterator_timers_expired=0
&first_traversal_timers_expired=0
&IS_THERE_timers_expired=&FALSE
&timetick_jump_timers_expired=&TRUE

&len_timer_expired_debug=0
&index_timer_expired_debug=0
&iterator_timer_expired_debug=0
&first_traversal_timer_expired_debug=0
&IS_THERE_timer_expired_debug=&FALSE
&timetick_jump_timer_expired_debug=&TRUE

&len_timers_expired_slave1=0
&index_timers_expired_slave1=0
&iterator_timers_expired_slave1=0
&first_traversal_timers_expired_slave1=0
&IS_THERE_timers_expired_slave1=&FALSE
&timetick_jump_timers_expired_slave1=&TRUE

&len_timers_expired_slave2=0
&index_timers_expired_slave2=0
&iterator_timers_expired_slave2=0
&first_traversal_timers_expired_slave2=0
&IS_THERE_timers_expired_slave2=&FALSE
&timetick_jump_timers_expired_slave2=&TRUE

&len_timers_expired_slave3=0
&index_timers_expired_slave3=0
&iterator_timers_expired_slave3=0
&first_traversal_timers_expired_slave3=0
&IS_THERE_timers_expired_slave3=&FALSE
&timetick_jump_timers_expired_slave3=&TRUE

&len_timer_trace=0
&index_timer_trace=0
&iterator_timer_trace=0
&first_traversal_timer_trace=0
&IS_THERE_timer_trace=&FALSE
&timetick_jump_timer_trace=&TRUE

&len_record_match_val=0
&index_record_match_val=0
&iterator_record_match_val=0
&first_traversal_record_match_val=0
&IS_THERE_record_match_val=&FALSE
&timetick_jump_record_match_val=&TRUE

&len_timer_api_calls=0
&index_timer_api_calls=0
&iterator_timer_api_calls=0
&first_traversal_timer_api_calls=0
&IS_THERE_timer_api_calls=&FALSE
&timetick_jump_timer_api_calls=&TRUE

&len_timer_defer_undefer_reference_count_log=0
&index_timer_defer_undefer_reference_count_log=0
&iterator_timer_defer_undefer_reference_count_log=0
&first_traversal_timer_defer_undefer_reference_count_log=0
&IS_THERE_timer_defer_undefer_reference_count_log=&FALSE
&timetick_jump_timer_defer_undefer_reference_count_log=&TRUE

&len_timers_remote_expired=0
&index_timers_remote_expired=0
&iterator_timers_remote_expired=0
&first_traversal_timers_remote_expired=0
&IS_THERE_timers_remote_expired=&FALSE
&timetick_jump_timers_remote_expired=&TRUE

&len_timer_clr_log=0
&index_timer_clr_log=0
&iterator_timer_clr_log=0
&first_traversal_timer_clr_log=0
&IS_THERE_timer_clr_log=&FALSE
&timetick_jump_timer_clr_log=&TRUE

&print_line_counter=1

;============================================================================

;============================================================================
; Get the arguments passed in.
;============================================================================
ENTRY &arg1_in &arg2_in &destination

&Presult=0
WE.AREA.RESet
WE.WINPOS 0. 0. 35% 100%
WE.AREA.Create TIMER
;WE.AREA.view TIMER
AREA TIMER
;RADIX.DECIMAL
;setup.var.%SYMBOL
;setup.var.%HEX
  
  ; Setup vars to use hex, strings, symbols & index 
  SETUP.VAR %H %S %Y %I

  ; setup the scrip variables to use hex symbols
  radix HEX


GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "                       TIMER DEBUG SCRIPT                             "
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "

&output_directory="C:\temp"
&output_to_csv=1
&processing_duration_entered=0

GOSUB PRINT_HELPER "Main Option: &arg1_in"
GOSUB PRINT_HELPER "Sub-menu Option: &arg2_in"
GOSUB PRINT_HELPER "Dest: &destination"

IF "&destination"==""
(
  GOSUB PRINT_HELPER "No destination directory listed!"
)
ELSE
(
  &output_directory="&destination"
)

&arg1=&arg1_in 
&arg2=&arg2_in

; Get current time
GOSUB ESTIMATE_CURRENT_TIME
GOSUB PRINT_HELPER "----------------------------------------------------------------------"
GOSUB PRINT_HELPER "Minimal check for timetick consistency,Cache status & timer interrupts"
GOSUB PRINT_HELPER "----------------------------------------------------------------------"
GOSUB CHECK_FOR_TIMETICK &TRUE
;GOSUB GENERAL_TIMER_DEBUG
;GOSUB PRINT_MERGED_LOGS
GOSUB CHECK_ATS_MISSING_CR
GOSUB CHECK_CACHE_FLUSH_STATUS
GOSUB CHECK_DISABLED_PENDING_INTERRUPTS
GOSUB CHECK_ATS_MISSING_INTERRUPT

;============================================================================
; Print the main menu contents, list options here.
;============================================================================

MENUSTART:
&print_line_counter=1
&inMainOption=""
&inSubOption=""
&numOptions=5
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER "                       M a i n   M e n u                              "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "1: Auto Debug "
GOSUB PRINT_HELPER "2: Self Debug "
GOSUB PRINT_HELPER "3: Power Debug "
GOSUB PRINT_HELPER "4: Display Chained link list "
GOSUB PRINT_HELPER "0: Exit "
GOSUB PRINT_HELPER ""

IF "&arg2"!=""
(
  &inSubOption=&arg2
  &arg2=""
)

IF "&arg1"==""
(
  ; Get input option
  enter &inMainOption
  GOSUB PRINT_HELPER " "
)
ELSE
(
  &inMainOption=&arg1
  &arg1=""
)

; Verify input option
IF "&inMainOption"==""  
(
  GOTO MENUSTART
)

if &inMainOption>&numOptions
(
  GOSUB PRINT_HELPER "Option not supported! Option Entered: &inMainOption Options Supported: &numOptions "
  GOSUB PRINT_HELPER " "
  GOTO MENUSTART
)

GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "Option &inMainOption input"
GOSUB PRINT_HELPER " "

; Option 1
if &inMainOption==1
(
  GOSUB MENUSTART_AUTO_DEBUG &inSubOption
)

; Option 2
if &inMainOption==2
(
  GOSUB MENUSTART_SELF_DEBUG &inSubOption
)

; Option 3
if &inMainOption==3
(
  GOSUB MENUSTART_POWER_DEBUG &inSubOption
)

; Option 4
if &inMainOption==4
(
  GOSUB MENUSTART_CHAINED_LIST
)

; Option 5
if &inMainOption==5
(
  GOSUB PRINT_UDS_LOGS
)

; Option 0
if &inMainOption==0
(
  GOSUB PRINT_HELPER "Exiting Timer Script..."
  ENDDO
)


; End, go back to the start
GOTO MENUSTART

ENDDO

MENUSTART_SELF_DEBUG:
&print_line_counter=1
ENTRY &arg_self
&numOptions=10
&inMainOptionSelf=0
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER "                     S e l f   D e b u g                              "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "1: Check timer linked list "
GOSUB PRINT_HELPER "2: Traverse through timer linked list "
GOSUB PRINT_HELPER "3: Get Timer Information "
GOSUB PRINT_HELPER "4: Check Recent Match Values "
GOSUB PRINT_HELPER "5: Check Recently Expired Timers "
GOSUB PRINT_HELPER "6: Check Timer Trace "
GOSUB PRINT_HELPER "7: Check Timers Set "
GOSUB PRINT_HELPER "8: Print Merged Timer Logs "
GOSUB PRINT_HELPER "9: Check Timetick Jumps & Current time "
GOSUB PRINT_HELPER "0: Exit "
GOSUB PRINT_HELPER ""

IF "&arg_self"==""
(
  ; Get input option
  enter &inMainOptionSelf
  GOSUB PRINT_HELPER " "
)
ELSE
(
  &inMainOptionSelf=&arg_self
)

; Verify input option
IF "&inMainOptionSelf"==""
(
  GOTO MENUSTART_SELF_DEBUG
)

; Verify input option
if &inMainOptionSelf>&numOptions
(
  GOSUB PRINT_HELPER "Option not supported! Option Entered: &inMainOption Options Supported: &numOptions "
  GOSUB PRINT_HELPER " "
  GOTO MENUSTART_SELF_DEBUG
)

GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "Option &inMainOptionSelf input"
GOSUB PRINT_HELPER " "

; Option 1
if &inMainOptionSelf==1
(
  GOSUB TIMER_LIST
  GOTO MENUSTART_SELF_DEBUG
)

; Option 2
if &inMainOptionSelf==2
(
  GOSUB TRAVERSE_TIMER_LIST
  GOTO MENUSTART_SELF_DEBUG
)

; Option 3
if &inMainOptionSelf==3
(
  GOSUB GET_TIMER_INFO
  GOTO MENUSTART_SELF_DEBUG
)

; Option 4
if &inMainOptionSelf==4
(
  GOSUB PRINT_RECENT_MATCH_VALUES
  GOTO MENUSTART_SELF_DEBUG
)

; Option 5
if &inMainOptionSelf==5
(
  GOSUB TIMERS_EXPIRED
  GOTO MENUSTART_SELF_DEBUG
)

; Option 6
if &inMainOptionSelf==6
(
  GOSUB TIMER_TRACE
  GOTO MENUSTART_SELF_DEBUG
)

; Option 7
if &inMainOptionSelf==7
(
  GOSUB TIMER_SETS
  GOTO MENUSTART_SELF_DEBUG
)

; Option 8
if &inMainOptionSelf==8
(
  GOSUB PRINT_MERGED_LOGS
  GOTO MENUSTART_SELF_DEBUG
)

; Option 9
if &inMainOptionSelf==9
(
  GOSUB CHECK_FOR_TIMETICK &TRUE
  GOTO MENUSTART_SELF_DEBUG
)

; Option 0
if &inMainOptionSelf==0
(
  GOSUB PRINT_HELPER "Exiting Self Debug..."
  RETURN
)

RETURN

GOSUB GENERAL_TIMER_DEBUG

RETURN

MENUSTART_CHAINED_LIST:
&print_line_counter=1
ENTRY &arg_power
&numOptions=5
&inMainOptionPower=0
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER "              C h a i n e d   l i n k   l i s t                       "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "1: Active timers List"
GOSUB PRINT_HELPER "2: Priority timers (p0_active) List"
GOSUB PRINT_HELPER "3: Timer groups List"
GOSUB PRINT_HELPER "4: Timer Bin Pool List"
GOSUB PRINT_HELPER "5: Timer_Free_Q list"
GOSUB PRINT_HELPER "0: Exit"
GOSUB PRINT_HELPER ""

IF "&arg_power"==""
(
  ; Get input option
  enter &inMainOptionPower
  GOSUB PRINT_HELPER " "
)
ELSE
(
  &inMainOptionPower=&arg_power
)

; Verify input option
IF "&inMainOptionPower"==""
(
  GOTO MENUSTART_CHAINED_LIST
)

; Verify input option
if &inMainOptionPower>&numOptions
(
  GOSUB PRINT_HELPER "Option not supported! Option Entered: &inMainOption Options Supported: &numOptions "
  GOSUB PRINT_HELPER " "
  GOSUB MENUSTART_CHAINED_LIST
)

GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "Option &inMainOptionPower input"
GOSUB PRINT_HELPER " "

; Option 1
if &inMainOptionPower==1
(
  	v.fixedchain %s %o %hex *(\timer\timers.active.list.first) (*(\timer\timers.active.list.first)).next
	v.fixedchain %s %o %hex *(\timer\timers.active.list.last) (*(\timer\timers.active.list.last)).prev
	GOSUB MENUSTART_CHAINED_LIST
)

; Option 2
if &inMainOptionPower==2
(
  	v.fixedchain %s %o %hex *(\timer\timers.p0_active.list.first) (*(\timer\timers.p0_active.list.first)).next
	v.fixedchain %s %o %hex *(\timer\timers.p0_active.list.last) (*(\timer\timers.p0_active.list.last)).prev
	GOSUB MENUSTART_CHAINED_LIST
)
; Option 3
if &inMainOptionPower==3
(
   v.fixedchain %s %o %hex \timer\timers.active (\timer\timers.active).next
   GOSUB MENUSTART_CHAINED_LIST
)

; Option 4
if &inMainOptionPower==4
(
   	v.fixedchain %s %o %hex *(\timer\timers.bins.first) (*(\timer\timers.bins.first)).next_bin
	v.fixedchain %s %o %hex *(\timer\timers.bins.last) (*(\timer\timers.bins.last)).prev_bin
	GOSUB MENUSTART_CHAINED_LIST
)

; Option 5
if &inMainOptionPower==5
(
   	v.fixedchain %s %o %hex *(timer_free_q.link.next_ptr) (timer_free_q.link.next_ptr).next_ptr
	GOSUB MENUSTART_CHAINED_LIST
)

; Option 0
if &inMainOptionPower==0
(
  RETURN
)

RETURN


MENUSTART_AUTO_DEBUG:
&print_line_counter=1
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER "                      A u t o   D e b u g                             "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER ""

GOSUB GENERAL_TIMER_DEBUG

RETURN

MENUSTART_POWER_DEBUG:
&print_line_counter=1
ENTRY &arg_power
&numOptions=2
&inMainOptionPower=0
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER "                     P o w e r   D e b u g                            "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "1: Find wakeup durations "
GOSUB PRINT_HELPER "2: Find Non-deferrable Timers"
GOSUB PRINT_HELPER "0: Exit "
GOSUB PRINT_HELPER ""

IF "&arg_power"==""
(
  ; Get input option
  enter &inMainOptionPower
  GOSUB PRINT_HELPER " "
)
ELSE
(
  &inMainOptionPower=&arg_power
)

; Verify input option
IF "&inMainOptionPower"==""
(
  GOTO MENUSTART_POWER_DEBUG
)

; Verify input option
if &inMainOptionPower>&numOptions
(
  GOSUB PRINT_HELPER "Option not supported! Option Entered: &inMainOption Options Supported: &numOptions "
  GOSUB PRINT_HELPER " "
  GOSUB MENUSTART_POWER_DEBUG
)

GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "Option &inMainOptionPower input"
GOSUB PRINT_HELPER " "

; Option 1
if &inMainOptionPower==1
(
  GOSUB TIMER_WAKEUP_DURATIONS
  GOTO MENUSTART_POWER_DEBUG
)

; Option 2
if &inMainOptionPower==2
(
  GOSUB TIMER_FIND_NON_DEFERRABLE_TIMERS
  GOTO MENUSTART_POWER_DEBUG
)

; Option 0
if &inMainOptionPower==0
(
  GOSUB PRINT_HELPER "Exiting Self Debug..."
  RETURN
)

RETURN

;============================================================================
; Subroutines go here.
;============================================================================

; Clear Window after each action
CLEAR_WINDOW:
  AREA.CLEAR INTRMENU
  AREA.RESET
RETURN

;============================================================================
; Check if the current timetick is already passed the interrupt match count
;============================================================================
CHECK_ATS_MISSING_INTERRUPT:

 &intr_expected_count=var.value(\timer\timers.set_value)
 &timers_processing=v.value(\timer\timers.processing)

 &timer_isr_delay=&current_time-&intr_expected_count
 &isr_time_val=v.value(\timer\timers.isr_time)
 
 var.if (&intr_expected_count<&current_time)
  (
   IF &timers_processing!=1
    (
      GOSUB PRINT_HELPER "- Missing/Delayed ATS timer interrupt"
	  ;GOSUB PRINT_HELPER ""
	  GOSUB PRINT_HELPER "  : Delayed by       = &timer_isr_delay"
	  GOSUB PRINT_HELPER "  : Current Timetick = &current_time"
      GOSUB PRINT_HELPER "  : ISR Expected at  = &intr_expected_count"
	  GOSUB PRINT_HELPER "  : Last ISR time    = &isr_time_val"
	  GOSUB PRINT_HELPER ""
    )  
  )

RETURN

;============================================================================
; Subroutines for checking Cache Flush Status
;============================================================================
CHECK_CACHE_FLUSH_STATUS:

&addr_flush_var=0x0
&rain_check_on_sym=0x0a

 if (&is_b_family==&TRUE)
  (
    &rain_check_on_sym=y.type(QURTK_flush_cache_status)
    IF &rain_check_on_sym==0x1
       &addr_flush_var=var.value(&QURTK_flush_cache_status)
  )
 else  
  (
    &rain_check_on_sym=y.type(BLASTK_flush_cache_status)
    IF &rain_check_on_sym==0x1  
     &addr_flush_var=var.value(&BLASTK_flush_cache_status)
  )  

 IF &rain_check_on_sym==0x1
  &cache_flush_status=var.value(*(uint32*)&addr_flush_var)
 else
  &cache_flush_status=0x11
 
 if (&cache_flush_status==0x1)
  (
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER "- Cache is properly Flushed."
    ;GOSUB PRINT_HELPER ""	 
  )
 else if (&cache_flush_status==0x11)
  (
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER "- Cache flush check skipped."
    ;GOSUB PRINT_HELPER ""	 
  )  
 else
  (
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER "- Cache is not Flushed. Dump vars are not reliable"
    GOSUB PRINT_HELPER ""	   
  )

RETURN


;============================================================================
; Subroutines for checking Cache Flush Status
;============================================================================
CHECK_DISABLED_PENDING_INTERRUPTS:

&addr_l2vic_enabled=0x0
&addr_l2vic_pending=0x0
&rain_check_on_sym=0x0a

 if (&is_b_family==&TRUE)
  (
    &rain_check_on_sym=y.type(QURTK_l2vic_enable_table_dump)
    IF &rain_check_on_sym==0x1
       &addr_l2vic_enabled=var.value(&QURTK_l2vic_enable_table_dump)

    &rain_check_on_sym=y.type(QURTK_l2vic_pending_table_dump)
    IF &rain_check_on_sym==0x1
       &addr_l2vic_pending=var.value(&QURTK_l2vic_pending_table_dump)
  )
 else
  (
    RETURN
  )

  if (&addr_l2vic_enabled!=0x0)
  (
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER "- Timer Interrupt status"
    &val_l2vic_enabled=var.value(*(uint32*)&addr_l2vic_enabled)
    &timer_irq_enabled=&val_l2vic_enabled&0x8
	if (&timer_irq_enabled==0x8)
	 (
       GOSUB PRINT_HELPER "  : Enabled = TRUE"
	 )
	else
	 (
       GOSUB PRINT_HELPER "  : Enabled = FALSE"
       GOSUB PRINT_HELPER ""	 
	 )	
  )

  if (&addr_l2vic_pending!=0x0)
  (
    &val_l2vic_pending=var.value(*(uint32*)&addr_l2vic_pending)
    &timer_irq_pending=&val_l2vic_pending&0x8
	if (&timer_irq_pending==0x8)
	 (
       GOSUB PRINT_HELPER "  : Pending = YES"
       GOSUB PRINT_HELPER ""	 
	 )
	else
	 (
       GOSUB PRINT_HELPER "  : Pending = NO"
       GOSUB PRINT_HELPER ""	 	 	   
	 )
  )

RETURN

;============================================================================
; Subroutines for checking missing CR's
;============================================================================
CHECK_ATS_MISSING_CR:

if (&is_b_family==&TRUE)
  (
    &timer_handle=v.value(dog_wakeup_timer.timer_handle)
	&timer_handle=&timer_handle&0xFFFFFFFF
	var.if (&timer_handle!=0x0)
	(
	 &timer_handle_xored=&timer_handle&0xFF000000
 	 var.if (&timer_handle_xored!=0xC3000000)
      (
	   if (&timer_handle!=0xDEADDEAD)
	    (
         GOSUB PRINT_HELPER ""
         GOSUB PRINT_HELPER "- CR 500838 (XOR based timer handle algorithm) not present."
         GOSUB PRINT_HELPER ""	 
		)
	  )
	)
	else
	(
       GOSUB PRINT_HELPER ""
       GOSUB PRINT_HELPER "- CR 500838 checking not done because of errors, please check manually."
       GOSUB PRINT_HELPER ""	 
	)
  )
else
  (
  if (&len_timers_expired_slave1==0x1E)  
     (
      GOSUB PRINT_HELPER ""
      GOSUB PRINT_HELPER "CR 361893 (Increase in Timer slave command queue size) not present."
      GOSUB PRINT_HELPER ""	   
	 )
  )

RETURN

;============================================================================
; Internal subroutine for the handling of the uds log printing
;============================================================================
GET_GROUP_FROM_HANDLE:
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER "                      Get Group from handle                           "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER ""
GOSUB PRINT_HELPER "Enter the group handle : "
GOSUB PRINT_HELPER ""
ENTER &in_group_handle
GOSUB PRINT_HELPER ""

  &in_group_handle=0x00000000FFFFFFFF&&in_group_handle

  ; values for handle comparision
  &GROUP_HANDLE_CONST=0XC3C3FFFF
  &GET_HANDLE_ONLY=0x0000FFFF


  &group_index=&in_group_handle&&GET_HANDLE_ONLY
  
  &gp_hndle_up=&in_group_handle^&GROUP_HANDLE_CONST
  &gp_hndle_up=&gp_hndle_up&0xFFFF0000
  &gp_hndle_up=&gp_hndle_up>>0x10
  &gp_hndle_dn=&in_group_handle&&GET_HANDLE_ONLY
  
  if (&gp_hndle_dn!=&gp_hndle_up)
	(
	  GOSUB PRINT_HELPER "Incorrect Group Handle entered"
	  RETURN
	)

  var.if (&group_index<0x0 || &group_index>0x40)	
	(
	  GOSUB PRINT_HELPER "Group index out ou bounds"
	  RETURN
	)   

  &name_grp=v.string(timer_internal_groups[&group_index])	
  &ext_self=v.string(timer_internal_groups[&group_index].ext_self)
  &disabled=v.value(timer_internal_groups[&group_index].disabled)
  &deferrable=v.value(timer_internal_groups[&group_index].deferrable)
  GOSUB PRINT_HELPER "Group : &name_grp"
  GOSUB PRINT_HELPER "  ext_self   = &ext_self"
  GOSUB PRINT_HELPER "  disabled   = &disabled"
  GOSUB PRINT_HELPER "  deferrable = &deferrable"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
	
RETURN

;============================================================================
; Internal subroutine for the handling of the uds log printing
;============================================================================
PRINT_UDS_LOGS_INTERNAL:
  ENTRY &debug_var &timetick_var &force

  &is_there=Y.TYPE(&debug_var)
  var.if (&is_there==0x3 || &force==0x1)
   (
   	&total_size=v.sizeof(&debug_var)
	&unit_size=v.sizeof(&debug_var[0])
	&num_indexes=v.value(&total_size / &unit_size)
	
	&index_iterator=0x0
	
	while (&index_iterator<&num_indexes)
	  (
	    &timetick_val=v.value(&debug_var[&index_iterator].&timetick_var)
		&debug_var_str=var.string(&debug_var[&index_iterator])
		WRITE #7 "&timetick_val, &debug_var[&index_iterator] = , &debug_var_str"
	    &index_iterator=&index_iterator+0x1
	  )
   )
  else
   (
     GOSUB PRINT_HELPER "Timer-services debug var : '&debug_var' not available"
   )

RETURN
   
;============================================================================
; Print the UDS logs in CSV format (in unsorted form)
;============================================================================
PRINT_UDS_LOGS:
  
  &uds_filename="timer_services_debug_vars.csv"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER "                      Printing UDS Logs                              "
GOSUB PRINT_HELPER "######################################################################"
GOSUB PRINT_HELPER " "
GOSUB PRINT_HELPER ""

  OPEN #7 &uds_filename /CREATE

  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timer_sets ts 0x0
  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timers_expired_slave1 processing_started 0x0
  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timers_expired_slave2 processing_started 0x0
  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timers_expired_slave3 processing_started 0x0
  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timer_expired_debug ts 0x0
  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timers_expired processing_started 0x0
  GOSUB PRINT_HELPER "... "
  
  ; Additional check for timer_trace
  &is_there_tt=Y.TYPE(timer_trace)
  if (&is_there_tt==0x3)
    (
    GOSUB PRINT_UDS_LOGS_INTERNAL timer_trace.events ts 0x1
	)
  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL record_match_val timer_now_supplied 0x0
  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timer_api_calls ts 0x0
  GOSUB PRINT_HELPER "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timer_defer_undefer_reference_count_log ts 0x0

;------- Interrupt logs -------
   ; Have to think something for this section
   
  CLOSE #7

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Completed printing the unified logs to : '&uds_filename'"
  GOSUB PRINT_HELPER ""

RETURN

;============================================================================
; Finds the largest timetick from the debug_log & checks for timetick jump
;============================================================================
PRINT_PROCESSING_TIMER_INFO:
  ENTRY &tmr_ext
  
  GOSUB PRINT_HELPER "Information of the Client Timer under processing :: "
  
   
    &tmr_ext_handle=v.value(((timer_type*)&tmr_ext)->timer_handle)
    &tmr_ext_group=v.value(((timer_type*)&tmr_ext)->group)
    &tmr_ext_handle=v.value(((timer_type*)&tmr_ext)->timer_handle)
	GOSUB GET_TIMER_INDEX &tmr_ext_handle 0x0
    &tmr_int_handle=&ret_get_timer_index
    &tmr_int=v.value(((timer_type*)&timer_buffer[&tmr_int_handle]))
    IF (&tmr_ext_group!=0)&&(v.value(((timer_group_type*)&tmr_ext_group)->disabled)<=1)&&(v.value(((timer_group_type*)&tmr_ext_group)->deferrable)<=1)
    (
	  GOSUB PRINT_HELPER "External timer info : "
	  GOSUB PRINT_EXT_TIMER_INFO &tmr_ext
      WINPOS 60% 0.0 40% 30% 0. 0. L1Info
	  var.addwatch %OPEN.1 (timer_type*)&tmr_ext
	  var.if (&ret_get_timer_index!=0xDEADD00D)
	  (
		var.if (&tmr_ext_handle!=-1 && &tmr_ext_handle!=0xDEADDEAD && &tmr_ext_handle!=0xFFFFFFFFDEADDEAD)
		(
			GOSUB EXTERNAL_TIMER_SANITY_CHECK &tmr_ext 0x1
			
			GOSUB PRINT_HELPER "Internal timer info (corresponding to the above external timer): "
			GOSUB PRINT_TIMER_INFO &tmr_int 1
			var.addwatch %OPEN.1 (timer_ptr_internal_type)&tmr_int
			GOSUB INTERNAL_TIMER_SANITY_CHECK &tmr_int 0x1
		    GOSUB INTERNAL_EXTERNAL_TIMER_MATCH &tmr_int &tmr_ext 0x1
			GOSUB PRINT_HELPER ""
			GOSUB PRINT_HELPER "Both the timers also added to the watch window above"
		)
	  )
    )
    ELSE
    (
      GOSUB PRINT_HELPER "Timer does not appear to be properly setup, or is corrupted! Exiting..."
    )
  
  
RETURN

;============================================================================
; Finds the largest timetick from the debug_log & checks for timetick jump
;============================================================================
CHECK_IF_TT_IS_OFFSET:
  ENTRY &timetick_value
  
  &check_if_tt_is_offset_ret=&TRUE
  
  &tt_offset=0x0
  
  &tmr_ptr=v.value(\timer\timers.active.list.first)
  
  if (&tmr_ptr!=0x0)
    (
	 	&tt_offset=v.value(((timer_internal_type*)&tmr_ptr)->sclk_delta)
	)
	
  if (&timetick_value==&tt_offset)
    (
	  &check_if_tt_is_offset_ret=&FALSE
	)
  
RETURN

;============================================================================
; Finds the largest timetick from the debug_log & checks for timetick jump
;============================================================================
CHECK_TIMETICK_INTERNAL:
  ENTRY &debug_var &timetick_var
  
  &tt_jump_index_string=""
  &check_timetick_internal_ret=0x0
  &num_index_ret=0x0
  &index_iterator_ret=0x0
  
  ; Exception for timer_trace
  &timer_trace_false_positive=0
  &is_timer_trace=&FALSE
  
  IF "&debug_var"=="timer_trace.events"
    (
      &is_timer_trace=&TRUE
	  &timer_trace_false_positive=0xF
    )
  
  &timetick_jump=0x0
  &prev_timetick_val=0x0
  &largest_timetick_val=0x0
  &last_index_for_jump=0x0

  &total_size=v.sizeof(&debug_var)
  &unit_size=v.sizeof(&debug_var[0])
  &num_indexes=v.value(&total_size / &unit_size)
	
  &num_index_ret=&num_indexes
  &len_&debug_var_name=&num_index_ret
	
  &index_iterator=0x0
	
  while (&index_iterator<&num_indexes)
	  (
	    &timetick_val=v.value(&debug_var[&index_iterator].&timetick_var)
		if (&timetick_val!=0x0)
		  (
		  GOSUB CHECK_IF_TT_IS_OFFSET &timetick_val
		  if (&check_if_tt_is_offset_ret==&FALSE)
		   (
		     GOSUB PRINT_HELPER "&debug_var[&index_iterator].&timetick_var=&timetick_val is just the sclk offset, i.e. RGPT timetick count is returned as ZERO"
		   )
		  )

		if (&index_iterator==0x0)
		  (
		  &prev_timetick_val=&timetick_val
		  )
		else
		  (
		    if (&prev_timetick_val>&timetick_val)
			 (
			   &timetick_jump=&timetick_jump+1
			   if (&timetick_jump>1)
			     (
				  &tt_jump_index_string="&tt_jump_index_string"+"[&last_index_for_jump], "
				  if &is_timer_trace==&TRUE
				    (
					&event_id=v.value(&debug_var[&last_index_for_jump].event)
					var.if &event_id==0
					   &timer_trace_false_positive=&timer_trace_false_positive+1
					)
				 )
			   &last_index_for_jump=&index_iterator
			 )
		   &prev_timetick_val=&timetick_val
		  )
	    
		if (&largest_timetick_val<=&timetick_val)
		  (
		    &index_iterator_ret=&index_iterator
		    &largest_timetick_val=&timetick_val
		  )
		&index_iterator=&index_iterator+0x1
	  )

	if (&timetick_jump>1)
	(

    ; We have not accounted for the last jump index 
	&tt_jump_index_string="&tt_jump_index_string"+"[&last_index_for_jump], "
	
	; Check for the timer_trace false timetick alarm
	if &is_timer_trace==&TRUE
	 (
		&event_id=v.value(&debug_var[&last_index_for_jump].event)
		var.if &event_id==0
           &timer_trace_false_positive=&timer_trace_false_positive+1

        &tmp_index_iterator=&index_iterator_ret+1;
		if (&tmp_index_iterator==&num_indexes)
		  (
		    &tmp_index_iterator=0
		  )
		   
        if (&timer_trace_false_positive==&timetick_jump+0xF)
		  (
		    &event_id=v.value(&debug_var[&tmp_index_iterator].event)
			if &event_id==0
			  &timer_trace_false_positive=0
		  )
        if (&timer_trace_false_positive==&timetick_jump+0xE)
		  (
		    &event_id=v.value(&debug_var[&tmp_index_iterator].event)
			if &event_id!=0
			  &timer_trace_false_positive=0
		  )		  
	 )	
		
		var.if (&is_timer_trace==&TRUE && &timer_trace_false_positive==0)
		  (
		    GOSUB PRINT_HELPER "Skipped timer_trace timetick variation for ISR events"
			&check_timetick_internal_ret=&largest_timetick_val
			GOSUB PRINT_HELPER ""
		  )		
	    else
		  (
	       &check_timetick_internal_ret=0xF00DF00D
	       &index_iterator_ret=0xFEEFD00D
		   GOSUB PRINT_HELPER "Timetick Jump Encountered in the debug var"
		   GOSUB PRINT_HELPER "'&debug_var' @ indexes :"
		   GOSUB PRINT_HELPER "&tt_jump_index_string"
		   GOSUB PRINT_HELPER ""
		  )
	 )
	else
	 (
	   &check_timetick_internal_ret=&largest_timetick_val
	 )
	 
RETURN

;============================================================================
; Subroutine to check timetick jump & get the latest timetick value.
;============================================================================
CHECK_FOR_TIMETICK_DEREF:
  ENTRY &debug_var_name &tt_storage_type &extn
  
  &rain_check=Y.TYPE(&debug_var_name)
  var.if (&rain_check==0x3)
  (
   &IS_THERE_&debug_var_name=&TRUE
   if ("&extn"!="0x0")
    (
	  &debug_var_name_2="&debug_var_name"+".&extn"
	  GOSUB CHECK_TIMETICK_INTERNAL &debug_var_name_2 &tt_storage_type
	)
   else
    (
      GOSUB CHECK_TIMETICK_INTERNAL &debug_var_name &tt_storage_type
	)
   var.if (&check_timetick_internal_ret!=0xF00DF00D)
    (
      &timetick_jump_&debug_var_name=&FALSE
	
	; Setup the debug var params once & for all
      &len_&debug_var_name=&num_index_ret
      &index_&debug_var_name=&index_iterator_ret+0x1
   
	  &&deref_index="&index_&debug_var_name"
	  if (&deref_index==&num_index_ret)
	     (
 	     &index_&debug_var_name=0x0
		 )

      if (&current_time<&check_timetick_internal_ret)
	   (
	    &&deref_idx="&index_&debug_var_name"
		&deref_idx=&deref_idx-0x1
		if (&deref_idx<0x0)
		 (
		   &&deref_idx="&len_&debug_var_name"
		   &deref_idx=&deref_idx-0x1
		 )
	    &current_time_from_str="&debug_var_name[&deref_idx]"
	    &current_time=&check_timetick_internal_ret
	   )
    )
  )

RETURN


;============================================================================
; Subroutine to check timetick jump & get the latest timetick value.
;============================================================================
CHECK_FOR_TIMERS_UNDER_PROCESSING:
  ENTRY &debug_var_n
  
 &index_itr=0x0
 &&deref_length="&len_&debug_var_n"

 &&deref_is_there_n="&IS_THERE_&debug_var_n"
 &&deref_tt_jump_n="&timetick_jump_&debug_var_n"
  
  ;var.if (&deref_is_there_n==&FALSE || &deref_tt_jump_n==&TRUE)
  var.if (&deref_is_there_n==&FALSE)
   (
    RETURN
   )
 
 while (&index_itr<&deref_length)
 (
  &processing_val=v.value(&debug_var_n[&index_itr].processing_time)
  var.if (&processing_val==0xDEADBEEFD00DFEED || &processing_val==0xDEADBEEF)
   (
 	 &client_tmr_ptr=v.string(&debug_var_n[&index_itr].timer_expired)
	 GOSUB PRINT_HELPER ""
     GOSUB PRINT_HELPER "Expired timers still under processing, logged in = &debug_var_n[&index_itr]"
	 GOSUB PRINT_HELPER "timer=&client_tmr_ptr"
	 &client_tmr_ptr=v.value(&debug_var_n[&index_itr].timer_expired)
	 GOSUB PRINT_PROCESSING_TIMER_INFO &client_tmr_ptr
   )
  &index_itr=&index_itr+0x1
 )
 
RETURN

;============================================================================
; Subroutine to check timetick jump & get the latest timetick value.
;============================================================================
CHECK_FOR_TIMETICK:
 ENTRY &check_deadbeef
 &current_time=0x0
 &iterator=0x1
 &timetick_from_str=""

 while (&iterator<=&number_of_debug_vars)
   (
     ; Get the debug var name from the iterator
	 &&deref_debug_var_name="&debug_var&iterator"
	 &&deref_debug_tt_name="&debug_var_tt_name&iterator"
	 &&deref_debug_extn="&debug_var_extra&iterator"
	 
	 GOSUB CHECK_FOR_TIMETICK_DEREF &deref_debug_var_name &deref_debug_tt_name &deref_debug_extn
	
	if (&check_deadbeef!=&FALSE)
	(
	 var.if (&iterator==0x2 || &iterator==0x3 || &iterator==0x4 || &iterator==0x6)
	  (
	   ; Check for timers still under processing 
	   GOSUB CHECK_FOR_TIMERS_UNDER_PROCESSING &deref_debug_var_name
	  )	 
	)
	 ; increment the iterator
     &iterator=&iterator+0x1
   )
   
   &timetick_from_str="&current_time_from_str"

   ; Compare the largest obtained timetick value with timers.isr
   &tt_from_timers=v.value(\timer\timers.isr_time)
   if (&tt_from_timers>&current_time)
	(
	  &timetick_from_str="\timer\timers.isr_time"
	  &current_time=&tt_from_timers
	)

; Compare the largest obtained timetick value with the interrupt logs timetick value 
   if (&tt_from_interrupts>&current_time)
	(
	  &timetick_from_str="&tt_from_intr_str"
	  &current_time=&tt_from_interrupts
	)   
   
   GOSUB PRINT_HELPER "- Current Timetick Estimate = &current_time"
   GOSUB PRINT_HELPER "  Obtained from &timetick_from_str"
   
  
RETURN

;============================================================================
; Timer group list checking.
;============================================================================
TIMER_GROUP_LIST_CHECK:
  ENTRY &operation &timer_group_address
  ; &operation can be passed as 1 to check for a aprticular group address validity

  &timer_group_list_check_ret=0x0
  &break_thold=0xFF
  &group_start=v.value(&\timer\timers.active)
  &group_type="(timer_group_ptr)"
  &group_ptr=v.value((&group_type&group_start)->next)
  &last_group=&group_start
  &last_last_group=&group_start
  &grp_count=0x0
  &sym_grp=""

  if (&operation!=0x1)
   (
    GOSUB PRINT_HELPER "--- Timer group list checking ---"
   )
  
  var.if (&operation==0x1 && &group_start==&timer_group_address)
   (
     &timer_group_list_check_ret=0x1
	 &operation=0x0
     RETURN
   )
 
  var.if (&group_ptr==0x0)
	(
	  &sym_grp=v.string(&group_type&last_group)
	  if (&operation!=0x1)
	   (
	    GOSUB PRINT_HELPER "!! Group list seems incorrect or not yet initialized : &sym_grp"
		GOSUB PRINT_HELPER ""
	   )
	  &operation=0x0
	  RETURN
	)

  while &group_ptr!=&group_start
	(
      var.if (&operation==0x1 && &group_ptr==&timer_group_address)
        (
           &timer_group_list_check_ret=0x1
		   &operation=0x0
		   RETURN
		)
		
		&group_ptr=v.value((&group_type&group_ptr)->next)
		
		var.if (&group_ptr==0x0)
			(
			  if (&operation!=0x1)
	          (
			   &sym_grp=v.string(&group_type&last_group)
			  
			   GOSUB PRINT_HELPER "!! Group corrupted :           &sym_grp"
			   &sym_grp1=v.string(&group_type&group_ptr)
			   GOSUB PRINT_HELPER "(&group_type&sym_grp)->next  = &sym_grp1"
			   &sym_grp2=v.string(&group_type&last_last_group)
			   GOSUB PRINT_HELPER "(&group_type&sym_grp2)->next = &sym_grp"
			   GOSUB PRINT_HELPER ""
			  )
			  &operation=0x0
			  RETURN
			)
		&last_group=&group_ptr
		if &grp_count>=1
			(
			  &last_last_group=v.value((&group_type&last_last_group)->next)
			)
		
		&grp_count=&grp_count+1
		var.if (&grp_count>=&break_thold)
			(
			  if (&operation!=0x1)
			  (
			   GOSUB PRINT_HELPER "!! Suspicious group list, too many groups (more than &break_thold)"
			   GOSUB PRINT_HELPER ""
			  )
			  &operation=0x0
			  RETURN
			)
	)
	
  &grp_count=&grp_count-1

  if (&operation!=0x1)
  (
   GOSUB PRINT_HELPER "Group list is correct & proper"
   GOSUB PRINT_HELPER "Total groups = &grp_count"
   GOSUB PRINT_HELPER ""
  )

&operation=0x0
RETURN

;============================================================================
; Internal timer Sanity checking Subroutine.
;============================================================================
TIMER_CHECK_TIMER_HANDLE_MAPPING:
  ENTRY &int_timer &ext_timer

  &ext_timer_local=&ext_timer&0xFFFFFFFF
  &int_timer_local=&int_timer&0xFFFFFFFF
  
  &ext_timer_handle=0x0
  &is_XOR_handle=&FALSE
  &index_from_ext_timer=0xFFFFFFFF
  &corrupted_handle=&FALSE
  &MAGIC_VAL=0xC3C3
  &ext_timer_string=0x0
  &ext_timer_handle=0x0

  if (&ext_timer_local==0x0)
    &ext_timer_local=var.value(((timer_internal_type*)&int_timer)->timer_ext)
  
  &ext_timer_string=var.string((timer_type*)&ext_timer_local)
  &ext_timer_handle=var.value(((timer_type*)&ext_timer_local)->timer_handle)
  &ext_timer_handle=&ext_timer_handle&0xFFFFFFFF
  &top_byte=&ext_timer_handle>>0x18
  if (&top_byte==0xC3)
    &is_XOR_handle=&TRUE
  else if (&top_byte!=0x0)
    &corrupted_handle=&TRUE
  
  ; Get the index if XOR based handle
  var.if (&corrupted_handle==&FALSE && &is_XOR_handle==&TRUE)
    (
      &ext_timer_handle_U=&ext_timer_handle>>0x10
 	 &ext_timer_handle_L=&ext_timer_handle&0xFFFF
 	 &magic_val_from_handle=&ext_timer_handle_U^&ext_timer_handle_L
 	 if (&magic_val_from_handle!=&MAGIC_VAL)
 	   (
 	    &corrupted_handle=&TRUE
 	   )
      else
 	   (
 	    &index_from_ext_timer=&ext_timer_handle_L
 	   )
    )
 
  ; Get the index if normal handle is there
  var.if (&corrupted_handle==&FALSE && &is_XOR_handle==&FALSE)
    (
 	 &index_from_ext_timer=&ext_timer_handle-1
    )

   ; Finally check if the index from external timer is valid or not
   &sizeof_timer_buffer=v.sizeof(timer_buffer)/v.sizeof(timer_buffer[0])
   var.if (&index_from_ext_timer<&sizeof_timer_buffer && &index_from_ext_timer>=0)
     &corrupted_handle=&FALSE
   else
     &corrupted_handle=&TRUE

  ; Corrupted handle error message
  if (&corrupted_handle==&TRUE)
   (
     GOSUB PRINT_HELPER "ERROR : &ext_timer_string->timer_handle is corrupt = &ext_timer_handle"
   )
  else
   (
    if (&int_timer_local==0x0)
      &int_timer_local=var.value(&timer_buffer[&index_from_ext_timer])
   )

    &int_timer_string=var.string((timer_internal_type*)&int_timer_local)
   ; Since both internal timer & external one is provided
   ; just check for the mapping in between them & return
   
   ; Internal to external mapping
   &timer_ext_addr=var.value(((timer_internal_type*)&int_timer_local)->timer_ext)
   if (&ext_timer_local!=&timer_ext_addr)
    (
	  GOSUB PRINT_HELPER "ERROR : &int_timer_string->timer_ext not pointing to &ext_timer_string"
	)
   
   ; external to internal mapping
   if (&corrupted_handle==&FALSE)
    (
	  &addr_from_index=var.value(&timer_buffer[&index_from_ext_timer])
     if (&addr_from_index!=&int_timer_local)
        GOSUB PRINT_HELPER "ERROR : &ext_timer_string->timer_handle not pointing back to &int_timer_string"
	)
  
RETURN

;============================================================================
; Internal timer Sanity checking Subroutine.
;============================================================================
INTERNAL_TIMER_SANITY_CHECK:
  ENTRY &internal_timer_addr &silent_sanity_check

  &test_result=0x1
  &internal_timer_str=var.string((timer_internal_type*)&internal_timer_addr)
  
  if (&silent_sanity_check!=0x0)
  GOSUB PRINT_HELPER "-- Sanity test for the internal timer : &internal_timer_str ---"
  
  ;--------------------------------------------------------------------------
  ; Check the links next/prev pointer values
  &link_next_val=var.value(((timer_internal_type*)&internal_timer_addr)->link.next_ptr)
  &link_prev_val=var.value(((timer_internal_type*)&internal_timer_addr)->link.prev_ptr)
  var.if (&link_next_val!=0x0 || &link_prev_val!=0x0)
	(
	  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - link's next/prev pointer seem to be having some corrupt value "
	)

  ;--------------------------------------------------------------------------
  ; Check the internal timers index vaue
  &index_val=var.value(((timer_internal_type*)&internal_timer_addr)->index)
  &addr_from_index=var.value(&timer_buffer[&index_val])
  if (&internal_timer_addr!=&addr_from_index)
	(
	  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - index value is not pointing back to the same timer"
	  &test_result=0x0
	)	
	
  ;--------------------------------------------------------------------------
  ; Check the group sanity for the timer
  &group_var=var.value(((timer_internal_type*)&internal_timer_addr)->group)
  if (&group_var==0x0)
	(
	  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - group is NULL"
	  &test_result=0x0
	)
  else
    (
	  GOSUB TIMER_GROUP_LIST_CHECK 0x1 &group_var
	  if (&timer_group_list_check_ret!=0x1)
	   (
	     GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - group is not in the timers active group list"
	   )
	  &deferrable_val=var.value(((timer_group_type*)&group_var)->deferrable)
	  var.if (&deferrable_val!=0x0 && &deferrable_val!=0x1)
	    (
		  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - group->deferrable is incorrect"
		  &test_result=0x0
		)
	  &disabled_val=var.value(((timer_group_type*)&group_var)->disabled)
	  var.if (&disabled_val!=0x0 && &disabled_val!=0x1)
	    (
		  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - group->disabled is incorrect"
		  &test_result=0x0
		)		
	)

  ;--------------------------------------------------------------------------
  ; Check the tcb sanity (maybe by checking whether the tcb pointer is some symbol only)
; Y.TYPE not working for checking symbols which are inside some structures
;  &type_ret=Y.TYPE(((timer_internal_type*)&internal_timer_addr)->tcb)
;  if (&type_ret==0x3)
;	(
;	  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - tcb seems incorrect"
;     &test_result=0x0
;	)

  ;--------------------------------------------------------------------------	
  ; Check if the sigs is not NULL, then tcb should also not be
  &sigs_var=var.value(((timer_internal_type*)&internal_timer_addr)->sigs)
  if (&sigs_var!=0x0)
	(
	  &tcb_var=var.value(((timer_internal_type*)&internal_timer_addr)->tcb)
	  if (&tcb_var==0x0)
	    (
		  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - tcb is NULL while signal mask is not"
		  &test_result=0x0
		)
	)

  ;--------------------------------------------------------------------------	
  ; Check if func1 or func2 is there, they should only be pointing to function addresses
;  &func_val=var.value(((timer_internal_type*)&internal_timer_addr)->func1)
;  if (&func_val!=0x0)
;	(
;	  &func_name=Y.FUNCTION(P:&func_val)
;	  if "&func_name"==""
;	    (
;		  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - func1 seems to be incorrect"
;		  &test_result=0x0
;		)
;	)
;  &func_val=var.value(((timer_internal_type*)&internal_timer_addr)->func2)
;  if (&func_val!=0x0)
;	(
;	  &func_name=Y.FUNCTION(P:&func_val)
;	  if "&func_name"==""
;	    (
;		  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - func2 seems to be incorrect"
;		  &test_result=0x0
;		)
;	)

  ;--------------------------------------------------------------------------	
  ; check the timers list pointer	
  &list_val=var.value(((timer_internal_type*)&internal_timer_addr)->list)
  &active_list_val=v.value(&\timer\timers.active.list)
  &p0_active_list_val=&active_list_val
  if (&is_b_family==&TRUE)
      &p0_active_list_val=v.value(&\timer\timers.p0_active.list)

  &p0_active_timer=&FALSE
  
  if (&list_val==&p0_active_list_val)
    (
	  &p0_active_timer=&TRUE  
	)
  var.if (&list_val!=&active_list_val && &p0_active_timer!=&TRUE)
	(
	  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - list not pointing to active timer list"
	  &test_result=0x0
	)

  ;--------------------------------------------------------------------------	
  ; Minimal cache structure checking
  &reload_from_cache=var.value(((timer_internal_type*)&internal_timer_addr)->cache.reload_sclk)
  &reload_val=var.value(((timer_internal_type*)&internal_timer_addr)->reload)
  if (&reload_val!=&reload_from_cache)
	(
	  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - reload is not matching with the value in cache"
	  &test_result=0x0
	)	

  ;--------------------------------------------------------------------------	
  ; Checking for internal timer's next & prev pointers sanity
  ; Really bad logic used here (couldn't find any better way)
  &next_val=var.value(((timer_internal_type*)&internal_timer_addr)->next)
  &prev_val=var.value(((timer_internal_type*)&internal_timer_addr)->prev)
  &next_found=0x0
  &prev_found=0x0
  &iterator_aliter=0x0
  
  ; Calculate num elements in  timer_buffer array
  &size_timer_buffer=v.sizeof(timer_buffer)
  &timer_buffer_unit_size=v.sizeof(timer_buffer[0])
  &size_timer_buffer=v.value(&size_timer_buffer / &timer_buffer_unit_size)
  
  ; Go in a while loop searching every timer address to match with next & prev pointers
  while (&iterator_aliter<&size_timer_buffer)
    (
	  &t_buff_addr=var.value(&timer_buffer[&iterator_aliter])
	  if (&next_val==&t_buff_addr)
		&next_found=0x1
	  if (&prev_val==&t_buff_addr)
		&prev_found=0x1
	
	  var.if (&next_found==0x1 && &prev_found==0x1)
	    &iterator_aliter=0xFF
	  
	  &iterator_aliter=&iterator_aliter+1
	)
	
  if (&next_found==0x0)
    (
      &last_timer_from_list=var.value(\timer\timers.active.list->last)
	  var.if (&last_timer_from_list==&internal_timer_addr && &next_val==0x0)
	  else
	   (
	    if (&p0_active_timer!=&TRUE)
		(
	    GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - next pointer is corrupted"
	    &test_result=0x0
		)
	   )
    )
  if (&prev_found==0x0)
    (
	  &first_timer_from_list=var.value(\timer\timers.active.list->first)
	  var.if (&first_timer_from_list==&internal_timer_addr && &prev_val==0x0)
	  else
	   (
	   	if (&p0_active_timer!=&TRUE)
		(
	    GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - prev pointer is corrupted"
	    &test_result=0x0
		)
	   )
    )

  ;--------------------------------------------------------------------------	
  ; Bin pointer value checking
  &bin_addr_val=var.value(((timer_internal_type*)&internal_timer_addr)->bin)
  &bin_found=0x0
  &iterator_aliter=0x0
  
  ; Calculate num elements in  timer_bin_pool array
  &size_timer_bin_pool=v.sizeof(timer_bin_pool)
  &timer_bin_pool_unit_size=v.sizeof(timer_bin_pool[0])
  &size_timer_bin_pool=v.value(&size_timer_bin_pool / &timer_bin_pool_unit_size)
  
  ; Go in a while loop searching every timer_bin_pool address to match with bin pointers
  while (&iterator_aliter<&size_timer_bin_pool)
    (
	  &t_bin_addr=var.value(&timer_bin_pool[&iterator_aliter])
	  if (&bin_addr_val==&t_bin_addr)
	    (
		  &bin_found=0x1
		  &iterator_aliter=0x7F
		)
	  &iterator_aliter=&iterator_aliter+1
	)
	
  if (&bin_found==0x0)
    (
	  if (&p0_active_timer==&TRUE)
	  (
	    if (&bin_addr_val!=0x0)
		 (
		   GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - bin pointer is corrupted"
		   &test_result=0x0
		 )
	  )
	  else
	  (
	  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - bin pointer is corrupted"
	  &test_result=0x0
	  )
	  
    )

  ;--------------------------------------------------------------------------	
  ; Check for internal->external->internal timer mapping correctness
  GOSUB TIMER_CHECK_TIMER_HANDLE_MAPPING &internal_timer_addr 0x0
  
  ;--------------------------------------------------------------------------	
  ; Check for the queue status of the timer
  &int_q_val=var.value(((timer_internal_type*)&internal_timer_addr)->internal_q)
  if (&int_q_val!=0x0CACACAC)
	(
	  &test_result=0x0
	  if (&int_q_val==0x0BABABAB)
		(
	    GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - internal_q is showing it is in FREE Queue"
		)
	  else 
	    (
	    GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - internal_q is corrupted"
		)
	)

  ;--------------------------------------------------------------------------	
  ; check for the timers slave task assignment
  &slave_num_val=var.value(((timer_internal_type*)&internal_timer_addr)->slave_task_assigned)
  var.if (&slave_num_val!=0x0 && &slave_num_val!=0x1 && &slave_num_val!=0x2)
	(
	  var.if (&p0_active_timer==&TRUE && &slave_num_val!=0xFF)
	  (
	  GOSUB PRINT_HELPER "!! Internal timer: &internal_timer_str - slave task number is invalid"
	  &test_result=0x0
	  )
	)

  	
  if (&silent_sanity_check!=0x0)
   (
   if (&test_result==0x0)
	(
	  GOSUB PRINT_HELPER "Sanity check for the timer failed : result above"
	)
  else
    (
	  GOSUB PRINT_HELPER "Internal Timer structure seems sane"
	)
  GOSUB PRINT_HELPER ""
   )
	
RETURN

;============================================================================
; External timer Sanity checking Subroutine.
;============================================================================
EXTERNAL_TIMER_SANITY_CHECK:
  ENTRY &external_timer_address &silent_int_sanity

  &ex_test_result=0x1
  &ex_external_timer_str=var.string((timer_type*)&external_timer_address)
  if (&silent_int_sanity!=0x0)
  GOSUB PRINT_HELPER "--- Sanity test for the external timer : &ex_external_timer_str ---"

  ;--------------------------------------------------------------------------
  ; Check the group sanity for the timer
  &ex_group_var=var.value(((timer_type*)&external_timer_address)->group)
  if (&ex_group_var==0x0)
	(
	  GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - group is NULL"
	  &ex_test_result=0x0
	)
  else
    (
	  GOSUB TIMER_GROUP_LIST_CHECK 0x1 &ex_group_var
	  if (&timer_group_list_check_ret!=0x1)
	   (
	     GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - not in the timers active group list"
		 &ex_test_result=0x0
	   )	
	  &ex_deferrable_val=var.value(((timer_group_type*)&ex_group_var)->deferrable)
	  var.if (&ex_deferrable_val!=0x0 && &ex_deferrable_val!=0x1)
	    (
		  GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - group->deferrable is incorrect"
		  &ex_test_result=0x0
		)
	  &ex_disabled_val=var.value(((timer_group_type*)&ex_group_var)->disabled)
	  var.if (&ex_disabled_val!=0x0 && &ex_disabled_val!=0x1)
	    (
		  GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - group->disabled is incorrect"
		  &ex_test_result=0x0
		)		
	)

  ;--------------------------------------------------------------------------
  ; Check the tcb sanity (maybe by checking whether the tcb pointer is some symbol only)
; Y.TYPE not working for checking symbols which are inside some structures
;  &ex_type_ret=Y.TYPE(((timer_type*)&external_timer_address)->tcb)
;  if (&ex_type_ret==0x3)
;	(
;	  GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - tcb seems incorrect"
;     &ex_test_result=0x0
;	)

  ;--------------------------------------------------------------------------	
  ; Check if internal-external timer mapping is correct
  GOSUB TIMER_CHECK_TIMER_HANDLE_MAPPING 0x0 &external_timer_address

  ;--------------------------------------------------------------------------	
  ; Check if the sigs is not NULL, then tcb should also not be
  &ex_sigs_var=var.value(((timer_type*)&external_timer_address)->sigs)
  if (&ex_sigs_var!=0x0)
	(
	  &ex_tcb_var=var.value(((timer_type*)&external_timer_address)->tcb)
	  if (&ex_tcb_var==0x0)
	    (
	      GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - tcb is NULL while signal mask is not"
		  &ex_test_result=0x0
		)
	)

  ;--------------------------------------------------------------------------	
  ; Check if func1 or func2 is there, they should only be pointing to function addresses
;  &ex_func_val=var.value(((timer_type*)&external_timer_address)->func1)
;  if (&ex_func_val!=0x0)
;	(
;	  &ex_func_name=Y.FUNCTION(P:&ex_func_val)
;	  if "&ex_func_name"==""
;	    (
;		  GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - func1 seems to be incorrect"
;		  &ex_test_result=0x0
;		)
;	)
;  &ex_func_val=var.value(((timer_type*)&external_timer_address)->func2)
;  if (&ex_func_val!=0x0)
;	(
;	  &ex_func_name=Y.FUNCTION(P:&ex_func_val)
;	  if "&ex_func_name"==""
;	    (
;		  GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - func2 seems to be incorrect"
;		  &ex_test_result=0x0
;		)
;	)  

  ;--------------------------------------------------------------------------	
  ; Check if timer_state is a valid value only
  &ex_timer_state=var.value(((timer_type*)&external_timer_address)->timer_state)
  var.if (&ex_timer_state<0x0FEDCBA9 || &ex_timer_state>0x0FEDCBAE)
	(
	  GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - Unknown timer state value"
	  &ex_test_result=0x0
	)
  else
	(
	  var.if (&ex_timer_state!=0x0FEDCBAE && &ex_timer_state!=0x0FEDCBAA)
	    (
         &ex_tmr_handle=var.value(((timer_type*)&external_timer_address)->timer_handle)
		 var.if (&ex_tmr_handle!=-1 && &ex_tmr_handle!=0xDEADDEAD && &ex_tmr_handle!=0xFFFFFFFFDEADDEAD)
		  (
		   &ex_test_result=0x0
		   GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - state is neither SET / RESUMED & the timer_handle is containing some value"
		  )			
		)
	)  
	
	;--------------------------------------------------------------------------	
  ; check for the timers slave task assignment
  &ex_slave_num_val=var.value(((timer_type*)&external_timer_address)->slave_task_assignment)
  var.if (&ex_slave_num_val!=0x0 && &ex_slave_num_val!=0x1 && &ex_slave_num_val!=0x2)
	(
	  if (&ex_slave_num_val!=0xFF)
	  (
	  GOSUB PRINT_HELPER "!! External timer: &ex_external_timer_str - assigned slave task number is invalid"
	  &ex_test_result=0x0
	  )
	)

  if (&silent_int_sanity!=0x0)
  (
   if (&ex_test_result==0x0)
 	(
	  GOSUB PRINT_HELPER "Sanity check for the external timer failed : result above"
	)
   else
    (
	  GOSUB PRINT_HELPER "External timer structure seems sane"
	)
   GOSUB PRINT_HELPER ""
  )
	
RETURN

;============================================================================
; Timer List Subroutine.
;============================================================================
TIMER_LIST:

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  ; Backup the line counter
  &temp_bkup_print_line_counter=&print_line_counter
  &print_line_counter=1

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "                A c t i v e   T i m e r   L i s t                     "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  &iterator=0
  &last_iterator=0
  &tmr=v.value(\timer\timers.active.list.first)
  WHILE &tmr!=0
  (
    &jump_duck=0x50
    &not_in_free_q=v.value(((timer_internal_type*)&tmr)->internal_q)
    IF &not_in_free_q==0xCACACAC
    (
      &timer_index=var.string(((timer_internal_type*)&tmr)->index)
      &timer_ext=var.string((((timer_internal_type*)&tmr)->timer_ext))
      &expiry=var.value(((timer_internal_type*)&tmr)->expiry)

      ;Print out list to screen
      GOSUB PRINT_HELPER "Timer #&iterator  -- Timer Index: &timer_index    Expiry: &expiry    External Timer: &timer_ext"
    )
	if (&iterator==&jump_duck)
	  (
	    GOSUB PRINT_HELPER ""
		GOSUB PRINT_HELPER "Press any key to continue displaying the timers list"
		ENTER &no_use_script_var
		GOSUB PRINT_HELPER ""
		&jump_duck=&jump_duck+0x50
	  )
    &iterator=&iterator+1
    &tmr=v.value(((timer_internal_type*)&tmr)->next)
  )

  AREA.CLOSE TLO
  
  WE.AREA.select TIMER  
  
  &last_iterator=&iterator

  GOSUB PRINT_HELPER " "
  GOSUB PRINT_HELPER " "

  GOSUB PRINT_HELPER "Get more info on a timer? Enter 'y' if you would like to."

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  ENTER &in_more_info

  IF "&in_more_info"=="y"
  (
    GOSUB PRINT_HELPER "Please enter timer number from the list printed out in the side window."
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""

    ENTER &in_timer_number

    IF &in_timer_number<&last_iterator
    (
      &iterator=0
      &tmr=v.value(\timer\timers.active.list.first)
      WHILE &iterator<&in_timer_number
      (
        &iterator=&iterator+1
        &tmr=v.value(((timer_internal_type*)&tmr)->next)
      )
    
      IF &tmr!=0
      (
        GOSUB PRINT_TIMER_INFO &tmr &in_timer_number
      )
    )
    ELSE
    (
      GOSUB PRINT_HELPER "Invalid timer number entered!"
      GOSUB PRINT_HELPER ""
      GOSUB PRINT_HELPER ""
    )

  )

  ; Restore the line counter
  &print_line_counter=&temp_bkup_print_line_counter 
  
RETURN

;============================================================================
; Recent Match Value Subroutine.
;============================================================================
PRINT_RECENT_MATCH_VALUES:
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "              R e c e n t   M a t c h   V a l u e s                   "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  var.if (&IS_THERE_record_match_val==&FALSE || &timetick_jump_record_match_val==&TRUE)
	(
	GOSUB PRINT_HELPER "Debug Variable : 'record_match_val' might be not available or could be having timetick jumps"
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
	RETURN
	)

    WINPOS 60% 0.0 40% 30% 0. 0. L1Info
    v.v %OPEN.1 record_match_val
	
  &to_print=0x0F
  
  if (&to_print>&len_record_match_val)
   (
     &to_print=&len_record_match_val
   )
  
  &end_idx=&index_record_match_val-0x1
  &start_idx=&end_idx-&to_print
  if (&start_idx<0x0)
   (
   &start_idx=&len_record_match_val-&to_print+&end_idx+0x1
   )
   
  &rmv_cnt=0x0
  &mv_setter_str=""

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO
  
  GOSUB PRINT_HELPER "Last &to_print match value entries from record_match_value"
  GOSUB PRINT_HELPER ""

  
  
  WHILE (&rmv_cnt<0xF)
  (
    &mv_setter=var.value(record_match_val[&start_idx].mv_setter)
    &timer_now_supplied=var.value(record_match_val[&start_idx].timer_now_supplied)
    &timer_match_value_actual_set=var.string(record_match_val[&start_idx].timer_match_value_actual_set)
    &timer_address=var.string((timer_type*)record_match_val[&start_idx].timer_address)

    ;TIMER_MVS_TIMER_PROCESSED = 0x1,
    IF &mv_setter==1
    (
      &mv_setter_str="Timer Processed"
    )
    ;TIMER_MVS_TIMER_SET,
    IF &mv_setter==2
    (
      &mv_setter_str="Timer Set"
    )
    ;TIMER_MVS_DEFER_MATCH_INT,
    IF &mv_setter==3
    (
      &mv_setter_str="Timers Deferred"
    )
    ;TIMER_MVS_UNDEFER_MATCH_INT,
    IF &mv_setter==4
    (
      &mv_setter_str="Timers Undeferred"
    )
    ;TIMER_MVS_GROUP_DISABLED,
    IF &mv_setter==5
    (
      &mv_setter_str="Timer Group Disabled"
    )
    ;TIMER_MVS_GROUP_ENABLED,
    IF &mv_setter==6
    (
      &mv_setter_str="Timer Group Enabled"
    )
    ;TIMER_MVS_TIMER_CLEARED,
    IF &mv_setter==7
    (
      &mv_setter_str="Timer Cleared"
    )
    ;TIMER_MVS_TIMER_PAUSED,
    IF &mv_setter==8
    (
      &mv_setter_str="Timer Paused"
    )
    ;TIMER_MVS_TIMER_RESUMED,
    IF &mv_setter==9
    (
      &mv_setter_str="Timer Resumed"
    )
    ;TIMER_MVS_TIMER_CLEAR_TASK_TIMERS,
    IF &mv_setter==10
    (
      &mv_setter_str="Task Timers Cleared"
    )
    ;TIMER_MVS_SET_WAKEUP,
    IF &mv_setter==11
    (
      &mv_setter_str="Wakeup Set"
    )

    ;Print out to screen
    GOSUB PRINT_HELPER "record_match_val[&start_idx]: ----------------------------------"
	GOSUB PRINT_HELPER "    MV Set Type: &mv_setter_str"
    GOSUB PRINT_HELPER "    MV Set Time: &timer_now_supplied"
    GOSUB PRINT_HELPER "    MV Set: &timer_match_value_actual_set"
    GOSUB PRINT_HELPER "    Timer: &timer_address"
    
    &rmv_cnt=&rmv_cnt+0x1
	&start_idx=&start_idx+0x1
	if (&start_idx==&len_record_match_val)
	  (
	    &start_idx=0x0
	  )
  )
    GOSUB PRINT_HELPER "----------------------------------------------------------------"
  AREA.CLOSE TLO
  
  
  WE.AREA.select TIMER
  
  GOSUB PRINT_HELPER "Output put into the area window TLO for recent match value entries"
  GOSUB PRINT_HELPER "Oldest Index for 'record_match_val' = &index_record_match_val"
  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
RETURN


;============================================================================
; Timers Expired.
;============================================================================
TIMERS_EXPIRED:
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "                    T i m e r s   E x p i r e d                       "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  
  var.if (&IS_THERE_timers_expired==&FALSE || &timetick_jump_timers_expired==&TRUE)
	(
	GOSUB PRINT_HELPER "Debug Variable : 'timers_expired' might be not available or could be having timetick jumps"
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
	RETURN
	)

  WINPOS 60% 0.0 40% 30% 0. 0. L1Info
  v.v %OPEN.1 timers_expired
	
  &to_print=0x0A
  &cnt=0x0
  
  if (&to_print>&len_timers_expired)
   (
     &to_print=&len_timers_expired
   )
  
  &end_idx=&index_timers_expired-0x1
  &start_idx=&end_idx-&to_print
  if (&start_idx<0x0)
   (
   &start_idx=&len_timers_expired-&to_print+&end_idx+0x1
   )
   
  GOSUB PRINT_HELPER "Last &to_print timers_expired logs"
  GOSUB PRINT_HELPER ""  

  &sizeof_timers_expired=v.sizeof(timers_expired)/v.sizeof(timers_expired[0])
  &start_cnt=v.value(timer_expired_cnt)
  &iterator=1

  &new_out_dir="&output_directory"+"\timers_expired.csv"

  IF &output_to_csv==1
  (
    OPEN #1 &new_out_dir /Create
    WRITE #1 "Timer Expired,Expiry Value,Processing Started,Processing Time,Processing Ended,Function Address,Callback Type"
  )

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  GOSUB PRINT_HELPER "Last &to_print timers_expired logs"
  GOSUB PRINT_HELPER ""  
  
  WHILE &cnt<&to_print
  (
    &timer_expired=var.string(timers_expired[&start_idx].timer_expired)
	if (&is_b_family==&TRUE)
    &expiry_value=var.value(timers_expired[&start_idx].expiry_value)
    &processing_started=var.value(timers_expired[&start_idx].processing_started)
    &processing_time=var.value(timers_expired[&start_idx].processing_time)
    &processing_end=var.value(timers_expired[&start_idx].processing_started)+&processing_time
    &fn_address=var.string(timers_expired[&start_idx].fn_address)
    &call_back_type=var.value(timers_expired[&start_idx].call_back_type)
    
    ;Print out to screen
    GOSUB PRINT_HELPER "timers_expired[&start_idx] :: --------------------------"
	GOSUB PRINT_HELPER "        Timer Expired:      &timer_expired"
	if (&is_b_family==&TRUE)
	GOSUB PRINT_HELPER "        Expiry Value:       &expiry_value"  
	GOSUB PRINT_HELPER "        Processing Started: &processing_started"  
	GOSUB PRINT_HELPER "        Processing Ended:   &processing_end"  
	GOSUB PRINT_HELPER "        Processing Time:    &processing_time"  
	GOSUB PRINT_HELPER "        Function Address:   &fn_address"   
	GOSUB PRINT_HELPER "        Callback Type:      &call_back_type"

    IF &output_to_csv==1
    (
      WRITE #1 "&timer_expired,&expiry_value,&processing_started,&processing_time,&processing_end,&fn_address,&call_back_type"
    )

    &cnt=&cnt+0x1
	&start_idx=&start_idx+0x1
	if (&start_idx==&len_timers_expired)
	 (
	   &start_idx=0x0
	 )
  )
    GOSUB PRINT_HELPER "----------------------------------------------------------------"
  AREA.CLOSE TLO
  
  WE.AREA.select TIMER
  
  GOSUB PRINT_HELPER "Output put into the area window TLO for recent expired timers"
  GOSUB PRINT_HELPER "Oldest Index for 'timers_expired' = &index_timers_expired"
  
  IF &output_to_csv==1
  (
    CLOSE #1
  )

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
RETURN


;============================================================================
; Timer Trace.
;============================================================================
TIMER_TRACE:
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "                       T i m e r   T r a c e                          "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  
  var.if (&IS_THERE_timer_trace==&FALSE || &timetick_jump_timer_trace==&TRUE)
	(
	GOSUB PRINT_HELPER "Debug Variable : 'timer_trace' is either not availale in this build or has timetick jumps"
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
	RETURN
	)  
  
  WINPOS 60% 0.0 40% 30% 0. 0. L1Info
  v.v %OPEN.1 timer_trace.events
  
  &to_print=0x20
  &cnt=0x0
  
  if (&to_print>&len_timer_trace)
   (
     &to_print=&len_timer_trace
   )
  
  &end_idx=&index_timer_trace-0x1
  &start_idx=&end_idx-&to_print
  if (&start_idx<0x0)
   (
   &start_idx=&len_timer_trace-&to_print+&end_idx+0x1
   )
   
   
   
  
  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  GOSUB PRINT_HELPER "Last &to_print timer_trace logs"
  GOSUB PRINT_HELPER ""  

  WHILE &cnt<&to_print
  (
    &event=var.string(timer_trace.events[&start_idx].event)
    &timestamp=var.value(timer_trace.events[&start_idx].ts)
    
    ;Print out to screen
    GOSUB PRINT_HELPER "timer_trace[&start_idx]: Timestamp: &timestamp  Event: &event"

    &cnt=&cnt+0x1
	&start_idx=&start_idx+0x1
	if &start_idx==&len_timer_trace
	 (
	  &start_idx=0x0
	 )
  )

    GOSUB PRINT_HELPER "----------------------------------------------------------------"
  AREA.CLOSE TLO
  

  
  WE.AREA.select TIMER
  
  GOSUB PRINT_HELPER "Output put into the area window TLO for recent timer trace events"
  GOSUB PRINT_HELPER "Oldest Index for 'timer_trace' = &index_timer_trace"
  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
RETURN


;============================================================================
; Timer Sets.
;============================================================================
TIMER_SETS:
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "                        T i m e r   S e t s                           "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  var.if (&IS_THERE_timer_sets==&FALSE || &timetick_jump_timer_sets==&TRUE)
	(
	GOSUB PRINT_HELPER "Debug Variable : 'timer_sets' is either not availale in this build or it has timetick jumps"
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
	RETURN
	)    

	  WINPOS 60% 0.0 40% 30% 0. 0. L1Info
      v.v %OPEN.1 timer_sets
	
  &end_idx=0x0
  &start_idx=0x0
  &to_print=0x20
  &cnt=0x0
  
  if (&to_print>&len_timer_sets)
   (
     &to_print=&len_timer_sets
   )

    &end_idx=&index_timer_sets-0x1
	&start_idx=&end_idx-&to_print
	if (&start_idx<0x0)
     ( 
     &start_idx=&len_timer_sets-&to_print+&end_idx+0x1
     )

   
  
  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  GOSUB PRINT_HELPER "Last &to_print timer_sets logs"
  GOSUB PRINT_HELPER ""  	
	
  WHILE &cnt<&to_print
  (
    if (&is_b_family==&TRUE)
    &timer_to_be_set=var.string(timer_sets[&start_idx].timer_to_be_set)
	else
	&timer_to_be_set=var.string(timer_sets[&start_idx].timer)
    &timestamp=var.value(timer_sets[&start_idx].ts)
    
    ;Print out to screen
    GOSUB PRINT_HELPER "timer_sets[&start_idx]: Timestamp=&timestamp  : Timer=&timer_to_be_set"

    &cnt=&cnt+0x1
	&start_idx=&start_idx+0x1
	if (&start_idx==&len_timer_sets)
	  (
	    &start_idx=0x0
	  ) 
  )

  GOSUB PRINT_HELPER "----------------------------------------------------------------"
  AREA.CLOSE TLO
  
 
  WE.AREA.select TIMER
  
  GOSUB PRINT_HELPER "Output put into the area window TLO for recent timer sets events"
  GOSUB PRINT_HELPER "Oldest Index for 'timer_sets' = &index_timer_sets"
  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
RETURN


;============================================================================
; Find Wakeup Information.
;============================================================================
TIMER_WAKEUP_DURATIONS:

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  &total_prints=0x0
  &print_limit=0x50
  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "            T i m e r   W a k e u p  I n f o r m a t i o n            "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  var.if (&IS_THERE_timer_expired_debug==&FALSE || &timetick_jump_timer_expired_debug==&TRUE)
	(
	GOSUB PRINT_HELPER "Debug Variable : 'timer_expired_debug' is either not availale in this build or it has timetick jumps"
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
    AREA.CLOSE TLO

    WE.AREA.select TIMER  	
	RETURN
	)   
  
  &sizeof_timer_expired_debug=v.sizeof(timer_expired_debug)/v.sizeof(timer_expired_debug[0])
  &start_cnt=v.value(timer_expired_debug_cnt)
  &curr_cnt=v.value(timer_expired_debug_cnt)
  &iterator=1
  &skip_first_part=0
  &expiry_cnt=0
  &wakeup_number=1
  &outstring=""

  &out_dir_wakeup="&output_directory"+"\wakeups.txt"
  &out_dir_ulog="&output_directory"+"\timers.ulog"

  OPEN #2 &out_dir_wakeup /Create

  WRITE #2 ""
  WRITE #2 ""
  WRITE #2 "######################################################################"
  WRITE #2 "            T i m e r   W a k e u p  I n f o r m a t i o n            "
  WRITE #2 "######################################################################"
  WRITE #2 ""
  WRITE #2 ""

  ;Find the first clean timer expiry
  WHILE (var.value(timer_expired_debug[&curr_cnt].whileloopcnt)>1)&&(&curr_cnt<&sizeof_timer_expired_debug)
  (
    &curr_cnt=&curr_cnt+1
  )

  ;If we exited early
  IF &curr_cnt==&sizeof_timer_expired_debug
  (
    &curr_cnt=0
    WHILE (var.value(timer_expired_debug[&curr_cnt].whileloopcnt)>1)&&(&curr_cnt<&start_cnt)
    (
      &curr_cnt=&curr_cnt+1
    )
    &skip_first_part=1
  )

  &last_cnt=&curr_cnt
  &first_tmr=&curr_cnt
  ;Print first half
  WHILE (&curr_cnt<&sizeof_timer_expired_debug)&&(&skip_first_part==0)
  (
    ;Roll Over Case
    IF var.value(timer_expired_debug[&curr_cnt].whileloopcnt)==1
    (
      IF (&last_cnt-&first_tmr)>5
      (
        ;Print all timers in between
        &iterator=0
        &first_timestamp=v.value(timer_expired_debug[&first_tmr].ts)
        &last_timestamp=&first_timestamp
        WHILE &first_tmr<=&last_cnt
        (
          &timer_exp_ptr=var.string((timer_type*)timer_expired_debug[&first_tmr].timer_exp_ptr)
          &timestamp=var.value(timer_expired_debug[&first_tmr].ts)
          &expiry=var.value(timer_expired_debug[&first_tmr].expiry)
          &last_timestamp=&timestamp
          &iterator=&iterator+1
          &first_tmr=&first_tmr+1
          &outstring="#&iterator: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_exp_ptr"
          GOSUB PRINT_HELPER "&outstring"
		  &total_prints=&total_prints+0x1
          WRITE #2 "&outstring"
		  
		  if (&total_prints==&print_limit)
		   (
		   GOSUB PRINT_HELPER "Press any key to continue..."
		   Enter &no_use_script_var
		   &total_prints=0x0
		   )
        )

        &duration=&last_timestamp-&first_timestamp
        &duration_us=(&duration*10)/192

        GOSUB PRINT_HELPER ""
        GOSUB PRINT_HELPER ""
        GOSUB PRINT_HELPER "Summary: Number of Timers Expired:  &iterator   Total Wakeup Duration:  &duration    Total Wakeup Duration in Microseconds:  &duration_us"
        GOSUB PRINT_HELPER ""
        GOSUB PRINT_HELPER ""
		&total_prints=&total_prints+0x5
        if (&total_prints==&print_limit)
		   (
		   GOSUB PRINT_HELPER "Press any key to continue..."
		   Enter &no_use_script_var
		   &total_prints=0x0
		   )

        WRITE #2 ""
        WRITE #2 ""
        WRITE #2 "Summary: Number of Timers Expired: &iterator   Total Wakeup Duration: &duration  Total Wakeup Duration in Microseconds: &duration_us"
        WRITE #2 ""
        WRITE #2 ""
		&total_prints=&total_prints+0x5
        if (&total_prints==&print_limit)
		   (
		   GOSUB PRINT_HELPER "Press any key to continue..."
		   Enter &no_use_script_var
		   &total_prints=0x0
		   )		
      )
      &first_tmr=&curr_cnt
      &last_cnt=&curr_cnt
    )
    ELSE
    (
      &last_cnt=&curr_cnt
    )
    
    &curr_cnt=&curr_cnt+1
  )

  &curr_cnt=0

  ;Print second half
  &last_cnt=&curr_cnt
  WHILE &curr_cnt<&start_cnt
  (
    ;Roll Over Case
    IF var.value(timer_expired_debug[&curr_cnt].whileloopcnt)==1
    (
      &total_first=0
      &total_last=0
      ;Wrap around case
      IF &last_cnt<&first_tmr
      (
        &total_first=(&sizeof_timer_expired_debug-&first_tmr)
        &total_last=&total_first+&last_cnt
      )
      ELSE
      (
        &total_first=&first_tmr
        &total_last=&last_cnt
      )
      IF ((&total_last-&total_first)>5)
      (
        ;Wrap Around Case
        IF &last_cnt<&first_tmr
        (
          ;Print all timers in between
          &iterator=0
          &first_timestamp=v.value(timer_expired_debug[&first_tmr].ts)
          &last_timestamp=0
          WHILE &first_tmr<&sizeof_timer_expired_debug
          (
            &timer_exp_ptr=var.string((timer_type*)timer_expired_debug[&first_tmr].timer_exp_ptr)
            &timestamp=var.value(timer_expired_debug[&first_tmr].ts)
            &expiry=var.value(timer_expired_debug[&first_tmr].expiry)
            &last_timestamp=&timestamp
            &iterator=&iterator+1
            &first_tmr=&first_tmr+1
            &outstring="#&iterator: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_exp_ptr"
            GOSUB PRINT_HELPER "&outstring"
			&total_prints=&total_prints+0x1
            WRITE #2 "&outstring"
		    if (&total_prints==&print_limit)
		     (
			 GOSUB PRINT_HELPER "Press any key to continue..."
		     Enter &no_use_script_var
		     &total_prints=0x0
		     )			
          )

          &first_tmr=0
          WHILE &first_tmr<=&last_cnt
          (
            &timer_exp_ptr=var.string((timer_type*)timer_expired_debug[&first_tmr].timer_exp_ptr)
            &timestamp=var.value(timer_expired_debug[&first_tmr].ts)
            &expiry=var.value(timer_expired_debug[&first_tmr].expiry)
            &last_timestamp=&timestamp
            &iterator=&iterator+1
            &first_tmr=&first_tmr+1
            &outstring="#&iterator: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_exp_ptr"
            GOSUB PRINT_HELPER "&outstring"
            WRITE #2 "&outstring"
          )

          &duration=&last_timestamp-&first_timestamp
          &duration_us=(&duration*10)/192

          GOSUB PRINT_HELPER ""
          GOSUB PRINT_HELPER ""
          GOSUB PRINT_HELPER "Summary: Number of Timers Expired: &iterator Total Wakeup Duration: &duration Total Wakeup Duration in Microseconds: &duration_us"
          GOSUB PRINT_HELPER ""
          GOSUB PRINT_HELPER ""
		&total_prints=&total_prints+0x5
        if (&total_prints==&print_limit)
		   (
		   GOSUB PRINT_HELPER "Press any key to continue..."
		   Enter &no_use_script_var
		   &total_prints=0x0
		   )		  

          WRITE #2 ""
          WRITE #2 ""
          WRITE #2 "Summary: Number of Timers Expired: &iterator  Total Wakeup Duration: &duration  Total Wakeup Duration in Microseconds: &duration_us"
          WRITE #2 ""
          WRITE #2 ""
		&total_prints=&total_prints+0x5
        if (&total_prints==&print_limit)
		   (
		   GOSUB PRINT_HELPER "Press any key to continue..."
		   Enter &no_use_script_var
		   &total_prints=0x0
		   )			  
        )
        ELSE
        (
          ;Print all timers in between
          &iterator=0
          &first_timestamp=v.value(timer_expired_debug[&first_tmr].ts)
          &last_timestamp=0
          WHILE &first_tmr<=&last_cnt
          (
            &timer_exp_ptr=var.string((timer_type*)timer_expired_debug[&first_tmr].timer_exp_ptr)
            &timestamp=var.value(timer_expired_debug[&first_tmr].ts)
            &expiry=var.value(timer_expired_debug[&first_tmr].expiry)
            &last_timestamp=&timestamp
            &iterator=&iterator+1
            &first_tmr=&first_tmr+1
            &outstring="#&iterator: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_exp_ptr"
            GOSUB PRINT_HELPER "&outstring"
		&total_prints=&total_prints+0x1
        if (&total_prints==&print_limit)
		   (
		   GOSUB PRINT_HELPER "Press any key to continue..."
		   Enter &no_use_script_var
		   &total_prints=0x0
		   )				
			
            WRITE #2 "&outstring"
          )

          &duration=&last_timestamp-&first_timestamp
          &duration_us=(&duration*10)/192

          GOSUB PRINT_HELPER ""
          GOSUB PRINT_HELPER ""
          GOSUB PRINT_HELPER "Summary: Number of Timers Expired: &iterator   Total Wakeup Duration:   &duration   Total Wakeup Duration in Microseconds: &duration_us"
          GOSUB PRINT_HELPER ""
          GOSUB PRINT_HELPER ""
		&total_prints=&total_prints+0x5
        if (&total_prints==&print_limit)
		   (
		   GOSUB PRINT_HELPER "Press any key to continue..."
		   Enter &no_use_script_var
		   &total_prints=0x0
		   )			  

          WRITE #2 ""
          WRITE #2 ""
          WRITE #2 "Summary: Number of Timers Expired: &iterator  Total Wakeup Duration: &duration  Total Wakeup Duration in Microseconds: &duration_us"
          WRITE #2 ""
          WRITE #2 ""
		&total_prints=&total_prints+0x5
        if (&total_prints==&print_limit)
		   (
		   GOSUB PRINT_HELPER "Press any key to continue..."
		   Enter &no_use_script_var
		   &total_prints=0x0
		   )			  
        )
      )
      &first_tmr=&curr_cnt
      &last_cnt=&curr_cnt
    )
    ELSE
    (
      &last_cnt=&curr_cnt
    )
    &curr_cnt=&curr_cnt+1
  )

  CLOSE #2
  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Output dumped to file in the location &out_dir_wakeup"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  
  AREA.CLOSE TLO
  
  WE.AREA.select TIMER  
  
RETURN




;============================================================================
; Traverse Timer List Subroutine.
;============================================================================
TRAVERSE_TIMER_LIST:

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  ; Backup the line counter
  &temp_bkup_print_line_counter=&print_line_counter
  &print_line_counter=1  
  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "              T r a v e r s e   T i m e r   L i s t                   "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  ;Initialize exit parameter as 0
  &exit_param=0
  &in_param=0
  &in_param_found=0

  ;Initialize sequence number
  &seq_num=1
  &total_tmrs=0

  ;Initialize timer to use (head)
  &tmr=v.value(\timer\timers.active.list.first)

  IF &tmr==0
  (
    GOSUB PRINT_HELPER "No timers on the timer linked list! Exiting Subroutine..."
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
    RETURN
  )

  ;Find total timers on linked list
  WHILE &tmr!=0
  (
    &total_tmrs=&total_tmrs+1
    &tmr=v.value(((timer_internal_type*)&tmr)->next)
  )

  ;Initialize timer to use (head)
  &tmr=v.value(\timer\timers.active.list.first)

  GOSUB PRINT_HELPER "Starting with head of the timer linked list"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  ;Print head timer
  GOSUB PRINT_TIMER_INFO &tmr &seq_num

  ;Loop until we get exit cmd
  WHILE &exit_param==0
  (

    GOSUB PRINT_HELPER "Please enter one of the following -- First:f   Next:n   Prev:p   Last:l   Exit:x"
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""

    ;Wait for user input
    ENTER &in_param

    IF "&in_param"=="n"
    (
      IF v.value(((timer_internal_type*)&tmr)->next)==0
      (
        GOSUB PRINT_HELPER "Cannot move forward in the linked list, already at tail!"
        GOSUB PRINT_HELPER ""
        GOSUB PRINT_HELPER ""
      )
      ELSE
      (
        &seq_num=&seq_num+1
        &tmr=v.value(((timer_internal_type*)&tmr)->next)
		GOSUB PRINT_TIMER_INFO &tmr &seq_num
      )
	  &in_param_found=1
    )

    IF "&in_param"=="p"
    (
      IF &seq_num==1
      (
        GOSUB PRINT_HELPER "Cannot move back in the timer linked list, already at the head!"
        GOSUB PRINT_HELPER ""
        GOSUB PRINT_HELPER ""
      )
      ELSE
      (
        &seq_num=&seq_num-1
        &tmr=v.value(((timer_internal_type*)&tmr)->prev)
		GOSUB PRINT_TIMER_INFO &tmr &seq_num
        
      )
	  &in_param_found=1
    )

    IF "&in_param"=="f"
    (
      &seq_num=1
      &tmr=v.value(\timer\timers.active.list.first)
      GOSUB PRINT_TIMER_INFO &tmr &seq_num
      &in_param_found=1
    )

    IF "&in_param"=="l"
    (
      &seq_num=&total_tmrs
      &tmr=v.value(\timer\timers.active.list.last)
      GOSUB PRINT_TIMER_INFO &tmr &seq_num
      &in_param_found=1
    )

    IF "&in_param"=="x"
    (
      GOSUB PRINT_HELPER "Exiting Traverse Subroutine..."
      GOSUB PRINT_HELPER ""
      GOSUB PRINT_HELPER ""

	  ; Restore the line counter
      &print_line_counter=&temp_bkup_print_line_counter  
  
      AREA.CLOSE TLO
      WE.AREA.select TIMER  
	  
      RETURN
    )

    IF &in_param_found==0
    (

      GOSUB PRINT_HELPER "Invalid Paramter Entered!"
      GOSUB PRINT_HELPER ""
      GOSUB PRINT_HELPER ""

    )

    ;Reinitialize value
    &in_param_found=0

  )

  ;Start with the head of the list
  ;GOSUB PRINT_TIMER_INFO &tmr 1

  ; Restore the line counter
  &print_line_counter=&temp_bkup_print_line_counter  
  
  AREA.CLOSE TLO
  
  WE.AREA.select TIMER     

RETURN

;============================================================================
; Internal timer - External timer matching Subroutine.
;============================================================================
INTERNAL_EXTERNAL_TIMER_MATCH:
  ENTRY &int_timer_addr &ext_timer_addr &silent_match
  
  &int_timer_string_var=var.string((timer_internal_type*)&int_timer_addr)
  &ext_timer_string_var=var.string((timer_type*)&ext_timer_addr)

  if (&silent_match!=0x0)
  GOSUB PRINT_HELPER "--- Checking Internal Timer vs. External Timer ---"
  
  &external_timer_addr=var.value(((timer_internal_type*)&int_timer_addr)->timer_ext)
  if (&external_timer_addr!=&ext_timer_addr)
	(
	  GOSUB PRINT_HELPER "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - timer_ext not matching with that in the internal timer buffer"
	)

  ; Check if internal-external timer mapping is correct
  GOSUB TIMER_CHECK_TIMER_HANDLE_MAPPING &int_timer_addr &ext_timer_addr	
	
  &int_timer_group=var.value(((timer_internal_type*)&int_timer_addr)->group)
  &ext_timer_group=var.value(((timer_type*)&ext_timer_addr)->group)
  if (&int_timer_group!=&ext_timer_group)
	(
	  GOSUB PRINT_HELPER "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - group mismatch"
	)
  
  &int_timer_tcb=var.value(((timer_internal_type*)&int_timer_addr)->tcb)
  &ext_timer_tcb=var.value(((timer_type*)&ext_timer_addr)->tcb)
  if (&int_timer_tcb!=&ext_timer_tcb)
	(
	  GOSUB PRINT_HELPER "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - tcb mismatch"
	)
  
  &int_timer_signal=var.value(((timer_internal_type*)&int_timer_addr)->sigs)
  &ext_timer_signal=var.value(((timer_type*)&ext_timer_addr)->sigs)
  if (&int_timer_signal!=&ext_timer_signal)
	(
	  GOSUB PRINT_HELPER "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - signal mismatch"
	)
  
  &int_timer_func1=var.value(((timer_internal_type*)&int_timer_addr)->func1)
  &ext_timer_func1=var.value(((timer_type*)&ext_timer_addr)->func1)
  if (&int_timer_func1!=&ext_timer_func1)
	(
	  GOSUB PRINT_HELPER "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - func1 pointer mismatch"
	)
  
  &int_timer_func2=var.value(((timer_internal_type*)&int_timer_addr)->func2)
  &ext_timer_func2=var.value(((timer_type*)&ext_timer_addr)->func2)
  if (&int_timer_func2!=&ext_timer_func2)
	(
	  GOSUB PRINT_HELPER "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - func2 pointer mismatch"
	)
  
  &int_timer_data=var.value(((timer_internal_type*)&int_timer_addr)->data)
  &ext_timer_data=var.value(((timer_type*)&ext_timer_addr)->data)
  if (&int_timer_data!=&ext_timer_data)
	(
	  GOSUB PRINT_HELPER "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - Callback Data mismatch"
	)
  
  &int_timer_slave_task=var.value(((timer_internal_type*)&int_timer_addr)->slave_task_assigned)
  &ext_timer_slave_task=var.value(((timer_type*)&ext_timer_addr)->slave_task_assignment)
  if (&int_timer_slave_task!=&ext_timer_slave_task)
	(
	  GOSUB PRINT_HELPER "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - slave task number mismatch"
	)

  if (&silent_match!=0x0)
  GOSUB PRINT_HELPER ""
  
  RETURN
  
;============================================================================
; Get Internal Timer Index Subroutine.
;============================================================================
GET_TIMER_INDEX:
  ENTRY &ext_timer_handle &silent

  &ret_get_timer_index=0xFFFFFFFF

  var.if (&ext_timer_handle==0xDEADDEAD || &ext_timer_handle==0xFFFFFFFF || &ext_timer_handle==0xFFFFFFFFDEADDEAD)
	(
		RETURN
	)

  &ext_timer_handle=0x00000000FFFFFFFF&&ext_timer_handle

  ; values for handle comparision
  &TIMER_HANDLE_CONST=0x0000FFFF
  &VERIFY_XOR_HANDLE=0xFF000000

  &XOR_HANDLE=0x0
  &INT_TIMER_INDEX=0x0

  if (&silent!=1)
  (
    GOSUB PRINT_HELPER "External timer_handle = &ext_timer_handle"
  )

  &XOR_HANDLE=&ext_timer_handle&&VERIFY_XOR_HANDLE

  var.if (&XOR_HANDLE==0xC3000000)
	(
	&INT_TIMER_INDEX=&TIMER_HANDLE_CONST&&ext_timer_handle
	)
  else
	(
	&INT_TIMER_INDEX=&ext_timer_handle-1
	)

  ; Check if the internal timer index is valid
  var.if	(&INT_TIMER_INDEX>0xFF || &INT_TIMER_INDEX<0x0)
	(
	if (&silent!=1)
     (
	  GOSUB PRINT_HELPER ">> Internal Timer index is incorrect = &INT_TIMER_INDEX"
	  GOSUB PRINT_HELPER ""
	 )

	; Flag the return to notify that the handle is incorrect
	&ret_get_timer_index=0xDEADD00D
	RETURN
	)

if (&silent!=1)
  (	
  GOSUB PRINT_HELPER "Internal Timer index  = &INT_TIMER_INDEX"
  GOSUB PRINT_HELPER ""
  )
&ret_get_timer_index=&INT_TIMER_INDEX

&silent=0x0


RETURN

;============================================================================
; Get Timer Info Subroutine.
;============================================================================
GET_TIMER_INFO:
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "                    G e t   T i m e r   I n f o                       "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  
  GOSUB PRINT_HELPER "Please enter the high-level-language name for the timer"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  ENTER &in_timer_symbol
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  &in_symbol_exist=y.type(&in_timer_symbol)
  
  IF &in_symbol_exist==0x3
  (
    AREA.CREATE TLO
    WINPOS 60% 30% 40% 70% 0. 0. TLO
    AREA.VIEW TLO
    AREA.SELECT TLO
	
    &tmr_ext=v.value((timer_type*)&(&in_timer_symbol))
    &tmr_ext_handle=v.value(((timer_type*)&tmr_ext)->timer_handle)
    &tmr_ext_group=v.value(((timer_type*)&tmr_ext)->group)
    &tmr_ext_handle=v.value(((timer_type*)&tmr_ext)->timer_handle)
	GOSUB GET_TIMER_INDEX &tmr_ext_handle 0x0
    &tmr_int_handle=&ret_get_timer_index
    &tmr_int=v.value(((timer_type*)&timer_buffer[&tmr_int_handle]))
    IF (&tmr_ext_group!=0)&&(v.value(((timer_group_type*)&tmr_ext_group)->disabled)<=1)&&(v.value(((timer_group_type*)&tmr_ext_group)->deferrable)<=1)
    (
	  GOSUB PRINT_HELPER "External timer info : "
	  GOSUB PRINT_EXT_TIMER_INFO &tmr_ext
      WINPOS 60% 0.0 40% 30% 0. 0. L1Info
	  var.addwatch %OPEN.1 &in_timer_symbol
	  var.if (&ret_get_timer_index!=0xDEADD00D)
	  (
		var.if (&tmr_ext_handle!=-1 && &tmr_ext_handle!=0xDEADDEAD && &tmr_ext_handle!=0xFFFFFFFFDEADDEAD)
		(
			GOSUB EXTERNAL_TIMER_SANITY_CHECK &tmr_ext 0x1
			
			GOSUB PRINT_HELPER "Internal timer info (corresponding to the above external timer): "
			GOSUB PRINT_TIMER_INFO &tmr_int 1
			var.addwatch %OPEN.1 (timer_ptr_internal_type)&tmr_int
			GOSUB INTERNAL_TIMER_SANITY_CHECK &tmr_int 0x1
		    GOSUB INTERNAL_EXTERNAL_TIMER_MATCH &tmr_int &tmr_ext 0x1
			GOSUB PRINT_HELPER ""
			GOSUB PRINT_HELPER "Both the timers also added to the watch window above"
		)
	  )
    )
    ELSE
    (
      GOSUB PRINT_HELPER "Timer does not appear to be properly setup, or is corrupted! Exiting..."
    )
  
  AREA.CLOSE TLO
  WE.AREA.select TIMER	
  
  )
  ELSE
  (
    GOSUB PRINT_HELPER "Variable Symbol does not exist! Exiting..."
  )
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

RETURN

;============================================================================
; Print Timer List Helper Function.
;============================================================================
PRINT_TIMER_INFO:

  ;Input parameter is the internal timer whose info will be printed
  ENTRY &internal_timer &sequence_number

  ;Print Spacer
  GOSUB PRINT_HELPER "### Timer #&sequence_number ###"

  ;Print Index
  &timer_index=var.string(((timer_internal_type*)&internal_timer)->index)
  GOSUB PRINT_HELPER "Timer Index:              &timer_index"
  
  ;Print External Timer
  &timer_ext=var.string(((timer_internal_type*)&internal_timer)->timer_ext)
  GOSUB PRINT_HELPER "External Timer:           &timer_ext"

  ;Print Group
  &group=var.string(((timer_internal_type*)&internal_timer)->group)
  GOSUB PRINT_HELPER "Timer Group:              &group"

  ;Print TCB (if available)
  &tcb=var.string(((timer_internal_type*)&internal_timer)->tcb)
  GOSUB PRINT_HELPER "Client TCB:               &tcb"

  ;Print sigs (if available)
  &sigs=var.string(((timer_internal_type*)&internal_timer)->sigs)
  &sigs_val=var.value(((timer_internal_type*)&internal_timer)->sigs)
  IF &sigs_val>0
  (
    GOSUB PRINT_HELPER "Signal to set:            &sigs"
  )

  ;Print func1 or func2 (if available)
  &func1=var.string(((timer_internal_type*)&internal_timer)->func1)
  &func1_val=var.value(((timer_internal_type*)&internal_timer)->func1)
  &func2=var.string(((timer_internal_type*)&internal_timer)->func2)
  &func2_val=var.value(((timer_internal_type*)&internal_timer)->func2)
  IF &func1_val!=0
  (
    GOSUB PRINT_HELPER "Callback Type 1 Function: &func1"
  )
  IF &func2_val!=0
  (
    GOSUB PRINT_HELPER "Callback Type 2 Function: &func2"
  )
  

  ;Print Callback Data (if func1 or func2 available)
  &cb_data=var.value(((timer_internal_type*)&internal_timer)->data)
  IF &func1_val!=0
  (
    GOSUB PRINT_HELPER "Callback Data:            &cb_data"
  )
  IF &func2_val!=0
  (
    GOSUB PRINT_HELPER "Callback Data:            &cb_data"
  )

  ; Print the timer list this timer is assigned to
  &tmr_list_allocated=var.string(((timer_internal_type*)&internal_timer)->list)  
  GOSUB PRINT_HELPER "Timer List assigned:      &tmr_list_allocated"
  
  ; Print the slave task assigned to this timer
  &tmr_slave_task=var.value(((timer_internal_type*)&internal_timer)->slave_task_assigned)  
  GOSUB PRINT_HELPER "Slave Task Assigned:      &tmr_slave_task"
  
  ;Print Start Timetick
  &start=var.string(((timer_internal_type*)&internal_timer)->start)
  GOSUB PRINT_HELPER "Start Timetick:           &start"

  ;Print Expiry Timetick
  &expiry=var.string(((timer_internal_type*)&internal_timer)->expiry)
  GOSUB PRINT_HELPER "Expiry Timetick:          &expiry"

  ;Print Last Expiry
  &last_expiry=var.string(((timer_internal_type*)&internal_timer)->timer_ext->last_expiry)
  GOSUB PRINT_HELPER "Last Expiry Timetick:     &last_expiry"

  ;Print State
  &timer_state=var.string(((timer_internal_type*)&internal_timer)->timer_ext->timer_state)
  GOSUB PRINT_HELPER "Timer State:              &timer_state"

  ;Print Spacer
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

RETURN


;============================================================================
; Print External Timer Helper Function.
;============================================================================
PRINT_EXT_TIMER_INFO:

  ;Input parameter is the internal timer whose info will be printed
  ENTRY &external_timer

  ;Print Timer Name & Address
  &name=var.string((timer_type*)&external_timer)
    GOSUB PRINT_HELPER "Timer :                   &name"

  ;Print Timer Group
  &group=var.string(((timer_type*)&external_timer)->group)
    GOSUB PRINT_HELPER "Timer Group:              &group"

  ;Print Timer TCB
  &tcb=var.string(((timer_type*)&external_timer)->tcb)
    GOSUB PRINT_HELPER "Timer TCB:                &tcb"

  ;Print Timer Sigs to Set
  &sigs=var.string(((timer_type*)&external_timer)->sigs)
  &sigs_val=var.value(((timer_type*)&external_timer)->sigs)
  IF &sigs_val>0
  (
    GOSUB PRINT_HELPER "Signal to set:            &sigs"
  )

  ;Print func1 or func2 (if available)
  &func1=var.string(((timer_type*)&external_timer)->func1)
  &func1_val=var.value(((timer_type*)&external_timer)->func1)
  &func2=var.string(((timer_type*)&external_timer)->func2)
  &func2_val=var.value(((timer_type*)&external_timer)->func2)
  IF &func1_val!=0
  (
    GOSUB PRINT_HELPER "Callback Type 1 Function: &func1"
  )
  IF &func2_val!=0
  (
    GOSUB PRINT_HELPER "Callback Type 2 Function: &func2"
  )

  ;Print callback data (if available)
  &cb_data=var.string(((timer_type*)&external_timer)->data)
  &cb_data_val=var.value(((timer_type*)&external_timer)->data)
  IF &cb_data_val!=0
  (
    GOSUB PRINT_HELPER "Callback Data:            &cb_data"
  )

  ;Print Last Start
  &last_start=var.string(((timer_type*)&external_timer)->last_start)
    GOSUB PRINT_HELPER "Last Start Timetick:      &last_start"

  ;Print Last Expiry
  &last_expiry=var.string(((timer_type*)&external_timer)->last_expiry)
    GOSUB PRINT_HELPER "Last Expiry Timetick:     &last_expiry"

  ;Print State
  &timer_state=var.string(((timer_type*)&external_timer)->timer_state)
    GOSUB PRINT_HELPER "Timer State:              &timer_state"

  ;Print Timer Slave Task Assigned
  &slave_assigned=var.value(((timer_type*)&external_timer)->slave_task_assignment)
    GOSUB PRINT_HELPER "Slave Task Assigned:      &slave_assigned"

  ;Print Spacer
    GOSUB PRINT_HELPER ""

RETURN


;============================================================================
; Search for Non-deferrable Timers.
;============================================================================
TIMER_FIND_NON_DEFERRABLE_TIMERS:

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  &ret=0x0

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "         F i n d   N o n - D e f e r r a b l e   T i m e r s          "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  &sizeof_timers_expired=0
  &sizeof_timers_expired_slave1=0
  &sizeof_timers_expired_slave2=0
  &sizeof_timers_expired_slave3=0
  &start_cnt=0
  &curr_cnt=0
  &iterator=1
  &ret=y.type(timers_expired_slave1)

  var.if (&IS_THERE_timers_expired!=&FALSE)
  (
    &sizeof_timers_expired=v.sizeof(timers_expired)/v.sizeof(timers_expired[0])
    &start_cnt=v.value(timer_expired_cnt)
    &curr_cnt=v.value(timer_expired_cnt)
  )
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave1=v.sizeof(timers_expired_slave1)/v.sizeof(timers_expired_slave1[0])
  )
  &ret=y.type(timers_expired_slave2)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave2=v.sizeof(timers_expired_slave2)/v.sizeof(timers_expired_slave2[0])
  )
  &ret=y.type(timers_expired_slave3)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave3=v.sizeof(timers_expired_slave3)/v.sizeof(timers_expired_slave3[0])
  )

  &out_dir_ulog="&output_directory"+"\timers.ulog"

  OPEN #3 &out_dir_ulog /Create

  GOSUB PRINT_HELPER "======================================================"
  GOSUB PRINT_HELPER " Checking Expired Non-deferrable Timers On Timer Task "
  GOSUB PRINT_HELPER "======================================================"
  GOSUB PRINT_HELPER ""

  ;Print first half
  var.if (&IS_THERE_timers_expired!=&FALSE)
  (
    WHILE &curr_cnt<&sizeof_timers_expired
    (
      &timer_expired=var.string(timers_expired[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired[&curr_cnt].timer_expired->group)->deferrable))
  	if (&is_b_family==&TRUE)
      &expiry_value=var.value(timers_expired[&curr_cnt].expiry_value)
  	else
  	&expiry_value="NA"
      &processing_started=var.value(timers_expired[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        GOSUB PRINT_HELPER "&iterator: Expiry Value: &expiry_value  Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired[&curr_cnt].timer_expired->group)->deferrable))
  	if (&is_b_family==&TRUE)
      &expiry_value=var.value(timers_expired[&curr_cnt].expiry_value)
  	else
  	&expiry_value="NA"	
      &processing_started=var.value(timers_expired[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        GOSUB PRINT_HELPER "&iterator: Expiry Value: &expiry_value  Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave1)
  IF (&ret==0x3)
  (
    GOSUB PRINT_HELPER "======================================================="
    GOSUB PRINT_HELPER " Checking Expired Non-deferrable Timers On Slave1 Task "
    GOSUB PRINT_HELPER "======================================================="
    GOSUB PRINT_HELPER ""
    &start_cnt=v.value(timer_expired_cnt_slave1)
    &curr_cnt=v.value(timer_expired_cnt_slave1)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave1
    (
      &timer_expired=var.string(timers_expired_slave1[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave1[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave1[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave1[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave1[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        GOSUB PRINT_HELPER "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave1[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave1[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave1[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave1[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave1[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        GOSUB PRINT_HELPER "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave2)
  IF (&ret==0x3)
  (
    GOSUB PRINT_HELPER "======================================================="
    GOSUB PRINT_HELPER " Checking Expired Non-deferrable Timers On Slave2 Task "
    GOSUB PRINT_HELPER "======================================================="
    GOSUB PRINT_HELPER ""
    &start_cnt=v.value(timer_expired_cnt_slave2)
    &curr_cnt=v.value(timer_expired_cnt_slave2)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave2
    (
      &timer_expired=var.string(timers_expired_slave2[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave2[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave2[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave2[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave2[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        GOSUB PRINT_HELPER "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave2[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave2[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave2[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave2[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave2[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        GOSUB PRINT_HELPER "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave3)
  IF (&ret==0x3)  
  (
    GOSUB PRINT_HELPER "======================================================="
    GOSUB PRINT_HELPER " Checking Expired Non-deferrable Timers On Slave3 Task "
    GOSUB PRINT_HELPER "======================================================="
    GOSUB PRINT_HELPER ""
    &start_cnt=v.value(timer_expired_cnt_slave3)
    &curr_cnt=v.value(timer_expired_cnt_slave3)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave3
    (
      &timer_expired=var.string(timers_expired_slave3[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave3[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave3[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave3[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave3[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        GOSUB PRINT_HELPER "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave3[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave3[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave3[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave3[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave3[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        GOSUB PRINT_HELPER "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )
  )

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "==========================================="
  GOSUB PRINT_HELPER " Checking for Active Non-deferrable Timers "
  GOSUB PRINT_HELPER "==========================================="
  GOSUB PRINT_HELPER ""

  &tmr=v.value(\timer\timers.active.list.first)
  &iterator=1

  WHILE &tmr!=0
  (
    &deferrable=v.value(((timer_internal_type*)&tmr)->group->deferrable)

    IF &deferrable==0
    (
      GOSUB PRINT_HELPER "Deferrable Timer #&iterator in linked list:"
      GOSUB PRINT_TIMER_INFO &tmr &iterator
      &iterator=&iterator+1
    )

    &tmr=v.value(((timer_internal_type*)&tmr)->next)
  )

  CLOSE #3
  GOSUB PRINT_HELPER "ULog file output in the following directory: &out_dir_ulog"

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  
  AREA.CLOSE TLO
  
  WE.AREA.select TIMER
  
RETURN

;============================================================================
; Reset the starting index iterator for the respective debug vars.
;============================================================================
RESET_DEBUG_VAR_ITERATOR:

&iterator=0x1

 while (&iterator<=&number_of_debug_vars)
   (
     ; Get the debug var name from the iterator
	 &&deref_debug_var_name="&debug_var&iterator"
 
	 ; Get the starting index deref for the debug var
	 &&defer_index="&index_&deref_debug_var_name"
	 
	 ; reinitialize the value
	 &iterator_&deref_debug_var_name=&defer_index
	 &first_traversal_&deref_debug_var_name=&TRUE
 
	 ; increment the iterator
     &iterator=&iterator+0x1
   )

RETURN

;============================================================================
; Reset the starting index iterator for the respective debug vars.
;============================================================================
GET_NEXT_TIMETICK_VAL:
  ENTRY &dbg_var_id

  &get_next_timetick_val_ret=0xFEEDF00D
  
  &&deref_dbg_var_name="&debug_var&dbg_var_id"
  &&deref_dbg_tt_name="&debug_var_tt_name&dbg_var_id"
  &&deref_dbg_extra="&debug_var_extra&dbg_var_id"
  
  &&deref_len="&len_&deref_dbg_var_name"
  &&deref_index="&index_&deref_dbg_var_name"
  &&deref_iterator="&iterator_&deref_dbg_var_name"
  &&deref_is_there="&IS_THERE_&deref_dbg_var_name"
  &&deref_tt_jump="&timetick_jump_&deref_dbg_var_name"
  
  var.if (&deref_is_there==&FALSE || &deref_tt_jump==&TRUE)
   (
    RETURN
   )
  
  ; reset the iterator to zero if it has reached the boundry
  if (&deref_iterator==&deref_len)
   (
   &iterator_&deref_dbg_var_name=0x0
   )
 
  &&deref_iterator_2="&iterator_&deref_dbg_var_name"
  &&deref_first_traversal="&first_traversal_&deref_dbg_var_name"
  
  
  var.if (&deref_iterator_2!=&deref_index || &deref_first_traversal==&TRUE)
   (
    if ("&deref_dbg_extra"!="0x0")
     (
	  &deref_dbg_var_name="&deref_dbg_var_name"+".&deref_dbg_extra"
	 )
    &get_next_timetick_val_ret=v.value(&deref_dbg_var_name[&deref_iterator_2].&deref_dbg_tt_name)
   )

RETURN

;============================================================================
; get the filename to use for merged outfile from CMD itself
;============================================================================
GET_MERGED_LOGS_FILENAME_CMD:

&FILENAME_PREFIX=""

GOSUB PRINT_HELPER ""
GOSUB PRINT_HELPER "Enter the output filename (leave blank to use 'timer_unified_logs.log' only)"
GOSUB PRINT_HELPER ""

enter &FILENAME_PREFIX

if "&FILENAME_PREFIX"==""
 &postfix_name="timer_unified_logs.log"
else
  &postfix_name="_timer_unified_logs.log"

&get_merged_logs_filename_ret="&FILENAME_PREFIX"+"&postfix_name"

RETURN

;============================================================================
; get the filename to use for merged outfile
;============================================================================
GET_MERGED_LOGS_FILENAME:

&FILENAME_PREFIX=""

DIALOG
(
  HEADER "Output Filename"
; define dialog width by printine empty text: POS 0. 0. <width> 1.
  POS 0. 0. 80. 1.
  TEXT ""
  
  POS 1. 0. 75. 1.
  TEXT "Enter the output filename prefix:"
  text_entered:		EDIT "" ""
  TEXT ""
  TEXT "e.g. If entered 'XYZ' ; then filename would be 'XYZ_timer_unified_logs.log'"
  TEXT "- leave blank to use 'timer_unified_logs.log' only"
  
  POS 1. 6. 10. 1.
  DEFBUTTON "OK" "CONTinue"
)
STOP
&FILENAME_PREFIX=DIALOG.STRING(text_entered);
DIALOG.END

if "&FILENAME_PREFIX"==""
 &postfix_name="timer_unified_logs.log"
else
  &postfix_name="_timer_unified_logs.log"

&get_merged_logs_filename_ret="&FILENAME_PREFIX"+"&postfix_name"

RETURN

;============================================================================
; Print the merged debug logs for timer-services
;============================================================================
PRINT_MERGED_LOGS:
 
 ; Reset the debug var iterator
   GOSUB RESET_DEBUG_VAR_ITERATOR
 
 ; Init local vars
 &tt_from_dbg_var=0x1FFFFFFFFFFFFF
 &dbg_var_identifier=0xF00FF00F
 
 ; Get the filename for outfile
 GOSUB GET_MERGED_LOGS_FILENAME_CMD
 
 ; Open / Create the file for the output
 &uds_out_dir="&output_directory"+"\&get_merged_logs_filename_ret"

 OPEN #15 &uds_out_dir /Create
 
 while (&dbg_var_identifier!=0xFFFFFFFF)
  (
   ; reinitialize the local script vars
   &dbg_var_identifier=0xFFFFFFFF
   &iterator=0x1
   &tt_from_dbg_var=0x1FFFFFFFFFFFFF
   
   while (&iterator<=&number_of_debug_vars)
   (
	 GOSUB GET_NEXT_TIMETICK_VAL &iterator
	 
	 var.if (&get_next_timetick_val_ret!=0xFEEDF00D && &get_next_timetick_val_ret<=&tt_from_dbg_var)
	   (	 
	     &tt_from_dbg_var=&get_next_timetick_val_ret
		 &dbg_var_identifier=&iterator
	   )
	 ; increment the iterator
     &iterator=&iterator+0x1
   )
   
   ; Send the debug var data to the out file
   if (&dbg_var_identifier!=0xFFFFFFFF)
    (
	GOSUB WRITE_OUT_FILE &dbg_var_identifier
	)
  )
  
  CLOSE #15
  
  GOSUB PRINT_HELPER "Merged Logs created & updated : &uds_out_dir"
  
RETURN

;============================================================================
; Write the debug var info on the output file
;============================================================================
WRITE_OUT_FILE:
  ENTRY &debug_var_id
  
  &tt_val_temp_str=0x0
  &str_to_write=""
  &&deref_debug_var_name="&debug_var&debug_var_id"
  &&deref_debug_extra="&debug_var_extra&debug_var_id"
  &&deref_debug_tt_str="&debug_var_tt_name&debug_var_id"
  
  &&deref_iterator="&iterator_&deref_debug_var_name"
  &deref_debug_var_name_to_use="&deref_debug_var_name"

  if ("&deref_debug_extra"!="0x0")
    (
	  &deref_debug_var_name_to_use="&deref_debug_var_name"+".&deref_debug_extra"
	;  &str_to_write=var.string(&deref_debug_var_name_2[&deref_iterator])
	;  &tt_val_temp_str=v.value(&deref_debug_var_name_2[&deref_iterator].&deref_debug_tt_str)
	)  
;  else
    ;(
	;  &str_to_write=var.string(&deref_debug_var_name[&deref_iterator])
	;  &tt_val_temp_str=v.value(&deref_debug_var_name[&deref_iterator].&deref_debug_tt_str)
	;)
  &tt_val_temp_str=v.value(&deref_debug_var_name_to_use[&deref_iterator].&deref_debug_tt_str)
  ;WRITE #15 "&tt_val_temp_str:   &deref_debug_var_name[&deref_iterator]= &str_to_write"
  WRITE #15 %CONTinue "&tt_val_temp_str:   "
  WRITE #15 %CONTinue "&deref_debug_var_name_to_use[&deref_iterator]= "
  Var.WRITE #15 &deref_debug_var_name_to_use[&deref_iterator]
  
  ; Increment the index
  &iterator_&deref_debug_var_name=&deref_iterator+0x1
  
  ; Mark first_traversal as false if it is not so
  &&deref_first_traversal="&first_traversal_&deref_debug_var_name"
  if (&deref_first_traversal==&TRUE)
	 (
	  &first_traversal_&deref_debug_var_name=&FALSE
	 )
	
RETURN


;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;============================================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;============================================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;               D e b u g   S u b r o u t i n e s 
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;============================================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;============================================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


;============================================================================
; General Debugging.
;============================================================================

GENERAL_TIMER_DEBUG:

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  ; Backup the line counter
  &general_timer_debug_line_counter=&print_line_counter
  &print_line_counter=1  
  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER "                     G e n e r a l   D e b u g                        "
  GOSUB PRINT_HELPER "######################################################################"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""

  &ret=0x0  
  ;
  ; Check first & last timer pointers
  ;
  &tmr_first=v.value(\timer\timers.active.list.first)
  &tmr_last=v.value(\timer\timers.active.list.last)
  &timers_processing=v.value(\timer\timers.processing)

  IF &timers_processing==1
  (
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER "WARNING: Timer task is currently processing timers, linked list may appear corrupted, but may not actually be!"
    GOSUB PRINT_HELPER ""
  )

  IF (&tmr_first==0)&&(&tmr_last!=0)
  (
    GOSUB PRINT_HELPER "ERROR: Timer list appears to be corrupted.  FIRST timer is NULL, LAST is not. "
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
  )

  IF (&tmr_last==0)&&(&tmr_first!=0)
  (
    GOSUB PRINT_HELPER "ERROR: Timer list appears to be corrupted.  LAST timer is NULL, FIRST is not. "
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
  )


  ;
  ; Check first & last timer pointers
  ;

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Checking Bins..."
  GOSUB PRINT_HELPER ""
  GOSUB TIMER_BIN_CHECK_DEBUG
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Bin Checking Completed!"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Checking Timer Groups..."
  GOSUB PRINT_HELPER ""
  GOSUB TIMER_GROUP_LIST_CHECK 0x0 0x0
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Group Checking Completed!"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"  

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Checking Timer Linked List..."
  GOSUB PRINT_HELPER ""
  GOSUB TIMER_ACTIVE_LIST_CHECK_DEBUG
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Timer Linked List Checking Completed!"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Checking Timer Free Queue..."
  GOSUB PRINT_HELPER ""
  GOSUB TIMER_FREE_Q_CHECKUP
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Timer Free Queue Checking Completed!"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"  

  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Checking Timetick jumps cases..."
  GOSUB PRINT_HELPER ""
  GOSUB CHECK_FOR_TIMETICK &FALSE
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Timetick jump checking complete!"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"  
  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Checking Callback Durations..."
  GOSUB PRINT_HELPER ""
  GOSUB TIMER_CHECK_LONG_CALLBACKS
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Callback Duration Checking Completed!"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"

  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Checking For Delayed ISR..."
  GOSUB PRINT_HELPER ""
  GOSUB TIMER_CHECK_FOR_DELAYED_ISR
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Delayed ISR Checking Completed!"
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "######################################################################"

  
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER ""
  AREA.CLOSE TLO
  
  WE.AREA.select TIMER

  ; restore the line counter value 
  &print_line_counter=&general_timer_debug_line_counter
    

RETURN

;============================================================================
timer_free_q checing subroutine
;============================================================================
TIMER_FREE_Q_CHECKUP:

  &q_var_name="timer_free_q"
  &q_var_max_cnt=0xFF
  &iterator=0x0
  &q_var_addr=var.value(&(&q_var_name))
  
  ; Calculate num elements in  timer_buffer array
  &size_timer_buffer=v.sizeof(timer_buffer)
  &timer_buffer_unit_size=v.sizeof(timer_buffer[0])
  &size_timer_buffer=v.value(&size_timer_buffer / &timer_buffer_unit_size)  
  
  &q_var_max_cnt=&size_timer_buffer  
  
  ; Check if the count is correct
  &queue_cnt_val=var.value((*(q_type *)&q_var_addr)->cnt)
  &q_nxt_ptr=var.value((*(q_type *)&q_var_addr)->link.next_ptr)
  &q_last_ptr=var.value((*(q_type *)&q_var_addr)->link.prev_ptr)
  
  ; If next / prev pointers are NULL then print error message & return
  if (&q_nxt_ptr==0x0)
   (
     GOSUB PRINT_HELPER "ERROR:  &q_var_name->next_ptr is NULL !!! it can never be NULL"
	 RETURN
   )
  if (&q_last_ptr==0x0)
   (
     GOSUB PRINT_HELPER "ERROR:  &q_var_name->prev_ptr is NULL !!! it can never be NULL"
	 RETURN
   )  
  
  ; If count is zero, the queue is an empty queue
  if (&queue_cnt_val==0)
   (
     var.if (&q_nxt_ptr!=&q_var_addr || &q_last_ptr!=&q_var_addr)
	  (
	     GOSUB PRINT_HELPER "ERROR:  &q_var_name->cnt is zero & next_ptr/prev_ptr not pointing to the queue itself."
		 RETURN
	  )
   )
  else
   (
    GOSUB CHECK_FOR_PTR_IN_ARR &q_nxt_ptr timer_buffer
	if (&check_for_ptr_in_arr_ret!=&TRUE)
	(
	  &check_for_ptr_in_arr_ret=&FALSE
	  GOSUB PRINT_HELPER "ERROR: &q_var_name.link->next_ptr is not a timer buffer array address"
	  RETURN
	)
    GOSUB CHECK_FOR_PTR_IN_ARR &q_last_ptr timer_buffer
	if (&check_for_ptr_in_arr_ret!=&TRUE)
	(
	  &check_for_ptr_in_arr_ret=&FALSE
	  GOSUB PRINT_HELPER "ERROR: &q_var_name.link->prev_ptr is not a timer buffer array address"
	  RETURN
	)	
   )
   
   
  ; If count is more than what the queue can gobble up, throw error
  if (&queue_cnt_val>&q_var_max_cnt)
   (
     GOSUB PRINT_HELPER "ERROR:  &q_var_name->cnt = &queue_cnt_val, this is too large"
	 RETURN
   )

  
   ; the next ptr of the last pointer of the queue should point to the queue itself
   &q_last_ptrs_next=var.value((*(q_type *)&q_last_ptr)->link.next_ptr)
   if (&q_last_ptrs_next!=&q_var_addr)
     GOSUB PRINT_HELPER "ERROR:  &q_var_name->prev_ptr->next_ptr is not pointing to the queue itself"
   
   &q_ptr=&q_var_addr
   &q_ptr_last_ptr=0x0
  ; traverse through the queue to find incorrect entries in between
  while (&iterator<=&queue_cnt_val)
   (
	  &tmr_pointer=var.value((*(q_type *)&q_ptr)->link.next_ptr)
	  if (&tmr_pointer!=&q_var_addr)
	  (
	  GOSUB CHECK_FOR_PTR_IN_ARR &tmr_pointer timer_buffer
	  if (&check_for_ptr_in_arr_ret!=&TRUE)
	  (
	    &check_for_ptr_in_arr_ret=&FALSE
	    GOSUB PRINT_HELPER "ERROR: &tmr_pointer obtained from &q_var_name is not a timer buffer array address"
	  )
	  else
	  (
	  GOSUB CHECK_FREE_INTERNAL_TIMER &tmr_pointer
	  )
	 )
   
	 &q_ptr_last_ptr=&q_ptr
     &q_ptr=var.value((*(q_type *)&q_ptr)->link.next_ptr)
     &iterator=&iterator+1
   )
  ; check that after the queue is traversed, the last entry is correct
  if (&q_ptr_last_ptr!=&q_last_ptr)
     GOSUB PRINT_HELPER "ERROR:  &q_var_name last pointer traversed is not matching with &q_var_name->prev_ptr"

  ; Manually traverse the queue to count the number of elements
  &q_ptr=var.value((*(q_type *)&q_var_addr)->link.next_ptr)
  &q_element_count=0
  while (&q_ptr!=&q_var_addr)
   (
   &q_ptr=var.value((*(q_type *)&q_ptr)->link.next_ptr)
   &q_element_count=&q_element_count+1
   if (&q_element_count>&q_var_max_cnt)
    (
	  GOSUB PRINT_HELPER "ERROR:  &q_var_name has incorrect number of queue items"
	  RETURN
	)
   )
  if (&q_element_count!=&queue_cnt_val)
   GOSUB PRINT_HELPER "ERROR:  &q_var_name->cnt (&queue_cnt_val) != Manually traversed count (&q_element_count)"
  
RETURN

;============================================================================
Bin checking subroutine
;============================================================================
TIMER_BIN_CHECK_DEBUG:
  
  &rain_check=y.type(timer_bin_pool)
  if (&rain_check!=0x3)
	(
	GOSUB PRINT_HELPER "Debug Variable : 'timer_bin_pool' is not availale in this build"
	RETURN
	)

  &bins_first=v.value((struct timer_bin_struct*)\timer\timers.bins.first)
  &bins_last=v.value((struct timer_bin_struct*)\timer\timers.bins.last)
  &bins_cnt=v.value((int*)\timer\timers.bins.count)
  
  GOSUB PRINT_HELPER "Checking for loops in the bin..."  
  GOSUB LIST_LOOP_CHECK &bins_first next_bin timer_bin_ptr
	if (&list_loop_check_ret==&FALSE)
	   (
	   GOSUB PRINT_HELPER "ERROR:  Loop in timers.bins"
	   GOSUB PRINT_HELPER ""
	   )  

  ;
  ; Check pointers to see if they make sense
  ;

  IF (&bins_first==0)&&(&bins_last!=0)
  (
    GOSUB PRINT_HELPER "ERROR:  Timer bin list appears corrupted.  FIRST bin is NULL, LAST is not"
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
  )

  IF (&bins_last==0)&&(&bins_first!=0)
  (
    GOSUB PRINT_HELPER "ERROR:  Timer bin list appears corrupted.  LAST bin is NULL, FIRST is not"
    GOSUB PRINT_HELPER ""
    GOSUB PRINT_HELPER ""
  )

  ;
  ; Verify the list of bins
  ;

  IF (&bins_first!=0)&&(&bins_last!=0)
  (
    ;
    ; Check forward direction of list counts
    ;

    &forward_cnt=0
    &bin=&bins_first
    &last_bin=&bin

    WHILE &bin!=0
    (
      &forward_cnt=&forward_cnt+1
      &last_bin=&bin
      &bin=v.value(((struct timer_bin_struct*)&bin)->next_bin)
    )

    IF &forward_cnt!=&bins_cnt
    (
      GOSUB PRINT_HELPER "ERROR: Detected Incorrect Number of Bins! Forward Count: &forward_cnt  Bins Count: &bins_cnt"
      GOSUB PRINT_HELPER ""
      GOSUB PRINT_HELPER ""
    )

    IF &last_bin!=&bins_last
    (
      GOSUB PRINT_HELPER "ERROR:  Detected Incorrect Last Bin!  Actual: &bins_last  Propagated: &last_bin"
    )


    ;
    ; Check reverse direction of list counts
    ;

    &reverse_cnt=0
    &bin=&bins_last
    &last_bin=&bin


    WHILE &bin!=0
    (
      &reverse_cnt=&reverse_cnt+1
      &last_bin=&bin
      &bin=v.value(((struct timer_bin_struct*)&bin)->prev_bin)
    )

    IF &reverse_cnt!=&bins_cnt
    (
      GOSUB PRINT_HELPER "ERROR: Detected Incorrect Number of Bins! Reverse Count: &reverse_cnt  Bins Count: &bins_cnt"
      GOSUB PRINT_HELPER ""
      GOSUB PRINT_HELPER ""
    )

    IF &last_bin!=&bins_first
    (
      GOSUB PRINT_HELPER "ERROR:  Detected Incorrect First Bin!  Actual: &bins_first  Propagated: &last_bin"
    )

    ;
    ; Check forward direction of list logically
    ;

    &bin_front=&bins_first
    &bin_back=&bins_first
    &counter=1

    WHILE &counter<=(&bins_cnt-1)
    (
      ;
      ; Get Front Direction
      ;

      &bin_back=v.value(((struct timer_bin_struct*)&bin_front)->next_bin->prev_bin)

      IF &bin_back!=&bin_front
      (
        &bin_front_str=v.string((struct timer_bin_struct*)&bin_front)
        &bin_back_str=v.string((struct timer_bin_struct*)&bin_back)
        GOSUB PRINT_HELPER "ERROR: Bin list corruption detected in the forward direction! Bin: &bin_front_str  Fwd->Back_Bin: &bin_back_str"
        GOSUB PRINT_HELPER ""
        GOSUB PRINT_HELPER ""
      )

      &bin_front=v.value(((struct timer_bin_struct*)&bin_front)->next_bin)
      
      &counter=&counter+1
    )
    

    ;
    ; Check reverse direction of list logically
    ;

    &bin_front=&bins_last
    &bin_back=&bins_last
    &counter=1

    WHILE &counter<=(&bins_cnt-1)
    (
      ;
      ; Get Reverse Direction
      ;

      &bin_front=v.value(((struct timer_bin_struct*)&bin_back)->prev_bin->next_bin)

      IF &bin_back!=&bin_front
      (
        &bin_front_str=v.string((struct timer_bin_struct*)&bin_front)
        &bin_back_str=v.string((struct timer_bin_struct*)&bin_back)
        GOSUB PRINT_HELPER "ERROR: Bin list corruption detected in the reverse direction! Bin: &bin_back_str  Back->Fwd_Bin: &bin_front_str"
        GOSUB PRINT_HELPER ""
        GOSUB PRINT_HELPER ""
      )

      &bin_back=v.value(((struct timer_bin_struct*)&bin_front)->prev_bin)
      
      &counter=&counter+1
    )
    
    ;
    ; Check timers within bin & bin ordering
    ;  

    &bin=&bins_first

    WHILE (&bin!=0)
    (
      &tmr_first=v.value((timer_internal_type*)((struct timer_bin_struct*)&bin)->first)
      &tmr_last=v.value((timer_internal_type*)((struct timer_bin_struct*)&bin)->last)
      &cnt=0
      &max=v.value(((struct timer_bin_struct*)&bin)->count)
      &lower=v.value(((struct timer_bin_struct*)&bin)->lower)
      &upper=v.value(((struct timer_bin_struct*)&bin)->upper)

      WHILE (&tmr_first!=0)&&(&cnt<&max)
      (
        &expiry=v.value(((timer_internal_type*)&tmr_first)->expiry)
        IF (&expiry>&upper)
        (
          GOSUB PRINT_HELPER "ERROR: Timer expiry exceeds the upper boundary of the bin! Bin: &bin  Timer: &tmr_first  Expiry: &expiry  Upper Bound: &upper"
        )

        IF (&expiry<&lower)
        (
          GOSUB PRINT_HELPER "ERROR: Timer expiry exceeds the lower boundary of the bin! Bin: &bin  Timer: &tmr_first  Expiry: &expiry  Lower Bound: &lower"
        )

        IF (&cnt==(&max-1))&&(&tmr_first!=&tmr_last)
        (
          GOSUB PRINT_HELPER "ERROR: Last timer in bin appears to be incorrect! Bin: &bin  Last Timer in Bin: &tmr_last  Traversed Last Timer: &tmr_first"          
        )

        &tmr_first=v.value(((timer_internal_type*)&tmr_first)->next)
        &cnt=&cnt+1
      )

      &bin=v.value(((struct timer_bin_struct*)&bin)->next_bin)
    )
  )


RETURN

;============================================================================
; Check for the active list of timer
;============================================================================
TIMER_LIST_SANITY_CHECK:
 ENTRY &tmr &last_expiry &order &last_tmr &next &prev

    &expiry=v.value(((timer_internal_type*)&tmr)->expiry)
    var.if (&order==1 && &expiry<&last_expiry)
    (
      &last_tmr_str=v.string((timer_internal_type*)&last_tmr)
      &tmr_str=v.string((timer_internal_type*)&tmr)
      GOSUB PRINT_HELPER "ERROR: Timer expiries appear out of order on the timer linked list! Previous Timer:&last_tmr_str  Previous Expiry:&last_expiry  Timer:&tmr_str  Expiry:&expiry"
    )
    var.if (&order==2 && &expiry>&last_expiry)
    (
      &last_tmr_str=v.string((timer_internal_type*)&last_tmr)
      &tmr_str=v.string((timer_internal_type*)&tmr)
      GOSUB PRINT_HELPER "ERROR: Timer expiries appear out of order on the timer linked list! Previous Timer:&last_tmr_str  Previous Expiry:&last_expiry  Timer:&tmr_str  Expiry:&expiry"
    )

    &tmr_next=v.value(((timer_internal_type*)&tmr)->&next)
    IF &tmr_next!=0
    (
      &tmr_next_prev=v.value(((timer_internal_type*)&tmr_next)->&prev)
      IF &tmr_next_prev!=&tmr
      (
        &last_tmr_str=v.string((timer_internal_type*)&tmr_next_prev)
        &tmr_str=v.string((timer_internal_type*)&tmr)
        GOSUB PRINT_HELPER "ERROR: Timer linked list corruption detected! &tmr_str->&next->&prev!=&last_tmr_str"
      )
    )

    &timer_state=v.value(((timer_internal_type*)&tmr)->timer_ext->timer_state)
    ; If timer is not in set state, display
    var.if ( &timer_state!=0x0FEDCBAA && &timer_state!=0x0FEDCBAE )
    (
      &timer_state_val=v.string(((timer_internal_type*)&tmr)->timer_ext->timer_state)
      &tmr_str=v.string((timer_internal_type*)&tmr)
      &tmr_ext_str=v.string(((timer_internal_type*)&tmr)->timer_ext)
      GOSUB PRINT_HELPER "ERROR:  External-timer=&tmr_ext_str, for active internal-timer=&tmr_str, not in SET/RESUMED state! Timer State: &timer_state_val"
    )
	
    GOSUB TIMER_DIAGNOSIS &tmr
	

RETURN
	
;============================================================================
; Check for the list of timer
;============================================================================
TIMER_ACTIVE_LIST_CHECK:
  ENTRY &loop_in_fwd_traversal &loop_in_bkwd_traversal &timer_list

  &timer_ptr_first=var.value(\timer\timers.&timer_list.list.first)
  &timer_ptr_last=var.value(\timer\timers.&timer_list.list.last)
  
  &fwd_timer_count=0x0
  &rev_timer_count=0x0
  
; ---------------------------------------------------------------------------
  ; check the timers in fwd traversal
  &timer_ptr=&timer_ptr_first
  if (&loop_in_fwd_traversal!=&TRUE)
  (
  &last_expiry=var.value(((timer_ptr_internal_type)&timer_ptr)->expiry)
  &last_tmr=&timer_ptr
  GOSUB PRINT_HELPER ""  
  GOSUB PRINT_HELPER "==== Forward traversing through &timer_list timers list..."  
  while (&timer_ptr!=0x0)
   (
	 GOSUB TIMER_LIST_SANITY_CHECK &timer_ptr &last_expiry 1 &last_tmr next prev
     &last_tmr=&timer_ptr
	 &last_expiry=var.value(((timer_ptr_internal_type)&last_tmr)->expiry)
     &fwd_timer_count=&fwd_timer_count+1
     &timer_ptr=var.value(((timer_ptr_internal_type)&timer_ptr)->next)
   )
  )
; ---------------------------------------------------------------------------
  ; check the timers in rev traversal
  &timer_ptr=&timer_ptr_last
  if (&loop_in_bkwd_traversal!=&TRUE)
  (
  &last_expiry=var.value(((timer_ptr_internal_type)&timer_ptr)->expiry)
  &last_tmr=&timer_ptr
  GOSUB PRINT_HELPER ""  
  GOSUB PRINT_HELPER "==== Reverse traversing through &timer_list timers list..."  
  while (&timer_ptr!=0x0)
   (
	 if (&loop_in_fwd_traversal==&TRUE)
	   GOSUB TIMER_LIST_SANITY_CHECK &timer_ptr &last_expiry 2 &last_tmr prev next
     &last_tmr=&timer_ptr
	 &last_expiry=var.value(((timer_ptr_internal_type)&last_tmr)->expiry)	   
     &rev_timer_count=&rev_timer_count+1
     &timer_ptr=var.value(((timer_ptr_internal_type)&timer_ptr)->prev)
   )
  )  
; ---------------------------------------------------------------------------  
; Match the fwd / rev traversal count;
if (&rev_timer_count!=&fwd_timer_count)
  (
  GOSUB PRINT_HELPER ""  
  GOSUB PRINT_HELPER "Mismatch in fwd timers count (&fwd_timer_count) w.r.t. reverse timers count(&rev_timer_count)"

    ; check the timers in rev traversal
    &timer_ptr=&timer_ptr_last
    if (&loop_in_bkwd_traversal!=&TRUE)
    (
    GOSUB PRINT_HELPER ""  
    GOSUB PRINT_HELPER "==== Running Diagnosis on reverse &timer_list timer linked list"    	
    &last_expiry=var.value(((timer_ptr_internal_type)&timer_ptr)->expiry)
    &last_tmr=&timer_ptr
    while (&timer_ptr!=0x0)
     (
       GOSUB TIMER_LIST_SANITY_CHECK &timer_ptr &last_expiry 2 &last_tmr prev next
       &last_tmr=&timer_ptr
	   &last_expiry=var.value(((timer_ptr_internal_type)&last_tmr)->expiry)	   
       &rev_timer_count=&rev_timer_count+1
       &timer_ptr=var.value(((timer_ptr_internal_type)&timer_ptr)->prev)
     )
    )
  )
  
  
RETURN

;============================================================================
;Checking active list of timers
;============================================================================
TIMER_ACTIVE_LIST_CHECK_DEBUG:

   &loop_in_active_list_fwd=&FALSE
   &loop_in_active_list_rev=&FALSE
   &loop_in_p0_active_list_fwd=&FALSE
   &loop_in_p0_active_list_rev=&FALSE
   

  ; Check for loops in the active list & p0_active list
  ;-------------------------------------------------------------------------- 
    GOSUB PRINT_HELPER "Checking for forward / reverse loops in the active timer list..."
    ; Front traversal
	&tmr_ptr=v.value(\timer\timers.active.list.first)
    GOSUB LIST_LOOP_CHECK &tmr_ptr next timer_ptr_internal_type
	if (&list_loop_check_ret==&FALSE)
	   (
	   &loop_in_active_list_fwd=&TRUE
	   GOSUB PRINT_HELPER "Loop in active timers forward list, aborting further forward traversing of the active list"
	   GOSUB PRINT_HELPER ""
	   )
   ; Reverse traversal
	&tmr_ptr=v.value(\timer\timers.active.list.last)
    GOSUB LIST_LOOP_CHECK &tmr_ptr prev timer_ptr_internal_type
	if (&list_loop_check_ret==&FALSE)
	   (
	   &loop_in_active_list_rev=&TRUE
	   GOSUB PRINT_HELPER "Loop in active timers reverse list, aborting further backward traversing of the active list"
	   GOSUB PRINT_HELPER ""
	   )   
	   
  ; Check if it is B Family for p0_active list
   if (&is_b_family==&TRUE)
	 (
	   GOSUB PRINT_HELPER "Checking for forward / reverse loops in the p0_active timer list..."
	   ; Front traversal
	   &tmr_ptr=v.value(\timer\timers.p0_active.list.first)	   
	   GOSUB LIST_LOOP_CHECK &tmr_ptr next timer_ptr_internal_type
	   if (&list_loop_check_ret==&FALSE)
	     (
	      &loop_in_p0_active_list_fwd=&TRUE
		  GOSUB PRINT_HELPER "Loop in p0_active timers list, aborting further forward traversing of the p0_active list"
	      GOSUB PRINT_HELPER ""
	     )
		 
	   ; Back traversal
	   &tmr_ptr=v.value(\timer\timers.p0_active.list.last)	   
	   GOSUB LIST_LOOP_CHECK &tmr_ptr prev timer_ptr_internal_type
	   if (&list_loop_check_ret==&FALSE)
	     (
	      &loop_in_p0_active_list_rev=&TRUE
		  GOSUB PRINT_HELPER "Loop in p0_active timers list, aborting further reverse traversing of the p0_active list"
	      GOSUB PRINT_HELPER ""
	     )		 
	 )

  ;--------------------------------------------------------------------------
  ; Check timers one by one from the timer_buffer array
  GOSUB PRINT_HELPER "Traversing through timer_buffer array..."
  &sizeof_timer_buffer=v.sizeof(timer_buffer)/v.sizeof(timer_buffer[0])
  ;GOSUB TIMER_BUFFER_ARRAY_CHECK &sizeof_timer_buffer &loop_in_active_list_fwd &loop_in_active_list_rev &loop_in_p0_active_list_fwd &loop_in_p0_active_list_rev
  
  
  ; Check for double internal timer cases
  GOSUB PRINT_HELPER ""
  GOSUB PRINT_HELPER "Checking for double internal timer cases for same external timer..."
  GOSUB PRINT_HELPER ""
  GOSUB TIMER_DOUBLE_ENTRY_CHECK timer_buffer &sizeof_timer_buffer timer_ext timer_ptr_type

  ;--------------------------------------------------------------------------  
  ; Check timers from the active timers list
    GOSUB PRINT_HELPER "Traversing through active timers list..."
    GOSUB TIMER_ACTIVE_LIST_CHECK &loop_in_active_list_fwd &loop_in_active_list_rev active

  ;--------------------------------------------------------------------------
  ; Check timers from the p0_active timers list  
  var.if (&is_b_family==&TRUE)
    (
      ; Check by traversing the p0 active timers list
	  GOSUB PRINT_HELPER ""
      GOSUB PRINT_HELPER "Traversing through p0_active timers list..."
      GOSUB TIMER_ACTIVE_LIST_CHECK &loop_in_p0_active_list_fwd &loop_in_p0_active_list_rev p0_active
	)
	
  GOSUB PRINT_HELPER "Done checking for the timers."
	
RETURN	

;============================================================================
;Checking timer_buffer array
;============================================================================
CHECK_FREE_INTERNAL_TIMER:
  ENTRY &tmr_pointer

  &fail_timer_struct_check=&FALSE
  
	       ; Get values from timer structure & check them !!
	       &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->internal_q)
	       if (&timer_struct_val==0x0)
	         &fail_timer_struct_check=&TRUE
		   else
		     (
			   ; check if the links->next pointer is a valid timer_buffer pointer
			   &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->link.next_ptr)
               GOSUB CHECK_FOR_PTR_IN_ARR &timer_struct_val timer_buffer
			   if (&check_for_ptr_in_arr_ret!=&TRUE)
			   (
			    &timer_free_q_addr=var.value(&timer_free_q)
				if (&timer_struct_val!=&timer_free_q_addr)
			    GOSUB PRINT_HELPER "ERROR: Incorrect value @ timer_buffer[&local_iterator].link.next_ptr = &timer_struct_val"
			   )
			 )

           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->internal_q)
	       if (&timer_struct_val!=0x0BABABAB)
	         &fail_timer_struct_check=&TRUE			 
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->group)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->tcb)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->sigs)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->func1)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->func2)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->data)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->list)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->expiry)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->reload)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->start)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->sclk_delta)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->cache.duration)
           if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->cache.duration_sclk)
           if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->cache.reload)
           if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->cache.reload_sclk)
           if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->cache.unit)
           if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE			 
		   &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->next)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->prev)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->bin)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE	  	  
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->timer_ext)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->slave_task_assigned)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
		  if (&is_b_family==&TRUE)
		   (
           &timer_struct_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->timer_priority)
	       if (&timer_struct_val!=0x0)
	         &fail_timer_struct_check=&TRUE
		   )

          ; Print error message if there was some incorrect value in the structure		   
		  if (&fail_timer_struct_check==&TRUE)
		   GOSUB PRINT_HELPER "ERROR: Incorrect value in free internal timer structure @ timer_buffer[&local_iterator]"		   

RETURN	

;============================================================================
;Checking timer_buffer array
;============================================================================
TIMER_BUFFER_ARRAY_CHECK:
  ENTRY &timer_buffer_size &loop_active_list_fwd &loop_active_list_rev &loop_p0_active_list_fwd &loop_p0_active_list_rev

  &local_iterator=0x0

  
  &num_timers_in_active_list=0x0
  &num_timers_in_p0_active_list=0x0
  
  while (&local_iterator<&timer_buffer_size)
   (
     &tmr_pointer=var.value(&timer_buffer[&local_iterator])
     &timer_internal_q=var.value(((timer_ptr_internal_type)&tmr_pointer)->internal_q)
	 
     ; Check if the index is correct
	 &timer_index_val=var.value(((timer_ptr_internal_type)&tmr_pointer)->index)
	 if (&timer_index_val!=&local_iterator)
	  (
	    GOSUB PRINT_HELPER "ERROR: Incorrect value @ timer_buffer[&local_iterator].index = &timer_index_val"
	  )

	 ;--------------------------------------------------------------------------
	 ; Checks if the timer queue state is TIMER_IN_FREE_Q
	 if (&timer_internal_q==0x0BABABAB)
        (
           GOSUB CHECK_FREE_INTERNAL_TIMER &tmr_pointer
		)
     else if (&timer_internal_q==0x0CACACAC)
	  (
	    ; Get the priority of the timer
		if (&is_b_family==&TRUE)
		(
	      &local_timer_priority=var.value(((timer_ptr_internal_type)&tmr_pointer)->timer_priority)
		
		;-------------------------------------
		; Check for priority active timer
		;-------------------------------------
		var.if (&local_timer_priority==0x0)
		  (
		   if (&loop_p0_active_list_fwd==&FALSE)
		     (
		     &active_list_first_ptr=var.value(&\timer\timers.p0_active.list.first)
		     GOSUB CHECK_FOR_PTR_IN_LIST &tmr_pointer &active_list_first_ptr timer_ptr_internal_type next
		     if (&check_for_ptr_in_list_ret==&FALSE)
		      (
			    GOSUB PRINT_HELPER "ERROR: For timer_buffer[&local_iterator], timer->priority is TIMER_PRIORITY_0, but the timer is not in the p0_active forward list"
			    GOSUB TIMER_DIAGNOSIS &tmr_pointer
			  )
		     )
		   if (&loop_p0_active_list_rev==&FALSE)
		     (
		     &active_list_first_ptr=var.value(&\timer\timers.p0_active.list.first)
		     GOSUB CHECK_FOR_PTR_IN_LIST &tmr_pointer &active_list_first_ptr timer_ptr_internal_type next
		     if (&check_for_ptr_in_list_ret==&FALSE)
		      (
			    GOSUB PRINT_HELPER "ERROR: For timer_buffer[&local_iterator], timer->priority is TIMER_PRIORITY_0, but the timer is not in the p0_active reverse list"
			    GOSUB TIMER_DIAGNOSIS &tmr_pointer
			  )
		     )			 
			var.if (&loop_p0_active_list_rev==&TRUE && &loop_p0_active_list_fwd==&TRUE)
			  GOSUB TIMER_DIAGNOSIS &tmr_pointer	
		  )
		else if (&local_timer_priority==0x1)
		  (
		   if (&loop_active_list_fwd==&FALSE)
		     (
		     &active_list_first_ptr=var.value(&\timer\timers.active.list.first)
		     GOSUB CHECK_FOR_PTR_IN_LIST &tmr_pointer &active_list_first_ptr timer_ptr_internal_type next
		     if (&check_for_ptr_in_list_ret==&FALSE)
		      (
			    GOSUB PRINT_HELPER "ERROR: For timer_buffer[&local_iterator], timer->priority is TIMER_PRIORITY_1, but the timer is not in the active forward list"
			    GOSUB TIMER_DIAGNOSIS &tmr_pointer
			  )
		     )
		   if (&loop_active_list_rev==&FALSE)
		     (
		     &active_list_first_ptr=var.value(&\timer\timers.active.list.first)
		     GOSUB CHECK_FOR_PTR_IN_LIST &tmr_pointer &active_list_first_ptr timer_ptr_internal_type next
		     if (&check_for_ptr_in_list_ret==&FALSE)
		      (
			    GOSUB PRINT_HELPER "ERROR: For timer_buffer[&local_iterator], timer->priority is TIMER_PRIORITY_1, but the timer is not in the active reverse list"
			    GOSUB TIMER_DIAGNOSIS &tmr_pointer
			  )
		     )			 
			var.if (&loop_active_list_rev==&TRUE && &loop_active_list_fwd==&TRUE)
			  GOSUB TIMER_DIAGNOSIS &tmr_pointer			 
		  )
		else
		  (
		    GOSUB PRINT_HELPER "ERROR: Goofed up timer_priority value, timer_buffer[&local_iterator].timer_prio = &local_timer_priority"
			GOSUB TIMER_DIAGNOSIS &tmr_pointer
		  )
		)
	  else
	    (
		   if (&loop_active_list_fwd==&FALSE)
		     (
		     &active_list_first_ptr=var.value(&\timer\timers.active.list.first)
		     GOSUB CHECK_FOR_PTR_IN_LIST &tmr_pointer &active_list_first_ptr timer_ptr_internal_type next
		     if (&check_for_ptr_in_list_ret==&FALSE)
		      (
			    GOSUB PRINT_HELPER "ERROR: timer_buffer[&local_iterator].internal_q = TIMER_NOT_IN_FREE_Q, but the timer is not in the active forward list"
			    GOSUB TIMER_DIAGNOSIS &tmr_pointer
			  )
		     )
		   if (&loop_active_list_rev==&FALSE)
		     (
		     &active_list_first_ptr=var.value(&\timer\timers.active.list.first)
		     GOSUB CHECK_FOR_PTR_IN_LIST &tmr_pointer &active_list_first_ptr timer_ptr_internal_type next
		     if (&check_for_ptr_in_list_ret==&FALSE)
		      (
			    GOSUB PRINT_HELPER "ERROR: timer_buffer[&local_iterator].internal_q = TIMER_NOT_IN_FREE_Q, but the timer is not in the active reverse list"
			    GOSUB TIMER_DIAGNOSIS &tmr_pointer
			  )
		     )			 
			var.if (&loop_active_list_rev==&TRUE && &loop_active_list_fwd==&TRUE)
			  GOSUB TIMER_DIAGNOSIS &tmr_pointer	
		)
	  )
	 else
	  (
	    GOSUB PRINT_HELPER "ERROR: Goofed up internal_q value, timer_buffer[&local_iterator].internal_q = &timer_internal_q"
	  )
     &local_iterator=&local_iterator+1
   )

RETURN

;============================================================================
;Check for timer active list
;============================================================================  
CHECK_FOR_PTR_IN_LIST_DUEL:


  ; Check in the forward direction
  &active_list_first_ptr=var.value(&\timer\timers.active.list.first)
  GOSUB CHECK_FOR_PTR_IN_LIST &tmr_pointer &active_list_first_ptr timer_ptr_internal_type next

RETURN
;============================================================================
;Check for timer active list
;============================================================================  
TIMER_FROM_LIST_CHECK:
  ENTRY &tmr &next &prev

  ; Check that the expiry values in the timer list are in order
  ; and check that the timer list is not broken
  &last_tmr=&tmr
  &last_expiry=0
  &expiry=0
  
  IF &tmr!=0
  (
    &last_expiry=v.value(((timer_internal_type*)&tmr)->expiry)
  )

  WHILE &tmr!=0
  (
    &expiry=v.value(((timer_internal_type*)&tmr)->expiry)
    IF &expiry<&last_expiry
    (
      &last_tmr_str=v.string((timer_internal_type*)&last_tmr)
      &tmr_str=v.string((timer_internal_type*)&tmr)
      GOSUB PRINT_HELPER "ERROR: Timer expiries appear out of order on the timer linked list! Previous Timer:&last_tmr_str  Previous Expiry:&last_expiry  Timer:&tmr_str  Expiry:&expiry"
    )

    &tmr_next=v.value(((timer_internal_type*)&tmr)->&next)
    IF &tmr_next!=0
    (
      &tmr_next_prev=v.value(((timer_internal_type*)&tmr_next)->&prev)
      IF &tmr_next_prev!=&tmr
      (
        &last_tmr_str=v.string((timer_internal_type*)&tmr_next_prev)
        &tmr_str=v.string((timer_internal_type*)&tmr)
        GOSUB PRINT_HELPER "ERROR: Timer linked list corruption detected! Timer->&next->&prev:&last_tmr_str  Timer:&tmr_str"
      )
    )

    &timer_state=v.value(((timer_internal_type*)&tmr)->timer_ext->timer_state)
    ; If timer is not in set state, display
    var.if ( &timer_state!=0x0FEDCBAA && &timer_state!=0x0FEDCBAE )
    (
      &timer_state_val=v.string(((timer_internal_type*)&tmr)->timer_ext->timer_state)
      &tmr_str=v.string((timer_internal_type*)&tmr)
      &tmr_ext_str=v.string(((timer_internal_type*)&tmr)->timer_ext)
      GOSUB PRINT_HELPER "ERROR:  External-timer=&tmr_ext_str, for active internal-timer=&tmr_str, not in SET/RESUMED state! Timer State: &timer_state_val"
    )
	
    GOSUB TIMER_DIAGNOSIS &tmr_pointer
	
    &last_tmr=&tmr
    &last_expiry=&expiry
    &tmr=v.value(((timer_internal_type*)&tmr)->&next)
  )
RETURN

;============================================================================
Checks for long timer callbacks
;===========================================================================
TIMER_CHECK_LONG_CALLBACKS:
  &sizeof_timers_expired=0
  &start_cnt=0
  &curr_cnt=0
  &iterator=1
  &processing_duration_measured=19200
  &sizeof_timers_expired_slave1=0
  &sizeof_timers_expired_slave2=0
  &sizeof_timers_expired_slave3=0

  var.if (&IS_THERE_timers_expired!=&FALSE)
  (
    &sizeof_timers_expired=v.sizeof(timers_expired)/v.sizeof(timers_expired[0])
    &start_cnt=v.value(timer_expired_cnt)
    &curr_cnt=v.value(timer_expired_cnt)
  )
  &ret=y.type(timers_expired_slave1)
  IF (&ret==0x3)  
  (
    &sizeof_timers_expired_slave1=v.sizeof(timers_expired_slave1)/v.sizeof(timers_expired_slave1[0])
  )
  &ret=y.type(timers_expired_slave2)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave2=v.sizeof(timers_expired_slave2)/v.sizeof(timers_expired_slave2[0])
  )
  &ret=y.type(timers_expired_slave3)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave3=v.sizeof(timers_expired_slave3)/v.sizeof(timers_expired_slave3[0])
  )


  ; Get processing duration
  var.if (&IS_THERE_timers_expired!=&FALSE)
  (
    IF &processing_duration_entered!=0
    (
      &processing_duration_measured=&processing_duration_entered
    )

    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired
    (
      &timer_expired=var.string(timers_expired[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        GOSUB PRINT_HELPER "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        GOSUB PRINT_HELPER "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave1)
  IF (&ret==0x3)
  (
    &start_cnt=v.value(timer_expired_cnt_slave1)
    &curr_cnt=v.value(timer_expired_cnt_slave1)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave1
    (
      &timer_expired=var.string(timers_expired_slave1[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave1[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        GOSUB PRINT_HELPER "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave1[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave1[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        GOSUB PRINT_HELPER "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave2)
  IF (&ret==0x3)
  (
    &start_cnt=v.value(timer_expired_cnt_slave2)
    &curr_cnt=v.value(timer_expired_cnt_slave2)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave2
    (
      &timer_expired=var.string(timers_expired_slave2[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave2[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        GOSUB PRINT_HELPER "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave2[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave2[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        GOSUB PRINT_HELPER "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave3)
  IF (&ret==0x3)
  (
    &start_cnt=v.value(timer_expired_cnt_slave3)
    &curr_cnt=v.value(timer_expired_cnt_slave3)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave3
    (
      &timer_expired=var.string(timers_expired_slave3[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave3[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        GOSUB PRINT_HELPER "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave3[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave3[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        GOSUB PRINT_HELPER "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )
  )


RETURN

ESTIMATE_CURRENT_TIME:
  &ret=Y.TYPE(pInterruptData)
  if (&ret==0x3)
	(
	&is_b_family=&TRUE
    &rain_check_on_sym=y.type(QURTK_flush_cache_status)
       IF &rain_check_on_sym!=0x1	
	   &is_b_family=&FALSE
	&log_cnt=v.value(pInterruptData.pLog.nIdx)
	&log_max=v.value(pInterruptData.pLog.nLogSize)

	IF &log_cnt==0
	(
		&log_cnt=&log_max-1
	)
	ELSE
	(
		;&log_cnt=&log_cnt-1
	)
	
	; Set the global current time
	&tt_from_interrupts=v.value(pInterruptData.pLog.pEntries[&log_cnt].nTimeStamp)
	&tt_from_intr_str="pInterruptData.pLog.pEntries[&log_cnt].nTimeStamp"
	GOSUB PRINT_HELPER ""
	)
 else
   (
	    &is_b_family=&FALSE
		&tramp_iterator=0x0
		&size_debug_var=v.sizeof(tramp_log.entries)
		&element_size=v.sizeof(tramp_log.entries[0])
		&len_tramp_log=v.value(&size_debug_var / &element_size)

		var.if (&len_tramp_log==0x0)
			(
			&len_tramp_log=0x800
			)
	   &tt_from_interrupts=v.value(tramp_log.entries[0].timestamp)
			
	   while (&tramp_iterator<&len_tramp_log)
		(
		&temp_timetick=v.value(tramp_log.entries[&tramp_iterator].timestamp)
		
		if &temp_timetick>=&tt_from_interrupts
			(
			&tt_from_intr_str="tramp_log.entries[&tramp_iterator].timestamp"
			&tt_from_interrupts=&temp_timetick
			)
	
		&tramp_iterator=&tramp_iterator+1	
		)
   )
   
	
	;use aliter method since the current time is not available
	
	RETURN

TIMER_CHECK_FOR_DELAYED_ISR:
  &isr_time_val=v.value(\timer\timers.isr_time)
  &match_value=v.value(\timer\timers.match_value)
  &tolerance=(19200*10)

  ;Check to see if we are more than 10ms late for ISR
  IF (&match_value>&isr_time_val)&&(&current_time>(&match_value+&tolerance))
  (
    &delay=&current_time-&match_value
    GOSUB PRINT_HELPER "Delayed ISR detected!  Match Value Set:&match_value   Current Time:&current_time   Last ISR:&isr_time_val   Delay:&delay"
  )

RETURN

;============================================================================
; PRINT SUBROUTINE
;============================================================================
PRINT_HELPER:
  ENTRY &str
  
  &print_line_counter=&print_line_counter+0x1
  var.if (&print_line_counter<0x5F)
    PRINT &str
  else
    (
	PRINT "Press any key to continue . . ."
    enter
	&print_line_counter=0x1	
	PRINT ""
	PRINT &str
	)
  
RETURN

;============================================================================
; Checking for looping in the passed list
;============================================================================
LIST_LOOP_CHECK:
  ENTRY &list_ptr &next &type
  
  &list_loop_check_ret=&TRUE
  
  if (&list_ptr==0x0)
    RETURN
	
  &double_jumper=var.value(((&type)&list_ptr)->&next)
  if (&double_jumper==0x0)
    RETURN
	
  while (&list_ptr!=&double_jumper)
  (
    &list_ptr=var.value(((&type)&list_ptr)->&next)
    if (&list_ptr==0x0)
	  (
        RETURN
	  )

    &double_jumper=var.value(((&type)&double_jumper)->&next)
    if (&double_jumper==0x0)
	  (
        RETURN
	  )	

    &double_jumper=var.value(((&type)&double_jumper)->&next)
    if (&double_jumper==0x0)
	  (
        RETURN
	  )	
  )
  
  &list_loop_check_ret=&FALSE  
    
RETURN

;============================================================================
Checking for double internal timer
;============================================================================
TIMER_DOUBLE_ENTRY_CHECK:

ENTRY &array_name &arr_size &element &element_type

&main_iterator=0x0
&int_iterator=0x0

while (&main_iterator<&arr_size)
  (
     &element_val=var.value(&array_name[&main_iterator].&element)

	 if (&element_val!=0x0)
	 (
		 while (&int_iterator<&arr_size)
		  (
		    if (&main_iterator!=&int_iterator)
			 ( 
			 &temp_element_val=var.value(&array_name[&int_iterator].&element)
			  var.if (&temp_element_val==&element_val && &temp_element_val!=0x0)
			   (
				 GOSUB PRINT_HELPER "Same &element value in &array_name[&main_iterator] & &array_name[&int_iterator]"
				 &element_val_str=var.string((&element_type)&element_val)
				 GOSUB PRINT_HELPER "&element =  (&element_type)&element_val_str"
				 GOSUB PRINT_HELPER ""
			   )
			 )
			 &int_iterator=&int_iterator+1
		  )
		  &int_iterator=0x0
     )
  &main_iterator=&main_iterator+1
  )
    
RETURN

;============================================================================
; Checks if the passed address is valid member in the list
;============================================================================
CHECK_FOR_PTR_IN_LIST:
  ENTRY &ptr_to_check &list_pointer &type &next

  &list_pointer_element=v.value(*(uint32 *)&list_pointer)
  &check_for_ptr_in_list_ret=&FALSE
  
  if (&ptr_to_check==0x0)
    RETURN
    

  while (&list_pointer_element!=0x0)
    (
	  if (&ptr_to_check==&list_pointer_element)
	     (
		  &check_for_ptr_in_list_ret=&TRUE
	      RETURN
		 )
	  &list_pointer_element=v.value((*(&type)&list_pointer_element)->&next)
	)
RETURN

;============================================================================
; Checks if the passed address is valid member in the array
;============================================================================
CHECK_FOR_PTR_IN_ARR:
  ENTRY &ptr_to_check &arr_name

  &check_for_ptr_in_arr_ret=&TRUE
  
  &arr_base_addr=v.value(&(&arr_name[0]))
  &single_element_size=v.sizeof(&arr_name[0])

  &total_size=v.sizeof(&arr_name)
  &unit_size=v.sizeof(&arr_name[0])
  &arr_element_count=v.value(&total_size / &unit_size)

  &arr_end_addr=&arr_element_count*&single_element_size
  &arr_end_addr=&arr_end_addr+&arr_base_addr
  
  &failed=0x0
  
  var.if (&ptr_to_check>=&arr_base_addr && &ptr_to_check<=&arr_end_addr)
   (
     &temp_var=&ptr_to_check-&arr_base_addr
     &temp_var=&temp_var%&single_element_size
     if &temp_var!=0
      &check_for_ptr_in_arr_ret=&FALSE
	  RETURN
   )
  else
   &check_for_ptr_in_arr_ret=&FALSE
   
RETURN

;============================================================================
; Diagnose a timer
;============================================================================
TIMER_DIAGNOSIS:  
  ENTRY &tmr

   ; Check the active timer Sanity
   GOSUB INTERNAL_TIMER_SANITY_CHECK &tmr 0x0

   ; Check the External timer sanity
   &int_timers_ext_pointer=v.value(((timer_internal_type*)&tmr)->timer_ext)
   GOSUB EXTERNAL_TIMER_SANITY_CHECK &int_timers_ext_pointer 0x0

   ; Check if the internal-external timer matches correctly
   GOSUB INTERNAL_EXTERNAL_TIMER_MATCH &tmr &int_timers_ext_pointer 0x0
  
  RETURN