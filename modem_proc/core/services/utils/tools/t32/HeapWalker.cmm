;============================================================================
;============================================================================
;
;   Heap Walker v2.2
;
;       Parses a given memheap and gets the statistics
;       Doesn't pinpoint who is causing the problem.
;       Provides the following in the summary (further parsed by 
;       the heapparser script:
;
;   Procedure:
;       1) Load the ELF file into T32 Simulator
;       2) Load the Jtag log or ram dumps (if working with Jtag log)
;       3) In the T32 Cmd Line : "do memheap2_heapWalker <Heap Variable> <Output Dir>"
;       4) Follow the output shown in "AREA ST" to fetch the results.
;
;
; Copyright (c) 2006-2015 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
;============================================================================

;============================================================================
;
;                        EDIT HISTORY FOR MODULE
;
; $Header: //components/rel/core.mpss/3.10/services/utils/tools/t32/HeapWalker.cmm#1 $ 
; $DateTime: 2018/06/26 03:18:17 $ 
; $Author: pwbldsvc $
;
;  when        who     what, where, why
; ---------    ---     --------------------------------------------------------
;05/11/16       nk      Updated script to give correct incomming block ptr and to work
;                       in both SPD and MPD and to print free block ptrs in a file.
;                       Changes to search in the memheap_info_free_array for recent frees
;                       adjacent to given address
;2/3/15          mg.... Update free Guard
;11/12/14       ps     Remove Debug Array
;05/16/14       rks    heap walker script v2.0
;01/21/14       rks    updated script to continue heap walk even after corruption is detected
;                      Also to take alarming false positive care in if ASSERTion 
;                      occured in between of a heap operation inside mem_free()
; 02/05/13      ps     Updated scripts for debug information in headers
; 11/16/12      ps     Unified scripts and added retreival of free block caller
; 02/05/07      mk     Added Memory Overflow Detection
; 10/01/07      mk     Created this script
;============================================================================

LOCAL &OpT32File
LOCAL &OpPlFile
LOCAL &HeapParserScript
;LOCAL &BlockHeaderSize
LOCAL &DebugModeCheck
LOCAL &DebugMethod
LOCAL &debug_info
LOCAL &debug_info_symbol
LOCAL &MemDebugSize
LOCAL &debug_index
LOCAL &stats_index
LOCAL &wait_count
LOCAL &err_thread_id
LOCAL &holder_thread_id
&BINsCorruption=0
&DoIntCheckReturn=0
&NextValidBlock=0
&calchashNext=0
&freeFlag_resolve_corruption=0
&freeFlagBlock_r_c=0
&lastflag=0
&count=0
&lastBlockCorruption=0
&tls_stats_index_count=0
&memheap_tls_to_tname=0
&heapname=0
&HeapVarSizeToKnowSPDorMPD=0x18
&appendStr="0"
&ImageInfo="0"
&coredump_reference="coredump"
&memheap_free_array_cnt=0
&memheap_free_array_str="0"
&pd_flag="0"

&incomBlockInBinNo=0xABCD; initilized with some garbage number since BIN 0 is also a valid BIN
&incomBlockBelongsToSec=0
&incomBlockFound=0
Local &debug_heap_file
LOCAL &BuildInfo
&qc_image_version=""
&qc_build_id=""

ENTRY &HeapVar &OpDir &BlockHeaderSize

Area.Reset
Area.Create ST 200. 1000.       ;create an AREA window              
Area.Select ST                  ;select the AREA window as PRACTICE 
                                ;input/output window                
Area ST                         ;display the AREA window            
&HeapParserScript=OS.PWD();
&HeapParserScript="&HeapParserScript"+"\memheap2_heapwalkparser.pl"
;Set the version of the script:
; 00.00.01 -- First Walker Script for Mem Heap With CRC enabled
&CMMVERSION="00.00.01"

print "====================Heap Walker v2.2==========================="
print ".......  go/HeapDebug for more heap debugging help\tips........"
print "---------------------------------------------------------------"

if ("&HeapVar"=="")
(
        print "Enter the heap variable to be parsed:"
        enter &HeapVar

)
&string_len=STRing.LENgth("&HeapVar")
;heapname stored to append it to output files

 if (y.exist(&HeapVar))
 (
   if ((&string_len)<&HeapVarSizeToKnowSPDorMPD)
   (
     &heapname="&HeapVar"
     if (y.exist(memheap_info_free_array_cnt))
     (
       &pd_flag="SPD"
     )
     else
     (
       &pd_flag="SMPD"
     )
   )
   else
   (
    &pd_flag="MPD"
   )
 )
 else
 (
   print "Please do --- v.v  &HeapVar + tab button --- and *Enter* heap reference of required PD:"
   enter &HeapVar   
   &pd_flag="MPD"
 )
 
 if ("&pd_flag"=="MPD")
 (
 
   &rm_last=0
   &pos=0
   &varLen=STRing.LENgth("&HeapVar")
   &pos=STRING.SCAN("&HeapVar","Global",0)
   &rm_last=&varLen-&pos
   &appendStart=STRing.CUT("&HeapVar",-(&rm_last))
   &pos=&pos+(0x7)
   &heapname=STRing.CUT("&HeapVar",&pos)
   &rm_last=&varLen-&pos
   &appendStr=STRing.CUT("&HeapVar",-(&rm_last))
   &tls_stats_index_count="&appendStr"+"tls_stats_index_count"  
   &memheap_tls_to_tname="&appendStr"+"memheap_tls_to_tname"
   &coredump_reference="&appendStr"+"coredump"
   &memheap_free_array_cnt_str="&appendStart"+"memheap\"+"memheap_info_free_array_cnt"
   &memheap_free_array_cnt=V.VALUE(&memheap_free_array_cnt_str)
   &memheap_free_array_str="&appendStr"+"memheap_info_free_array"
 )
 else if ("&pd_flag"=="SMPD")
 (
   print "Please do --- v.v  memheap_info_free_array + tab button --- and *Enter* heap reference of root PD:"
   enter &memheap_info_free_array_str
   &varLen=STRing.LENgth("&memheap_info_free_array_str")
   &pos=STRING.SCAN("&memheap_info_free_array_str","Global",0)
   &rm_last=&varLen-&pos
   &appendStr=STRing.CUT("&memheap_info_free_array_str",-(&rm_last))
   &tls_stats_index_count="&appendStr"+"Global\tls_stats_index_count"  
   &memheap_tls_to_tname="&appendStr"+"Global\memheap_tls_to_tname"
   &coredump_reference="&appendStr"+"Global\coredump"
   &memheap_free_array_cnt_str="&appendStr"+"memheap\"+"memheap_info_free_array_cnt"
   &memheap_free_array_cnt=V.VALUE(&memheap_free_array_cnt_str)
   &memheap_free_array_str="&appendStr"+"Global\memheap_info_free_array" 
   &appendStr="&appendStr"+"Global\"
 )
 else if ("&pd_flag"=="SPD")
 (
    &memheap_free_array_cnt=V.VALUE(memheap_info_free_array_cnt)
    &memheap_free_array_str="memheap_info_free_array"
    &memheap_tls_to_tname="memheap_tls_to_tname"
    &tls_stats_index_count="tls_stats_index_count"
    &coredump_reference="coredump"
 )
 
&MemHeapTypeSize=0
if ("&BlockHeaderSize"=="")
(
    &BlockHeaderSize=16
)

&DebugModeCheck=0
&DebugMethod=0
&isHeapStats=1
&heapStatistics=0

 &heapusedhash=V.VALUE((mem_heap_type *) &HeapVar.magic_num_used)
 &heapfreehash=V.VALUE((mem_heap_type *) &HeapVar.magic_num_free)
 
if (&BlockHeaderSize>8)
(
   &DebugModeCheck=1
   print "Debug mode is enabled on this build"
)

&heapStatistics=v.value(&HeapVar.heapStatistics)

if (&heapStatistics==0)
(
   &isHeapStats=0
   print "!!!!"
   print "Heap Statistics not found for heap."
   print "!!!!"
)

if (&DebugModeCheck==1)
(
   print "Using inline debug information"
   &DebugMethod=1
)
 
 &mutexTaken=0
 &falsePositiveBlock=0
 &crit_sect=V.VALUE(&HeapVar.memheap_crit_sect)
 &raw=(V.VALUE(((osal_crit_sect_t*)&crit_sect)->raw))
 if (0xFE!=&raw)
 (

   &mutexTaken=1
   print "*******Heap Mutex is taken :some memory block is in process, " 
   print "       for the block it may not have the header data completly updated , so should consider it while doing heap analysis*********"
   print "  "
 )


if ("&OpDir"=="")
(
        print "Please enter the directory where the results should be stored"
        dialog.dir *.*
        ENTRY &OpDir
)
if ("&OpDir"=="")
(
        print "Output Dir not chosen.. Bailing Out...."
        enddo
)

if ("&MemDebugSize"=="")
(
        &MemDebugSize=8000
)
if (!os.file(&HeapParserScript))
(
      dialog.file *.pl
      ENTRY &HeapParserScript
)
if ("&HeapParserScript"!="")
(
  if (!os.file(&HeapParserScript))
  (
       print "Parser Script not chosen.. Bailing Out...."
       enddo
  )
)
else
(
  print "Parser Script not chosen.. Bailing Out...."
  enddo
)
if (Y.EXIST(QC_IMAGE_VERSION_STRING_AUTO_UPDATED))
(
   &qc_image_version=V.STRING(QC_IMAGE_VERSION_STRING_AUTO_UPDATED)
)
else
(
   &ImageInfo="QC_IMAGE_VERSION_STRING_AUTO_UPDATED"
   &ImageInfo="&appendStr"+"&ImageInfo"
   if (Y.EXIST(&ImageInfo))
   (
     &qc_image_version=V.STRING(&ImageInfo)
   )
   else
   (
     &qc_image_version=""
   )
)
if (Y.EXIST(IMAGE_VARIANT_STRING_AUTO_UPDATED))
(
   &qc_build_id=V.STRING(IMAGE_VARIANT_STRING_AUTO_UPDATED)
)
else
(
   &BuildInfo="IMAGE_VARIANT_STRING_AUTO_UPDATED"
   &BuildInfo="&appendStr"+"&BuildInfo"   
   if (Y.EXIST(&BuildInfo))
   (
     &qc_build_id=V.STRING(&BuildInfo)
   )
   else
   (
     &qc_build_id=""
   )
)
if ("&qc_image_version"!="")
(
    
    WHILE STRING.FIND("&qc_image_version","=")
    &qc_image_version=STRING.CUT("&qc_image_version",1)
    print "Image version = &qc_image_version"
    &BuildInfo="&qc_image_version"
)
else
(
   &BuildInfo=""
)

if ("&qc_build_id"!="")
(
    WHILE STRING.FIND("&qc_build_id","=")
    &qc_build_id=STRING.CUT("&qc_build_id",1)
    print "Build Id = &qc_build_id"
    &BuildInfo="&BuildInfo"+"_&qc_build_id"
)


&debug_heap_file="&heapname"+"_FreeBlocksInBins.txt"
OPEN #3 "&OpDir\&debug_heap_file" /CREATE
CLOSE #3
&incoming_Block=V.VALUE((mem_heap_type *)&HeapVar.incomingBlock)
&wait_count=V.VALUE(((osal_crit_sect_t *)&HeapVar.memheap_crit_sect)->wait_count)
if (0x0==&wait_count)
(
  print " "
)
else
(
  &err_thread_id=V.VALUE(&coredump_reference.err.tid) 
  &holder=V.VALUE(((osal_crit_sect_t *)&HeapVar.memheap_crit_sect)->holder)
  &holder_thread_id=V.VALUE((*((struct QURT_ugp_ptr *)&holder)).utcb.thread_id) 
  if (&holder_thread_id==&err_thread_id)
  (
    
    &Heap_addr=&HeapVar
    &Heap_address=STRing.CUT("&Heap_addr",2)
    &memheap_free_array_cnt_var=&memheap_free_array_cnt
    if (&memheap_free_array_cnt_var==(0x0))
    (
      &memheap_free_array_cnt_var=0x400
    )
    &memheap_free_array_cnt_var=&memheap_free_array_cnt_var-1
    while (&Heap_address!=V.VALUE(&memheap_free_array_str[&memheap_free_array_cnt_var].heap_ptr))
    (
      if (&memheap_free_array_cnt_var==(0x0))
      (
        &memheap_free_array_cnt_var=0x400
      )
      &memheap_free_array_cnt_var=&memheap_free_array_cnt_var-1
    )
    &incoming_Block=V.VALUE(&memheap_free_array_str[&memheap_free_array_cnt_var].mem_ptr)
    &incoming_Block=&incoming_Block+0x10
  )
  else if (&wait_count==1) ; one more case if wait_count = 1 and mutex holder task is not the same one which did the err fatal, then we can say 
  ( 
    if (&holder_thread_id!=&err_thread_id)
    (
        &incoming_Block=V.VALUE((mem_heap_type *)&HeapVar.incomingBlock)
    )
  )
  else
  (
    print "Please verify from the call stack"
  )
 )
&OpT32File="&OpDir\"+"&BuildInfo"+"_"+"&heapname"+"_MemBlkList.csv" ;
&OpT32FileMemDb="&OpDir\"+"&BuildInfo"+"_"+"&heapname"+"_memdebug_db_MemBlkList.csv" ;
&OpT32FileStatsDb="&OpDir\"+"&BuildInfo"+"_"+"&heapname"+"_threadstats.csv" ;
&OpPlFile="&OpDir\"+"&BuildInfo"+"_"+"&heapname"+"_MemCost.csv"

&legacyCheck=V.VALUE(&HeapVar.legacy_check)
if (&legacyCheck==0x2)
(
  print "   "
  print "---Start: verifying the free memory block's BINs in the heap--- "
  print "   "
  gosub walkBINs &HeapVar
  print "---End:free BINs verification -----------------------------------"
  print "   "
)

if (&isHeapStats==1)
(
    &statsCount=v.value(&tls_stats_index_count)
    gosub walkStatsDB &HeapVar &OpDir &statsCount
)
print "1. Walking through the heap"
gosub walkHeap &HeapVar &OpDir
print "2. Running the Parser"
gosub ProcHeap &OpT32File &OpT32FileMemDb &OpPlFile &BlockHeaderSize
print " "
print " "
print "3. Enter block address to know who was recently using that particular memory region( it will parse memheap_info_free_array):"
enter &corrupted_Block
gosub search_in_memheap_info_free_array &corrupted_Block
print "3. Exit"
enddo


walkBINs:
ENTRY &HeapVar
OPEN #3 "&OpDir\&debug_heap_file" /WRITE
WRITE #3 ""
WRITE #3 ""
&i=0
&totalBINsCount=0x20 ;0x20 is the max BINs count
  while (&i<&totalBINsCount) 
  (
     &j=0
     &nextBlock=0
     &nextBlock_backUp=0
     &corruptedBlock=0
     &infiniteLoop=0
     &staleData=0
     &curr_bin_firstBlock=V.VALUE((mem_heap_type *) &HeapVar.BIN[&i].firstNode)
     &total_Nodes=V.VALUE((mem_heap_type *) &HeapVar.BIN[&i].totalNodes)
     if ((&total_Nodes)!=0x0)
     (
       WRITE #3 ""
       WRITE #3 " <<<<<< free memory blocks in BIN[&i] >>>>>>>> "
     )
     if (&curr_bin_firstBlock!=0x0)
     (
         &nextBlock=&curr_bin_firstBlock
         while (&nextBlock!=0x0)
         (
            &nextBlock_backUp=&nextBlock
            &blkhashNext=V.VALUE(*((uint16*) &nextBlock))
            &calchash0=V.VALUE(*((uint16*) &nextBlock))
            &calchash2=V.VALUE(*((uint16*) &nextBlock+1))
            &calchash4=V.VALUE(*((uint16*) &nextBlock+2))
            &calchash6=V.VALUE(*((uint16*) &nextBlock+3))
            &calchash8=V.VALUE(*((uint16*) &nextBlock+4))
            &calchash10=V.VALUE(*((uint16*) &nextBlock+5))
            &calchash12=V.VALUE((&nextBlock&0xFFFF))
            &calchash14=V.VALUE(((&nextBlock>>16)&0xFFFF))
            &calchashNext=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&calchash12^&calchash14^&heapfreehash
            if (&blkhashNext==&calchashNext)
            (
               &calfreeflag=V.VALUE(*((uint8*) &nextBlock+3))
               &flagfree=(&calfreeflag&0x40)
              if (&flagfree==0)
               (
                  print "<<<<<Block &nextBlock with Free flag 0 is added to the bin = &i as node &j >>>>>"
                  print " "
               )
               &forwardoffset=V.VALUE(*((uint32*) &nextBlock+1))
               if (&forwardoffset==0)
               (
                 print "<<<<<Block &nextBlock with Forward offset(size) 0 is added to the bin = &i as node &j >>>>>"
                 print " "
               )
               WRITE #3 " node &j is &nextBlock "
                &j=&j+1
                &nextBlock=V.VALUE(*((uint32*) &nextBlock+2))
                if (&total_Nodes<&j)
                (
                   &nextBlock=0
                   &infiniteLoop=1
                   print "<<<<<Infinite loop detected at BIN = &i >>>>>>"
                   print "  "
                )
            )
            else ; check if this is stale data
            (
                &blkhashNext=V.VALUE(*((uint16*) &nextBlock))
                &calchash0=V.VALUE(*((uint16*) &nextBlock))
                &calchash2=V.VALUE(*((uint16*) &nextBlock+1))
                &calchash4=V.VALUE(*((uint16*) &nextBlock+2))
                &calchash6=V.VALUE(*((uint16*) &nextBlock+3))
                &calchash12=V.VALUE((&nextBlock&0xFFFF))
                &calchash14=V.VALUE(((&nextBlock>>16)&0xFFFF))
                &calchashNext=&calchash2^&calchash4^&calchash6^&calchash12^&calchash14^&heapusedhash
        WRITE #3 " node &j is &nextBlock and found corrupted,  exiting !!"
                if (&blkhashNext==&calchashNext)
                (
                    print "<<< Stale data detected at BIN no. = &i , the memory block &nextBlock has header as of valid *used* block present at &j position in this free BIN >>>"
                    print "  "
                    &staleData=1
                    &nextBlock=0
                )
                else
                (
                   &corruptedBlock=&nextBlock
                   &nextBlock=0
                )
            )
            if (&incoming_Block==&nextBlock_backUp)
            (
                 &incomBlockInBinNo=&i
            )
         )
     )

     if ((&j!=&total_Nodes)&&(&infiniteLoop==0)&&(&staleData==0))
     (
        print " -----------------------------------------------------------------------------------------------------------------------------------------------------"
        print "Corruption detected in free blocks BINs at bin no. =&i  "
        print "Total *valid* Free Blocks expected =  &total_Nodes , and found = &j *valid* blocks"
        print "Issue detected: the free block = &corruptedBlock in the bin number =&i is corrupted so stopped further traversing on this BIN's free block's list"
        print " -----------------------------------------------------------------------------------------------------------------------------------------------------"
        print "   "
        &BINsCorruption=1
     )
     &i=&i+1
  )
  ; check if there any corruption in binToUSeForMalloc in freeBlokcStruct 
  ;since sometimes memory allcoation failure occures due to this as well
  &i=0
  while (&i<&totalBINsCount) ;0x20 is the max BINs count
  (
    &binToUSe=V.VALUE((mem_heap_type *) &HeapVar.BIN[&i].binToUSeForMalloc)
    &nodePtr=V.VALUE((mem_heap_type *) &HeapVar.BIN[&binToUSe].firstNode)
    if (((&nodePtr==0)&&(&binToUSe!=(&totalBINsCount-1)))||(&binToUSe<&i))
    (
       print " -----------------------------------------------------------------------------------------------------------------------------------------------------"
       print "Corruption detected in free blocks BINs at bin no. =&i  for binToUSeForMalloc"
       print "Side effect(issue) can be caused due to this is: FALSE heap exhaustion(i.e. unable to allcoate requested memory even though enough of the memory availble in the heap) "
       print " -----------------------------------------------------------------------------------------------------------------------------------------------------"
       print "   "
    )
    &i=&i+1
  )
CLOSE #3
return ;End of walkBINs

DoIntCheck:
ENTRY &next_heap_block

    &blkhashNext=V.VALUE(*((uint16*) &next_heap_block))
    &flagbytes=V.VALUE(*((uint8*) &next_heap_block + 3))
    &freeflag_t=(&flagbytes&0x40)>>6

    if (&freeflag_t==0)
    (
      &calchash0=V.VALUE(*((uint16*) &next_heap_block))
      &calchash2=V.VALUE(*((uint16*) &next_heap_block+1))
      &calchash4=V.VALUE(*((uint16*) &next_heap_block+2))
      &calchash6=V.VALUE(*((uint16*) &next_heap_block+3))
      &calchash8=V.VALUE((&next_heap_block&0xFFFF))
      &calchash10=V.VALUE(((&next_heap_block>>16)&0xFFFF))
      &calchashNext=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&heapusedhash           
    )
    if (&freeflag_t==1)
    (
      &calchash0=V.VALUE(*((uint16*) &next_heap_block))
      &calchash2=V.VALUE(*((uint16*) &next_heap_block+1))
      &calchash4=V.VALUE(*((uint16*) &next_heap_block+2))
      &calchash6=V.VALUE(*((uint16*) &next_heap_block+3))
      &calchash8=V.VALUE(*((uint16*) &next_heap_block+4))
      &calchash10=V.VALUE(*((uint16*) &next_heap_block+5))
      &calchash12=V.VALUE((&next_heap_block&0xFFFF))
      &calchash14=V.VALUE(((&next_heap_block>>16)&0xFFFF))
      &calchashNext=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&calchash12^&calchash14^&heapfreehash
    )
    if (&calchashNext!=&blkhashNext)
    (
      &DoIntCheckReturn=1
    )
    else
    (
      &DoIntCheckReturn=0
    )
return ;end DoIntCheck


FindNextValidBlock:
ENTRY &curr_heap_mem &curr_heap_end
    print "Trying to find out next valid block .....";
    &exitfromLoop=0
    while ((&curr_heap_mem<&curr_heap_end)&&(&exitfromLoop==0))
    (
        &curr_heap_mem=&curr_heap_mem+0x10
        &NextValidBlock=0
        &size=V.VALUE(*((uint32*) &curr_heap_mem + 1))

        &maxFrdOffset=&curr_heap_end-&curr_heap_mem
        &maxFrdOffset=&maxFrdOffset+1
        if ((&size!=0)&&(&size<&maxFrdOffset))
        (
          gosub DoIntCheck &curr_heap_mem
          if (&DoIntCheckReturn==0)
          (
              print "Next valid memory block =: &curr_heap_mem";
              print " "
              &exitfromLoop=1
              &NextValidBlock=&curr_heap_mem
           )
       )

       if (&curr_heap_mem>=&curr_heap_end)
       (
          &lastflag=0x01
          &lastBlockCorruption=1
          print " ---It was the last *valid* memory block found of this heap Section---"
       )
    )
    print " -----------------------------------------------------------"
return ;end FindNextValidBlock

walkHeap:
ENTRY &HeapVar &OpDir

&tcb_ptr_symbol=""
&thread_id=0x0
&found=0
&tls_id=0x0

; Initialize the heap buffer pointer
 &curr_heap_mem=V.VALUE((mem_heap_type *) &HeapVar.first_block)

 &HeapMemBuffer=Y.NAME(D:&curr_heap_mem)

 &legacy=0
 &legacyCheck=V.VALUE(&HeapVar.legacy_check)
 if (&legacyCheck!=2)
 (
    &legacy=1
 )
 
 OPEN #1 &OpT32File /Create 

&maxHeapUsed=V.VALUE((mem_heap_type *) &HeapVar.max_used)
&currentHeapUsage=V.VALUE((mem_heap_type *) &HeapVar.used_bytes)
; Important : Don't change this header! Used by Parser as is.
 WRITE #1 "Blocks List Report" 
 WRITE #1 "------------------"
 WRITE #1 "Version                          : &CMMVERSION"  
 WRITE #1 "Heap State Variable              : &HeapVar"
 WRITE #1 "Heap Buffer                      : &HeapMemBuffer"
 WRITE #1 "Maximum heap usage(Watermark)    : &maxHeapUsed Bytes"
 WRITE #1 "Current heap usage               : &currentHeapUsage Bytes"
 WRITE #1 "  "
if (&DebugModeCheck==1)
(
    WRITE #1 "Block No ,Address,CallerPtr,CallerPtr_Symbol,TaskName, Thread Index, Allocated Bytes,Extra Bytes,Section_index,Start Flag,Free Flag,Last Flag"
)
else
(
    WRITE #1 "Block No,Address,Allocated Bytes,Extra Bytes,Section_index,Start Flag,Free Flag,Last flag"
)

 &count=1;
 &writestring=""
if (&DebugModeCheck==1)
(
   &debug_info=0x0
   &debug_info_symbol=""
)
&concatenatedWithPrevBlock=0
&hash=0x0
&pre_block_free_flag=0
&pre_mem_block=0
&pre_block_section=0
&corruptedBlock=0
 &size=0
 &number_of_sections=0
 &total_number_of_sections=V.VALUE((mem_heap_type *) &HeapVar.number_of_sections)
 if (&total_number_of_sections==0)
 (
    &total_number_of_sections=1
 ) 
 while (&number_of_sections!=&total_number_of_sections)
 (
     &heapSectionSize=V.VALUE((mem_heap_type *) &HeapVar.sections[&number_of_sections].size)
     &heapSectionStartAddr=V.VALUE((mem_heap_type *) &HeapVar.sections[&number_of_sections].start_addr)
     &curr_heap_end= &heapSectionSize+&heapSectionStartAddr
     &size=0
     if ((&incoming_Block<&curr_heap_end)&&(&heapSectionStartAddr<=&incoming_Block))
     (
        &incomBlockBelongsToSec=&number_of_sections
        &incomBlockFound=1
     )
     while ((&lastflag!=0x01)&&(&curr_heap_mem<&curr_heap_end))
     (
         &thread_id=0
         &tcb_ptr_symbol=0
         &&debug_info=0
         &debug_info_symbol=0
         &handled=0
         &flagbytes=V.VALUE(*((uint8*) &curr_heap_mem + 3))
         &freeflag=(&flagbytes&0x40)>>6

         &blkhash=V.VALUE(*((uint16*) &curr_heap_mem))
         gosub DoIntCheck &curr_heap_mem
         if (&DoIntCheckReturn!=0)
         (
             &calchashSecond=0
             if ((&mutexTaken==1)&&(&freeflag==1))
             (
                 &falsePositiveBlock=1
                 &calchash0=V.VALUE(*((uint16*) &curr_heap_mem))
                 &calchash2=V.VALUE(*((uint16*) &curr_heap_mem+1))
                 &calchash4=V.VALUE(*((uint16*) &curr_heap_mem+2))
                 &calchash6=V.VALUE(*((uint16*) &curr_heap_mem+3))
                 &calchash8=V.VALUE((&curr_heap_mem&0xFFFF))
                 &calchash10=V.VALUE(((&curr_heap_mem>>16)&0xFFFF))
                 &calchashSecond=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&heapusedhash^0x4000 ; XOR with 0x4000 since freeFlag is set
             )

             if ((&blkhash==&calchashSecond)&&(&blkhash!=0))
             (
                print "===================================================================";
                print "heap block's free_flag setting to 0 passed the integrity test on the Block Address: &curr_heap_mem ,"
                print " mostly this is the memory block pointer passed in mem_free() = &curr_heap_mem+0x10"
                print "===================================================================";
                &handled=1
                &freeFlag_resolve_corruption=1
                &freeFlagBlock_r_c=&curr_heap_mem
                &freeflag=0 ; setting free_flag to 0 for printing its inforamtion in the output file

             )
             if ((&mutexTaken==1)&&(&blkhash!=&calchashSecond)&&(&blkhash!=0)&&(&freeflag==1)&&(&handled==0))
             (
                  &sizeN=V.VALUE(*((uint32*) &curr_heap_mem + 1))
                  &next_heap_block=&curr_heap_mem+&sizeN
                  gosub DoIntCheck &next_heap_block
                  &maxSize=&curr_heap_end-&curr_heap_mem
                  if ((&DoIntCheckReturn!=0)&&(&sizeN<=&maxSize))
                  (
                     while ((&curr_heap_mem<&next_heap_block)&&(&found==0))
                     (
                       &next_heap_block=&next_heap_block-0x10
                       &value0=V.VALUE(*((uint32*) &next_heap_block))
                       &value1=V.VALUE(*((uint32*) &next_heap_block +1))
                       &value3=V.VALUE(*((uint32*) &next_heap_block +3))
                       &value3=&value3>>16 ; MSB 4 bytes has to be 0 for this since its storing the stats_index that has max value as 0x3E7
                       if ((&value3==0x0)&&(&value0==0x0)&&(&value1==0x0)&&((&incoming_Block-0x10)==&next_heap_block))
                       (
                            &found=1
                            &corruptedBlock=&curr_heap_mem+&sizeN
                            print " "
                            print "<<<IncomingBlock got *concatenated*>>>"
                            print " "
                            print "The ptr passed in mem_free() got concatenated with the prev. free block = &curr_heap_mem  !!";
                            print "Memory block got corrupted is &corruptedBlock ";
                            &next_heap_block=&next_heap_block+0x10
                            print "the ptr passed in mem_free() = &next_heap_block and this is the block that caused corruption"
                            &debug_info=V.VALUE(*((uint32*) (&incoming_Block-0x10) + 2))
                            &debug_info_symbol= Y.NAME(D:&debug_info)
                            &stats_index=V.VALUE(*((uint32*) (&incoming_Block-0x10) + 3))
                            if (&isHeapStats==1)
                            (
                               &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
                               &thread_id=&stats_index
                            )
                            &thread_id=&stats_index
                            print " This block(&next_heap_block) was allocated from function(i.e. Owner of it) = &debug_info_symbol , task = &tcb_ptr_symbol ,thread_id = &thread_id"
                            print " "
                            &next_heap_block=&next_heap_block-0x10
                            print "<<<End of info for this block>>>"
                            print " "
                            &handled=1
                            &concatenatedWithPrevBlock=1
                        )
                     )
                  )
                  else if (&sizeN<=&maxSize)
                  (
                     while ((&curr_heap_mem<&next_heap_block)&&(&found==0))
                     (
                       &next_heap_block=&next_heap_block-0x10
                       &value0=V.VALUE(*((uint32*) &next_heap_block))
                       &value1=V.VALUE(*((uint32*) &next_heap_block +1))
                       &value3=V.VALUE(*((uint32*) &next_heap_block +3))
                       &value3=&value3>>16 ; MSB 4 bytes has to be 0 for this since its storing the stats_index that has max value as 0x3E7
                       if ((&value3==0x0)&&(&value0==0x0)&&(&value1==0x0)&&((&incoming_Block-0x10)==&next_heap_block))
                       (
                            &found=1
                            &corruptedBlock=&curr_heap_mem+&sizeN
                            print " "
                            print "<<<IncomingBlock got *concatenated*>>>"
                            &next_heap_block=&next_heap_block+0x10
                            print "The ptr passed &next_heap_block in mem_free() got concatenated with the prev. free block = &curr_heap_mem  !!";
                            &next_heap_block=&next_heap_block-0x10
                            print "<<<End of info for this block>>>"
                            print " "
                            &handled=1
                        )
                     )
                  )
                  ;check if the block got concatenated with the nextBlock
                  if (&handled==0)
                  (
                     &sizeN=V.VALUE(*((uint32*) &curr_heap_mem + 1))
                     &exit=0
                     while ((&sizeN<=&maxSize)&&(&sizeN>0)&&(&exit==0))
                     (
                         &calchashSecond=0
                         (
                             &falsePositiveBlock=1
                             &calchash0=V.VALUE(*((uint16*) &curr_heap_mem))
                             &calchash2=V.VALUE(*((uint16*) &curr_heap_mem+1))
                             &calchash4=(0xFFFF0000&(&sizeN))
                             &calchash6=0x0000FFFF&(&sizeN)
                             &calchash8=V.VALUE((&curr_heap_mem&0xFFFF))
                             &calchash10=V.VALUE(((&curr_heap_mem>>16)&0xFFFF))
                             &calchashSecond=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&heapusedhash^0x4000 ; XOR with 0x4000 since freeFlag is set
                         )

                         if ((&blkhash==&calchashSecond)&&(&blkhash!=0))
                         (
                            &nextBlock=&curr_heap_mem+&sizeN
                            print "============================================================================================================";
                            print " The ptr passed  &curr_heap_mem+0x10 in mem_free()  got concatenated  with the next free block = &nextBlock "
                            print "=============================================================================================================";
                            &handled=1
                            &freeFlag_resolve_corruption=1
                            &freeFlagBlock_r_c=&curr_heap_mem
                            &freeflag=0 ; setting free_flag to 0 for printing its inforamtion in the output file
                            &exit=1
                         )
                         &sizeN=&sizeN-0x10
                     )
                  )
         
             )
             if (&handled==0)
             (
                print "<<<Heap Corruption Detected!!>>";
                gosub DoIntCheck &curr_heap_mem ; calling it again to udpate &calchashNext which is global
                print " Current Pad: required Pad Value: &calchashNext: &blkhash";
                &count=&count-1
                print "Memory block got corrupted is &curr_heap_mem ";
                &curruptedBlock=&curr_heap_mem-&size 
                if (&curr_heap_mem!=&curruptedBlock)
                (
                    print "Possible Overflown Block              : "+format.DECIMAL(8.,&count);
                    print "Overflown Block's Header address      : &curruptedBlock";  
                    print "Size allocated to the Overflown Block : "+format.DECIMAL(8., &size);
                    &flagbytes=V.VALUE(*((uint8*) &curruptedBlock + 3))
                    &freeflag=(&flagbytes&0x40)>>6
                    if (&freeFlagBlock_r_c==&curruptedBlock)
                    (
                        print " <<It seems that the ptr &freeFlagBlock_r_c+0x10 passed in mem_free() is the culprit >>"
                        &freeflag=0
                    )
                    if (&freeflag!=0x1)
                    (
                        &debug_info=V.VALUE(*((uint32*) (&curruptedBlock) + 2))
                        &debug_info_symbol= Y.NAME(D:&debug_info)
                        &stats_index=V.VALUE(*((uint32*) (&curruptedBlock) + 3))
                        if (&isHeapStats==1)
                        (
                         &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
                        )
                        &thread_id=&stats_index
                        print " This expected culprit(Overflown) block was allocated from function(i.e. Owner of it) = &debug_info_symbol , task = &tcb_ptr_symbol ,thread_id = &thread_id"
                    )
                    else
                    (
                       print "But this is a free block so it can not be the culprit and it should be there in the Free BINs "
                       print " please check for some other possiblities of this corruption "
                       print "  "
                    )
                )
                else
                (
                   print "*******Fisrt Block of the section number &number_of_sections got corrupted == &HeapVar.sections[&number_of_sections].start_addr ******** "
                )
                &count=&count+1 ; reset the counter back to this present number
                print " "
                ;check if there is BIT flip issue
                &iteration=0
                &freeFlagBitFlip=0;
                &bitCheckDone=0
                gosub DoIntCheck &curr_heap_mem ; calling it again to udpate &calchashNext which is global
                while ((&iteration<2)&&(&bitCheckDone==0)) ;do 2 iterations if bit flip occured on free_flag itself
                (
                    &hashDiff=&calchashNext^&blkhash
                    &bitNo=0
                    &bitsSum=0
                    &bitValue=0

                    while (&hashDiff!=0)
                    (
                      &temp=&hashDiff&1
                      &bitsSum=&bitsSum+(&temp&1)
                      &hashDiff=&hashDiff>>1;
                    )
                    if (&bitsSum==1)
                    (
                       if (&freeFlagBitFlip==1)
                       (
                           print "                   Bit flip is occured in **free_flag** of this block header            "
                       )
                      print "***there is total one bit flip in the corrupted block header that casued the integrity check fail***"
                      print " "
                      &bitCheckDone=1
                    )
                    if (&bitsSum==2)
                    (
                       if (&freeFlagBitFlip==1)
                       (
                          print "                   Bit flip is occured in **free_flag** of this block header            "
                       )
                       print "***there are total 2 bit flips in the corrupted block header that casued the integrity check fail***"
                       print " "
                       &bitCheckDone=1
                    )
                    if (&freeflag==1)
                    (
                       &calchash0=V.VALUE(*((uint16*) &curr_heap_mem))
                       &calchash2=V.VALUE(*((uint16*) &curr_heap_mem+1))
                       &calchash4=V.VALUE(*((uint16*) &curr_heap_mem+2))
                       &calchash6=V.VALUE(*((uint16*) &curr_heap_mem+3))
                       &calchash8=V.VALUE((&curr_heap_mem&0xFFFF))
                       &calchash10=V.VALUE(((&curr_heap_mem>>16)&0xFFFF))
                       &calchashNext=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&heapusedhash
                       &hashDiff=&calchashNext^&blkhash                      
                    )
                    if (&freeflag==0)
                    (
                       &calchash0=V.VALUE(*((uint16*) &curr_heap_mem))
                       &calchash2=V.VALUE(*((uint16*) &curr_heap_mem+1))
                       &calchash4=V.VALUE(*((uint16*) &curr_heap_mem+2))
                       &calchash6=V.VALUE(*((uint16*) &curr_heap_mem+3))
                       &calchash8=V.VALUE(*((uint16*) &curr_heap_mem+4))
                       &calchash10=V.VALUE(*((uint16*) &curr_heap_mem+5))
                       &calchash12=V.VALUE((&curr_heap_mem&0xFFFF))
                       &calchash14=V.VALUE(((&curr_heap_mem>>16)&0xFFFF))
                       &calchashNext=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&calchash12^&calchash14^&heapfreehash
                       &hashDiff=&calchashNext^&blkhash
                    )
                    &iteration=&iteration+1
                    &freeFlagBitFlip=1
               )
               if (&curr_heap_mem<&curr_heap_end)
               (
                   gosub FindNextValidBlock &curr_heap_mem &curr_heap_end
               )
               else if (&curr_heap_mem>=&curr_heap_end)
               (
                   &lastflag=0x01
                   print " it was the last memory block of this Section"
               )
           )

        )

       &size=V.VALUE(*((uint32*) &curr_heap_mem + 1))
       &extrabytes=V.VALUE(*((uint8*) &curr_heap_mem + 2))
       &flagbytes=V.VALUE(*((uint8*) &curr_heap_mem + 3))

       ;first 5 bits are sectionNumber
       &section_number=&flagbytes&0x1f
       &startflag=(&flagbytes&0x20)>>5
       &lastflag=(&flagbytes&0x80)>>7


       if (&DebugModeCheck==1)
       (
           if (&freeflag!=0x1)
           (
              if (&legacy!=0x0)
              (
                  &debug_info=V.VALUE(*((uint32*) &curr_heap_mem + 2))
              )
              else
              (
                   &stats_index=V.VALUE(*((uint32*) &curr_heap_mem + 3))
                  if (&DebugMethod==1)
                  (
                     if (&isHeapStats==1)
                     (
                        &debug_info=V.VALUE(*((uint32*) &curr_heap_mem + 2))
                     )
                  )
                  if (&isHeapStats==1)
                  (
                      &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
                      &thread_id=&stats_index
                  )
                  else
                  (
                      &tcb_ptr_symbol=""
                  )

              )
              &debug_info_symbol= Y.NAME(D:&debug_info)
           )
           else
           (
              &debug_info=V.VALUE(((mem_header_free_info_caller *) &curr_heap_mem)->caller)
              &debug_info_symbol= Y.NAME(D:&debug_info)
           )
       )
       if (&lastBlockCorruption!=1)
       (
           &writestring=format.DECIMAL(8.,&count)
           &writestring="&writestring,"+"0x"+format.HEX(8., &curr_heap_mem)  
           if (&DebugModeCheck==1)
           (
              &writestring="&writestring,"+"0x"+format.HEX(8., &debug_info)
              if ("&debug_info_symbol"!="")
              ( 
                 &writestring="&writestring,"+""+"&debug_info_symbol"
              )
              else
              (
                 &writestring="&writestring,"+"NoSymbol"
              )
              if ("&tcb_ptr_symbol"!="")
              ( 
                  &writestring="&writestring,"+""+"&tcb_ptr_symbol"
                  &writestring="&writestring,"+""+format.DECIMAL(8., &thread_id)
              )
              else
              (
                 &writestring="&writestring,"+"NoSymbol"
                 &writestring="&writestring,"+""+format.DECIMAL(8., &thread_id)
              )
           )
           &writestring="&writestring,"+""+format.DECIMAL(8., &size)
           &writestring="&writestring,"+format.DECIMAL(8., &extrabytes)
           &writestring="&writestring,"+format.DECIMAL(2., &section_number)
           &writestring="&writestring,"+"0x"+format.HEX(1., &startflag)
           &writestring="&writestring,"+"0x"+format.HEX(1., &freeflag)
           &writestring="&writestring,"+"0x"+format.HEX(1., &lastflag)
           WRITE #1 "&writestring"
           &lastBlockCorruption=0
        )
       ;; check if next block's size is zero and falg as corruption
       &frd_offset_zero_corruption=0
       if ((&lastflag!=1)&&(&concatenatedWithPrevBlock==0))
       (
          &next_heap_block=&curr_heap_mem+&size
          &size2=V.VALUE(*((uint32*) &next_heap_block + 1))
          if ((&size2==0)&&(&next_heap_block<&curr_heap_end))
          (

               print "<<<Heap Corruption Detected! frd offset is set to zero ! for block : &next_heap_block >>";
               &frd_offset_zero_corruption=1
               print "Corrupted Block's Header address      : &next_heap_block";
               print "Possible Overflown Block              : "+format.DECIMAL(8.,&count);
               print "Overflown Block's Header address      : &curr_heap_mem";
               print "Size allocated to the Overflown Block : "+format.DECIMAL(8., &size);
               &flagbytes=V.VALUE(*((uint8*) &curr_heap_mem + 3))
               &freeflag=(&flagbytes&0x40)>>6
                if (&freeFlagBlock_r_c==&curr_heap_mem)
                (
                    print " <<It seems that the ptr &freeFlagBlock_r_c+0x10 passed in mem_free() is the culprit >>"
                    &freeflag=0 ; reset the freeflag  for this block since its under process in mem_free()

                )

                if (&freeflag!=0x1)
                (
                    &debug_info=V.VALUE(*((uint32*) (&curr_heap_mem) + 2))
                    &debug_info_symbol= Y.NAME(D:&debug_info)
                    &stats_index=V.VALUE(*((uint32*) (&curr_heap_mem) + 3))

                    if (&isHeapStats==1)
                    (
                         &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
                         &thread_id=&stats_index
                    )
                    &thread_id=&stats_index
                    print " This expected culprit(Overflown) block was allocated from function(i.e. Owner of it) = &debug_info_symbol , task = &tcb_ptr_symbol ,thread_id = &thread_id"
                )
                else
                (
                   print "   But this is a free block so it can not be the culprit and it should be there in the Free BINs "
                   print "   please check for some other possiblities of this corruption"
                   print "  "
                )

               if (&next_heap_block<&curr_heap_end)
               (
                   gosub FindNextValidBlock &next_heap_block &curr_heap_end
                   &curr_heap_mem=&NextValidBlock
                )
                else if (&curr_heap_mem>=&curr_heap_end)
                (
                    print "Aborting the script, it was the last memory block of heap"
                    CLOSE #1
                    enddo
                 )

          )
       )
       &concatenatedWithPrevBlock=0
       &flagbytes=V.VALUE(*((uint8*) &curr_heap_mem + 3))
       &curr_block_free_flag=(&flagbytes&0x40)>>6       
       &curr_block_section=&flagbytes&0x1f

       if ((&pre_block_free_flag==1)&&(&curr_block_free_flag==1)&&(&pre_block_section==&curr_block_section))
       (
          print " consecutive  free blocks found &pre_mem_block and &curr_heap_mem memory section = &pre_block_section"
          print " ----------- "
       )
       &pre_mem_block=&curr_heap_mem
       if (&corruptedBlock!=0)
       (
          if (&corruptedBlock<&curr_heap_end)
          (
             gosub FindNextValidBlock &corruptedBlock &curr_heap_end
          )
          else if (&corruptedBlock>=&curr_heap_end)
          (
             &lastflag=0x01
             print " it was the last memory block of this Section"
          )
          &corruptedBlock=0
       )
       else if (&frd_offset_zero_corruption==0)
       (
          &curr_heap_mem=&curr_heap_mem+&size
       )
       &frd_offset_zero_corruption=0
       &count=&count+1
       &flagbytes=V.VALUE(*((uint8*) &pre_mem_block + 3))
       &pre_block_free_flag=(&flagbytes&0x40)>>6
       &pre_block_section=&flagbytes&0x1f

    )

     &number_of_sections=&number_of_sections+1
     if (&number_of_sections<&total_number_of_sections)
     (
         &lastflag=0
         if (&lastBlockCorruption==1)
         (
            &lastBlockCorruption=0
            &count=&count-1
         )
         &curr_heap_mem=V.VALUE((mem_heap_type *) &HeapVar.sections[&number_of_sections].start_addr)
     )

 )
if (&lastBlockCorruption==1)
(
  &count=&count-1
)
&count=&count-1

print "  "
print "<<<<<<------------------------------------------------------------------------->>>>>"
&totalBlocks=V.VALUE((mem_heap_type *) &HeapVar.total_blocks)
print "       Total valid Heap Blocks expected in the heap = &totalBlocks"
print "       Total valid Heap Blocks could be detected(traversed) by the script= &count"
print "<<<<<<------------------------------------------------------------------------->>>>>"
print "  "

;information on incoming block 
print "!!<<< Memory Block passed in recent mem_free() call on *this* heap is = &incoming_Block >>>!!"
print "!! Below is more information on ptr passed in recent mem_free() (incoming block ptr) !!"

if (&incomBlockFound==1)
(
  if (&incomBlockInBinNo!=0xABCD)
  (
    print "!!The incoming block ptr is already a free block and present in free BIN no. = &incomBlockInBinNo   !!"
  )
  print "!!The incoming block belongs to setion no. = &incomBlockBelongsToSec of this heap                    !!"
  
)
else
(
  print "!!This was an invalid ptr passed in mem_free that dose not belong to the heap!!"
)
print "!!<<< ------------------------ end of incoming block info ------------------------ >>>!!"
print "   "
close #1
return ;End of walkHeap

walkStatsDB:
ENTRY &HeapVar &OpDir &MemStatsSize

if (&isHeapStats!=1)
(
;Debug stats is not present.
print "Debug stats not present, skipping the processing of debug stats"
return;
)
 OPEN #2 &OpT32FileStatsDb /Create 
; Important : Don't change this header! Used by Parser as is.
WRITE #2 "tcb_pointer,current_usage,max_usage" 
 &count=0;
 &writestring=""
 &thread_id=0
 &current_usage=0
 &max_usage=0
 &task_name=0x0

 
 while (&count!=&MemStatsSize)
 (
 ; First check for PAD 
 &max_usage=V.VALUE(&HeapVar.heapStatistics[&count].max_usage) 
 &current_usage= V.VALUE(&HeapVar.heapStatistics[&count].current_usage) 
 if (&max_usage!=0x0)      
 (
    &max_usage=V.VALUE(&HeapVar.heapStatistics[&count].max_usage)
    &task_name=V.STRING(&memheap_tls_to_tname[&count])
    &writestring="&task_name"
    ;&writestring=format.DECIMAL(8., &count)     
    &writestring="&writestring,"+""+format.DECIMAL(8., &current_usage)
    &writestring="&writestring,"+format.DECIMAL(8., &max_usage)
    WRITE #2 "&writestring"
 )
 &count=&count+1;
 )
close #2
return ;End of walkStatsDB

ProcHeap:
ENTRY &OpT32File &OpT32FileMemDb &OpPlFile &BlockHeaderSize
print "     Executing perl &HeapParserScript -i &OpT32File -o &OpPlFile -s &BlockHeaderSize"
os.area "perl &HeapParserScript -i &OpT32File -o &OpPlFile -s &BlockHeaderSize"

print "     Parser finished executing."
print "     Please check &OpPlFile, &OpT32File and &OpT32FileMemDb for results"
return ;End of ProcHeap

search_in_memheap_info_free_array:
ENTRY &corrupted_Block
   print " "
   print "The present value of memheap_info_free_array_cnt is &memheap_free_array_cnt "
   &check_cnt=&memheap_free_array_cnt
   &i=&memheap_free_array_cnt
   if (&i==(0x0))
   (
     &i=0x400
   )
   &i=&i-1
   &found_flag=0
   while (&i!=&check_cnt)
   (
      &mem_ptr=V.VALUE((memheap_info_free_array_type*)&memheap_free_array_str[&i].mem_ptr)
      &frd_offset=V.VALUE((memheap_info_free_array_type*)&memheap_free_array_str[&i].forw_offset)
      if ((&corrupted_Block)>(&mem_ptr-1)&&((&corrupted_Block)<((&mem_ptr+&frd_offset))))
      (
            &debug_info=V.VALUE((memheap_info_free_array_type*)&memheap_free_array_str[&i].caller)
            &debug_info_symbol= Y.NAME(D:&debug_info)
            &corrupt_task=V.VALUE(&memheap_free_array_str[&i].task_id)
            print "the memory block was part of &mem_ptr recently freed from &debug_info_symbol with task_id = &corrupt_task at index &i"
            &found_flag=1
      )
      if (&i==(0x0))
      (
            &i=0x400
      )
      else
      (
            &i=&i-1
      )
   )
   if (&found_flag==0)
   (
     print "No block found using &corrupted_Block address  "
   )
print "Check done"
print " "
print "Enter block address to know who was recently using that particular memory region( it will parse memheap_info_free_array):"
enter &corrupted_Block
gosub search_in_memheap_info_free_array &corrupted_Block
return;
