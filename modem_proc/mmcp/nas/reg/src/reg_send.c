/*==============================================================================
                             COPYRIGHT INFORMATION

Copyright (c) 2002 Qualcomm Technologies, Incorporated and its licensors.  All Rights
Reserved.  QUALCOMM Proprietary.  Export of this technology or software
is regulated by the U.S. Government. Diversion contrary to U.S. law prohibited.

                            EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order.

$PVCSPath:  L:/src/asw/MSM5200/reg/vcs/reg_send.c_v   1.4   07 Jun 2002 14:23:08   kabraham  $
$Header: //components/rel/mmcp.mpss/6.1.10/nas/reg/src/reg_send.c#1 $ $DateTime: 2023/04/25 14:39:18 $ $Author: pwbldsvc $

when       who     what, where, why
--------   ---     -------------------------------------------------------------
02/07/02   kwa     Initial version.
05/20/02   kwa     Replaced calls to ERR with MSG_ERROR.
05/29/02   kwa     Replaced rat_search_order with rat in mmr_reg_req.
06/06/02   kwa     Replaced mode_pref with dual_mode and rat in
                   mmr_plmn_search_req.
07/24/02   kwa     Included cmwll.h instead of cmll.h
09/19/02   kwa     Added function to send an mmr_act_req.
10/18/02   kwa     Added function to send a cm_deep_sleep_ind.
05/21/03   kwa     Added #include "msg.h" to eliminate a lint warning.  Modified
                   reg_send_cm_mm_information_ind to pass the info_p parameter
                   as a const pointer to eliminate a lint warning.  Modified
                   reg_send_cm_network_list_cnf to pass the plmn_list_p
                   parameter as a const pointer to eliminate a lint warning.
08/12/03   kwa     Added function reg_send_last_mmr_reg_req.
09/08/03   kwa     Removed FEATURE_REG_DEEP_SLEEP.
09/18/03   kwa     Added sys_band_mask_type to reg_send_mmr_act_req, 
                   reg_send_mmr_plmn_search_req, and reg_send_mmr_reg_req.
10/02/03   kwa     Modified reg_send_mmr_act_req to activate the GSM stack when
                   the mode preference received from SD/MMoC is
                   SYS_MODE_PREF_UMTS_RADIO_ACCESS_PREFERRED.
12/10/03   kwa     Added reg_send_last_mmr_reg_req_gsm_only to support a change
                   in handling MMR_CAUSE_FAILURE_LAI_NOT_ALLOWED so the phone
                   will attempt to acquire GSM_ONLY service on the same PLMN.
02/04/04   kwa     Added ps_for_request parameter to reg_send_mmr_reg_req.
02/10/04   kwa     Added FEATURE_PS_FOLLOW_ON_REQUEST to set the ps_for_request
                   parameter to FALSE for targets that do not wish to enable
                   this feature.
02/22/04   kwa     Explicitly cast enumerated values used to identify each
                   message to a byte when filling each message header.
                   Suppress Lint Error (Info) 778: Constant expression
                   evaluates to 0 in operation '-' when computing the length
                   of an empty message.
05/16/04   kwa     Added cs_for_request parameter to reg_send_mmr_reg_req.
                   Added function to send a cm_camped_ind.
06/09/04   kwa     Undefined FEATURE_MEM_DEBUG locally to eliminate compiler
                   warnings generated by inclusion of memheap.h
07/19/04   kwa     Removed service_state parameter from cm_camped_ind.
07/26/04   kwa     Added active_rat and active_band parameters to
                   reg_send_cm_camped_ind.
11/10/04   kwa     Added higher_priority_plmn_list_p parameter to
                   reg_send_mmr_plmn_search_req.
07/15/05   up      Added function reg_send_mmr_eq_plmn_change_ind.
09/19/05   up      Added reg_send_cm_hplmn_search_cnf to support on demand 
                   HPLMN search from user.
11/07/05   ajt     Added function reg_send_cm_emergency_num_list_ind.                   
12/08/05   up      Updated reg_send_cm_network_list_cnf to add status field.
01/02/06   up      Added reg_send_mmr_plmn_search_abort_req to abort ongoing
                   PLMN Search.
01/18/06   up      Updated reg_send_mmr_plmn_search_req to set trans ID.
04/06/06   sn      Added reg_send_cm_cell_service_ind
07/27/06   sn      Added Uniform OOS changes.
                   FEATURE_UMTS_UNIFORM_OOS_HANDLING
10/12/06   sn      WCDMA_1X mode preference implementation.   
11/23/06   sn      Added feature FEATURE_UMTS_BACKGROUND_FULL_SERVICE_SEARCH
12/15/09   abhi    Removing UOOS feature flag
01/31/11   rajesh  voice domain preference and UE usage setting related changes
10/05/11   gps     Initiated some primitives with all zeros
09/12/11   HC      Replacing the #include "reg_mm.h" with #include "reg_mm_v.h" 
                   as a part of CMI activity
==============================================================================*/

/*==============================================================================

                            INCLUDE FILES FOR MODULE

==============================================================================*/

/*
** Undefine FEATURE_MEM_DEBUG locally in this file to eliminate compiler
** warnings generated by inclusion of memheap.h
*/
#include "mmcp_variation.h"
#ifdef FEATURE_MEM_DEBUG
#undef FEATURE_MEM_DEBUG
#endif

#include "cmwll.h"
#include "customer.h"
#include "gs_v.h"
#include "ms.h"
#include "msg.h"
#include "reg_cm_v.h"
#include "reg_mm_v.h"
#include "reg_mode.h"
#include "reg_send.h"
#include "reg_state.h"
#include "cb_reg.h"
#include "time_genoff.h"
#include "time_jul.h"
#include "err.h"
#include "reg_nv.h"


#include "sys_eplmn_list_v.h"
#include "reg_timers.h"
#include <stringl/stringl.h>
/* The below flag is defined to make the code work this 
#define won't be used in functionality */

#define CURRENT_CENTURY 2000

/*==============================================================================

                                TYPE DEFINITIONS

==============================================================================*/

/*==============================================================================

                          STATIC FUNCTION DECLARATIONS

==============================================================================*/
#ifdef FEATURE_CIOT
static void reg_send_remove_other_rats (sys_rat_pri_list_info_s_type* rat_pri_list_info, 
                                        sys_radio_access_tech_e_type rat, boolean one_rat)
{
   uint8 i;
   sys_sys_mode_e_type  acq_sys_mode = SYS_SYS_MODE_NONE;
   sys_priority_list_info_s_type cache;
   boolean gsm_found = FALSE;
   acq_sys_mode = reg_mode_convert_access_tech_to_acq_mode(rat);

   if ((rat_pri_list_info->num_items == 1)||(rat_pri_list_info->num_items == 0)||
       ((acq_sys_mode != SYS_SYS_MODE_LTE_M1) && (acq_sys_mode != SYS_SYS_MODE_LTE_NB1)))
   {
	   return;
   }
   /* At this point the rat to be acquired is of LTE flavor */
   if (FALSE == one_rat)
   {       
       /* Determine if GSM rat is present and cache its resources */
       for (i = 0; i < rat_pri_list_info->num_items; ++i )
       {       
           if (SYS_SYS_MODE_GSM == rat_pri_list_info->priority_list_info[i].acq_sys_mode)
           {               
               memscpy(&cache, sizeof(sys_priority_list_info_s_type), 
                         &rat_pri_list_info->priority_list_info[i], sizeof(sys_priority_list_info_s_type));          
               gsm_found = TRUE;
           }
       }
   }
 
   for (i = 0; i < rat_pri_list_info->num_items; ++i )
   {
       /* Find the rat to be acquired, move its location to the top */
       if (acq_sys_mode == rat_pri_list_info->priority_list_info[i].acq_sys_mode)
       {
           // here LTE rat to be acquired moves to the top
           memscpy(&rat_pri_list_info->priority_list_info[0], sizeof(sys_priority_list_info_s_type), 
                     &rat_pri_list_info->priority_list_info[i], sizeof(sys_priority_list_info_s_type));
       }
   }
   if (gsm_found)
   {
      memscpy(&rat_pri_list_info->priority_list_info[1], sizeof(sys_priority_list_info_s_type), 
                     &cache, sizeof(sys_priority_list_info_s_type));
      rat_pri_list_info->num_items = 2;
   }
   else
   {
      rat_pri_list_info->num_items = 1;
   }

}
static void reg_send_remove_other_bands (sys_rat_pri_list_info_s_type* rat_pri_list_info, 
                                        sys_plmn_id_s_type plmn)
{
    uint32 mcc;
    reg_nv_mcc_band_s_type mcc_and_bands;
    sys_lte_band_mask_e_type bands;
    boolean bands_set_efs = FALSE;
    /* ----------------------------------------
    ** PLMN octet 1 = MCC digit 2 | MCC digit 1
        mcc_digit_1 = plmn.identity[0] & 0x0F;
        mcc_digit_2 = plmn.identity[0] / 0x10;
        mcc_digit_3 = plmn.identity[1] & 0x0F;
       *mcc_ptr = 100 * mcc_digit_1 + 10 * mcc_digit_2 + mcc_digit_3;
    ** ---------------------------------------- */
    mcc = (plmn.identity[0] & 0x0F)* 100;
    mcc += ((plmn.identity[0] / 0x10)*10);

    /* ----------------------------------------
    ** PLMN octet 2 = MNC digit 3 | MCC digit 3
    ** ---------------------------------------- */
    mcc += (plmn.identity[1] & 0x0F);

    /* Only one element is in the rat priority list*/
    mcc_and_bands = reg_nv_search_mcc_bands(rat_pri_list_info->priority_list_info[0].acq_sys_mode, mcc);
    MSG_HIGH_DS_1(REG_SUB, "=REG= MCC %u", mcc);
    if (mcc_and_bands.bands[0] == 0 && 
		mcc_and_bands.bands[1] == 0 && 
		mcc_and_bands.bands[2] == 0 && 
		mcc_and_bands.bands[3] == 0)
    {
        MSG_HIGH_DS_2(REG_SUB, "=REG= MCC %u for rat %d does not have bands enabled", mcc,
            rat_pri_list_info->priority_list_info[0].acq_sys_mode);
        return;
    }
    MSG_HIGH_DS_6(REG_SUB, "=REG= MCC %u for rat %d have bands 0x%x  0x%x 0x%x 0x%x enabled", mcc, 
        rat_pri_list_info->priority_list_info[0].acq_sys_mode, mcc_and_bands.bands[0],mcc_and_bands.bands[1], mcc_and_bands.bands[2], mcc_and_bands.bands[3]);

    /* Create a subset of the bands that have been passed */
#if (LTE_BAND_NUM == 256)
    bands = rat_pri_list_info->priority_list_info[0].bst_band_cap.lte_band_cap;
	if(((bands.bits_1_64 & mcc_and_bands.bands[0]) != 0) ||
	   ((bands.bits_65_128 & mcc_and_bands.bands[1]) !=0 )||
	   ((bands.bits_129_192 & mcc_and_bands.bands[2]) != 0) ||
	   ((bands.bits_193_256 & mcc_and_bands.bands[3]) != 0))
	{
	  bands.bits_1_64 = (bands.bits_1_64 & mcc_and_bands.bands[0]);
	  bands.bits_65_128 = (bands.bits_65_128 & mcc_and_bands.bands[1]);
	  bands.bits_129_192 = (bands.bits_129_192 & mcc_and_bands.bands[2]);
	  bands.bits_193_256 = (bands.bits_193_256 & mcc_and_bands.bands[3]);
	  bands_set_efs = TRUE;
	} 
    if (bands_set_efs == TRUE)
    {
        /* At least one band has been enabled, apply it*/
        rat_pri_list_info->priority_list_info[0].bst_band_cap.lte_band_cap = bands;
        rat_pri_list_info->priority_list_info[0].band_cap.lte_band_cap = bands;
        MSG_HIGH_DS_5(REG_SUB, "=REG= MCC %u bands filtered to 0x%x 0x%x 0x%x 0x%x", mcc, bands.bits_1_64,bands.bits_65_128, bands.bits_129_192, bands.bits_193_256 );
    } 
    else
    {
        MSG_HIGH_DS_1(REG_SUB, "=REG= MCC %u no band filtering applied", mcc);
    }
#endif
}

#endif
/*==============================================================================

                               DATA DECLARATIONS

==============================================================================*/
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE 
static mmr_reg_req_s_type reg_send_mmr_reg_req_msg_sim[MAX_NAS_STACKS];
#define reg_send_mmr_reg_req_msg  reg_send_mmr_reg_req_msg_sim[reg_as_id]

extern sys_mode_pref_e_type  reg_sim_mode_pref_sim[MAX_NAS_STACKS];
extern reg_cm_network_list_req_e_type reg_last_recieved_list_req_type_sim[MAX_NAS_STACKS];
#define reg_last_recieved_list_req_type reg_last_recieved_list_req_type_sim[reg_as_id]

typedef struct reg_debug_msg_info_s
{
  IMH_T hdr;
  sys_modem_as_id_e_type as_id;
} reg_debug_msg_info_s_type;

#else
static mmr_reg_req_s_type reg_send_mmr_reg_req_msg;
extern reg_cm_network_list_req_e_type reg_last_recieved_list_req_type;

#endif /* FEATURE_DUAL_SIM*/

#ifdef FEATURE_SGLTE
extern boolean reg_sglte_mode;
#endif

/* FEATURE_TRIPLE_SIM*/
#ifdef FEATURE_TRIPLE_SIM
static boolean            reg_send_grat_scan_done_sim[MAX_NAS_STACKS] = {FALSE, FALSE,FALSE};
#define reg_send_grat_scan_done reg_send_grat_scan_done_sim[reg_as_id]

#ifdef FEATURE_FEMTO_CSG
static sys_network_selection_mode_e_type  reg_send_nw_sel_mode_sent_to_mm_sim[MAX_NAS_STACKS] = { SYS_NETWORK_SELECTION_MODE_NONE,
                                                                                              SYS_NETWORK_SELECTION_MODE_NONE,
                                                                                              SYS_NETWORK_SELECTION_MODE_NONE };
#define reg_send_nw_sel_mode_sent_to_mm reg_send_nw_sel_mode_sent_to_mm_sim[reg_as_id]
#endif

#elif defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE 
static boolean            reg_send_grat_scan_done_sim[MAX_NAS_STACKS] = {FALSE, FALSE};
#define reg_send_grat_scan_done reg_send_grat_scan_done_sim[reg_as_id]

#ifdef FEATURE_FEMTO_CSG
static sys_network_selection_mode_e_type  reg_send_nw_sel_mode_sent_to_mm_sim[MAX_NAS_STACKS] = { SYS_NETWORK_SELECTION_MODE_NONE,
                                                                                              SYS_NETWORK_SELECTION_MODE_NONE };
#define reg_send_nw_sel_mode_sent_to_mm reg_send_nw_sel_mode_sent_to_mm_sim[reg_as_id]
#endif
#else
static boolean            reg_send_grat_scan_done = FALSE;
#ifdef FEATURE_FEMTO_CSG
static sys_network_selection_mode_e_type reg_send_nw_sel_mode_sent_to_mm = SYS_NETWORK_SELECTION_MODE_NONE;
#endif
#endif

#ifdef FEATURE_SGLTE
static boolean reg_send_sglte_main_stop_cnf_pending = FALSE; 
extern boolean reg_state_sglte_hybrid_stack_inactive(void);
#endif 
/*==============================================================================

                          STATIC FUNCTION DEFINITIONS

==============================================================================*/


/*==============================================================================

FUNCTION NAME

  reg_set_proc_time

  This function updates the UTC at timer with the time received from 3GPP Networks
  ATS_TOD - base type which is common for all radios in multimode env
  TIME_SCLK - system clock
  TIME_JULIAN - Julian time
  T_SET - setting time

  Returns: None

==============================================================================*/

static void reg_set_proc_time(sys_time_and_time_zone_s_type* info)
{
  time_genoff_args_struct_type time_genoff_args;
  time_julian_type             jul_val;

  MSG_HIGH_DS_3 (REG_SUB, "=REG= Updating TIME Services with NITZ Info - year=%d , month=%d , day=%d", info->year,info->month,info->day);
  MSG_HIGH_DS_3 (REG_SUB, "=REG= hr=%d,  minute=%d,  sec=%d",info->hour,info->minute,info->second);

  jul_val.year = (uint16)(CURRENT_CENTURY + info->year);
  jul_val.month = (uint16)info->month;
  jul_val.day = (uint16)info->day;
  jul_val.hour = (uint16)info->hour;
  jul_val.minute = (uint16)info->minute;
  jul_val.second = (uint16)info->second;

  time_genoff_args.base        = ATS_3GPP; 
  time_genoff_args.base_source = TIME_SCLK;
  time_genoff_args.ts_val      = (void *)(&jul_val);
  time_genoff_args.unit        = TIME_JULIAN;
  time_genoff_args.operation   = T_SET;
  time_genoff_opr( &time_genoff_args );

}

/*==============================================================================

FUNCTION NAME

  reg_send_grat_scan_done_set

==============================================================================*/

void reg_send_grat_scan_done_set
(
  boolean flag
)
{
    reg_send_grat_scan_done = flag;
}

/*==============================================================================

FUNCTION NAME

  reg_send_last_reg_req_plmn_get

==============================================================================*/

sys_plmn_id_s_type reg_send_last_reg_req_plmn_get
(
  void
)
{
  return reg_send_mmr_reg_req_msg.plmn;
}

//FRACQ
/*==============================================================================

FUNCTION NAME

  reg_send_last_reg_req_scan_scope_get

==============================================================================*/

sys_scan_scope_e_type reg_send_last_reg_req_scan_scope_get
(
  void
)
{
  return reg_send_mmr_reg_req_msg.scan_scope;
}

/*==============================================================================

/*==============================================================================

FUNCTION NAME

  reg_send_last_reg_req_rat_get

==============================================================================*/

sys_radio_access_tech_e_type reg_send_last_reg_req_rat_get
(
  void
)
{
  return reg_send_mmr_reg_req_msg.rat;
}

/*==============================================================================

FUNCTION NAME

  reg_send_last_rat_pri_list_get

==============================================================================*/

sys_rat_pri_list_info_s_type* reg_send_last_rat_pri_list_get(void)
{
  return &reg_send_mmr_reg_req_msg.original_rat_pri_list_info;
}

/*==============================================================================

FUNCTION NAME

  reg_send_update_cm_service_capability

  This function updates the Registered service domain to CM  depending upon whether
  the PLMN is forbidden for GPRS service or not
  It also updates registered service domain based on the PLMN service capability
==============================================================================*/

static void reg_send_update_cm_service_capability
(
  sys_plmn_service_state_s_type*  service_state
)
{
  if((service_state->service_status == SYS_SRV_STATUS_SRV) &&
     (
#ifdef FEATURE_DUAL_SIM
      (reg_sim_plmn_gprs_forbidden(service_state->plmn,(sys_modem_as_id_e_type)reg_sub_id))||
#else
      (reg_sim_plmn_gprs_forbidden(service_state->plmn)) ||
#endif
     (service_state->plmn_service_capability == SYS_SRV_CAPABILITY_CS_SERVICE_ONLY)))
  {
    if(service_state->reg_service_domain == SYS_SRV_DOMAIN_CS_PS)
    {
      MSG_HIGH_DS_2(REG_SUB, "=REG= registered service domain is changed from %x to %x",
                    service_state->reg_service_domain, SYS_SRV_DOMAIN_CS_ONLY);
      service_state->reg_service_domain = SYS_SRV_DOMAIN_CS_ONLY;
    }
    else if(service_state->reg_service_domain == SYS_SRV_DOMAIN_PS_ONLY)
    {
      MSG_HIGH_DS_2(REG_SUB, "=REG= registered service domain is changed from %x to %x",
                    service_state->reg_service_domain, SYS_SRV_DOMAIN_NO_SRV);
      service_state->reg_service_domain = SYS_SRV_DOMAIN_NO_SRV;
      service_state->service_status     = SYS_SRV_STATUS_LIMITED;
    }
  }
}

/*==============================================================================

FUNCTION NAME

  reg_send_message

DESCRIPTION

  Function that places a message on the specified message queue.

RETURN VALUE

  None

==============================================================================*/

static void reg_send_message
(
  void*         msg_p,
  gs_queue_id_T queue_id
)
{
  gs_status_T gs_status;
  reg_add_message_to_debug_buffer(((IMH_T *)msg_p)->message_set, (byte)((IMH_T *)msg_p)->message_id, FALSE , reg_mode_mode_pref_get());

  gs_status = gs_send_message( queue_id, msg_p, TRUE );

  if( gs_status != GS_SUCCESS )
  {
    MSG_ERROR_DS_1( REG_SUB, "=REG= Failed to send msg (status = %d)", gs_status);
  }
}


/*==============================================================================

                              FUNCTION DEFINITIONS

==============================================================================*/

/*==============================================================================

FUNCTION NAME

  reg_send_cm_camped_ind

==============================================================================*/

void reg_send_cm_camped_ind
(
#ifndef FEATURE_GSM_BAND_PREF
  sys_radio_access_tech_e_type    active_rat
#else
  sys_radio_access_tech_e_type    active_rat,
  /* Union type that groups bands  */
  sys_active_band_u_type          active_band
#endif
  ,sys_plmn_id_s_type             plmn
  ,sys_lac_type                   lac_id
)
{
  cm_camped_ind_s_type msg;
  memset(&msg,0x00,sizeof(cm_camped_ind_s_type));

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_CAMPED_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_camped_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_camped_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.active_rat  = active_rat;
#ifdef FEATURE_GSM_BAND_PREF
  msg.active_band = active_band;
#endif
  msg.plmn        = plmn;
  msg.lac_id      = lac_id;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();


  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_CAMPED_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_attach_failed_ind

==============================================================================*/

void reg_send_cm_attach_failed_ind
(
  void 
)
{
  cm_ps_attach_failed_ind_s_type msg;
  memset(&msg,0x00,sizeof(cm_ps_attach_failed_ind_s_type));

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_PS_ATTACH_FAILED_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_ps_attach_failed_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_ps_attach_failed_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_PS_ATTACH_FAILED_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_mm_information_ind

==============================================================================*/

void reg_send_cm_mm_information_ind
(
  const sys_mm_information_s_type*      info_p
)
{
  cm_mm_information_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_MM_INFORMATION_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_mm_information_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_mm_information_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.info = *info_p;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

  if (msg.info.univ_time_and_time_zone_avail)
  {
    reg_set_proc_time(&msg.info.univ_time_and_time_zone);
  }

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_MM_INFORMATION_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================

FUNCTION NAME

  reg_send_empty_cm_network_list_cnf

==============================================================================*/

void reg_send_empty_cm_network_list_cnf
(
  reg_cm_transaction_id_type      transaction_id,
  sys_plmn_id_s_type              rplmn,
  reg_mm_plmn_search_status_e_type status
)
{
  sys_found_plmn_list_u_type  *available_list= NULL;
  available_list = (sys_found_plmn_list_u_type *)
         modem_mem_calloc(1,sizeof(sys_found_plmn_list_u_type), 
                          MODEM_MEM_CLIENT_NAS);
  reg_check_for_null_ptr((void*)available_list);
  reg_send_cm_network_list_cnf
  (
    transaction_id,
    rplmn,
    available_list,
    status
  );
  modem_mem_free(available_list, MODEM_MEM_CLIENT_NAS);
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_network_list_cnf

==============================================================================*/
void reg_send_cm_network_list_cnf
(
        reg_cm_transaction_id_type          transaction_id,
        sys_plmn_id_s_type                  rplmn,
        const sys_found_plmn_list_u_type*   found_plmn_list,
        reg_mm_plmn_search_status_e_type    status
)
{
  cm_network_list_cnf_s_type *msg = NULL;
#ifdef FEATURE_MODEM_HEAP
      msg = (cm_network_list_cnf_s_type *)modem_mem_alloc(sizeof(cm_network_list_cnf_s_type), MODEM_MEM_CLIENT_NAS);
#else
      msg = (cm_network_list_cnf_s_type *)gs_alloc(sizeof(cm_network_list_cnf_s_type));
#endif
  reg_check_for_null_ptr((void*)msg );

  memset(msg,0x00,sizeof(cm_network_list_cnf_s_type));

  msg->message_header.message_set     = MS_CM_REG;
  msg->message_header.message_id      = (byte)CM_NETWORK_LIST_CNF;
  msg->message_header.message_len_lsb =
    (sizeof(cm_network_list_cnf_s_type) - sizeof(IMH_T)) % 256;
  msg->message_header.message_len_msb =
    (sizeof(cm_network_list_cnf_s_type) - sizeof(IMH_T)) / 256;

  msg->transaction_id      = transaction_id;
  msg->rplmn               = rplmn;
  msg->available_plmn_list = *found_plmn_list;
  
  if(status == REG_MM_PLMN_SEARCH_SUCCESS)
  {
    msg->status = REG_CM_NETWORK_LIST_SUCCESS;
  }
  else if( status == REG_MM_PLMN_SEARCH_PARTIAL)                 
  {
    msg->status = REG_CM_NETWORK_LIST_PARTIAL;
  }
  else if(status == REG_MM_PLMN_SEARCH_ABORTED_ON_RLF)
  {
    msg->status = REG_CM_NETWORK_LIST_ABORTED_ON_RLF;
  }
#ifdef FEATURE_GPS_WWAN_PRIORITY_SEARCH	
  else if(status == REG_CM_NETWORK_LIST_FAIL_IN_CONNECTED_MODE)
  {
    msg->status = REG_CM_NETWORK_LIST_FAIL_IN_CONNECTED_MODE;
  }
#endif
  else
  {
    msg->status = REG_CM_NETWORK_LIST_AS_ABORT;
  }

#ifdef FEATURE_GPS_WWAN_PRIORITY_SEARCH	
  if(found_plmn_list->gps_wwan_scan_result != NULL && status != REG_CM_NETWORK_LIST_FAIL_IN_CONNECTED_MODE)
  {
     msg->status = REG_CM_NETWORK_LIST_SUCCESS;
  }
#endif

  msg->as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg->stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_NETWORK_LIST_CNF");
  reg_send_message(msg, GS_QUEUE_CM);
#ifndef FEATURE_MODEM_HEAP
   gs_free(msg);
#else
   modem_mem_free(msg, MODEM_MEM_CLIENT_NAS);
#endif
  msg = NULL;
}
#ifdef FEATURE_NO_CBS_LTD 
/*==========================================================================

FUNCTION NAME
  reg_send_cb_service_ind

============================================================================*/
void reg_send_cb_service_ind
(
  sys_plmn_service_state_s_type   service_state
)
{
  reg_service_state_ind_T msg;
  msg.message_header.message_set    = MS_REG_CB;
  msg.message_header.message_id     = (byte)REG_SERVICE_STATE_IND;
  msg.message_header.message_len_lsb =
    (sizeof(reg_service_state_ind_T) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(reg_service_state_ind_T) - sizeof(IMH_T)) / 256;
  if(service_state.service_status == SYS_SRV_STATUS_SRV)
  {
    msg.service_state = TRUE;
  }
  else
  {
    msg.service_state = FALSE;
  }
  switch(service_state.active_rat)
  {
    case SYS_RAT_GSM_RADIO_ACCESS:
      msg.gsm_active_rat = TRUE;
      break;
    case SYS_RAT_UMTS_RADIO_ACCESS:
    case SYS_RAT_TDS_RADIO_ACCESS:
      msg.gsm_active_rat = FALSE;
      break;
    default :
        MSG_HIGH_DS_0(REG_SUB, "=REG= This RAT is not considered for CB");
      break;
  }
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE 
  msg.as_id = reg_as_id;
#endif

  MSG_HIGH_DS_0(REG_SUB, "=REG= REG_SERVICE_STATE_IND");
  reg_send_message(&msg, GS_QUEUE_CB);
}
#endif
#ifdef FEATURE_DUAL_SIM
void reg_send_cb_ds_stat_chgd_ind (uint8 active_subs)
{
  cb_reg_stat_chgd_req_s_type msg;
  msg.message_header.message_set    = MS_REG_CB;
  msg.message_header.message_id     = (byte)REG_MODE_CHANGE_STATE_IND;
  msg.message_header.message_len_lsb =
    (sizeof(reg_service_state_ind_T) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(reg_service_state_ind_T) - sizeof(IMH_T)) / 256;

  msg.active_subs = active_subs;
  MSG_HIGH_DS_0(REG_SUB, "=REG= REG_MODE_STATE_CHANGE_IND");
  reg_send_message(&msg, GS_QUEUE_CB);
  /*when mainlining take header file out of FEATURE_NO_CBS_LTD, otherwise
        compilation failures will come*/
}
#endif



/*==============================================================================

FUNCTION NAME

  reg_send_cm_service_cnf

==============================================================================*/

void reg_send_cm_service_cnf
(
  reg_cm_transaction_id_type      transaction_id,
  sys_plmn_service_state_s_type   service_state
)
{
  cm_service_cnf_s_type msg;
  memset(&msg,0x00,sizeof(cm_service_cnf_s_type));
#ifdef FEATURE_NO_CBS_LTD 
  reg_send_cb_service_ind( service_state);
#endif

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_SERVICE_CNF;
  msg.message_header.message_len_lsb =
    (sizeof(cm_service_cnf_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_service_cnf_s_type) - sizeof(IMH_T)) / 256;

  msg.transaction_id = transaction_id;
  reg_send_update_cm_service_capability(&service_state);
  msg.service_state  = service_state;

  msg.scan_status = reg_mode_scan_status_get();
  MSG_HIGH_DS_2(REG_SUB, "=REG= scan_status: %d CP sMS status %d ", msg.scan_status, msg.service_state.cp_sms_service_status);
  
#ifdef FEATURE_FEMTO_CSG
  msg.service_state.registered_plmn = reg_nv_read_rplmn();
#ifdef FEATURE_DUAL_SIM
  if(reg_sim_per_subs_plmn_forbidden(msg.service_state.registered_plmn, (sys_modem_as_id_e_type)reg_sub_id))
#else
  if(reg_sim_plmn_forbidden(msg.service_state.registered_plmn))
#endif 
  {
    sys_plmn_undefine_plmn_id(&msg.service_state.registered_plmn);
  }
#endif 

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE 
  if (msg.service_state.acq_status != SYS_ACQ_STATUS_NO_RESOURCE)
  {
    msg.service_state.acq_status = SYS_ACQ_STATUS_SUCCESS;
  }
#endif
  if(msg.service_state.service_status == SYS_SRV_STATUS_SRV)
  {
    reg_mode_clear_cm_serv_req_count();
    reg_timers_stop_nb1_tier3_fullband_timer();
    reg_timers_stop_nb1_tier3_acq_timer();
  }
  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

if(( !sys_plmn_id_is_undefined(msg.service_state.registered_plmn) )
	  && reg_nv_read_override_roam_status(
#ifdef FEATURE_DUAL_SIM
       reg_sub_id
#endif
       ) == TRUE &&
#ifdef FEATURE_DUAL_SIM
       (reg_sim_check_mcc_same_country_per_sub(msg.service_state.registered_plmn, reg_sub_id) == TRUE)
#else
       (reg_sim_check_mcc_same_country(msg.service_state.registered_plmn) == TRUE)
#endif
       )
  {
    msg.service_state.roaming_ind = 
            reg_state_get_override_roam_status
                       (msg.service_state.registered_plmn,
#ifdef FEATURE_DUAL_SIM
                        reg_sub_id,
#endif
                        msg.service_state.roaming_ind);
  }

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_SERVICE_CNF");
  reg_send_message(&msg, GS_QUEUE_CM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_cm_service_ind

==============================================================================*/

void reg_send_cm_service_ind
(
  sys_plmn_service_state_s_type   service_state
)
{
  cm_service_ind_s_type msg;
  memset(&msg,0x00,sizeof(cm_service_ind_s_type));
#ifdef FEATURE_NO_CBS_LTD 
  reg_send_cb_service_ind( service_state);
#endif

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_SERVICE_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_service_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_service_ind_s_type) - sizeof(IMH_T)) / 256;

  reg_send_update_cm_service_capability( &service_state);
  msg.service_state = service_state;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

#ifdef FEATURE_FEMTO_CSG
  msg.service_state.registered_plmn = reg_nv_read_rplmn();
#ifdef FEATURE_DUAL_SIM
  if(reg_sim_per_subs_plmn_forbidden(msg.service_state.registered_plmn, (sys_modem_as_id_e_type)reg_sub_id))
#else
  if(reg_sim_plmn_forbidden(msg.service_state.registered_plmn))
#endif 
  {
    sys_plmn_undefine_plmn_id(&msg.service_state.registered_plmn);
  }
#endif 

#ifdef FEATURE_CIOT
  if(msg.service_state.service_status == SYS_SRV_STATUS_SRV)
  {
    reg_mode_clear_cm_serv_req_count();
	reg_timers_stop_nb1_tier3_fullband_timer();
	reg_timers_stop_nb1_tier3_acq_timer();
  } //FRACQ
#endif
  MSG_HIGH_DS_1(REG_SUB, "=REG= CM_SERVICE_IND cp_sms_service_status %d",msg.service_state.cp_sms_service_status);

 if(( !sys_plmn_id_is_undefined(msg.service_state.registered_plmn) ) && 
     reg_nv_read_override_roam_status(
#ifdef FEATURE_DUAL_SIM
       reg_sub_id
#endif
       ) == TRUE &&
#ifdef FEATURE_DUAL_SIM
       (reg_sim_check_mcc_same_country_per_sub(msg.service_state.registered_plmn, reg_sub_id) == TRUE)
#else
       (reg_sim_check_mcc_same_country(msg.service_state.registered_plmn) == TRUE)
#endif
       )
  {
    msg.service_state.roaming_ind = 
            reg_state_get_override_roam_status
                       (msg.service_state.registered_plmn,
#ifdef FEATURE_DUAL_SIM
                        reg_sub_id,
#endif
                        msg.service_state.roaming_ind);
  }
  reg_send_message(&msg, GS_QUEUE_CM);
}

#ifndef FEATURE_NAS_IMS_VOICE_DISABLED
/*==============================================================================

FUNCTION NAME

  reg_send_cm_emergency_num_list_ind

==============================================================================*/

void reg_send_cm_emergency_num_list_ind
(
  cm_emergency_num_list_ind_s_type* msg_p
)
{
  cm_emergency_num_list_ind_s_type msg;
  memset(&msg,0x00,sizeof(cm_emergency_num_list_ind_s_type));

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_EMERGENCY_NUM_LIST_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_emergency_num_list_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_emergency_num_list_ind_s_type) - sizeof(IMH_T)) / 256;
    
  memscpy(&(msg.emergency_number_list), sizeof(cm_emergency_num_list_s_type), &(msg_p->emergency_number_list),
    sizeof(cm_emergency_num_list_s_type));  

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_EMERGENCY_NUM_LIST_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

#endif 

/*==============================================================================

FUNCTION NAME

  reg_send_cm_sim_available_cnf

==============================================================================*/

void reg_send_cm_sim_available_cnf
(
  reg_cm_transaction_id_type      transaction_id
)
{
  cm_sim_available_cnf_s_type msg;
  memset(&msg,0x00,sizeof(cm_sim_available_cnf_s_type));

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_SIM_AVAILABLE_CNF;
  msg.message_header.message_len_lsb =
    (sizeof(cm_sim_available_cnf_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_sim_available_cnf_s_type) - sizeof(IMH_T)) / 256;

  msg.transaction_id = transaction_id;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();


  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_SIM_AVAILABLE_CNF");
  reg_send_message(&msg, GS_QUEUE_CM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_cm_sim_not_available_cnf

==============================================================================*/

void reg_send_cm_sim_not_available_cnf
(
  reg_cm_transaction_id_type      transaction_id
)
{
  cm_sim_not_available_cnf_s_type msg;
  memset(&msg,0x00,sizeof(cm_sim_not_available_cnf_s_type));

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_SIM_NOT_AVAILABLE_CNF;
  msg.message_header.message_len_lsb =
    (sizeof(cm_sim_not_available_cnf_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_sim_not_available_cnf_s_type) - sizeof(IMH_T)) / 256;

  msg.transaction_id = transaction_id;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();


  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_SIM_NOT_AVAILABLE_CNF");
  reg_send_message(&msg, GS_QUEUE_CM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_cm_stop_mode_cnf

==============================================================================*/

void reg_send_cm_stop_mode_cnf
(
  reg_cm_transaction_id_type      transaction_id
)
{
  cm_stop_mode_cnf_s_type msg;

#ifdef FEATURE_SGLTE
  if(REG_SGLTE_DUAL_STACK && 
    (reg_as_id == reg_ps_stack_id) && 
    ((reg_state_last_stop_mode_reason == SYS_STOP_MODE_REASON_UE_MODE_CHANGE) ||
      (reg_state_last_stop_mode_reason == SYS_STOP_MODE_REASON_MODE_CHANGE) ||
      (reg_state_last_stop_mode_reason == SYS_STOP_MODE_REASON_LPM) ||
      (reg_state_last_stop_mode_reason == SYS_STOP_MODE_REASON_POWER_OFF) ||
      (reg_state_last_stop_mode_reason == SYS_STOP_MODE_REASON_OFFLINE) ||
      (reg_state_last_stop_mode_reason == SYS_STOP_MODE_REASON_DSDS_SUSPEND) ||
      (reg_state_last_stop_mode_reason == SYS_STOP_MODE_REASON_DUAL_SWITCH)) &&
     !reg_state_sglte_hybrid_stack_inactive())
  {
    reg_send_sglte_main_stop_cnf_pending = TRUE;
    reg_state_last_stop_mode_reason = SYS_STOP_MODE_REASON_NONE;
    MSG_HIGH_DS_0(REG_SUB, "=REG= CM_STOP_MODE_CNF - Buffered waiting for hybrid stack to stop");
    return;
  }
#endif 
  memset(&msg,0x00,sizeof(cm_stop_mode_cnf_s_type));

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_STOP_MODE_CNF;
  msg.message_header.message_len_lsb =
    (sizeof(cm_stop_mode_cnf_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_stop_mode_cnf_s_type) - sizeof(IMH_T)) / 256;

  msg.transaction_id = transaction_id;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

#ifdef FEATURE_GSTK
    if((reg_state_last_stop_mode_reason == SYS_STOP_MODE_REASON_NO_SYS) && (!reg_nv_is_imsi_switch_enabled()))
    {
      reg_send_mmr_gstk_service(FALSE);
    }
#endif
  reg_state_last_stop_mode_reason = SYS_STOP_MODE_REASON_NONE;

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_STOP_MODE_CNF");
  reg_send_message(&msg, GS_QUEUE_CM);

#ifdef FEATURE_SGLTE
  if(REG_SGLTE_DUAL_STACK &&
     (reg_as_id == reg_cs_stack_id) && 
     (reg_send_sglte_main_stop_cnf_pending == TRUE))
  {
    reg_as_id = reg_ps_stack_id;

    msg.transaction_id = reg_state_cm_transaction_id_get();

    msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
    msg.stack_id = reg_set_cm_stack_id();

    MSG_HIGH_DS_0(REG_SUB, "=REG= CM_STOP_MODE_CNF - Sending Buffered");
    reg_send_message(&msg, GS_QUEUE_CM);
    reg_as_id = reg_cs_stack_id;
    reg_send_sglte_main_stop_cnf_pending = FALSE;
  }
#endif 

}



/*==============================================================================

FUNCTION NAME

  reg_send_cm_ph_status_chgd_cnf

==============================================================================*/

void reg_send_cm_ph_status_chgd_cnf
(
  reg_cm_transaction_id_type      transaction_id,
  sys_ph_status_chgd_status_e_type status
)
{
  cm_ph_status_chgd_cnf_s_type msg;
  memset(&msg,0x00,sizeof(cm_ph_status_chgd_cnf_s_type));

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_PH_STATUS_CHGD_CNF;
  msg.message_header.message_len_lsb =
    (sizeof(cm_ph_status_chgd_cnf_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_ph_status_chgd_cnf_s_type) - sizeof(IMH_T)) / 256;

  msg.transaction_id = transaction_id;
  msg.ph_status_chgd_status = status;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_PH_STATUS_CHGD_CNF");
  reg_send_message(&msg, GS_QUEUE_CM);
}


#ifdef FEATURE_GW_ON_DEMAND_HPLMN_SRCH
/*==============================================================================

FUNCTION NAME

  reg_send_cm_hplmn_search_cnf

==============================================================================*/

void reg_send_cm_hplmn_search_cnf
(
  boolean                         search_initiated
)
{
  cm_hplmn_search_cnf_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_HPLMN_SEARCH_CNF;
  msg.message_header.message_len_lsb =
    (sizeof(cm_stop_mode_cnf_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_stop_mode_cnf_s_type) - sizeof(IMH_T)) / 256;

  msg.search_initiated = search_initiated;

  msg.as_id = reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_1(REG_SUB, "=REG= CM_HPLMN_SEARCH_CNF - %d", search_initiated);
  reg_send_message(&msg, GS_QUEUE_CM);
}
#endif

#ifdef FEATURE_NAS_GW
#if defined FEATURE_MMCP_EGPRS || defined FEATURE_GSM_DTM || defined FEATURE_HSDPA
/*==============================================================================

FUNCTION NAME

  reg_send_cm_cell_service_ind

==============================================================================*/
void reg_send_cm_cell_service_ind
(
  cm_cell_service_ind_s_type* cell_service_ind
)
{
  cell_service_ind->message_header.message_set    = MS_CM_REG;
  cell_service_ind->message_header.message_id     = (byte)CM_CELL_SERVICES_IND;
  cell_service_ind->message_header.message_len_lsb = 
    (sizeof(cm_cell_service_ind_s_type) - sizeof(IMH_T)) % 256;
  cell_service_ind->message_header.message_len_msb =
    (sizeof(cm_cell_service_ind_s_type) - sizeof(IMH_T)) / 256;

  cell_service_ind->as_id = (sys_modem_as_id_e_type)reg_sub_id;
  cell_service_ind->stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_CELL_SERVICE_IND");
  reg_send_message(cell_service_ind, GS_QUEUE_CM);
}
#endif
#endif
#ifdef FEATURE_HSPA_CALL_STATUS_IND
/*==============================================================================

FUNCTION NAME

  reg_send_cm_hspa_call_status_ind

==============================================================================*/
void reg_send_cm_hspa_call_status_ind
(
  cm_hspa_call_status_ind_s_type* call_status_ind
)
{
  call_status_ind->message_header.message_set    = MS_CM_REG;
  call_status_ind->message_header.message_id     = (byte)CM_HSPA_CALL_STATUS_IND;
  call_status_ind->message_header.message_len_lsb =
    (sizeof(cm_hspa_call_status_ind_s_type) - sizeof(IMH_T)) % 256;
  call_status_ind->message_header.message_len_msb =
    (sizeof(cm_hspa_call_status_ind_s_type) - sizeof(IMH_T)) / 256;

  call_status_ind->as_id = (sys_modem_as_id_e_type)reg_sub_id;
  call_status_ind->stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_HSPA_CALL_STATUS_IND");
  reg_send_message(call_status_ind, GS_QUEUE_CM);
}
#endif

#ifdef FEATURE_OOSC_SERVICE_STATUS_UI_UPDATE
/*==============================================================================

FUNCTION NAME

  reg_send_cm_cm_conn_mode_ss_ind

==============================================================================*/
void reg_send_cm_conn_mode_ss_ind
(
  cm_conn_mode_ss_ind_s_type* conn_mode_ss_ind
)
{
  conn_mode_ss_ind->message_header.message_set    = MS_CM_REG;
  conn_mode_ss_ind->message_header.message_id     = (byte)CM_CONN_MODE_SERVICE_STATUS_IND;
  conn_mode_ss_ind->message_header.message_len_lsb =
    (sizeof(cm_conn_mode_ss_ind_s_type) - sizeof(IMH_T)) % 256;
  conn_mode_ss_ind->message_header.message_len_msb =
    (sizeof(cm_conn_mode_ss_ind_s_type) - sizeof(IMH_T)) / 256;

  conn_mode_ss_ind->as_id = (sys_modem_as_id_e_type)reg_sub_id;
  conn_mode_ss_ind->stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_CONN_MODE_SS_IND");
  reg_send_message(conn_mode_ss_ind, GS_QUEUE_CM);
}
#endif

/*==============================================================================

FUNCTION NAME

  reg_send_cm_reg_reject_ind

==============================================================================*/

void reg_send_cm_reg_reject_ind
(
  sys_srv_domain_e_type      reject_domain,
  byte                       reject_cause,
  sys_plmn_id_s_type  plmn,
  sys_lac_type        tac
#ifdef FEATURE_FEMTO_CSG
  , sys_csg_id_type    csg_id
#endif 
  ,sys_radio_access_tech_e_type  rat
)
{
  cm_reg_reject_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_REG_REJECT_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_reg_reject_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_reg_reject_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.reject_domain = reject_domain;
  msg.reject_cause = reject_cause;
  msg.plmn = plmn;
  msg.tac  = tac;
  msg.ciot_lte_mode = SYS_SYS_MODE_NONE;
#ifdef FEATURE_CIOT
        if(reg_state_is_active_rat_lte(rat))
        {
            msg.rat              = SYS_RAT_LTE_RADIO_ACCESS;
            msg.ciot_lte_mode    = reg_mode_convert_access_tech_to_acq_mode(rat);
        }
        else
#endif
       {
            msg.rat = rat;
       }

  
#ifdef FEATURE_FEMTO_CSG
  msg.csg_id = csg_id;
#endif 

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_REG_REJECT_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

#ifdef FEATURE_NAS_GW
/*==============================================================================

FUNCTION NAME

  reg_send_cm_cell_access_ind

==============================================================================*/
void reg_send_cm_cell_access_ind(sys_domain_access_bar_s_type cell_access_status)
{
  cm_cell_access_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_CELL_ACCESS_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_cell_access_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_cell_access_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.cell_access_status = cell_access_status;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();
 
  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_CELL_ACCESS_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}
#endif 
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_plmn_search_req

==============================================================================*/

void reg_send_mmr_plmn_search_req
(
  sys_network_selection_mode_e_type         network_selection_mode,
  boolean                                   dual_mode,
  sys_radio_access_tech_e_type              rat 
#ifdef FEATURE_GSM_BAND_PREF
  ,sys_band_mask_type                       band_pref
#endif
#if defined(FEATURE_GTOW_BACKGROUND_PLMN_SEARCH) || defined(FEATURE_RAT_PRIORITY_LIST)
  ,const sys_plmn_rat_list_s_type*          higher_priority_plmn_list_p
#endif
#if defined(FEATURE_UMTS_BACKGROUND_FULL_SERVICE_SEARCH) || defined(FEATURE_LTE)
  ,sys_service_search_e_type                 service_search
#endif
#ifdef FEATURE_FEMTO_CSG
  ,sys_csg_search_type_e_type             csg_search_type
#endif
#ifdef FEATURE_RAT_PRIORITY_LIST
  ,const sys_rat_pri_list_info_s_type  *rat_pri_list_info
  ,const sys_rat_pri_list_info_s_type   *mcc_mode_band_filter 	
#endif
  ,sys_scan_scope_e_type   scan_scope                  
  ,uint8 num_cells                 
#ifdef FEATURE_GPS_WWAN_PRIORITY_SEARCH	
  ,sys_wwan_adavnce_scan_pram_s_type*     gps_wwan_search_info
#endif
)
{
  mmr_plmn_search_req_s_type *msg = NULL;
#ifdef FEATURE_MODEM_HEAP
      msg = (mmr_plmn_search_req_s_type *)modem_mem_alloc(sizeof(mmr_plmn_search_req_s_type), MODEM_MEM_CLIENT_NAS);
#else
      msg = (mmr_plmn_search_req_s_type *)gs_alloc(sizeof(mmr_plmn_search_req_s_type));
#endif
  reg_check_for_null_ptr((void*)msg );

  memset(msg,0,sizeof(mmr_plmn_search_req_s_type));    

  msg->message_header.message_set     = MS_MM_REG;
  msg->message_header.message_id      = (byte)MMR_PLMN_SEARCH_REQ;
  msg->message_header.message_len_lsb =
    (sizeof( mmr_plmn_search_req_s_type ) - sizeof(IMH_T)) % 256;
  msg->message_header.message_len_msb =
    (sizeof( mmr_plmn_search_req_s_type ) - sizeof(IMH_T)) / 256;

  msg->network_selection_mode = network_selection_mode;
  msg->dual_mode              = dual_mode;
  msg->rat                    = rat;
  msg->transaction_id         = reg_state_plmn_search_transaction_id_set();
#ifdef FEATURE_GPS_WWAN_PRIORITY_SEARCH	  
 if(gps_wwan_search_info != NULL)
 {
  msg->gps_wwan_search_info   = *gps_wwan_search_info;
 }
#endif
#ifdef FEATURE_GSM_BAND_PREF
  msg->band_pref              = band_pref;
#endif
  msg->cell_search_num_cells = num_cells;
#if defined(FEATURE_GTOW_BACKGROUND_PLMN_SEARCH) || defined(FEATURE_RAT_PRIORITY_LIST)
  msg->higher_priority_plmn_list = *higher_priority_plmn_list_p;
#endif
#if defined(FEATURE_UMTS_BACKGROUND_FULL_SERVICE_SEARCH) || defined(FEATURE_LTE)
  msg->service_search         = service_search;
  MSG_HIGH_DS_1(REG_SUB, "=REG= SERVICE_SEARCH TYPE %d", msg->service_search);
#endif

  if( scan_scope == SYS_SCAN_SCOPE_ACQ_DB)
  {
    msg->scan_scope             = SYS_SCAN_SCOPE_ACQ_DB;              
  }
  else
  {
    msg->scan_scope             = SYS_SCAN_SCOPE_FULL_BAND;
  }
 


#ifdef FEATURE_FEMTO_CSG
  msg->csg_search_type = csg_search_type;
  MSG_HIGH_DS_1(REG_SUB, "=REG= CSG SEARCH TYPE %d", csg_search_type);
#endif
#ifdef FEATURE_RAT_PRIORITY_LIST
  memscpy(&msg->rat_pri_list_info, sizeof(sys_rat_pri_list_info_s_type), rat_pri_list_info, sizeof(sys_rat_pri_list_info_s_type));
#ifdef FEATURE_CIOT
/* NAS needs to send only information for the selected RAT*/
  reg_send_remove_other_rats (&msg->rat_pri_list_info, rat, TRUE);
#endif
  if(mcc_mode_band_filter)
  {
     memscpy(&msg->mcc_mode_band_filter, sizeof(sys_rat_pri_list_info_s_type), mcc_mode_band_filter, sizeof(sys_rat_pri_list_info_s_type)); 
#ifdef FEATURE_CIOT
    /* NAS needs to send only information for the selected RAT*/
    reg_send_remove_other_rats (&msg->mcc_mode_band_filter, rat, TRUE);
#endif
     MSG_HIGH_DS_1( REG_SUB, "=REG= BST changes length of mcc mode filter =%d",
                                       msg->mcc_mode_band_filter.num_items);
  }
#endif

  switch (rat)
  {
    case SYS_RAT_GSM_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_PLMN_SEARCH_REQ RAT(GSM) TI (%d) scan scope %d ", msg->transaction_id,scan_scope);
      break;

    case SYS_RAT_UMTS_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_PLMN_SEARCH_REQ RAT(UMTS) TI (%d) scan scope %d", msg->transaction_id,scan_scope);
      break;

    case SYS_RAT_TDS_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_PLMN_SEARCH_REQ RAT(TDSCDMA) TI (%d) scan scope %d", msg->transaction_id,scan_scope);
      break;
#ifdef FEATURE_LTE
    case SYS_RAT_LTE_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_PLMN_SEARCH_REQ RAT(LTE) TI (%d) scan scope %d", msg->transaction_id,scan_scope);
      break;
    case SYS_RAT_LTE_M1_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_PLMN_SEARCH_REQ RAT(LTE_M1) TI (%d) scan scope %d", msg->transaction_id,scan_scope);
      break;
    case SYS_RAT_LTE_NB1_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_PLMN_SEARCH_REQ RAT(LTE_NB1) TI (%d) scan scope %d", msg->transaction_id,scan_scope);
      break;
#endif
    default:
      MSG_ERROR_DS_2(REG_SUB, "=REG= MMR_PLMN_SEARCH_REQ RAT(UNKNOWN) TI (%d) scan scope %d", msg->transaction_id,scan_scope);
      break;
  }
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg->as_id = (sys_modem_as_id_e_type)reg_as_id;
#endif

  reg_send_message(msg, GS_QUEUE_MM );
#ifndef FEATURE_MODEM_HEAP
   gs_free(msg);
#else
   modem_mem_free(msg, MODEM_MEM_CLIENT_NAS);
#endif
  msg = NULL;
}


/*==============================================================================

FUNCTION NAME

  reg_send_mmr_reg_req

==============================================================================*/

void reg_send_mmr_reg_req
(
  sys_network_selection_mode_e_type         network_selection_mode,
  sys_plmn_id_s_type                        plmn,
  sys_srv_domain_e_type                     req_service_domain,
  sys_mode_pref_e_type                      mode_pref,
  boolean                                   cs_for_request,
  boolean                                   ps_for_request,
  sys_radio_access_tech_e_type              rat
#ifdef FEATURE_GSM_BAND_PREF
  ,sys_band_mask_type                        band_pref
#endif
#ifdef FEATURE_RAT_PRIORITY_LIST
  ,const sys_rat_pri_list_info_s_type  *rat_pri_list_info
#endif
  ,mmr_reg_req_e_type              type
#ifdef FEATURE_LTE
  , boolean sms_only,
    uint32  additional_info
#endif
#ifdef FEATURE_FEMTO_CSG
  ,sys_csg_id_type    csg_id
#endif 
  ,mmr_reg_interlace_scan_s_type             scan_info  //FRACQ
)
{
#ifdef FEATURE_LTE
  rex_timer_cnt_type max_timer_count = 0;
  sys_block_plmn_cause_e_type cause = SYS_BLOCK_PLMN_CAUSE_NONE;
#endif
  reg_send_mmr_reg_req_msg.message_header.message_set     = MS_MM_REG;
  reg_send_mmr_reg_req_msg.message_header.message_id      = (byte)MMR_REG_REQ;
  reg_send_mmr_reg_req_msg.message_header.message_len_lsb =
    (sizeof(mmr_reg_req_s_type) - sizeof(IMH_T)) % 256;
  reg_send_mmr_reg_req_msg.message_header.message_len_msb =
    (sizeof(mmr_reg_req_s_type) - sizeof(IMH_T)) / 256;

  reg_send_mmr_reg_req_msg.network_selection_mode = network_selection_mode;
#ifdef FEATURE_LTE
  if(reg_sim_plmn_rat_forbidden(plmn,rat,(sys_modem_as_id_e_type)reg_sub_id) &&
     (network_selection_mode != SYS_NETWORK_SELECTION_MODE_MANUAL 
#ifdef FEATURE_LTE_REL9
      &&
      network_selection_mode != SYS_NETWORK_SELECTION_MODE_LIMITED
#endif
     ))
  {
    sys_plmn_undefine_plmn_id(&plmn);
  }
#endif
  reg_send_mmr_reg_req_msg.plmn                   = plmn;
  reg_send_mmr_reg_req_msg.req_service_domain     = req_service_domain;
#ifndef FEATURE_RAT_PRIORITY_LIST  
  reg_send_mmr_reg_req_msg.dual_mode              = (boolean)(
    (mode_pref == SYS_MODE_PREF_GSM_RADIO_ACCESS_PREFERRED) ||
    (mode_pref == SYS_MODE_PREF_UMTS_RADIO_ACCESS_PREFERRED) );
#else
  reg_send_mmr_reg_req_msg.dual_mode = 
    (reg_mode_is_rat_present_in_rat_pri_list(SYS_RAT_GSM_RADIO_ACCESS, rat_pri_list_info, FALSE))&&
    ((reg_mode_is_rat_present_in_rat_pri_list(SYS_RAT_UMTS_RADIO_ACCESS, rat_pri_list_info, FALSE) ||
    (reg_mode_is_rat_present_in_rat_pri_list(SYS_RAT_TDS_RADIO_ACCESS, rat_pri_list_info, FALSE)))
);
#endif 
  reg_send_mmr_reg_req_msg.rat                    = rat;
#ifdef FEATURE_SGLTE
  if (REG_SGLTE_DUAL_STACK && type != MMR_REG_REQ_SGLTE_PSTIMER_EXPIRY && 
      (reg_as_id == reg_ps_stack_id) &&
       rat == SYS_RAT_GSM_RADIO_ACCESS)
  {            
    MSG_ERROR_DS_0(REG_SUB,"=REG= initial rat is set to GSM on PS stack in dual stack mode -- ERROR");
  }
#endif
  if(type == MMR_REG_REQ_SGLTE_PS_ONLY_ACQUISITION)         
  {
    reg_send_mmr_reg_req_msg.is_split_needed = TRUE;
    reg_send_mmr_reg_req_msg.type = reg_mode_convert_cm_req_type_to_mm(reg_state_get_last_cm_service_req_type(), network_selection_mode);
  }
  else
  {
    reg_send_mmr_reg_req_msg.type = type;
    reg_send_mmr_reg_req_msg.is_split_needed = FALSE;
  }
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  reg_send_mmr_reg_req_msg.as_id = (sys_modem_as_id_e_type)reg_as_id;
#endif

  reg_send_mmr_reg_req_msg.cs_for_request         = cs_for_request;

  reg_send_mmr_reg_req_msg.ps_for_request         = ps_for_request;

#ifdef FEATURE_GSM_BAND_PREF
  reg_send_mmr_reg_req_msg.band_pref              = band_pref;
#endif

#ifdef FEATURE_RAT_PRIORITY_LIST
  memscpy(&reg_send_mmr_reg_req_msg.rat_pri_list_info, sizeof(sys_rat_pri_list_info_s_type), 
                                        rat_pri_list_info, sizeof(sys_rat_pri_list_info_s_type));
  memscpy(&reg_send_mmr_reg_req_msg.original_rat_pri_list_info, sizeof(sys_rat_pri_list_info_s_type), 
                                        reg_mode_rat_pri_list_get(), sizeof(sys_rat_pri_list_info_s_type));

#endif
#ifdef FEATURE_LTE
  /*
  ** For limited manual acquistion the PLMN ID sent in the REG request will be the valid Manual
  ** selected PLMN. In limited routine acquistion, REG should not disable LTE as we can camp
  ** on any PLMN.
  */
  if ((network_selection_mode != SYS_NETWORK_SELECTION_MODE_LIMITED) &&
      (network_selection_mode != SYS_NETWORK_SELECTION_MODE_LIMITED_ROUTINE_ACQUISITION) &&
      (network_selection_mode != SYS_NETWORK_SELECTION_MODE_LIMITED_MANUAL_ACQUISITION) &&      
	  (reg_state_is_active_rat_lte(rat) == FALSE) &&
      (reg_sim_plmn_rat_forbidden(plmn,SYS_RAT_LTE_RADIO_ACCESS,(sys_modem_as_id_e_type)reg_sub_id) ||
       reg_mode_check_eplmn_backoff_forbidden(&plmn,&max_timer_count,&cause,
                                              (sys_modem_as_id_e_type)reg_sub_id)))
  {    
    reg_mode_remove_rat_from_rat_pri_list_lte(&reg_send_mmr_reg_req_msg.rat_pri_list_info);
    MSG_HIGH_DS_0(REG_SUB, "=REG= Requested PLMN backoff forbidden, removing LTE from rat priority list");
  }
  reg_mode_curr_rat_pri_list_set(&reg_send_mmr_reg_req_msg.rat_pri_list_info);
#endif

#ifdef FEATURE_CIOT
  /* NAS needs to send only information for the selected RAT. But if GSM is present, it will be sent
     to EMM as well.
  */  
  reg_send_remove_other_rats (&reg_send_mmr_reg_req_msg.rat_pri_list_info, rat, FALSE);
  /* Now filter the unwanted bands out*/
  reg_send_remove_other_bands(&reg_send_mmr_reg_req_msg.rat_pri_list_info, plmn);  
  if ((rat == SYS_RAT_LTE_NB1_RADIO_ACCESS) || (rat == SYS_RAT_LTE_M1_RADIO_ACCESS) )
  {
     /* Determine if the MCC is home or roam */
     reg_mode_determine_mcc(plmn);
  }
#endif


#ifdef FEATURE_EOOS
  #error code not present
#endif

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
  #error code not present
#endif
  if ( rat == SYS_RAT_GSM_RADIO_ACCESS) reg_send_grat_scan_done_set(TRUE);
  reg_send_mmr_reg_req_msg.grat_scan_done = reg_send_grat_scan_done;
  MSG_HIGH_DS_1(REG_SUB, "=REG= grat_scan_status: %d", reg_send_mmr_reg_req_msg.grat_scan_done);

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  reg_send_mmr_reg_req_msg.mode_pref = reg_sim_mode_pref_sim[reg_as_id];
#endif
#ifdef FEATURE_LTE 
  reg_send_mmr_reg_req_msg.sms_only = sms_only;
  reg_send_mmr_reg_req_msg.lte_cs_domain_param = reg_mode_lte_cs_domain_param_get();
  reg_send_mmr_reg_req_msg.additional_info = additional_info;
#endif 
#ifdef FEATURE_FEMTO_CSG
  reg_send_mmr_reg_req_msg.csg_id  = csg_id;
#endif 
  reg_send_mmr_reg_req_msg.scan_info.new_scan  = scan_info.new_scan;
  reg_send_mmr_reg_req_msg.scan_info.use_timer = scan_info.use_timer;
  reg_send_mmr_reg_req_msg.scan_info.scan_time = scan_info.scan_time;
  reg_send_mmr_reg_req_msg.scan_info.nb1_acqdb_timer_status = scan_info.nb1_acqdb_timer_status;
  reg_send_mmr_reg_req_msg.scan_info.nb1_fullband_timer_status = scan_info.nb1_fullband_timer_status;
  MSG_HIGH_DS_5(REG_SUB, "=REG= Scan Info New scan %d, use_timer=%d, scan_time=%d, nb1_acqdb_timer_status=%d, nb1_fullband_timer_status = %d", 
                 scan_info.new_scan,scan_info.use_timer,
                 scan_info.scan_time, scan_info.nb1_acqdb_timer_status, scan_info.nb1_fullband_timer_status);
  
  //FRACQ
  reg_send_mmr_reg_req_msg.trm_timeout = reg_mode_trm_timeout_value_get(reg_send_mmr_reg_req_msg.rat);
  reg_send_mmr_reg_req_msg.scan_scope = reg_mode_scan_scope_get();             
  reg_send_last_mmr_reg_req();
  reg_state_camped_ind_received_set(FALSE);

  reg_send_mmr_reg_req_msg.csg_id = SYS_CSG_ID_INVALID;
#ifdef FEATURE_LTE 
  reg_mode_reset_addtnl_info(SYS_ADDTNL_INFO_FORCE_RADIO_CAP_UPDATE);
#endif 
}

void  reg_send_mmr_gstk_service(boolean service_available)
{
  mmr_gstk_service_ind_s_type reg_send_gstk_service;
  reg_send_gstk_service.message_header.message_set = MS_MM_REG;
  reg_send_gstk_service.message_header.message_id  = (byte)MMR_GSTK_SERVICE_IND;  
  reg_send_gstk_service.message_header.message_len_lsb =
    (sizeof(mmr_gstk_service_ind_s_type) - sizeof(IMH_T)) % 256;
  reg_send_gstk_service.message_header.message_len_msb =
    (sizeof(mmr_gstk_service_ind_s_type) - sizeof(IMH_T)) / 256;

  reg_send_gstk_service.service_available = service_available;
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  reg_send_gstk_service.as_id = (sys_modem_as_id_e_type)reg_as_id;
#endif
  reg_send_message(&reg_send_gstk_service, GS_QUEUE_MM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_last_mmr_reg_req_gsm_only

==============================================================================*/

void reg_send_last_mmr_reg_req_gsm_only
(
  void
)
{
  reg_send_mmr_reg_req_msg.dual_mode      = FALSE;
  reg_send_mmr_reg_req_msg.rat            = SYS_RAT_GSM_RADIO_ACCESS;

#ifdef FEATURE_UMTS_1X_HANDOVER_UMTSMSM
  #error code not present
#endif

  reg_mode_update_attempted_plmn_list
  (
    reg_send_mmr_reg_req_msg.plmn,
    reg_send_mmr_reg_req_msg.rat
  );

  reg_send_last_mmr_reg_req();
}

#ifdef FEATURE_HPLMN_NOT_ALLOWED_SELECT_NEXT
/*==============================================================================

FUNCTION NAME

  reg_send_last_mmr_reg_req_invalid_plmn

==============================================================================*/

void reg_send_last_mmr_reg_req_invalid_plmn
(
  void
)
{
  sys_plmn_undefine_plmn_id(&reg_send_mmr_reg_req_msg.plmn);

  reg_mode_req_plmn_set(reg_send_mmr_reg_req_msg.plmn);

  reg_send_last_mmr_reg_req();
}
#endif

/*==============================================================================
FUNCTION NAME

  reg_send_last_mmr_reg_req_new_type
==============================================================================*/
void reg_send_last_mmr_reg_req_new_type
(
  mmr_reg_req_e_type type
)
{

  reg_send_mmr_reg_req_msg.type = type;
  
  reg_send_last_mmr_reg_req();
}


#ifdef FEATURE_LTE
/*==============================================================================
FUNCTION NAME

  reg_send_mmr_reg_req_curr_rat_list
==============================================================================*/
void reg_send_mmr_reg_req_curr_rat_list
(
  void
)
{
  memscpy(&reg_send_mmr_reg_req_msg.rat_pri_list_info,sizeof(sys_rat_pri_list_info_s_type),
                      reg_mode_curr_rat_pri_list_get(),sizeof(sys_rat_pri_list_info_s_type));
  reg_send_mmr_reg_req_msg.plmn = reg_state_service_plmn_get();
  reg_send_mmr_reg_req_msg.rat = reg_state_active_rat_get();
  reg_mode_req_plmn_set(reg_send_mmr_reg_req_msg.plmn);
  reg_send_last_mmr_reg_req();
}
#endif

/*==============================================================================

FUNCTION NAME

  reg_send_last_mmr_reg_req

==============================================================================*/

void reg_send_last_mmr_reg_req
(
  void
)
{
  boolean plmn_id_is_undefined;
  boolean mnc_includes_pcs_digit;
  uint32  mcc;
  uint32  mnc;

  sys_plmn_get_mcc_mnc
  (
    reg_send_mmr_reg_req_msg.plmn,
    &plmn_id_is_undefined,
    &mnc_includes_pcs_digit,
    &mcc,
    &mnc
  );

  switch (reg_send_mmr_reg_req_msg.rat)
  {
    case SYS_RAT_GSM_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_REG_REQ PLMN(%u-%u) RAT(GSM)", mcc, mnc);
      break;
    case SYS_RAT_UMTS_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_REG_REQ PLMN(%u-%u) RAT(UMTS)", mcc, mnc);
      break;
    case SYS_RAT_TDS_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_REG_REQ PLMN(%u-%u) RAT(TDSCDMA)", mcc, mnc);
      break;
#ifdef FEATURE_LTE
    case SYS_RAT_LTE_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_REG_REQ PLMN(%u-%u) RAT(LTE)", mcc, mnc);
      break;
    case SYS_RAT_LTE_M1_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_REG_REQ PLMN(%u-%u) RAT(LTE_M1)", mcc, mnc);
      break;
    case SYS_RAT_LTE_NB1_RADIO_ACCESS:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_REG_REQ PLMN(%u-%u) RAT(LTE_NB1)", mcc, mnc);
      break;
#endif
    default:
      MSG_HIGH_DS_2(REG_SUB, "=REG= MMR_REG_REQ PLMN(%u-%u) RAT(UNKNOWN)", mcc, mnc);
      break;
  }

#ifdef FEATURE_SGLTE
   if(REG_SUB_IS_SGLTE)
   {

     if((( IS_UE_IN_SGLTE_STATE_4 &&
        reg_state_get_active_rat_per_subs((sys_modem_as_id_e_type)reg_as_id) == SYS_RAT_GSM_RADIO_ACCESS &&
        (reg_state_get_service_status_per_subs((sys_modem_as_id_e_type)reg_as_id)== SYS_SRV_STATUS_SRV)) ||
  	   IS_SGLTE_MERGE_IN_PROGRESS) &&
        (reg_send_mmr_reg_req_msg.rat == SYS_RAT_LTE_RADIO_ACCESS ||
         reg_send_mmr_reg_req_msg.rat == SYS_RAT_TDS_RADIO_ACCESS)&&
        (!IS_SGLTE_SPLIT_IN_PROGRESS)
      )
    {
      reg_send_mmr_reg_req_msg.type = reg_mode_convert_cm_req_type_to_mm(reg_state_get_last_cm_service_req_type(), reg_send_mmr_reg_req_msg.network_selection_mode);
      reg_send_mmr_reg_req_msg.is_split_needed = TRUE;
    }
    else
    {
      reg_send_mmr_reg_req_msg.is_split_needed = FALSE;
    }
  
  
    if(reg_sglte_mode &&
       (reg_send_mmr_reg_req_msg.rat == SYS_RAT_LTE_RADIO_ACCESS ||
         reg_send_mmr_reg_req_msg.rat == SYS_RAT_TDS_RADIO_ACCESS) &&
       (reg_send_mmr_reg_req_msg.req_service_domain != SYS_SRV_DOMAIN_PS_ONLY) )
    {
      reg_send_mmr_reg_req_msg.req_service_domain = SYS_SRV_DOMAIN_PS_ONLY;
    }
    if((REG_SGLTE_DUAL_STACK && (reg_as_id == reg_ps_stack_id) &&
        reg_send_mmr_reg_req_msg.type != MMR_REG_REQ_SGLTE_PSTIMER_EXPIRY && 
        reg_send_mmr_reg_req_msg.rat == SYS_RAT_GSM_RADIO_ACCESS))
    {
      MSG_FATAL_DS(REG_SUB, "=REG= Reg sending Service Request on GSM in SGLTE HOME Dual stack mode", 0, 0, 0);
    }

  }
#endif

  reg_send_mmr_reg_req_msg.scan_scope = reg_mode_scan_scope_get();

#ifdef FEATURE_FEMTO_CSG
  MSG_HIGH_DS_1(REG_SUB, "=REG=  CSG_ID = %d", reg_send_mmr_reg_req_msg.csg_id);

  reg_mode_req_csg_id_set(reg_send_mmr_reg_req_msg.csg_id);
  reg_send_nw_sel_mode_sent_to_mm = reg_send_mmr_reg_req_msg.network_selection_mode;

#endif 

#ifdef FEATURE_LTE
  reg_timers_stop_update_lte_cap_timer();
#endif

  if((mmr_reg_req_is_valid(&reg_send_mmr_reg_req_msg) == FALSE) ||
#ifdef FEATURE_RAT_PRIORITY_LIST
    (!reg_mode_is_rat_present_in_rat_pri_list(reg_send_mmr_reg_req_msg.rat,&reg_send_mmr_reg_req_msg.rat_pri_list_info,FALSE))
#else
    ((reg_send_mmr_reg_req_msg.dual_mode == FALSE) && (((reg_send_mmr_reg_req_msg.rat == SYS_RAT_GSM_RADIO_ACCESS) && (reg_send_mmr_reg_req_msg.mode_pref == SYS_MODE_PREF_UMTS_RADIO_ACCESS_ONLY)) ||
      ((reg_send_mmr_reg_req_msg.rat == SYS_RAT_UMTS_RADIO_ACCESS) && (reg_send_mmr_reg_req_msg.mode_pref == SYS_MODE_PREF_GSM_RADIO_ACCESS_ONLY))))
#endif
    )
  {
    MSG_FATAL_DS(REG_SUB, "=REG= Invalid MMR_REG_REQ",0,0,0);
  }

  reg_send_message(&reg_send_mmr_reg_req_msg, GS_QUEUE_MM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_mmr_sim_available_req

==============================================================================*/

void reg_send_mmr_sim_available_req
(
#if defined FEATURE_DUAL_SIM 
  sys_mode_pref_e_type dual_mode_pref,
  mmgsdi_client_id_type mmgsdi_client_id,
  mmgsdi_session_type_enum_type mmgsdi_session_type,
  uint8 nv_context_id
#else
  mmgsdi_client_id_type mmgsdi_client_id
#endif
)
{
  mmr_sim_available_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_SIM_AVAILABLE_REQ;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_sim_available_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_sim_available_req_s_type) - sizeof(IMH_T)) / 256;
  /*lint +e778 */
#ifdef FEATURE_DUAL_SIM
  msg.mode_pref       = dual_mode_pref;
  msg.nv_context_id   = nv_context_id;
  msg.mmgsdi_session_type    = mmgsdi_session_type;
#endif
#if defined(FEATURE_SGLTE) || defined(FEATURE_DUAL_SIM)
  msg.as_id = (sys_modem_as_id_e_type)reg_as_id;
#endif
  msg.mmgsdi_client_id    = mmgsdi_client_id;

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_SIM_AVAILABLE_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_mmr_sim_not_available_req

==============================================================================*/

void reg_send_mmr_sim_not_available_req
(
  void
)
{
  mmr_sim_not_available_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_SIM_NOT_AVAILABLE_REQ;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_sim_not_available_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_sim_not_available_req_s_type) - sizeof(IMH_T)) / 256;
  /*lint +e778 */
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id = (sys_modem_as_id_e_type)reg_as_id;
#endif

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_SIM_NOT_AVAILABLE_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_mmr_stop_mode_req

==============================================================================*/

void reg_send_mmr_stop_mode_req
(
  sys_stop_mode_reason_e_type     stop_mode_reason
)
{
  mmr_stop_mode_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_STOP_MODE_REQ;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_stop_mode_req_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_stop_mode_req_s_type ) - sizeof(IMH_T)) / 256;

  if(stop_mode_reason == SYS_STOP_MODE_REASON_NO_SYS)
  {
    msg.stop_mode_reason = SYS_STOP_MODE_REASON_MODE_CHANGE;
  }
  else
  {
    msg.stop_mode_reason = stop_mode_reason;
  }  
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id = (sys_modem_as_id_e_type)reg_as_id;
#endif

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_STOP_MODE_REQ");
  reg_send_message(&msg, GS_QUEUE_MM );
}

/*==============================================================================

FUNCTION NAME

  reg_send_mmr_eq_plmn_change_ind

==============================================================================*/

void reg_send_mmr_eq_plmn_change_ind
(
  void
)
{
  mmr_eq_plmn_change_ind_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_EQ_PLMN_CHANGE_IND;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_eq_plmn_change_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_eq_plmn_change_ind_s_type) - sizeof(IMH_T)) / 256;
  /*lint +e778 */
  
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_EQ_PLMN_CHANGE_IND");
  reg_send_message(&msg, GS_QUEUE_MM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_cm_plmn_list_change_ind

==============================================================================*/

void reg_send_cm_plmn_list_change_ind
(
  sys_plmn_list_type_e_type changed_list_type
)
{
  cm_plmn_list_change_ind_s_type msg;
  memset(&msg,0x00,sizeof(cm_plmn_list_change_ind_s_type));

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_PLMN_LIST_CHANGE_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_plmn_list_change_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_plmn_list_change_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.changed_list_type = changed_list_type;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;

  MSG_HIGH_DS_1(REG_SUB, "=REG= CM_PLMN_LIST_CHANGE_IND type %d", msg.changed_list_type );
  reg_send_message(&msg, GS_QUEUE_CM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_eq_plmn_change_ind

==============================================================================*/

void reg_send_eq_plmn_change_ind
(
  void
)
{
  reg_send_mmr_eq_plmn_change_ind();
  reg_send_cm_plmn_list_change_ind(SYS_PLMN_LIST_TYPE_EPLMN);
}


/*==============================================================================

FUNCTION NAME

  reg_send_mmr_plmn_search_abort_req

==============================================================================*/

void reg_send_mmr_plmn_search_abort_req
(
  void
)
{
  mmr_plmn_search_abort_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_PLMN_SEARCH_ABORT_REQ;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_plmn_search_abort_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_plmn_search_abort_req_s_type) - sizeof(IMH_T)) / 256;
  /*lint +e778 */

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  reg_last_recieved_list_req_type = REG_CM_NETWORK_LIST_NONE;
#ifdef FEATURE_GPS_WWAN_PRIORITY_SEARCH
  reg_state_is_stack_suspended = FALSE;
#endif

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_PLMN_SEARCH_ABORT_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}

/*==============================================================================

FUNCTION NAME

  reg_send_mmr_ph_status_chng_req

==============================================================================*/

void reg_send_mmr_ph_status_chng_req
(
  sys_stop_mode_reason_e_type     stop_mode_reason
)
{
  mmr_ph_status_change_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_PH_STATUS_CHANGE_REQ;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_ph_status_change_req_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_ph_status_change_req_s_type ) - sizeof(IMH_T)) / 256;

  msg.stop_mode_reason = stop_mode_reason;

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_PH_STATUS_CHANGE_REQ");
  reg_send_message(&msg, GS_QUEUE_MM );
}

#ifdef FEATURE_OOSC_USER_ACTION
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_exit_from_pwr_save

==============================================================================*/

void reg_send_mmr_exit_from_pwr_save
(
  void
)
{
  mmr_exit_from_pwr_save_s_type msg;
  
  msg.message_header.message_set         = MS_MM_REG;
  msg.message_header.message_id          = (byte)MMR_EXIT_FROM_PWR_SAVE;
  msg.message_header.message_len_lsb     =
    (sizeof( mmr_exit_from_pwr_save_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb     =
    (sizeof( mmr_exit_from_pwr_save_s_type ) - sizeof(IMH_T)) / 256;
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_EXIT_FROM_PWR_SAVE");
  reg_send_message(&msg, GS_QUEUE_MM );
}

#endif

#ifdef FEATURE_DUAL_SIM
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_ds_stat_chgd_req

==============================================================================*/

void reg_send_mmr_ds_stat_chgd_req
(
  boolean                         dual_standby_mode,
  sys_modem_dual_standby_pref_e_type dual_standby_mode_info,
  sys_modem_device_mode_e_type    device_mode
)
{
  mmr_ds_stat_chgd_req_s_type msg;

  msg.message_header.message_set         = MS_MM_REG;
  msg.message_header.message_id          = (byte)MMR_DS_STAT_CHGD_REQ;
  msg.message_header.message_len_lsb     =
    (sizeof( mmr_ds_stat_chgd_req_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb     =
    (sizeof( mmr_ds_stat_chgd_req_s_type ) - sizeof(IMH_T)) / 256;
  msg.dual_standby_mode = dual_standby_mode;
  msg.dual_standby_mode_info = dual_standby_mode_info;
  msg.device_mode = device_mode;
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_DS_STAT_CHGD_REQ");
  reg_send_message(&msg, GS_QUEUE_MM );
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_ds_stat_chgd_cnf

==============================================================================*/

void reg_send_cm_ds_stat_chgd_cnf
(
  reg_cm_transaction_id_type      transaction_id
)
{
  cm_ds_stat_chgd_cnf_s_type msg;

  msg.message_header.message_set         = MS_CM_REG;
  msg.message_header.message_id          = (byte)CM_DS_STAT_CHGD_CNF;
  msg.message_header.message_len_lsb     =
    (sizeof( cm_ds_stat_chgd_cnf_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb     =
    (sizeof( cm_ds_stat_chgd_cnf_s_type ) - sizeof(IMH_T)) / 256;
  msg.transaction_id = transaction_id;

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_DS_STAT_CHGD_CNF");
  reg_send_message(&msg, GS_QUEUE_CM );
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_multimode_subs_chgd_cnf

==============================================================================*/
void reg_send_cm_multimode_subs_chgd_cnf
(
  void
)
{
  cm_multimode_subs_chgd_cnf_s_type msg;

  msg.message_header.message_set         = MS_CM_REG;
  msg.message_header.message_id          = (byte)CM_MULTIMODE_SUBS_CHGD_CNF;
  msg.message_header.message_len_lsb     =
    (sizeof( cm_multimode_subs_chgd_cnf_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb     =
    (sizeof( cm_multimode_subs_chgd_cnf_s_type ) - sizeof(IMH_T)) / 256;

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_MULTIMODE_SUBS_CHGD_CNF");
  reg_send_message(&msg, GS_QUEUE_CM );
}
#endif

#if defined(FEATURE_DUAL_SIM)
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_ds_tuneaway_status_change_ind

==============================================================================*/

void reg_send_mmr_ds_tuneaway_status_change_ind
(
  const boolean                         tuneaway_status
)
{
  mmr_ds_tuneaway_status_change_ind_s_type msg;

  msg.message_header.message_set         = MS_MM_REG;
  msg.message_header.message_id          = (byte)MMR_DS_TUNEAWAY_STATUS_CHANGE_IND;
  msg.message_header.message_len_lsb     =
    (sizeof( mmr_ds_tuneaway_status_change_ind_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb     =
    (sizeof( mmr_ds_tuneaway_status_change_ind_s_type ) - sizeof(IMH_T)) / 256;
  msg.tuneaway_status = tuneaway_status;

  MSG_HIGH_DS_1(REG_SUB, "=REG= MMR_DS_TUNEAWAY_STATUS_CHANGE_IND tuneway status %d", tuneaway_status);
  reg_send_message(&msg, GS_QUEUE_MM );
}
#endif

#if defined(FEATURE_LTE) || defined(FEATURE_WRLF_SYSTEM_SEL)
void reg_send_cm_suitable_search_end_ind
(
  void
)
{
  cm_suitable_search_end_ind_s_type suitable_search_end_ind;
  
  suitable_search_end_ind.message_header.message_set     = MS_CM_REG;
  suitable_search_end_ind.message_header.message_id      = (byte)CM_SUITABLE_SEARCH_END_IND;
  suitable_search_end_ind.message_header.message_len_lsb =
         (sizeof(cm_suitable_search_end_ind_s_type) - sizeof(IMH_T)) % 256;
  suitable_search_end_ind.message_header.message_len_msb =
          (sizeof(cm_suitable_search_end_ind_s_type) - sizeof(IMH_T)) / 256;

  suitable_search_end_ind.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  suitable_search_end_ind.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_SUITABLE_SEARCH_END_IND");
  reg_send_message(&suitable_search_end_ind.message_header, GS_QUEUE_CM);
}
#endif

#if defined(FEATURE_WRLF_SYSTEM_SEL) && defined(FEATURE_NAS_GW) && !defined(FEATURE_NAS_CS_DISABLED)
void reg_send_cm_disable_bplmn_ind
(
  mmr_disable_bplmn_ind_s_type mmr_disable_bplmn_ind
)
{
  cm_disable_bplmn_ind_s_type disable_bplmn_ind;
  
  disable_bplmn_ind.message_header.message_set     = MS_CM_REG;
  disable_bplmn_ind.message_header.message_id      = (byte)CM_DISABLE_BPLMN_IND;
  disable_bplmn_ind.status = mmr_disable_bplmn_ind.disable_status;
  disable_bplmn_ind.message_header.message_len_lsb =
         (sizeof(cm_disable_bplmn_ind_s_type) - sizeof(IMH_T)) % 256;
  disable_bplmn_ind.message_header.message_len_msb =
          (sizeof(cm_disable_bplmn_ind_s_type) - sizeof(IMH_T)) / 256;

  disable_bplmn_ind.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  disable_bplmn_ind.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_DISABLE_BPLMN_IND");
  reg_send_message(&disable_bplmn_ind.message_header, GS_QUEUE_CM);
}
#endif 

#ifdef FEATURE_NAS_ECALL
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_ecall_mode_ind

==============================================================================*/
void reg_send_mmr_ecall_mode_ind
(
 mmr_ecall_mode_e_type mode_type
)
{
  mmr_ecall_mode_ind_s_type msg;
  
  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_ECALL_MODE_IND;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_ecall_mode_ind_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_ecall_mode_ind_s_type ) - sizeof(IMH_T)) / 256;

  msg.mode_type = mode_type;
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_ECALL_MODE_IND");
  reg_send_message(&msg, GS_QUEUE_MM );
}

/*==============================================================================

FUNCTION NAME

  reg_send_mmr_profile_type_ind

==============================================================================*/
void reg_send_mmr_profile_type_ind
(
  mmgsdi_profile_type_enum_type profile_type
)
{
  mmr_profile_type_ind_s_type msg;
  
  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_PROFILE_TYPE_IND;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_ecall_mode_ind_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_ecall_mode_ind_s_type ) - sizeof(IMH_T)) / 256;

  msg.profile_type = profile_type;
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_PROFILE_TYPE_IND");
  reg_send_message(&msg, GS_QUEUE_MM );
}
#endif /*FEATURE_NAS_ECALL*/

#ifdef FEATURE_FEMTO_CSG
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_ecall_mode_ind

==============================================================================*/
void reg_send_mmr_file_refresh_ind
(
  mmgsdi_file_enum_type file_name
)
{
  mmr_file_refresh_ind_s_type msg;
  
  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_FILE_REFRESH_IND;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_file_refresh_ind_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_file_refresh_ind_s_type ) - sizeof(IMH_T)) / 256;

  msg.file_name= file_name;
  
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_FILE_REFRESH_IND");
  reg_send_message(&msg, GS_QUEUE_MM );

}

#if defined(FEATURE_LTE) && defined(FEATURE_FEMTO_CSG)
/*==============================================================================

FUNCTION NAME

  reg_send_cm_home_nodeb_name_ind

==============================================================================*/
void reg_send_cm_home_nodeb_name_ind
(
  mmr_home_nodeb_name_ind_s_type *home_nodeb_name
)
{
  cm_home_nodeb_name_ind_s_type hnb_name_ind;

  hnb_name_ind.message_header.message_set     = MS_CM_REG;
  hnb_name_ind.message_header.message_id      = (byte)CM_HOME_NODEB_NAME_IND;
  hnb_name_ind.message_header.message_len_lsb =
         (sizeof(cm_home_nodeb_name_ind_s_type) - sizeof(IMH_T)) % 256;
  hnb_name_ind.message_header.message_len_msb =
          (sizeof(cm_home_nodeb_name_ind_s_type) - sizeof(IMH_T)) / 256;

  hnb_name_ind.csg_info = home_nodeb_name->csg_info;
  hnb_name_ind.plmn = home_nodeb_name->plmn;

  hnb_name_ind.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  hnb_name_ind.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_HOME_NODEB_NAME_IND");
  reg_send_message(&hnb_name_ind.message_header, GS_QUEUE_CM);
}
#endif /*FEATURE_LTE*/

#endif 

#ifdef FEATURE_LTE
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_ps_detach_req

==============================================================================*/
void reg_send_mmr_ps_detach_req
(
 const sys_ps_detach_e_type  detach_type
)
{
  mmr_ps_detach_req_s_type msg;
  
  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_PS_DETACH_REQ;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_ps_detach_req_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_ps_detach_req_s_type ) - sizeof(IMH_T)) / 256;

  msg.detach_type = detach_type;

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_PS_DETACH_REQ");
  reg_send_message(&msg, GS_QUEUE_MM );
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_ps_detach_cnf

==============================================================================*/
void reg_send_cm_ps_detach_cnf()
{
  cm_ps_detach_cnf_s_type ps_detach_cnf;
  
  ps_detach_cnf.message_header.message_set     = MS_CM_REG;
  ps_detach_cnf.message_header.message_id      = (byte)CM_PS_DETACH_CNF;
  ps_detach_cnf.message_header.message_len_lsb =
         (sizeof(cm_ps_detach_cnf_s_type) - sizeof(IMH_T)) % 256;
  ps_detach_cnf.message_header.message_len_msb =
          (sizeof(cm_ps_detach_cnf_s_type) - sizeof(IMH_T)) / 256;

  ps_detach_cnf.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  ps_detach_cnf.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_PS_DETACH_CNF");
  reg_send_message(&ps_detach_cnf.message_header, GS_QUEUE_CM);
}

#ifdef FEATURE_LTE_TO_1X
/*==============================================================================

FUNCTION NAME

  reg_send_cm_fplmn_list_ind

==============================================================================*/

void reg_send_cm_fplmn_list_ind
(
  sys_forbidden_list_type_e_type   list_type
)
{
  cm_fplmn_list_ind_s_type *msg = NULL;
  reg_sim_plmn_list_s_type  plmn_list;
  uint32              i;

#ifdef FEATURE_MODEM_HEAP
  msg = (cm_fplmn_list_ind_s_type *)modem_mem_alloc(sizeof(cm_fplmn_list_ind_s_type), MODEM_MEM_CLIENT_NAS);
#else
  msg = (cm_fplmn_list_ind_s_type *)gs_alloc(sizeof(cm_fplmn_list_ind_s_type));
#endif

  reg_check_for_null_ptr((void*)msg );
  msg->message_header.message_set     = MS_CM_REG;
  msg->message_header.message_id      = (byte)CM_FPLMN_LIST_IND;
  msg->message_header.message_len_lsb =
    (sizeof(cm_fplmn_list_ind_s_type) - sizeof(IMH_T)) % 256;
  msg->message_header.message_len_msb =
    (sizeof(cm_fplmn_list_ind_s_type) - sizeof(IMH_T)) / 256;

  msg->list_type = list_type;

  switch (list_type)
  {
     case SYS_FORBIDDEN_LIST_TYPE_FPLMN:
#ifdef FEATURE_DUAL_SIM
         reg_sim_read_fplmn_list(&plmn_list,TRUE,(sys_modem_as_id_e_type)reg_sub_id);
#else
         reg_sim_read_fplmn_list(&plmn_list, TRUE);
#endif
         msg->plmn_list.fplmn_list.length = MIN(plmn_list.length, SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH);
         memscpy((void *)&msg->plmn_list.fplmn_list.plmn[0], sizeof(msg->plmn_list.fplmn_list.plmn), (void*)&plmn_list.plmn[0], plmn_list.length*sizeof(sys_plmn_id_s_type));
         break;

     case SYS_FORBIDDEN_LIST_TYPE_GPRS_FPLMN:
         msg->plmn_list.plmn_list.length = MIN(reg_sim_gprs_fplmn_list.length, SYS_PLMN_LIST_MAX_LENGTH);
         for(i = 0; i < msg->plmn_list.plmn_list.length ; i++)
         {
            if (reg_sim_gprs_fplmn_list.plmn_info[i].is_forbidden == TRUE)
            {
              msg->plmn_list.plmn_list.plmn[i] = reg_sim_gprs_fplmn_list.plmn_info[i].plmn;
            }
         }
         break;

     case SYS_FORBIDDEN_LIST_TYPE_LTE_BACKOFF_FPLMN:
        rex_enter_crit_sect(&reg_backoff_fplmn_crit_sect);
        msg->plmn_list.plmn_list.length = MIN(reg_sim_backoff_fplmn_list.length, REG_SIM_BACKOFF_FPLMN_LIST_LENGTH);
        for(i = 0; i < msg->plmn_list.plmn_list.length ; i++)
        {
           msg->plmn_list.plmn_list.plmn[i] = reg_sim_backoff_fplmn_list.plmn_timer_list[i].plmn;
        }
         rex_leave_crit_sect(&reg_backoff_fplmn_crit_sect);
        break;

     default:
        MSG_HIGH_DS_1(REG_SUB, "=REG= Forbidden list type = %d", list_type);
        break;
  }

  msg->as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg->stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_FPLMN_LIST_IND");
  reg_send_message(msg, GS_QUEUE_CM);
#ifndef FEATURE_MODEM_HEAP
   gs_free(msg);
#else
   modem_mem_free(msg, MODEM_MEM_CLIENT_NAS);
#endif
  msg = NULL;

}
#endif 

#ifdef DISABLE_9x05_OPTIMIZATIONS

/*==============================================================================

FUNCTION NAME

  reg_send_cm_set_drx_cnf

==============================================================================*/
void reg_send_cm_set_drx_cnf
(
  boolean result
)
{
  cm_set_drx_cnf_s_type set_drx_cnf;

  set_drx_cnf.message_header.message_set     = MS_CM_REG;
  set_drx_cnf.message_header.message_id      = (byte)CM_SET_DRX_CNF;
  set_drx_cnf.message_header.message_len_lsb =
         (sizeof(cm_set_drx_cnf_s_type) - sizeof(IMH_T)) % 256;
  set_drx_cnf.message_header.message_len_msb =
          (sizeof(cm_set_drx_cnf_s_type) - sizeof(IMH_T)) / 256;

  set_drx_cnf.result = result;
  set_drx_cnf.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  set_drx_cnf.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_SET_DRX_CNF");
  reg_send_message(&set_drx_cnf.message_header, GS_QUEUE_CM);
}

/*==============================================================================

FUNCTION NAME

  reg_send_mmr_set_drx_req

==============================================================================*/
void reg_send_mmr_set_drx_req
(
 const sys_drx_cn_coefficient_s1_e_type drx_coefficient
)
{
  mmr_set_drx_req_s_type msg;
  
  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_SET_DRX_REQ;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_set_drx_req_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_set_drx_req_s_type ) - sizeof(IMH_T)) / 256;

  msg.drx_coefficient = drx_coefficient;
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_SET_DRX_REQ");
  reg_send_message(&msg, GS_QUEUE_MM );
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_get_drx_cnf

==============================================================================*/
void reg_send_cm_get_drx_cnf
(
  const sys_drx_cn_coefficient_s1_e_type drx_coefficient
)
{
  cm_get_drx_cnf_s_type get_drx_cnf;

  get_drx_cnf.message_header.message_set     = MS_CM_REG;
  get_drx_cnf.message_header.message_id      = (byte)CM_GET_DRX_CNF;
  get_drx_cnf.message_header.message_len_lsb =
         (sizeof(cm_get_drx_cnf_s_type) - sizeof(IMH_T)) % 256;
  get_drx_cnf.message_header.message_len_msb =
          (sizeof(cm_get_drx_cnf_s_type) - sizeof(IMH_T)) / 256;

  get_drx_cnf.drx_coefficient = drx_coefficient;

  get_drx_cnf.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  get_drx_cnf.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_GET_DRX_CNF");
  reg_send_message(&get_drx_cnf, GS_QUEUE_CM);
}
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_get_drx_req

==============================================================================*/
void reg_send_mmr_get_drx_req
(
 void
)
{
  mmr_get_drx_req_s_type msg;
  
  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_GET_DRX_REQ;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_get_drx_req_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_get_drx_req_s_type ) - sizeof(IMH_T)) / 256;

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_GET_DRX_REQ");
  reg_send_message(&msg.message_header, GS_QUEUE_MM );
}
#endif

/*==============================================================================

FUNCTION NAME

  reg_send_mmr_block_plmn_req

==============================================================================*/

void reg_send_mmr_block_plmn_req
(
  sys_plmn_id_s_type        plmn,
  rex_timer_cnt_type        timer_count,
  boolean                   is_plmn_blocked_for_eplmn_check,
  sys_block_plmn_cause_e_type cause
)
{
  mmr_block_plmn_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_BLOCK_PLMN_REQ;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_block_plmn_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_block_plmn_req_s_type) - sizeof(IMH_T)) / 256;

  msg.plmn = plmn;
  msg.timer_count = timer_count;
  msg.is_plmn_blocked_for_eplmn_check = is_plmn_blocked_for_eplmn_check;
  msg.cause = cause;
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_BLOCK_PLMN_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}
#endif

/*==============================================================================

FUNCTION NAME

  reg_send_mmr_sim_state_update_ind

==============================================================================*/
void reg_send_mmr_sim_state_update_ind
(
 const sys_sim_state_e_type sim_state
)
{
  mmr_sim_state_update_ind_s_type msg;
  
  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_SIM_STATE_UPDATE_IND;
  msg.message_header.message_len_lsb =
    (sizeof( mmr_sim_state_update_ind_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof( mmr_sim_state_update_ind_s_type ) - sizeof(IMH_T)) / 256;

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif

  msg.sim_state = sim_state;
  
  MSG_HIGH_DS_1(REG_SUB, "=REG= MMR_SIM_STATE_UPDATE_IND sim_state %d", sim_state);
  reg_send_message(&msg, GS_QUEUE_MM );
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_sim_update_ind

==============================================================================*/
void reg_send_cm_sim_update_ind
(
  const sys_sim_state_e_type sim_state
)
{
  cm_sim_state_update_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_SIM_STATE_UPDATE_IND;
  msg.message_header.message_len_lsb =
         (sizeof(cm_sim_state_update_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
          (sizeof(cm_sim_state_update_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();

  msg.sim_state = sim_state;

  MSG_HIGH_DS_1(REG_SUB, "=REG= CM_SIM_STATE_UPDATE_IND sim_state %d", sim_state);
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_get_hplmn_search_timer_cnf

==============================================================================*/
void reg_send_cm_get_hplmn_search_timer_cnf
(
  uint32 timer_value
)
{
  cm_get_hplmn_search_timer_cnf_s_type get_hplmn_timer_cnf;

  get_hplmn_timer_cnf.message_header.message_set     = MS_CM_REG;
  get_hplmn_timer_cnf.message_header.message_id      = (byte)CM_GET_HPLMN_SEARCH_TIMER_CNF;
  get_hplmn_timer_cnf.message_header.message_len_lsb =
         (sizeof(cm_get_hplmn_search_timer_cnf_s_type) - sizeof(IMH_T)) % 256;
  get_hplmn_timer_cnf.message_header.message_len_msb =
          (sizeof(cm_get_hplmn_search_timer_cnf_s_type) - sizeof(IMH_T)) / 256;

  get_hplmn_timer_cnf.timer_value = timer_value;

  get_hplmn_timer_cnf.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  get_hplmn_timer_cnf.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_GET_HPLMN_SEARCH_TIMER_CNF");
  reg_send_message(&get_hplmn_timer_cnf, GS_QUEUE_CM);
}


/*==============================================================================

FUNCTION NAME

  reg_send_mmr_clear_lai_reject_list_req

==============================================================================*/

void reg_send_mmr_clear_lai_reject_list_req( void )
{
  mmr_clear_lai_reject_list_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte) MMR_CLEAR_LAI_REJECT_LIST_REQ;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_clear_lai_reject_list_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_clear_lai_reject_list_req_s_type) - sizeof(IMH_T)) / 256;
  /*lint +e778 */
  
#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_CLEAR_LAI_REJECT_LIST_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}

#ifdef FEATURE_DUAL_SIM
/*==============================================================================

FUNCTION NAME

  reg_send_mmr_multimode_subs_chgd_req

==============================================================================*/

void reg_send_mmr_multimode_subs_chgd_req
(
  subs_capability_e_type  *subs_capability
)
{
  mmr_multimode_subs_chgd_req_s_type msg;
  sys_modem_as_id_e_type as_id;

  msg.message_header.message_set         = MS_MM_REG;
  msg.message_header.message_id          = (byte)MMR_MULTIMODE_SUBS_CHGD_REQ;
  msg.message_header.message_len_lsb     =
    (sizeof( mmr_multimode_subs_chgd_req_s_type ) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb     =
    (sizeof( mmr_multimode_subs_chgd_req_s_type ) - sizeof(IMH_T)) / 256;

    for(as_id = SYS_MODEM_AS_ID_1; as_id < MAX_AS_IDS;as_id++)
    {
      msg.subs_capability[as_id] = subs_capability[as_id];
    }

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_MULTIMODE_SUBS_CHGD_REQ");
  reg_send_message(&msg, GS_QUEUE_MM );
}


 /*==============================================================================
 
 FUNCTION NAME
 
   reg_send_mmr_dds_switch_ind
 
 ==============================================================================*/
 void reg_send_mmr_dds_switch_ind
 (
  sys_modem_as_id_e_type target_dds_sub
 )
 {
   mmr_dds_switch_ind_s_type msg;
   
   msg.message_header.message_set = MS_MM_REG;
   msg.message_header.message_id  = (byte)MMR_DDS_SWITCH_IND;
   msg.message_header.message_len_lsb =
     (sizeof( mmr_dds_switch_ind_s_type ) - sizeof(IMH_T)) % 256;
   msg.message_header.message_len_msb =
     (sizeof( mmr_dds_switch_ind_s_type ) - sizeof(IMH_T)) / 256;

   msg.target_dds_sub = target_dds_sub;
 
   MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_DDS_SWITCH_IND");
   reg_send_message(&msg.message_header, GS_QUEUE_MM );
 }


#endif
/*==============================================================================*/
#if defined (FEATURE_SGLTE) || defined (FEATURE_1XSRLTE)|| defined (FEATURE_SVLTE_DUAL_SIM)
void reg_send_mmr_ue_mode_change_ind(sys_ue_mode_e_type  reg_mode_change_indication,boolean  ue_submode_srlte)
{
  mm_ue_mode_ind_s_type msg;
  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte) MMR_UE_MODE_CHANGE_IND;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mm_ue_mode_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mm_ue_mode_ind_s_type) - sizeof(IMH_T)) / 256;
  msg.ue_mode = reg_mode_change_indication;
  msg.ue_mode_substate_srlte = ue_submode_srlte;
  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_UE_MODE_CHANGE_IND");
  reg_send_message(&msg, GS_QUEUE_MM);
}
#endif

#ifdef FEATURE_DUAL_DATA
void reg_send_mmr_data_priority_ind(sys_data_priority_e_type  reg_data_prio_ind)
{
  mmr_data_priority_ind_s_type msg;
  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte) MMR_DATA_PRIORITY_IND;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_data_priority_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_data_priority_ind_s_type) - sizeof(IMH_T)) / 256;
  msg.priority = reg_data_prio_ind;
  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_DATA_PRIORITY_IND");
  reg_send_message(&msg, GS_QUEUE_MM);
}
#endif


#if defined (FEATURE_TDSCDMA) || defined (FEATURE_SGLTE)
void reg_send_mmr_pseudo_list_change_ind(sys_radio_access_tech_e_type rat, boolean can_use_pseudo)
{
  mmr_pseudo_list_update_ind_type msg;
  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte) MMR_PSEUDO_LIST_UPDATE_IND;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_pseudo_list_update_ind_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_pseudo_list_update_ind_type) - sizeof(IMH_T)) / 256;
  msg.rat = rat;
  msg.can_use_pseudo = can_use_pseudo;
  msg.as_id = (sys_modem_as_id_e_type)reg_as_id;
  MSG_HIGH_DS_1(REG_SUB, "=REG= MMR_PSEUDO_LIST_UPDATE_IND, rat = %d ",rat);
  reg_send_message(&msg, GS_QUEUE_MM);
}
#endif
#ifdef FEATURE_SGLTE
void reg_send_ps_timer_expiry(void)
{
 MSG_HIGH_DS_0(REG_SUB, "=REG= PS is Transferred to GSM ");
 reg_send_mmr_reg_req_msg.type = MMR_REG_REQ_SGLTE_PSTIMER_EXPIRY;
 reg_send_mmr_reg_req_msg.rat = SYS_RAT_GSM_RADIO_ACCESS;
 reg_send_mmr_reg_req_msg.plmn = reg_state_service_plmn_get_per_subs((sys_modem_as_id_e_type)reg_cs_stack_id);
 reg_send_last_mmr_reg_req();
}

void reg_send_cm_stack_deact_ind(void)
{

  cm_stack_deact_ind_s_type msg;
  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte) CM_STACK_DEACT_IND;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
         (sizeof(cm_stack_deact_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
          (sizeof(cm_stack_deact_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_STACK_DEACT_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

void reg_send_cm_stack_act_ind( void )
{

  cm_stack_act_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte) CM_STACK_ACT_IND;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(cm_stack_act_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_stack_act_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_STACK_ACT_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================

FUNCTION NAME

  reg_send_cm_service_ind

==============================================================================*/

void reg_send_cm_stat_ind
(
  sys_plmn_service_state_s_type   service_state
)
{
  cm_service_ind_s_type msg;
  memset(&msg,0x00,sizeof(cm_service_ind_s_type));
  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_SERVICE_STAT_IND;
  msg.message_header.message_len_lsb =
    (sizeof(cm_service_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_service_ind_s_type) - sizeof(IMH_T)) / 256;

  reg_send_update_cm_service_capability( &service_state);
  msg.service_state = service_state;
  msg.as_id = (sys_modem_as_id_e_type)reg_sub_id;
  msg.stack_id = reg_set_cm_stack_id();
  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_SERVICE_STAT_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}
#endif
/*===============================================================================

FUNCTION NAME

 reg_send_mmr_net_sel_mode_change_ind

DESCRIPTION

  Function sends the network selection mode change indication to MM if UE already registered on PLMN before looping back with confrimation to CM.

RETURN VALUE

  None

==============================================================================*/

void reg_send_mmr_net_sel_mode_change_ind
(
  sys_network_selection_mode_e_type   network_selection_mode
)
{
  mmr_net_sel_mode_change_ind_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_NET_SEL_MODE_CHANGE_IND;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_net_sel_mode_change_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_net_sel_mode_change_ind_s_type) - sizeof(IMH_T)) / 256;
  /*lint +e778 */

  msg.network_selection_mode         = network_selection_mode;
  
#ifdef FEATURE_DUAL_SIM
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_NET_SEL_MODE_CHANGE_IND");
  reg_send_message(&msg, GS_QUEUE_MM);
}
#ifdef MMOC_API_PH_STAT_CNF_WITH_STATUS
void reg_send_mmr_sim_busy_ind(boolean sim_busy)
{
  mmr_sim_busy_ind_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_SIM_BUSY_IND;
  msg.is_sim_busy = sim_busy;
  /*lint -e778 */
  msg.message_header.message_len_lsb =
    (sizeof(mmr_sim_busy_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_sim_busy_ind_s_type) - sizeof(IMH_T)) / 256;
  /*lint +e778 */

    
#ifdef FEATURE_DUAL_SIM
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_SIM_BUSY_IND");
  reg_send_message(&msg, GS_QUEUE_MM);

}
#endif	

#ifdef FEATURE_FEMTO_CSG
/*==============================================================================
FUNCTION NAME:  reg_send_mmr_csg_select_config_update_ind

DESCRIPTION
  This REG function sends MMR_CSG_SELECT_CONFIG_UPDATE_IND to MM.

RETURN VALUE
  none
==============================================================================*/

void reg_send_mmr_csg_select_config_update_ind
(
  const sys_csg_selection_config_e_type csg_selection_config
)
{
  mmr_csg_select_config_update_ind_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_CSG_SELECT_CONFIG_UPDATE_IND;

  msg.message_header.message_len_lsb =
    (sizeof(mmr_csg_select_config_update_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_csg_select_config_update_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.csg_selection_config = csg_selection_config;

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_CSG_SELECT_CONFIG_UPDATE_IND");
  reg_send_message(&msg, GS_QUEUE_MM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_cm_csg_search_trigger_ind

DESCRIPTION
  This REG function sends CM_CSG_SEARCH_TRIGGER_IND to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_csg_search_trigger_ind
(
  void
)
{
  cm_csg_search_trigger_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_CSG_SEARCH_TRIGGER_IND;

  msg.message_header.message_len_lsb =
    (sizeof(cm_csg_search_trigger_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_csg_search_trigger_ind_s_type) - sizeof(IMH_T)) / 256;

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_CSG_SEARCH_TRIGGER_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_cm_csg_nw_sel_mode_update_ind

DESCRIPTION
  This REG function sends CM_CSG_NW_SEL_MODE_UPDATE_IND to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_csg_nw_sel_mode_update_ind
(
  const sys_network_selection_mode_e_type nw_sel_mode 
)
{
  cm_csg_nw_sel_mode_update_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_CSG_NW_SEL_MODE_UPDATE_IND;

  msg.message_header.message_len_lsb =
    (sizeof(cm_csg_nw_sel_mode_update_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_csg_nw_sel_mode_update_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.nw_sel_mode = nw_sel_mode;

#if defined FEATURE_DUAL_SIM || defined FEATURE_SGLTE
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif
  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_CSG_NW_SEL_MODE_UPDATE_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_get_nw_sel_mode_sent_to_mm_get
==============================================================================*/
sys_network_selection_mode_e_type reg_send_nw_sel_mode_sent_to_mm_get
(
  void
)
{
  return reg_send_nw_sel_mode_sent_to_mm;
}
#endif /*FEATURE_FEMTO_CSG*/

#ifdef FEATURE_GPS_WWAN_PRIORITY_SEARCH
/*==============================================================================
FUNCTION NAME:  reg_send_filter_bands_for_gps

DESCRIPTION
  This function filter the bands for GPS FR.

RETURN VALUE
  none
==============================================================================*/

void reg_send_filter_bands_for_gps
(
sys_radio_access_tech_e_type rat,
sys_wwan_adavnce_scan_pram_s_type gps_wwan_search_info,
sys_rat_pri_list_info_s_type *rat_pri_list_info,
sys_plmn_id_s_type plmn,
sys_srv_status_e_type  service_status
)
{
    uint32 i;
	
	if(rat == SYS_RAT_LTE_M1_RADIO_ACCESS && 
		gps_wwan_search_info.assist_param.wwan_rat_scan_param.m1_scan_params.is_m1_blind_scan_req == TRUE && 
		service_status != SYS_SRV_STATUS_NO_SRV)
	{
	  for(i=0;i<rat_pri_list_info->num_items;i++)
	 {
       if(rat == reg_mode_convert_acq_mode_to_access_tech(rat_pri_list_info->priority_list_info[i].acq_sys_mode))
       	{
          reg_send_remove_other_bands(rat_pri_list_info, plmn);
       	}
	 }
 	}
	else if(rat == SYS_RAT_LTE_NB1_RADIO_ACCESS && 
		gps_wwan_search_info.assist_param.wwan_rat_scan_param.nb1_scan_params.is_nb1_blind_scan_req == TRUE && 
		service_status != SYS_SRV_STATUS_NO_SRV)
	{
	  for(i=0;i<rat_pri_list_info->num_items;i++)
	 {
       if(rat == reg_mode_convert_acq_mode_to_access_tech(rat_pri_list_info->priority_list_info[i].acq_sys_mode))
       	{
          reg_send_remove_other_bands(rat_pri_list_info, plmn);
       	}
	 }
 	}
}
#endif

/*==============================================================================
FUNCTION NAME:  reg_send_cm_t3346_timer_ind

DESCRIPTION
  This REG function sends CM_NAS_T3346_TIMER_IND to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_t3346_timer_ind
(
   mmr_t3346_timer_ind_s_type *msg_ptr 
)
{
  cm_nas_t3346_timer_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_NAS_T3346_TIMER_IND;

  msg.message_header.message_len_lsb =
    (sizeof(cm_nas_t3346_timer_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_nas_t3346_timer_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.active_rat = msg_ptr->active_rat;
  msg.t3346_notification = msg_ptr->t3346_notification;
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.stack_id = reg_set_cm_stack_id();

  MSG_HIGH_DS_2(REG_SUB, "=REG= CM_NAS_T3346_TIMER_IND, RAT: %d, T3346 Notification: %d",
                          msg.active_rat, msg.t3346_notification);
  reg_send_message(&msg, GS_QUEUE_CM);
}


/*==============================================================================
FUNCTION NAME:  reg_send_mmr_psm_ready_req

DESCRIPTION
  This REG function sends MMR_PSM_READY_REQ to MM.

RETURN VALUE
  none
==============================================================================*/

void reg_send_mmr_psm_ready_req
(
  void
)
{
  mmr_psm_ready_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_PSM_READY_REQ;

  msg.message_header.message_len_lsb =
    (sizeof(mmr_psm_ready_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_psm_ready_req_s_type) - sizeof(IMH_T)) / 256;

#ifdef FEATURE_DUAL_SIM
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_PSM_READY_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}


/*==============================================================================
FUNCTION NAME:  reg_send_cm_psm_ready_rsp

DESCRIPTION
  This REG function sends CM_PSM_READY_RSP to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_psm_ready_rsp
(
  mmr_psm_ready_rsp_s_type *msg_ptr
)
{
  cm_psm_ready_rsp_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_PSM_READY_RSP;

  msg.message_header.message_len_lsb =
    (sizeof(cm_psm_ready_rsp_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_psm_ready_rsp_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.status = msg_ptr->status;
  msg.periodic_update_timer_value = msg_ptr->periodic_update_timer_value;

#ifdef FEATURE_CIOT
   /* Block PSM if the timer have expired or Manual PLMN search ongoing*/
   if (reg_state_get_timers_expired())
   {
     msg.status = SYS_PSM_STATUS_NOT_READY_ACTIVE_TIMER_RUNNING;
     reg_state_set_psm_sleep_blocked(TRUE);
     MSG_HIGH_DS_0(REG_SUB, "=REG= PSM Sleep blocked");     
   }
   else if (reg_state_current_state_get() == REG_STATE_MANUAL_SEARCH)
   {
   	 msg.status = SYS_PSM_STATUS_NOT_READY_NOT_IDLE;
	 reg_state_set_psm_sleep_blocked(TRUE);
	 MSG_HIGH_DS_0(REG_SUB, "=REG= PSM Sleep blocked. Manual PLMN Search Ongoing");
   }
#endif
  MSG_HIGH_DS_2(REG_SUB, "=REG= CM_PSM_READY_RSP, status: %d, periodic_update_timer_value: %d",
                        msg.status, msg.periodic_update_timer_value);
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_cm_psm_ready_ind

DESCRIPTION
  This REG function sends CM_PSM_READY_IND to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_psm_ready_ind
(
  mmr_psm_ready_ind_s_type *msg_ptr
)
{
  cm_psm_ready_ind_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_PSM_READY_IND;

  msg.message_header.message_len_lsb =
    (sizeof(cm_psm_ready_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_psm_ready_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.periodic_update_timer_value = msg_ptr->periodic_update_timer_value;

  MSG_HIGH_DS_1(REG_SUB, "=REG= CM_PSM_READY_IND, periodic_update_timer_value: %d",
                        msg.periodic_update_timer_value);
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_mmr_psm_set_config_params_req

DESCRIPTION
  This REG function sends MMR_PSM_SET_CONFIG_PARAMS_REQ to MM.

RETURN VALUE
  none
==============================================================================*/

void reg_send_mmr_psm_set_config_params_req
(
  cm_psm_set_config_params_req_s_type *msg_ptr
)
{
  mmr_psm_set_config_params_req_s_type msg;

  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_PSM_SET_CONFIG_PARAMS_REQ;

  msg.message_header.message_len_lsb =
    (sizeof(mmr_psm_set_config_params_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_psm_set_config_params_req_s_type) - sizeof(IMH_T)) / 256;

#ifdef FEATURE_DUAL_SIM
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif

  msg.psm_enabled = msg_ptr->psm_enabled;
  msg.active_timer_value = msg_ptr->active_timer_value;
  msg.periodic_tau_timer_value = msg_ptr->periodic_tau_timer_value;
  msg.periodic_rau_timer_value = msg_ptr->periodic_rau_timer_value;
  msg.gprs_ready_timer_value = msg_ptr->gprs_ready_timer_value;
  msg.change_mask = msg_ptr->change_mask;

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_PSM_SET_CONFIG_PARAMS_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_mmr_psm_get_timer_info_req

DESCRIPTION
  This REG function sends MMR_PSM_GET_TIMER_INFO_REQ to MM.

RETURN VALUE
  none
==============================================================================*/

void reg_send_mmr_psm_get_timer_info_req
(
  cm_psm_get_timer_info_req_s_type *msg_ptr
)
{
  mmr_psm_get_timer_info_req_s_type msg;

  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_PSM_GET_TIMER_INFO_REQ;

  msg.message_header.message_len_lsb =
    (sizeof(mmr_psm_get_timer_info_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_psm_get_timer_info_req_s_type) - sizeof(IMH_T)) / 256;
#ifdef FEATURE_DUAL_SIM
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif

  msg.user_config = msg_ptr->user_config;
  
  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_PSM_GET_TIMER_INFO_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_cm_psm_auto_ready_ind

DESCRIPTION
  This REG function sends CM_PSM_AUTO_READY_IND to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_psm_auto_ready_ind
(
  mmr_psm_auto_ready_ind_s_type *msg_ptr
)
{
  cm_psm_auto_ready_ind_s_type msg;

  msg.message_header.message_set = MS_CM_REG;
  msg.message_header.message_id  = (byte)CM_PSM_AUTO_READY_IND;

  msg.message_header.message_len_lsb =
    (sizeof(cm_psm_auto_ready_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_psm_auto_ready_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.periodic_update_timer_value = msg_ptr->periodic_update_timer_value;

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_PSM_AUTO_READY_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_cm_psm_timer_change_ind

DESCRIPTION
  This REG function sends CM_PSM_TIMER_CHANGE_IND to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_psm_timer_change_ind
(
  mmr_psm_timer_change_ind_s_type *msg_ptr
)
{
  cm_psm_timer_change_ind_s_type msg;

  msg.message_header.message_set = MS_CM_REG;
  msg.message_header.message_id  = (byte)CM_PSM_TIMER_CHANGE_IND;

  msg.message_header.message_len_lsb =
    (sizeof(cm_psm_timer_change_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_psm_timer_change_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.active_rat = msg_ptr->active_rat;
  msg.active_timer_value = msg_ptr->active_timer_value;
  msg.periodic_update_timer_value = msg_ptr->periodic_update_timer_value;
  msg.gprs_ready_timer_value = msg_ptr->gprs_ready_timer_value;

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_PSM_TIMER_CHANGE_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_cm_psm_set_config_params_rsp

DESCRIPTION
  This REG function sends CM_PSM_SET_CONFIG_PARAMS_RSP to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_psm_set_config_params_rsp
(
  void
)
{
  cm_psm_set_config_params_rsp_s_type msg;

  msg.message_header.message_set = MS_CM_REG;
  msg.message_header.message_id  = (byte)CM_PSM_SET_CONFIG_PARAMS_RSP;

  msg.message_header.message_len_lsb =
    (sizeof(cm_psm_set_config_params_rsp_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_psm_set_config_params_rsp_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_PSM_SET_CONFIG_PARAMS_RSP");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_cm_psm_get_timer_info_rsp

DESCRIPTION
  This REG function sends CM_PSM_GET_TIMER_INFO_RSP to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_psm_get_timer_info_rsp
(
  mmr_psm_get_timer_info_rsp_s_type *msg_ptr
)
{
  cm_psm_get_timer_info_rsp_s_type msg;

  msg.message_header.message_set = MS_CM_REG;
  msg.message_header.message_id  = (byte)CM_PSM_GET_TIMER_INFO_RSP;

  msg.message_header.message_len_lsb =
    (sizeof(cm_psm_get_timer_info_rsp_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_psm_get_timer_info_rsp_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.active_timer_value = msg_ptr->active_timer_value;
  msg.periodic_tau_timer_value = msg_ptr->periodic_tau_timer_value;
  msg.periodic_rau_timer_value = msg_ptr->periodic_rau_timer_value;
  msg.gprs_ready_timer_value = msg_ptr->gprs_ready_timer_value;

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_PSM_GET_TIMER_INFO_RSP");
  reg_send_message(&msg, GS_QUEUE_CM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_mmr_psm_save_mmgsdi_ef_req

DESCRIPTION
  This REG function sends MMR_PSM_SAVE_MMGSDI_EF_REQ to MM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_mmr_psm_save_mmgsdi_ef_req
(
  void
)
{
  mmr_psm_save_mmgsdi_ef_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_PSM_SAVE_MMGSDI_EF_REQ;

  msg.message_header.message_len_lsb =
    (sizeof(mmr_psm_save_mmgsdi_ef_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_psm_save_mmgsdi_ef_req_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_PSM_SAVE_MMGSDI_EF_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_mmr_enter_psm_mode_req

DESCRIPTION
  This REG function sends MMR_ENTER_PSM_MODE_REQ to MM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_mmr_enter_psm_mode_req
(
  void
)
{
  mmr_enter_psm_mode_req_s_type msg;

  msg.message_header.message_set     = MS_MM_REG;
  msg.message_header.message_id      = (byte)MMR_ENTER_PSM_MODE_REQ;

  msg.message_header.message_len_lsb =
    (sizeof(mmr_enter_psm_mode_req_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_enter_psm_mode_req_s_type) - sizeof(IMH_T)) / 256;

#ifdef FEATURE_DUAL_SIM
  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
#endif

  MSG_HIGH_DS_0(REG_SUB, "=REG= MMR_ENTER_PSM_MODE_REQ");
  reg_send_message(&msg, GS_QUEUE_MM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_cm_enter_psm_mode_rsp

DESCRIPTION
  This REG function sends CM_ENTER_PSM_MODE_RSP to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_enter_psm_mode_rsp
 (
  boolean         status,
  uint8          *buf_ptr,
  uint32          buf_len
  )
{
  cm_enter_psm_mode_rsp_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_ENTER_PSM_MODE_RSP;

  msg.message_header.message_len_lsb =
    (sizeof(cm_enter_psm_mode_rsp_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_enter_psm_mode_rsp_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.status = status;

  if(status == FALSE)
  {
     msg.context_size = 0;
     msg.context = NULL;
     msg.is_context_changed = TRUE;
  }
  else
  {
     msg.context_size = buf_len;
     msg.context = buf_ptr;
     msg.is_context_changed = TRUE;
     MSG_HIGH_DS_2(REG_SUB, "=REG= Context status: %d length = %d", msg.status,buf_len);
  }

  MSG_HIGH_DS_2(REG_SUB, "=REG= CM_ENTER_PSM_MODE_RSP, status: %d length = %d", msg.status,buf_len);
  reg_send_message(&msg, GS_QUEUE_CM);
}



/*==============================================================================
FUNCTION NAME:  reg_send_cm_psm_save_mmgsdi_ef_rsp

DESCRIPTION
  This REG function sends CM_PSM_SAVE_MMGSDI_EF_RSP  to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_psm_save_mmgsdi_ef_rsp
(
  boolean status
)
{
  cm_psm_save_mmgsdi_ef_rsp_s_type msg;

  msg.message_header.message_set     = MS_CM_REG;
  msg.message_header.message_id      = (byte)CM_PSM_SAVE_MMGSDI_EF_RSP;

  msg.message_header.message_len_lsb =
    (sizeof(cm_psm_save_mmgsdi_ef_rsp_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_psm_save_mmgsdi_ef_rsp_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.status = status;

  MSG_HIGH_DS_1(REG_SUB, "=REG= CM_PSM_SAVE_MMGSDI_EF_RSP, status: %d", msg.status);
  reg_send_message(&msg, GS_QUEUE_CM);
}


/*==============================================================================
FUNCTION NAME:  reg_send_cm_edrx_params_change_ind

DESCRIPTION
  This REG function sends CM_EDRX_PARAMS_CHANGE_IND to CM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_edrx_params_change_ind
(
  mmr_edrx_params_change_ind_s_type *msg_ptr
)
{
  cm_edrx_params_change_ind_s_type msg;
  memset(&msg, 0x00, sizeof(cm_edrx_params_change_ind_s_type));

  msg.message_header.message_set = MS_CM_REG;
  msg.message_header.message_id  = (byte)CM_EDRX_PARAMS_CHANGE_IND;

  msg.message_header.message_len_lsb =
    (sizeof(cm_edrx_params_change_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(cm_edrx_params_change_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.rat_type = msg_ptr->rat_type;
  msg.edrx_supported = msg_ptr->edrx_supported;
  msg.edrx_ptw = msg_ptr->edrx_ptw;
  msg.edrx_cycle_length = msg_ptr->edrx_cycle_length;

  MSG_HIGH_DS_0(REG_SUB, "=REG= CM_EDRX_PARAMS_CHANGE_IND");
  reg_send_message(&msg, GS_QUEUE_CM);
}
#ifdef FEATURE_CIOT
/*==============================================================================
FUNCTION NAME:  reg_send_cm_unblock

DESCRIPTION
  This REG function unblocks the PSM sleep

RETURN VALUE
  none
==============================================================================*/
void reg_send_cm_psm_unblock (void)
{

    mmr_psm_ready_ind_s_type msg;
    msg.periodic_update_timer_value = 0;
    MSG_HIGH_DS_0(REG_SUB, "=REG= Unblocking PSM");
    reg_send_cm_psm_ready_ind(&msg);    
}

/*==============================================================================
FUNCTION NAME:  reg_send_mmr_home_roam

DESCRIPTION
  This REG function sends MMR_SEND_PLMN_HOME_ROAM to MM.

RETURN VALUE
  none
==============================================================================*/
void reg_send_mmr_home_roam
(
  boolean home
)
{
  mmr_send_plmn_home_roam_ind_s_type msg;
  memset(&msg, 0x00, sizeof(mmr_send_plmn_home_roam_ind_s_type));

  msg.message_header.message_set = MS_MM_REG;
  msg.message_header.message_id  = (byte)MMR_SEND_PLMN_HOME_ROAM;

  msg.message_header.message_len_lsb =
    (sizeof(mmr_send_plmn_home_roam_ind_s_type) - sizeof(IMH_T)) % 256;
  msg.message_header.message_len_msb =
    (sizeof(mmr_send_plmn_home_roam_ind_s_type) - sizeof(IMH_T)) / 256;

  msg.as_id =(sys_modem_as_id_e_type)reg_as_id;
  msg.home = home;

  MSG_HIGH_DS_1(REG_SUB, "=REG= MMR_SEND_PLMN_HOME_ROAM %d", home);
  reg_send_message(&msg, GS_QUEUE_MM);
}

/*==============================================================================
FUNCTION NAME:  reg_send_mmr_reset_scan_info

DESCRIPTION
  This function resets scan info contests of last reg request

RETURN VALUE
  none
==============================================================================*/

void reg_send_mmr_reset_scan_info()
{
  reg_send_mmr_reg_req_msg.scan_info.new_scan = TRUE;
  reg_send_mmr_reg_req_msg.scan_info.scan_time = FALSE;
  reg_send_mmr_reg_req_msg.scan_info.use_timer = FALSE;
}

#endif
