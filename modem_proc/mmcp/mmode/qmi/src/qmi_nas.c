/*===========================================================================

                         Q M I _ N A S . C

DESCRIPTION

 The Qualcomm Network Access Services MSM Interface source file.

EXTERNALIZED FUNCTIONS

  qmi_nas_init()
    Register the Network Access Service with QMUX for all applicable QMI links.

  qmi_nas_gen_serving_system_ind_cb()
    Call back function called when the serving system changes.

  qmi_nas_rssi_change_cb()
    Callback to be called when signal strength changes.

Copyright (c) 2004-2015 QUALCOMM Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary.
===========================================================================*/
/*===========================================================================

                      EDIT HISTORY FOR FILE

  $Header: //components/rel/mmcp.mpss/6.1.10/mmode/qmi/src/qmi_nas.c#2 $ $DateTime: 2023/09/08 07:19:13 $ $Author: pwbldsvc $

when        who    what, where, why
--------    ---    ----------------------------------------------------------

05/15/12    aa     Centralized EONS support status message
06/21/10    kk     Fix to check UIM status before posting commands to mmgsdi->
11/10/09    jee    Changes to support MMGSDI re-architecture
10/22/09    kk     Windows7 compliance - WDS changes and BER/PER/FER support.
10/16/09    kk     Windows7 compliance - new messages and ATCoP dependencies.
10/09/09    kk     Windows7 compliance - NAS changes.
04/13/09    rt     Fixed the issue of array bound overflow if PLMN list is
                   large.
02/19/09    am     DS Task De-coupling effort and introduction of DCC task.
09/21/06    ks     Fix qmi_nasi_get_client_sp_by_clid() to return cl_sp for
                   correct NAS instance.
08/23/06    ks     Changes to support multiple qmi/rmnet instances.
07/20/06    ks     Fixed a bug in NAS ABORT request.
07/11/06    ks     Fixed potential memory leak, change to use dsi_get_nv_item
07/10/06    ks     Fixed error in passing result and error code for some msgs
07/06/06    ks     Major clean up
07/06/06    ks     Changed implementation of signal strength reporting.
05/01/06    ks     Updated Attach and Register commands.
04/18/06    ks     Added support for Aborting NAS commands.
03/22/06    ks     Changed QMI_ERR_IN_USE to QMI_ERR_DEVICE_IN_USE.
03/13/06    ks     Changed parsing of requests to return error for fixed
                   length tlvs when tlv lengh passed is incorrect.
03/13/06    ks     Changed QMI_ERR_INVALID_ARG to QMI_ERR_MALFORMED_MSG.
                   Added reporting of some new error codes.
03/07/06    ks     Removed De-register support. Populating in_use bit in
                   network_scan status.
03/06/06    ks     Returning QMI_ERR_INVALID_ARG if a malformed TLV is
                   received.
12/11/05    jd     Support message bundling, remove command buffers from
                   pending queues upon client reset.
09/15/05    ks     Corrected type of TLV in Network_scan response.
09/15/05    ks     Fixes in perform_network_register().
09/09/05    ks     Fixed some async transaction stuff.
09/08/05    ks     Added support for more QMI_NAS messages.
08/15/05    ks     Return error when all optional TLVs are absent for messages
                   which don't have any mandatory TLVs.
06/27/05    jd     Removed nasi_get_version, fixed message numbering
05/13/05   ks/jd   Created module
===========================================================================*/

/*===========================================================================

                          INCLUDE FILES FOR MODULE

===========================================================================*/

#include "mmcp_variation.h"
#include "comdef.h"
#include "customer.h"
#include "cmrpm_lte.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stringl/stringl.h>
#include "dsm.h"
#include "ps_byte.h"
#include "ps_in.h"
#include "sys.h"
#include "cm.h"
#include "mm.h"
#include "cmtaski.h"
#include "cmmmgsdi.h"
#ifdef FEATURE_DUAL_SIM
#include  "cm_dualsim.h"
#endif /*FEATURE_DUAL_SIM*/
#include "fs_lib.h"
#if defined(FEATURE_MMODE_3GPP2)
#include "auth.h"
#endif
#ifdef FEATURE_CMI
#include "sys_v.h"
#endif

#include "nv.h"
#include "rex.h"

#include "qmi_svc_utils.h"
#include "qmi_nas.h"
#include "ds_qmi_defs.h"

#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
#include "mmgsdilib.h"
#include "mmgsdisessionlib.h"
#include "mmgsdilib_common.h"
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
#endif /* FEATURE_MMGSDI_SESSION_LIB */

/* This is a temporary include, until the ATCoP team moves the required
 * APIs to dsat.h */

#include "qmi_nas_msg.h"
//#include "qmi_nas_mmgsdi->h"

#ifdef FEATURE_HDR
#include "ds_sys_conf.h"
#endif

#include "qmi_nas_utils.h"
#include "qmi_nas_internal.h"
#include "time_genoff.h"

#include "qmi_nas_hdr.h"
#include "cm_v.h" // CM APIs
#if (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900))
#include "mccdma_v.h"
#endif

#include "qmi_svc_utils.h"
#include "qmi_mmode_task_cmd.h"
#include "modem_mem.h"
#include "qmi_mmode_svc.h"

#include "qmi_idl_lib.h"
#include "network_access_service_v01.h"
#include "network_access_service_impl_v01.h"

#ifdef FEATURE_TDSCDMA
#include "tds_rrc_msg.h"
#endif


#include "lte_cphy_rssi_msg.h"

#include "lte_rrc_ext_msg.h"
#include "geran_grr_msg.h"

#include "cm_msgr_msg.h"

#include "qm_comdef.h"
#include "qm_cbpq.h"
#include "qm_si.h"
#include "qm_nas_clnt.h"
#include "qm_util.h"
#include "qm_meas.h"
#include "qm_tib.h"
#include "qm_mstats.h"
#include "qm_efs.h"
#include "lte_rrc_ext_msg.h"
#include "lte_rrc_ext_api.h"
#ifdef FEATURE_WCDMA
#include "wcdma_rrc_msg.h"
#endif
#include "policyman.h"
#include "sd_v.h"

#ifdef FEATURE_MODEM_CONFIG_REFRESH
#include "mcfg_refresh.h"
#endif // FEATURE_MODEM_CONFIG_REFRESH

#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
#include "marb.h"
#endif

#include "lte_cphy_msg.h"
#include "nb1_cphy_msg.h"
#include "qmi_mmode_taski.h"
/*===========================================================================

                               DEFINITIONS

===========================================================================*/

/*---------------------------------------------------------------------------
  Service management
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
  Major and Minor Version Nos for NAS
---------------------------------------------------------------------------*/
#define NASI_BASE_VER_MAJOR  (1)
#define NASI_BASE_VER_MINOR  (25)

#define NASI_ADDENDUM_VER_MAJOR  (0)
#define NASI_ADDENDUM_VER_MINOR  (0)

/*---------------------------------------------------------------------------
  Message-internal TLV type field values
---------------------------------------------------------------------------*/
#define NASI_PARAM_TYPE_MANUAL_REGISTER                   (0x10)
#define NASI_PARAM_TYPE_3GPP_NETWORK_SCAN                 (0x10)
#define NASI_PARAM_TYPE_3GPP_NETWORK_SCAN_RAT             (0x11)
#define NASI_PARAM_TYPE_3GPP_PREF_NETWORKS                (0x10)
#define NASI_PARAM_TYPE_3GPP_STATIC_PREF_NETWORKS         (0x11)
#define NASI_PARAM_TYPE_3GPP_PREF_NETWORKS_MNC_PCS        (0x12)
#define NASI_PARAM_TYPE_3GPP_STATIC_PREF_NETWORKS_MNC_PCS (0x13)
#define NASI_PARAM_TYPE_SET_PREF_NETWORKS                 (0x10)
#define NASI_PARAM_TYPE_SET_PREF_NETWORKS_MNC_PCS         (0x11)
#define NASI_PARAM_TYPE_SET_PREF_NETWORKS_CLEAR_PREV      (0x12)
#define NASI_PARAM_TYPE_GET_FORB_NETWORKS                 (0x10)
#define NASI_PARAM_TYPE_SET_FORB_NETWORKS                 (0x10)

#define NASI_SIG_STRENGTH_INACTIVE_RSSI                   (255)
#define NASI_SIG_STRENGTH_INACTIVE_IO                     (9999)
#define NASI_SIG_STRENGTH_INACTIVE_ECIO                   (9999)
#define NASI_SIG_STRENGTH_INACTIVE_SINR                   (255)
#define NASI_SIG_STRENGTH_INACTIVE_RSRP                   (9999)
#define NASI_SIG_STRENGTH_INACTIVE_RSRQ                   (127)
#define NASI_LTE_SNR_STRENGTH_INACTIVE                    (255)
#define NASI_AUTOMATIC_REGISTER                           (0x01)
#define NASI_MANUAL_REGISTER                              (0x02)

#define NASI_PLMN_STATUS_CURRENT_MASK        (0x01)
#define NASI_PLMN_STATUS_AVAILABLE_MASK      (0x02)
#define NASI_PLMN_STATUS_HOME_MASK           (0x04)
#define NASI_PLMN_STATUS_ROAM_MASK           (0x08)
#define NASI_PLMN_STATUS_FORBIDDEN_MASK      (0x10)
#define NASI_PLMN_STATUS_NOT_FORBIDDEN_MASK  (0x20)
#define NASI_PLMN_STATUS_PREFERRED_MASK      (0x40)
#define NASI_PLMN_STATUS_NOT_PREFERRED_MASK  (0x80)

#define NASI_PARAM_PLMN_INFO_MAX_SIZE     (270)

/*---------------------------------------------------------------------------
  Max length of network name
---------------------------------------------------------------------------*/
#define NASI_SIG_STRENGTH_DELTA_NO_CHANGE        ((uint8)-1)

#define NASI_DEFAULT_RSSI_DELTA     5 /* Default RSSI delta change threshold
                                      ** for SIGNAL STRENGTH reporting
                                      */

#define NASI_DEFAULT_IO_DELTA      5 /* Default IO delta change threshold
                                      ** for SIGNAL STRENGTH reporting
                                      */
#define NASI_DEFAULT_RSRQ_DELTA    5 /* Default RSRQ delta change threshold */
#define NASI_DEFAULT_RSRP_DELTA    1 /* Default RSRQ delta change threshold */
#define NASI_MIN_SINR_DELTA        1 /* Minimum delta threshold for SINR */
#define NASI_MIN_ECIO_DELTA        1 /* Minimum delta threshold for ECIO */
#define NASI_MIN_SIG_INFO_DELTA    1 /* Minimum delta threshold for ECIO */

/*---------------------------------------------------------------------------
  Event Reporting Mode
---------------------------------------------------------------------------*/
#define NASI_EVENT_REPORT_MODE_DELTA     0x00
#define NASI_EVENT_REPORT_MODE_THRESHOLD 0x01

#define NASI_PRL_WILDCARD_SID 0x0000
#define NASI_PRL_WILDCARD_NID 0xFFFF

/*---------------------------------------------------------------------------
  Macro used in command handlers (common)
---------------------------------------------------------------------------*/
#define CHECK_RETVAL()  if (FALSE == retval) { dsm_free_packet(&response); \
                                               return NULL; }

// Event registration check helper
#define REGISTERED(cl_sp, event) ( cl_sp->report_status.report_##event == TRUE )

/*---------------------------------------------------------------------------
  Other Macros used in command handlers (common)
---------------------------------------------------------------------------*/
#define TARGET_SUPPORTS_GSM   (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_GSM  )
#define TARGET_SUPPORTS_WCDMA (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_WCDMA)
#define TARGET_SUPPORTS_CDMA  (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_CDMA )
#define TARGET_SUPPORTS_HDR   (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_HDR  )
#define TARGET_SUPPORTS_LTE   (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_LTE  )
#define TARGET_SUPPORTS_TDS   (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_TDS  )

#define QMI_NAS_6BIT_2_8BIT(a)  (int8)(((a)&0x20) ? ((a)|0xC0) : ((a)&0x3F)) // convert 6bit 2's complement integer to 8bit 2's complement integer

#define IS_TAC_VALID(X)  ( (X) != 0xFFFE && (X) != 0 )
/*---------------------------------------------------------------------------
  EFS File for persistent NITZ caching
---------------------------------------------------------------------------*/
#define MMGSDI_EFS_NITZ_PLMN_INFO "/nv/item_files/modem/uim/mmgsdi/eons/rplmn_info"

#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
//Periodic CSG Configuration
#define QMI_NAS_TUI_CSG_CONFIG_EFS_FILE "/nv/item_files/modem/mmode/tui/csg_search_sel_config"
#endif

//Invalid SSAC Barring time in LTE Service Indication
#define QMI_NAS_SSAC_INVALID_BARR_TIME  20

/*===========================================================================

                                DATA TYPES

===========================================================================*/

/*---------------------------------------------------------------------------
  Type of core network which the mobile is registered on
---------------------------------------------------------------------------*/
typedef enum
{
  NASI_REG_NET_UNKNOWN   = 0x00,   /* the mobile is not registered */
  NASI_REG_NET_3GPP2     = 0x01,   /* 3GPP2 network */
  NASI_REG_NET_3GPP      = 0x02    /* 3GPP network */
} qmi_nasi_reg_net_e_type;

/*---------------------------------------------------------------------------
  CS Attach enum type
---------------------------------------------------------------------------*/
typedef enum
{
  NASI_CS_UNKNOWN   = 0x00,   /* the mobile is not attached */
  NASI_CS_ATTACHED  = 0x01,
  NASI_CS_DETACHED  = 0x02
} qmi_nasi_cs_attach_e_type;

#ifndef FEATURE_MMODE_DISABLE_EMERGENCY
typedef enum
{
  NASI_MODE_EMERGENCY_MODE_OFF     = 0x00,
  NASI_MODE_EMERGENCY_MODE_ON      = 0x01
} qmi_nasi_emergency_mode_e_type;
#endif
/*---------------------------------------------------------------------------
  Enum for Mode preference Bitmask
  Bit 0 : cdma2000 1X
  Bit 1 : cdma2000 HRPD (1xEV-DO)
  Bit 2 : GSM
  Bit 3 : UMTS
  Bit 4 : LTE
---------------------------------------------------------------------------*/
#define QMI_NAS_MODE_PREF_BIT_CDMA   0x0001
#define QMI_NAS_MODE_PREF_BIT_HDR    0x0002
#define QMI_NAS_MODE_PREF_BIT_GSM    0x0004
#define QMI_NAS_MODE_PREF_BIT_UMTS   0x0008
#define QMI_NAS_MODE_PREF_BIT_LTE    0x0010
#define QMI_NAS_MODE_PREF_BIT_TDS    0x0020
#define QMI_NAS_MODE_PREF_BIT_ALL    0x003F

#define QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_WB   0x0001
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_M1   0x0002
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_NB1  0x0004

#define QMI_NAS_SYS_EDRX_CONFIG_INFO_MASK_NONE                               0x0000
#define QMI_NAS_SYS_EDRX_CONFIG_INFO_MASK_EDRX_ENABLED                       0x0001
#define QMI_NAS_SYS_EDRX_CONFIG_INFO_MASK_PTW                                0x0002
#define QMI_NAS_SYS_EDRX_CONFIG_INFO_MASK_EDRX_CYCLE_LENGTH                  0x0004

// list of supported mode pref in CM
// CHGW only supported in non-LTE targets for now
#define QMI_NAS_MODE_PREF_NONE  (0x0000)
#define QMI_NAS_MODE_PREF_C     (QMI_NAS_MODE_PREF_BIT_CDMA)
#define QMI_NAS_MODE_PREF_H     (QMI_NAS_MODE_PREF_BIT_HDR)
#define QMI_NAS_MODE_PREF_CH    (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_H)
#define QMI_NAS_MODE_PREF_G     (QMI_NAS_MODE_PREF_BIT_GSM)
#define QMI_NAS_MODE_PREF_W     (QMI_NAS_MODE_PREF_BIT_UMTS)
#define QMI_NAS_MODE_PREF_GW    (QMI_NAS_MODE_PREF_BIT_GSM|QMI_NAS_MODE_PREF_BIT_UMTS)
#define QMI_NAS_MODE_PREF_CGW   (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_GW)
#define QMI_NAS_MODE_PREF_CHGW  (QMI_NAS_MODE_PREF_BIT_HDR|QMI_NAS_MODE_PREF_CGW)
#define QMI_NAS_MODE_PREF_L     (QMI_NAS_MODE_PREF_BIT_LTE)
#define QMI_NAS_MODE_PREF_GWL   (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_GW)
#define QMI_NAS_MODE_PREF_CHGWL (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_CHGW)
#define QMI_NAS_MODE_PREF_HL    (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_BIT_HDR)
#define QMI_NAS_MODE_PREF_CHL   (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_CH)
#define QMI_NAS_MODE_PREF_CL    (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_BIT_CDMA)
#define QMI_NAS_MODE_PREF_GL    (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_BIT_GSM)
#define QMI_NAS_MODE_PREF_CGL   (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_GL)
#define QMI_NAS_MODE_PREF_HGL   (QMI_NAS_MODE_PREF_BIT_HDR|QMI_NAS_MODE_PREF_GL)
#define QMI_NAS_MODE_PREF_WL    (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_BIT_UMTS)
#define QMI_NAS_MODE_PREF_CWL   (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_WL)
#define QMI_NAS_MODE_PREF_HWL   (QMI_NAS_MODE_PREF_BIT_HDR|QMI_NAS_MODE_PREF_WL)
#define QMI_NAS_MODE_PREF_T     (QMI_NAS_MODE_PREF_BIT_TDS)
#define QMI_NAS_MODE_PREF_GT    (QMI_NAS_MODE_PREF_BIT_TDS|QMI_NAS_MODE_PREF_BIT_GSM)
#define QMI_NAS_MODE_PREF_CHG   (QMI_NAS_MODE_PREF_CH|QMI_NAS_MODE_PREF_G)
#define QMI_NAS_MODE_PREF_CG    (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_BIT_GSM)
#define QMI_NAS_MODE_PREF_TGWL  (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_GWL)
#define QMI_NAS_MODE_PREF_TGW   (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_GW)
#define QMI_NAS_MODE_PREF_TCHGWL (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_CHGWL)
#define QMI_NAS_MODE_PREF_TL    (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_BIT_LTE)
#define QMI_NAS_MODE_PREF_TGL   (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_GL)
#define QMI_NAS_MODE_PREF_TW    (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_BIT_UMTS)
#define QMI_NAS_MODE_PREF_TWL   (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_WL)
#define QMI_NAS_MODE_PREF_TCHGL (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_CHG|QMI_NAS_MODE_PREF_L)
#define QMI_NAS_MODE_PREF_TCHGW (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_CHGW)
#define QMI_NAS_MODE_PREF_TCGW  (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_CGW)
#define QMI_NAS_MODE_PREF_CHGL   (QMI_NAS_MODE_PREF_CHG|QMI_NAS_MODE_PREF_BIT_LTE)
#define QMI_NAS_MODE_PREF_CGWL   (QMI_NAS_MODE_PREF_CGW|QMI_NAS_MODE_PREF_BIT_LTE)

#define QMI_NAS_LTE_IOT_OP_MODE_PREF_NONE  (0x0000)
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_WB    (QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_WB)
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_M1    (QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_M1)
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_NB1   (QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_NB1)
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_M1_NB1  (QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_NB1 | QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_M1)
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_M1   (QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_WB | QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_M1)
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_NB1  (QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_WB | QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_NB1)
#define QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_M1_NB1  (QMI_NAS_LTE_IOT_OP_MODE_PREF_BIT_WB | QMI_NAS_LTE_IOT_OP_MODE_PREF_M1_NB1)


#ifndef FEATURE_MMODE_QMI_LTE_ONLY
struct qmi_nas_nv_mode_pref_s {
  uint16            qmi_val;
  nv_mode_enum_type nv_val;
};

#if defined(FEATURE_MMODE_QMI_GPRS_LTE)
const struct qmi_nas_nv_mode_pref_s qmi_nas_allowed_nv_mode_pref[] = {
  { QMI_NAS_MODE_PREF_G,     NV_MODE_GSM_ONLY              },
  { QMI_NAS_MODE_PREF_L,     NV_MODE_LTE_ONLY}
};
#else
const struct qmi_nas_nv_mode_pref_s qmi_nas_allowed_nv_mode_pref[] = {
#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  { QMI_NAS_MODE_PREF_C,     NV_MODE_CDMA_ONLY             },
  { QMI_NAS_MODE_PREF_H,     NV_MODE_HDR_ONLY              },
  { QMI_NAS_MODE_PREF_CH,    NV_MODE_CDMA_HDR_ONLY         },
#endif
  { QMI_NAS_MODE_PREF_G,     NV_MODE_GSM_ONLY              },
#if defined(FEATURE_WCDMA)
  { QMI_NAS_MODE_PREF_W,     NV_MODE_WCDMA_ONLY            },
  { QMI_NAS_MODE_PREF_GW,    NV_MODE_GSM_WCDMA_ONLY        },
#endif
  { QMI_NAS_MODE_PREF_L,     NV_MODE_LTE_ONLY}
};
#endif
#endif

/*---------------------------------------------------------------------------
  QMI NAS network type to mode pref
---------------------------------------------------------------------------*/
struct qmi_nas_network_to_mode_pref_s {
  uint8               network_type;
  cm_mode_pref_e_type cm_val;
};

#if defined(FEATURE_MMODE_QMI_GPRS_LTE)
  const struct qmi_nas_network_to_mode_pref_s qmi_nas_allowed_network_types[] = {
  { NAS_NETWORK_TYPE_GSM_ONLY_V01, CM_MODE_PREF_GSM_ONLY },
  { NAS_NETWORK_TYPE_LTE_ONLY_V01, CM_MODE_PREF_LTE_ONLY },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01), CM_MODE_PREF_GSM_LTE }
};
#elif defined(FEATURE_MMODE_QMI_LTE_ONLY)
  const struct qmi_nas_network_to_mode_pref_s qmi_nas_allowed_network_types[] = {
  { NAS_NETWORK_TYPE_LTE_ONLY_V01, CM_MODE_PREF_LTE_ONLY }
};
#else
const struct qmi_nas_network_to_mode_pref_s qmi_nas_allowed_network_types[] = {
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01), CM_MODE_PREF_GWL },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_WCDMA_ONLY_V01), CM_MODE_PREF_GSM_WCDMA_ONLY },
  { NAS_NETWORK_TYPE_GSM_ONLY_V01, CM_MODE_PREF_GSM_ONLY },
  { NAS_NETWORK_TYPE_WCDMA_ONLY_V01, CM_MODE_PREF_WCDMA_ONLY },
  { NAS_NETWORK_TYPE_LTE_ONLY_V01, CM_MODE_PREF_LTE_ONLY },
  { NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01, CM_MODE_PREF_TDS_ONLY},
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01), CM_MODE_PREF_GSM_LTE },
  { (NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01), CM_MODE_PREF_WCDMA_LTE },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_GSM },
  { (NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_WCDMA },
  { (NAS_NETWORK_TYPE_LTE_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_LTE },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_GSM_WCDMA },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_GSM_LTE },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_GSM_WCDMA_LTE }
};
#endif

/*---------------------------------------------------------------------------
  NAS Command enum type - not equal to the actual command values!
  mapping is in qmi_nas_cmd_callbacks table

  DO NOT REORDER THIS ENUM!  (make sure the command value here = index into
  qmi_nasi_cmd_callbacks table for corresponding command)
---------------------------------------------------------------------------*/
typedef enum
{
  NASI_CMD_MIN                         = 0,
  NASI_CMD_RESET                       = NASI_CMD_MIN,
  NASI_CMD_ABORT,
  NASI_CMD_SET_EVENT_REPORT,
  NASI_CMD_INDICATION_REGISTER,
  NASI_CMD_GET_SIGNAL_STRENGTH,
  NASI_CMD_PERFORM_NETWORK_SCAN,
  NASI_CMD_INITIATE_NETWORK_REGISTER,
  NASI_CMD_INITIATE_ATTACH,
  NASI_CMD_GET_SERVING_SYSTEM,
  NASI_CMD_GET_HOME_NETWORK,
  NASI_CMD_GET_PREFERRED_NETWORKS,
  NASI_CMD_SET_PREFERRED_NETWORKS,
  NASI_CMD_GET_FORBIDDEN_NETWORKS,
  NASI_CMD_SET_FORBIDDEN_NETWORKS,
  NASI_CMD_SET_TECHNOLOGY_PREFERENCE,
  NASI_CMD_GET_TECHNOLOGY_PREFERENCE,
  NASI_CMD_GET_ACCOLC,
  NASI_CMD_SET_ACCOLC,
  NASI_CMD_GET_SYSTEM_PREFERENCE,
  NASI_CMD_GET_DEVICE_CONFIG,
  NASI_CMD_SET_DEVICE_CONFIG,
  NASI_CMD_GET_RF_BAND_INFO,
  NASI_CMD_GET_AN_AAA_STATUS,
  NASI_CMD_SET_SYS_SEL_PREF,
  NASI_CMD_GET_SYS_SEL_PREF,
  NASI_CMD_SET_DDTM_PREFERENCE,
  NASI_CMD_GET_OPERATOR_NAME_DATA,
  NASI_CMD_GET_CSP_PLMN_MODE_BIT,
  NASI_CMD_UPDATE_AKEY,
  NASI_CMD_GET_3GPP2_SUBSCRIPTION_INFO,
  NASI_CMD_SET_3GPP2_SUBSCRIPTION_INFO,
  NASI_CMD_GET_MOB_CAI_REV,
  NASI_CMD_GET_RTRE_CONFIG,
  NASI_CMD_SET_RTRE_CONFIG,
  NASI_CMD_GET_CELL_LOCATION_INFO,
  NASI_CMD_GET_PLMN_NAME,
  NASI_CMD_BIND_SUBSCRIPTION,
  NASI_CMD_GET_MODE_PREF,
  NASI_CMD_SET_DUAL_STANDBY_PREF_NEW,
  NASI_CMD_GET_SYS_INFO,
  NASI_CMD_GET_SIG_INFO,
  NASI_CMD_CONFIG_SIG_INFO,
  NASI_CMD_GET_ERR_RATE,
  NASI_CMD_GET_HDR_SUBTYPE,
  NASI_CMD_GET_HDR_COLOR_CODE,
  NASI_CMD_GET_CURRENT_ACQ_SYS_MODE,
  NASI_CMD_SET_RX_DIVERSITY,
  NASI_CMD_GET_TX_RX_INFO,
  NASI_CMD_UPDATE_AKEY_EXT,
  NASI_CMD_GET_DUAL_STANDBY_PREF,
  NASI_CMD_DETACH_LTE,
  NASI_CMD_BLOCK_LTE_PLMN,
  NASI_CMD_UNBLOCK_LTE_PLMN,
  NASI_CMD_RESET_LTE_PLMN_BLOCKING,
  NASI_CMD_CONFIG_EMBMS,
  NASI_CMD_GET_EMBMS_STATUS,
  NASI_CMD_GET_CDMA_POSITION_INFO,
  NASI_CMD_FORCE_NETWORK_SEARCH,
  NASI_CMD_GET_MANAGED_ROAMING_CONFIG,
  NASI_CMD_GET_CENTRALIZED_EONS_SUPPORT_STATUS,
  NASI_CMD_CONFIG_SIG_INFO2,
  NASI_CMD_GET_TDS_CELL_AND_POSITION_INFO,
  NASI_CMD_SET_HPLMN_IRAT_SEARCH_TIMER,
  NASI_CMD_GET_EMBMS_SIG,
  NASI_CMD_LIMIT_SYS_INFO_IND_REPORTING,
  NASI_CMD_GET_SYS_INFO_IND_REPORTING_LIMIT,
  NASI_CMD_UPDATE_IMS_STATUS,
  NASI_CMD_GET_IMS_PREF_STATUS,
  NASI_CMD_IMS_PREF_STATUS_IND,
  NASI_CMD_CONFIG_PLMN_NAME_IND_REPORTING,
  NASI_CMD_CDMA_AVOID_SYSTEM,
  NASI_CMD_GET_CDMA_AVOID_SYSTEM_LIST,
  NASI_CMD_SET_HPLMN_SEARCH_TIMER,
  NASI_CMD_GET_HPLMN_SEARCH_TIMER,
  NASI_CMD_SET_BUILTIN_PLMN_LIST,
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
  NASI_CMD_SET_E911_STATE,
#endif
  NASI_CMD_E911_STATE_READY_IND,
  NASI_CMD_GET_LTE_SIB16_NETWORK_TIME,
  NASI_CMD_LTE_SIB16_NETWORK_TIME_IND,
  NASI_CMD_SET_LTE_BAND_PRIORITY,
  NASI_CMD_GET_EMBMS_SIG_EXT,
  NASI_CMD_LTE_CPHY_CA_IND,
  NASI_CMD_GET_SUBSCRIPTION_INFO,
  NASI_CMD_PERFORM_INCREMENTAL_NETWORK_SCAN,
  NASI_CMD_GET_NETWORK_TIME,
  NASI_CMD_SUBSCRIPTION_CHANGE_IND,
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
  NASI_CMD_IMS_DEREGISTRATION,
#endif
  NASI_CMD_SET_DRX,
  NASI_CMD_GET_DRX,
  NASI_CMD_SET_CELL_LOCK_CONFIG,
  NASI_CMD_CSG_SEARCH_SELECTION_CONFIG,
  NASI_CMD_CSG_IMMEDIATE_SEARCH_SELECTION,
  NASI_CMD_GET_CSG_SEARCH_SELECTION_CONFIG,
  NASI_CMD_SSAC_INFO_IND,
  NASI_CMD_SSAC_CHANGE_INFO_IND,
  NASI_CMD_GET_SSAC_INFO,
  NASI_CMD_GET_SERVING_CELL_SIB,
  NASI_CMD_SET_PERIODIC_SEARCH_ALLOWED,
  NASI_CMD_GET_ACB_INFO,
  NASI_CMD_SET_DATA_SUBS_PRIORITY,
  NASI_CMD_GET_DATA_SUBS_PRIORITY,
  NASI_CMD_DATA_SUBS_PRIORITY_IND,
  NASI_CMD_SET_DATA_ROAMING_STATUS,
  NASI_CMD_GET_DATA_ROAMING_STATUS,
  NASI_CMD_SET_SRVCC,
  NASI_SET_BSR_TIMER,
  NASI_GET_BSR_TIMER,
  NASI_CMD_AVOID_TUNEAWAY,
  NASI_CMD_T3346_TIMER_STATUS_CHANGE_IND,
  NASI_CMD_SET_MCC,
  NASI_CMD_SET_DRX_SCALING_FACTOR,
  #ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
  NASI_CMD_CALL_MODE_IND,
  NASI_CMD_GET_CALL_MODE,
  NASI_CMD_VOLTE_STATE_NOTIFICATION,
  NASI_CMD_IMS_CALL_STATE_NOTIFICATION,
#endif
  NASI_CMD_GET_LTE_RRC_TX_INFO,
  NASI_CMD_SET_GNSS_SESSION_STATUS,
  NASI_CMD_SET_RPM_PARAMETERS,
  NASI_CMD_GET_RPM_PARAMETERS,
  NASI_CMD_SET_RPM_STATE,
  NASI_CMD_SET_EDRX_PARAMS,
  NASI_CMD_GET_EDRX_PARAMS,
  #ifdef FEATURE_ENABLE_QMI_DMS
  NASI_CMD_SET_OPERATING_MODE,
  NASI_CMD_GET_OPERATING_MODE,
  NASI_CMD_GET_BAND_CAPABILITY,
  NASI_CMD_GET_PSM_CONFIG_PARAMS,
  NASI_CMD_SET_PSM_CONFIG_PARAMS,
  NASI_CMD_PSM_ENTER,
  #endif
  NASI_CMD_SET_CELL_CONFIG,
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  NASI_CMD_SET_APP_PRIORITY,
  #endif
  NASI_CMD_GET_SCAN_CONFIG,
NASI_CMD_GET_CURRENT_SCAN_INFO,
  NASI_CMD_MAX,
  NASI_CMD_WIDTH                       = 0xFFFF

} qmi_nasi_cmd_e_type;

typedef enum
{
  NASI_CMD_VAL_RESET                      = 0x0000,
  NASI_CMD_VAL_ABORT                      = 0x0001,
  NASI_CMD_VAL_SET_EVENT_REPORT           = 0x0002,
  NASI_CMD_VAL_INDICATION_REGISTER        = 0x0003,
  NASI_CMD_VAL_GET_SIGNAL_STRENGTH        = 0x0020,
  NASI_CMD_VAL_PERFORM_NETWORK_SCAN       = 0x0021,
  NASI_CMD_VAL_INITIATE_NETWORK_REGISTER  = 0x0022,
  NASI_CMD_VAL_INITIATE_ATTACH            = 0x0023,
  NASI_CMD_VAL_GET_SERVING_SYSTEM         = 0x0024,
  NASI_CMD_VAL_GET_HOME_NETWORK           = 0x0025,
  NASI_CMD_VAL_GET_PREFERRED_NETWORKS     = 0x0026,
  NASI_CMD_VAL_SET_PREFERRED_NETWORKS     = 0x0027,
  NASI_CMD_VAL_GET_FORBIDDEN_NETWORKS     = 0x0028,
  NASI_CMD_VAL_SET_FORBIDDEN_NETWORKS     = 0x0029,
  NASI_CMD_VAL_SET_TECHNOLOGY_PREFERENCE  = 0x002A,
  NASI_CMD_VAL_GET_TECHNOLOGY_PREFERENCE  = 0x002B,
  NASI_CMD_VAL_GET_ACCOLC                 = 0x002C,
  NASI_CMD_VAL_SET_ACCOLC                 = 0x002D,
  NASI_CMD_VAL_GET_SYSTEM_PREFERENCE      = 0x002E,
  NASI_CMD_VAL_GET_DEVICE_CONFIG          = 0x002F,
  NASI_CMD_VAL_SET_DEVICE_CONFIG          = 0x0030,
  NASI_CMD_VAL_GET_RF_BAND_INFO           = 0x0031,
  NASI_CMD_VAL_GET_AN_AAA_STATUS          = 0x0032,
  NASI_CMD_VAL_SET_SYS_SEL_PREF           = 0x0033,
  NASI_CMD_VAL_GET_SYS_SEL_PREF           = 0x0034,
  NASI_CMD_VAL_SET_NAM                    = 0x0035,
  NASI_CMD_VAL_GET_NAM                    = 0x0036,
  NASI_CMD_VAL_SET_DDTM_PREFERENCE        = 0x0037,
  NASI_CMD_VAL_DDTM_IND                   = 0x0038,
  NASI_CMD_VAL_GET_OPERATOR_NAME_DATA     = 0x0039,
  NASI_CMD_VAL_OPERATOR_NAME_DATA_IND     = 0x003A,
  NASI_CMD_VAL_GET_CSP_PLMN_MODE_BIT      = 0x003B,
  NASI_CMD_VAL_CSP_PLMN_MODE_BIT_IND      = 0x003C,
  NASI_CMD_VAL_UPDATE_AKEY                = 0x003D,
  NASI_CMD_VAL_GET_3GPP2_SUBSCRIPTION_INFO = 0x003E,
  NASI_CMD_VAL_SET_3GPP2_SUBSCRIPTION_INFO = 0x003F,
  NASI_CMD_VAL_GET_MOB_CAI_REV            = 0x0040,
  NASI_CMD_VAL_GET_RTRE_CONFIG            = 0x0041,
  NASI_CMD_VAL_SET_RTRE_CONFIG            = 0x0042,
  NASI_CMD_VAL_GET_CELL_LOCATION_INFO     = 0x0043,
  NASI_CMD_VAL_GET_PLMN_NAME              = 0x0044,
  NASI_CMD_VAL_BIND_SUBSCRIPTION          = 0x0045,
  NASI_CMD_VAL_MANAGED_ROAMING_IND        = 0x0046,
  NASI_CMD_VAL_DUAL_STANDBY_PREF_IND      = 0x0047,
  NASI_CMD_VAL_SUBSCRIPTION_INFO_IND      = 0x0048,
  NASI_CMD_VAL_GET_MODE_PREF              = 0x0049,
  NASI_CMD_VAL_THERMAL_EMERGENCY_STATE_IND= 0x004A,
  NASI_CMD_VAL_SET_DUAL_STANDBY_PREF_NEW  = 0x004B,
  NASI_CMD_VAL_NETWORK_TIME_IND           = 0x004C,
  NASI_CMD_VAL_GET_SYS_INFO               = 0x004D,
  NASI_CMD_VAL_SYS_INFO_IND               = 0x004E,
  NASI_CMD_VAL_GET_SIG_INFO               = 0x004F,
  NASI_CMD_VAL_CONFIG_SIG_INFO            = 0x0050,
  NASI_CMD_VAL_SIG_INFO_IND               = 0x0051,
  NASI_CMD_VAL_GET_ERR_RATE               = 0x0052,
  NASI_CMD_VAL_ERR_RATE_IND               = 0x0053,
  NASI_CMD_VAL_HDR_SESSION_CLOSE_IND      = 0x0054,
  NASI_CMD_VAL_HDR_UATI_UPDATE_IND        = 0x0055,
  NASI_CMD_VAL_GET_HDR_SUBTYPE            = 0x0056,
  NASI_CMD_VAL_GET_HDR_COLOR_CODE         = 0x0057,
  NASI_CMD_VAL_GET_CURRENT_ACQ_SYS_MODE   = 0x0058,
  NASI_CMD_VAL_SET_RX_DIVERSITY           = 0x0059,
  NASI_CMD_VAL_GET_TX_RX_INFO             = 0x005A,
  NASI_CMD_VAL_UPDATE_AKEY_EXT            = 0x005B,
  NASI_CMD_VAL_GET_DUAL_STANDBY_PREF      = 0x005C,
  NASI_CMD_VAL_DETACH_LTE                 = 0x005D,
  NASI_CMD_VAL_BLOCK_LTE_PLMN             = 0x005E,
  NASI_CMD_VAL_UNBLOCK_LTE_PLMN           = 0x005F,
  NASI_CMD_VAL_RESET_LTE_PLMN_BLOCKING    = 0x0060,
  NASI_CMD_VAL_CURRENT_PLMN_NAME_IND      = 0x0061,
  NASI_CMD_VAL_CONFIG_EMBMS               = 0x0062,
  NASI_CMD_VAL_GET_EMBMS_STATUS           = 0x0063,
  NASI_CMD_VAL_EMBMS_STATUS_IND           = 0x0064,
  NASI_CMD_VAL_GET_CDMA_POSITION_INFO     = 0x0065,
  NASI_CMD_VAL_RF_BAND_INFO_IND           = 0x0066,
  NASI_CMD_VAL_FORCE_NETWORK_SEARCH       = 0x0067,
  NASI_CMD_VAL_NETWORK_REJECT_IND         = 0x0068,
  NASI_CMD_VAL_GET_MANAGED_ROAMING_CONFIG = 0x0069,
  NASI_CMD_VAL_RTRE_CONFIG_IND            = 0x006A,
  NASI_CMD_VAL_GET_CENTRALIZED_EONS_SUPPORT_STATUS = 0x006B,
  NASI_CMD_VAL_CONFIG_SIG_INFO2           = 0x006C,
  NASI_CMD_VAL_GET_TDS_CELL_AND_POSITION_INFO= 0x006D,
  NASI_CMD_VAL_SET_HPLMN_IRAT_SEARCH_TIMER = 0x006E,
  NASI_CMD_VAL_GET_EMBMS_SIG               = 0x006F,
  NASI_CMD_VAL_LIMIT_SYS_INFO_IND_REPORTING = 0x0070,
  NASI_CMD_VAL_GET_SYS_INFO_IND_REPORTING_LIMIT = 0x0071,
  NASI_CMD_VAL_UPDATE_IMS_STATUS          = 0x0072,
  NASI_CMD_VAL_GET_IMS_PREF_STATUS        = 0x0073,
  NASI_CMD_VAL_IMS_PREF_STATUS_IND        = 0x0074,
  NASI_CMD_VAL_CONFIG_PLMN_NAME_IND_REPORTING   = 0x0075,
  NASI_CMD_VAL_CDMA_AVOID_SYSTEM                = 0x0076,
  NASI_CMD_VAL_GET_CDMA_AVOID_SYSTEM_LIST       = 0x0077,
  NASI_CMD_VAL_SET_HPLMN_SEARCH_TIMER    = 0x0078,
  NASI_CMD_VAL_GET_HPLMN_SEARCH_TIMER    = 0x0079,
  NASI_CMD_VAL_SET_BUILTIN_PLMN_LIST     = 0x0084,
  NASI_CMD_VAL_SET_E911_STATE             = 0x007A,
  NASI_CMD_VAL_E911_STATE_READY_IND       = 0x007B,
  NASI_CMD_VAL_GET_SUBSCRIPTION_INFO      = 0x007C,
  NASI_CMD_VAL_GET_NETWORK_TIME                 = 0x007D,
  NASI_CMD_VAL_GET_LTE_SIB16_NETWORK_TIME           = 0x007E,
  NASI_CMD_VAL_LTE_SIB16_NETWORK_TIME_IND           = 0x007F,
  NASI_CMD_VAL_SET_LTE_BAND_PRIORITY            = 0x0080,
  NASI_CMD_VAL_GET_EMBMS_SIG_EXT                = 0x0081,
  NASI_CMD_VAL_LTE_CPHY_CA_IND        = 0x0082,
  NASI_CMD_VAL_GET_LTE_BAND_PRIORITY            = 0x0083,
  NASI_CMD_VAL_PERFORM_INCREMENTAL_NETWORK_SCAN  = 0x0085,
  NASI_CMD_VAL_SUBSCRIPTION_CHANGE_IND    = 0x0086,
  NASI_CMD_VAL_IMS_DEREGISTRATION         = 0x0087,
  NASI_CMD_VAL_SET_DRX                    = 0x0088,
  NASI_CMD_VAL_GET_DRX                    = 0x0089,
  NASI_CMD_VAL_CSG_SEARCH_SELECTION_CONFIG      = 0x008A,
  NASI_CMD_VAL_CSG_IMMEDIATE_SEARCH_SELECTION   = 0x008B,
  NASI_CMD_VAL_GET_CSG_SEARCH_SELECTION_CONFIG  = 0x008C,
  NASI_CMD_VAL_SSAC_INFO_IND         = 0x008D,
  NASI_CMD_VAL_GET_LTE_EMBMS_INFO         = 0x008E,
  NASI_CMD_VAL_GET_SERVING_CELL_SIB       = 0x008F,
  NASI_CMD_VAL_SSAC_CHANGE_INFO_IND         = 0x0090,
  NASI_CMD_VAL_GET_SSAC_INFO         = 0x0091,
  NASI_CMD_VAL_SET_PERIODIC_SEARCH_ALLOWED  = 0x0092,
  NASI_CMD_VAL_GET_ACB_INFO           = 0x0094,
  NASI_CMD_VAL_SET_DATA_SUBS_PRIORITY = 0x0095,
  NASI_CMD_VAL_GET_DATA_SUBS_PRIORITY = 0x0096,
  NASI_CMD_VAL_DATA_SUBS_PRIORITY_IND = 0x0097,
  NASI_CMD_VAL_AVOID_TUNEAWAY_REQ = 0x0098,
  NASI_CMD_VAL_SET_MCC = 0x0099,
  NASI_CMD_VAL_SET_DATA_ROAMING_STATUS = 0x009A,
  NASI_CMD_VAL_GET_DATA_ROAMING_STATUS = 0x009B,
  NASI_CMD_VAL_SET_SRVCC = 0x009C,
  NASI_CMD_VAL_SET_BSR_TIMER = 0x009D,
  NASI_CMD_VAL_GET_BSR_TIMER = 0x009E,
  NASI_CMD_VAL_T3346_TIMER_STATUS_CHANGE_IND = 0x00A0,
  NASI_CMD_VAL_SET_DRX_SCALING_FACTOR = 0x009F,
  NASI_CMD_VAL_IMS_CALL_STATE_NOTIFICATION = 0x00A1,
  NASI_CMD_VAL_CALL_MODE_IND         = 0x00A2,
  NASI_CMD_VAL_GET_CALL_MODE         = 0x00A3,
  NASI_CMD_VAL_VOLTE_STATE_NOTIFICATION         = 0x00A4,
  NASI_CMD_VAL_SET_RPM_PARAMETERS        = 0x00A9,
  NASI_CMD_VAL_GET_RPM_PARAMETERS        = 0x00AA,
  NASI_CMD_VAL_SET_RPM_STATE        = 0x00AB,
  NASI_CMD_VAL_SET_RPM_PARAMETERS_2 = 0x00B9,
  NASI_CMD_VAL_SET_CELL_LOCK_CONFIG       = 0x00AF,
  NASI_CMD_VAL_EDRX_CHANGE_INFO_IND = 0x00BF,
  NASI_CMD_VAL_SET_EDRX_PARAMS = 0x00C0,
  NASI_CMD_VAL_GET_EDRX_PARAMS = 0x00C1,
  NASI_CMD_VAL_ABORT_SCAN = 0x00C2,
  NASI_CMD_VAL_LTE_RRC_TX_INFO_IND = 0x00C6,
  NASI_CMD_VAL_GET_LTE_RRC_TX_INFO = 0x00C7,
  NASI_CMD_VAL_SET_GNSS_SESSION_STATUS = 0x00C8,
  #ifdef FEATURE_ENABLE_QMI_DMS
  NASI_CMD_VAL_SET_OPERATING_MODE = 0X00D7,
  NASI_CMD_VAL_GET_OPERATING_MODE = 0X00D8,
  NASI_CMD_VAL_GET_BAND_CAPABILITY = 0X00D9,
  NASI_CMD_VAL_GET_PSM_CONFIG_PARAMS = 0x00DA,
  NASI_CMD_VAL_SET_PSM_CONFIG_PARAMS = 0x00DB,
  NASI_CMD_VAL_PSM_CONFIG_PARAMS_CHANGE_IND = 0x00DC,
  NASI_CMD_VAL_PSM_STATUS_IND = 0x00DD,
  NASI_CMD_VAL_PSM_ENTER = 0x00DE,
  #endif
  NASI_CMD_VAL_SET_CELL_CONFIG = 0x00D8,
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  NASI_CMD_VAL_SET_APP_PRIORITY=0x00DC,
  #endif
  NASI_CMD_VAL_GET_NEXT_SFN_REQ = 0x00EF,
  NASI_CMD_VAL_SET_SFN_CONFIG_REQ = 0x00F0,
  NASI_CMD_VAL_GET_JAMMING_STATUS=0x00F5,
#ifdef FEATURE_FSK_TX
  NASI_CMD_VAL_FSK_DATA=0x00F8,
  NASI_CMD_VAL_SET_FSK_HOP_TABLE=0x00F9,
  NASI_CMD_VAL_GET_FSK_HOP_TABLE=0x00FA,
  NASI_CMD_VAL_FSK_START=0x00FB,
  NASI_CMD_VAL_SET_FSK_DEBUG=0x00FC,
  NASI_CMD_VAL_GET_FSK_DEBUG=0x00FD,
  NASI_CMD_VAL_FSK_STOP=0x00FE,
  NASI_CMD_VAL_SET_FSK_PCL=0x00FF,
  NASI_CMD_VAL_GET_FSK_PCL=0x0100,
#endif
  NASI_CMD_VAL_GET_SCAN_CONFIG=0x0102,
  NASI_CMD_VAL_GET_CURRENT_SCAN_INFO=0x010D,  
  NASI_CMD_VAL_GET_CE_LEVEL_INFO=0x112,
  NASI_CMD_VAL_WWAN_SLEEP_INFO_IND=0x124,
  NASI_CMD_VAL_GET_WWAN_SLEEP_THRESHOLD=0x125,
  NASI_CMD_VAL_SET_WWAN_SLEEP_THRESHOLD=0x126,
  NASI_CMD_VAL_GET_CELL_SELECT_INFO=0x128,
   #ifdef FEATURE_FMD_SPEED_INFO
  NASI_CMD_VAL_GET_FMD_SPEED_INFO=0x151,
   #endif
/* QC EXTERNAL QMI COMMAND RANGE IS 0x0000 - 0x5555.
   Add the next external QMI Command here */

/* VENDOR SPECIFIC QMI COMMAND RANGE IS 0x5556 - 0xAAAA.
   IMPORTANT!
   Add the vendor specific QMI Commands within this range only to avoid
   conflicts with QC QMI commands that would get released in future */

/* RESERVED QC QMI COMMAND RANGE IS 0xAAAB - 0xFFFE */
  NASI_CMD_VAL_WIDTH                      = 0xFFFF
} qmi_nasi_cmd_val_e_type;

//===========================================================================
// GLOBALS
//===========================================================================
struct qmi_nasi_global_s qmi_nasi_global;
struct qmi_nas_nitz_time_info_s qmi_nasi_nitz_time;
struct qmi_nas_ssac_change_info_s  qmi_nasi_ssac_info;
/*===========================================================================

                               INTERNAL DATA                           =====================================================================*/

/*Calculated Display params*/
  //display_operator_info[2][2][2]
  boolean display_operator_info_param[MMGSDI_EONS_IN_ROAMING_NW][MMGSDI_EONS_RPLMN_DISPLAY_BIT_VAL_1][MMGSDI_EONS_SPN_DISPLAY_BIT_VAL_1]=
  {
    /*HOME*/
    {
      {0,0},
      {1,1},
    },

    /*ROAM*/
    {
      {1,1},
      {1,1},
    },
  };

    //display_spn[2][2][2]
  boolean display_spn_param[MMGSDI_EONS_IN_ROAMING_NW][MMGSDI_EONS_RPLMN_DISPLAY_BIT_VAL_1][MMGSDI_EONS_SPN_DISPLAY_BIT_VAL_1]=
  {
    /*HOME*/
    {
      {1,1},
      {1,1},
    },

    /*ROAM*/
    {
      {1,0},
      {1,0},
    },
  };

/*===========================================================================*/

/*---------------------------------------------------------------------------
  QMI_NAS service command handlers
  forward declarations & cmd handler dispatch table definition
---------------------------------------------------------------------------*/

#ifdef _WIN32
#define NAS_HDLR_PROTOTYPE(x)   dsm_item_type* x( qmi_mmode_svc_info_type*, qmi_mmode_qcsi_transaction_type*, void*, dsm_item_type** )
#else
#define NAS_HDLR_PROTOTYPE(x)   dsm_item_type* x( qmi_mmode_svc_info_type*, qmi_mmode_qcsi_transaction_type*, void*, dsm_item_type** )__attribute__((unused))
#endif

static NAS_HDLR_PROTOTYPE(qmi_nasi_reset);
static NAS_HDLR_PROTOTYPE(qmi_nasi_abort);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_event_report);
static NAS_HDLR_PROTOTYPE(qmi_nasi_indication_register);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_signal_strength);
static NAS_HDLR_PROTOTYPE(qmi_nasi_perform_network_scan);
static NAS_HDLR_PROTOTYPE(qmi_nasi_initiate_network_register);
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
static NAS_HDLR_PROTOTYPE(qmi_nasi_initiate_attach);
#endif

static NAS_HDLR_PROTOTYPE(qmi_nasi_get_serving_system);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_home_network);
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_preferred_networks);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_preferred_networks);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_forbidden_networks);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_forbidden_networks);

static NAS_HDLR_PROTOTYPE(qmi_nasi_set_technology_preference);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_technology_preference);
#endif
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_accolc);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_accolc);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_system_preference);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_device_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_device_config);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_rf_band_info);
#if defined(FEATURE_HDR)
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_an_aaa_status);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_sys_sel_pref);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_sys_sel_pref);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_ddtm_preference);

static NAS_HDLR_PROTOTYPE(qmi_nasi_get_operator_name_data);

#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_csp_plmn_mode_bit);
#endif
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
static NAS_HDLR_PROTOTYPE(qmi_nasi_update_akey);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_3gpp2_subscription_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_3gpp2_subscription_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_mob_cai_rev);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_rtre_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rtre_config);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cell_location_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_plmn_name);
#ifdef FEATURE_DUAL_SIM
static NAS_HDLR_PROTOTYPE(qmi_nasi_bind_subscription);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_mode_pref);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_dual_standby_pref_new);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_sys_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_sig_info);
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
static NAS_HDLR_PROTOTYPE(qmi_nasi_config_sig_info);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_err_rate);
#ifdef FEATURE_QMI_NAS_HDR
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_hdr_subtype);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_hdr_color_code);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cm_acq_mode);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rx_diversity);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_tx_rx_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_update_akey_ext);
#ifdef FEATURE_DUAL_SIM
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_dual_standby_pref);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_detach_lte);
static NAS_HDLR_PROTOTYPE(qmi_nasi_block_lte_plmn);
static NAS_HDLR_PROTOTYPE(qmi_nasi_unblock_lte_plmn);
static NAS_HDLR_PROTOTYPE(qmi_nasi_reset_lte_plmn_blocking);
#ifdef FEATURE_LTE_EMBMS
static NAS_HDLR_PROTOTYPE(qmi_nasi_config_embms);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_embms_status);
#endif
#ifdef FEATURE_CDMA
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cdma_position_info);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_force_network_search);
#ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_managed_roaming_config);
#endif
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_centralized_eons_support_status);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_config_sig_info2);
#ifdef FEATURE_TDSCDMA
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_tds_cell_and_position_info);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_hplmn_irat_search_timer);
#ifdef FEATURE_LTE_EMBMS
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_embms_sig);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_limit_sys_info_ind_reporting);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_sys_info_ind_reporting_limit);
static NAS_HDLR_PROTOTYPE(qmi_nasi_update_ims_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_ims_pref_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_config_plmn_name_ind_reporting);
#if defined (FEATURE_CDMA)
static NAS_HDLR_PROTOTYPE(qmi_nasi_cdma_avoid_system);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cdma_avoid_system_list);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_hplmn_search_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_hplmn_search_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_builtin_plmn_list);
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
NAS_HDLR_PROTOTYPE(qmi_nasi_set_e911_state);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_lte_sib16_network_time);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_lte_band_priority);
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_app_priority);
#endif
#ifdef FEATURE_LTE_EMBMS
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_embms_sig_ext);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_lte_band_priority_list);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_subscription_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_perform_incremental_network_scan);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_network_time);
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
NAS_HDLR_PROTOTYPE(qmi_nasi_ims_deregistration);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_drx);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_drx);
#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
static NAS_HDLR_PROTOTYPE(qmi_nasi_csg_search_selection_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_csg_immediate_search_selection);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_csg_search_selection_config);
#endif
#endif
#ifdef FEATURE_LTE_EMBMS
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_lte_embms_info);
#endif
#ifndef REMOVE_QMI_NAS_GET_SERV_CELL_SIB_V01
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_serving_cell_sib);
#endif
#ifndef REMOVE_QMI_NAS_GET_SSAC_INFO_V01
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_ssac_info);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_periodic_search_allowed);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_acb_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_scan_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_current_scan_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_data_subs_priority);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_data_subs_priority);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_srvcc);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_bsr_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_bsr_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_avoid_tuneaway_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_mcc);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_drx_scaling_factor);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_data_roaming_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_data_roaming_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_rpm_parameters);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rpm_state);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_edrx_params);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_edrx_params);
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
NAS_HDLR_PROTOTYPE(qmi_nasi_get_call_mode);
void qmi_nasi_generate_call_mode_ind( qmi_mmodei_msgr_type * msg_p );
NAS_HDLR_PROTOTYPE(qmi_nasi_volte_state_notification);
NAS_HDLR_PROTOTYPE(qmi_nasi_ims_call_state_notification);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_lte_rrc_tx_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_gnss_session_status);
#ifdef FEATURE_ENABLE_QMI_DMS
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_operating_mode);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_operating_mode);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_band_capability);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_psm_config_params);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_psm_config_params);
static NAS_HDLR_PROTOTYPE(qmi_nasi_psm_enter);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_abort_scan);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_next_sfn_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_sfn_config_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_jamming_status);
#ifdef FEATURE_FSK_TX
static NAS_HDLR_PROTOTYPE(qmi_nasi_fsk_data_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_fsk_hop_table_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_fsk_hop_table_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_fsk_start_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_fsk_debug_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_fsk_debug_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_fsk_stop_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_fsk_pcl_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_fsk_pcl_req);
#endif
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_ce_level_info_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_wwan_sleep_threshold);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_wwan_sleep_threshold);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cell_select_info_req);
  #ifdef FEATURE_FMD_SPEED_INFO
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_fmd_speed_info_req);
 #endif
static void qmi_nas_generate_net_scan_resp_ext ( sys_found_plmn_list_u_type *available_networks, sys_plmn_list_status_e_type available_networks_list_cnf, cm_network_list_type_e_type list_type);
static void qmi_nas_set_hplmn_irat_search_timer_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err );
boolean qmi_nas_get_nitz_time_from_cache(nas_get_network_time_resp_msg_v01 *resp);
void qmi_nas_update_cached_time_info( cm_mm_ss_info_s_type *p_info );
#ifndef REMOVE_QMI_NAS_GET_SSAC_INFO_V01
void qmi_nasi_ssac_info_ind( lte_rrc_ssac_params_s * );
void qmi_nasi_ssac_change_info_ind( lte_rrc_ssac_params_s * );
#endif
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
void qmi_nasi_gen_emm_t3402_changed_ind( emm_t3402_changed_ind_s_type * );
#endif
void qmi_nasi_acb_info_ind( lte_rrc_ac_barring_info_s * );
void qmi_nasi_set_data_subs_priority_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nasi_set_srvcc_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nasi_avoid_tuneaway_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
static void qmi_nasi_generate_set_drx_scaling_factor_rsp ( errno_enum_type status);
void qmi_nasi_set_data_roaming_status_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
static void qmi_nasi_generate_manual_scan_fail_ind ( sys_modem_as_id_e_type asid );

static dsm_item_type* qmi_nasi_set_cell_lock_config ( qmi_mmode_svc_info_type*, qmi_mmode_qcsi_transaction_type*, void*, dsm_item_type** );
static void qmi_nasi_set_cell_lock_config_resp (lte_rrc_cell_lock_status_e status);

static dsm_item_type *qmi_nasi_set_cell_config ( void *, qmi_mmode_qcsi_transaction_type*, void *, dsm_item_type ** );
static void qmi_nasi_set_cell_config_resp (lte_rrc_cell_lock_status_e status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rpm_parameters_2);

static void qmi_nasi_edrx_change_info_ind(qmi_cm_ph_info_s_type *p_info);
void qmi_nas_set_edrx_params_resp();
void qmi_nas_get_edrx_params_resp(mm_cmd_get_edrx_params_rsp_s *p_info);
void qmi_nas_gen_lte_rrc_tx_info_ind(cm_mm_ss_info_s_type       * p_ss_info);
void qmi_nas_set_gnss_session_status_resp(qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ss_cmd_err_e_type cm_ss_cmd_err);
void qmi_nas_set_mcc_resp(qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err);
void qmi_nas_send_jamming_status(qmi_nas_jamming_status_msg_s_type *p_info);
#ifdef FEATURE_FSK_TX
void qmi_nas_fsk_data_resp(geran_fsk_data_rsp_type *p_info);
void qmi_nas_set_fsk_hop_table_resp(geran_fsk_hop_table_rsp_type *p_info);
void qmi_nas_get_fsk_hop_table_resp(geran_fsk_hop_table_query_rsp_type *p_info);
void qmi_nas_fsk_start_resp(geran_fsk_start_rsp_type *p_info);
void qmi_nas_set_fsk_debug_resp(geran_fsk_debug_rsp_type *p_info);
void qmi_nas_get_fsk_debug_resp(geran_fsk_debug_query_rsp_type *p_info);
void qmi_nas_fsk_stop_resp(geran_fsk_stop_rsp_type *p_info);
void qmi_nas_set_fsk_pcl_resp(geran_fsk_pcl_rsp_type *p_info);
void qmi_nas_get_fsk_pcl_resp(geran_fsk_pcl_query_rsp_type *p_info);  
#endif
void qmi_nas_get_cell_select_info_resp(qmi_nasi_cell_select_info_type *p_info);
  #ifdef FEATURE_FMD_SPEED_INFO
void qmi_nas_get_fmd_speed_info_resp(lte_rrc_fmd_speed_info_rsp_s *p_info);
#endif

static void qmi_nasi_populate_get_preferred_nw_resp(nas_get_preferred_networks_resp_msg_v01 *nas_get_pref_resp);
void qmi_nas_get_next_sfn_resp(lte_cphy_get_next_sfn_rsp_s *p_info);
void qmi_nas_set_sfn_config_resp(lte_cphy_set_sfn_config_rsp_s *p_info);
void qmi_nas_sfn_threshold_reached_ind(lte_cphy_sfn_threshold_reached_ind_s *p_info);
void qmi_nas_set_true_srv_status(cm_3gpp_service_status_s_type *p_info );
#ifdef FEATURE_ENABLE_QMI_DMS
void qmi_nas_set_operating_mode_resp(qmi_mmode_qcsi_transaction_type *p_cmd_buf,cm_ph_cmd_err_e_type ph_cmd_err);
static void qmi_nasi_get_psm_config_params_resp(cm_psm_get_cfg_params_rsp_s_type psm_cfg_params_rsp);
static void qmi_nasi_psm_config_params_change_ind ( cm_mm_psm_cfg_change_ind_s_type psm_cfg_params_ind);
static void qmi_nasi_psm_status_ind(cm_psm_status_ind_s_type   psm_status_ind);
static void qmi_nasi_operating_mode_ind(sys_oprt_mode_e_type   oprt_mode);
#endif
void qmi_nas_get_ce_level_info_resp(lte_cphy_ce_level_rpt_rsp_s *p_info);
void qmi_nas_wwan_sleep_info_ind ( uint32 sleep_duration);
#define NAS_HDLR(a,b)  QMI_MMODE_SVC_RAW_MSG_HDLR( (uint16)a, (qmi_mmode_svc_raw_msg_hdlr_ftype) b )

static qmi_mmode_svc_cmd_hdlr_type  qmi_nasi_cmd_callbacks[NASI_CMD_MAX] =
{
    #ifndef REMOVE_QMI_NAS_RESET_V01
    NAS_HDLR( NASI_CMD_VAL_RESET,                       qmi_nasi_reset ),
    #endif
    #ifndef REMOVE_QMI_NAS_ABORT_V01
    NAS_HDLR( NASI_CMD_VAL_ABORT,                       qmi_nasi_abort ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_EVENT_REPORT_V01
    NAS_HDLR( NASI_CMD_VAL_SET_EVENT_REPORT,            qmi_nasi_set_event_report ),
    #endif
    #ifndef REMOVE_QMI_NAS_INDICATION_REGISTER_V01
    NAS_HDLR( NASI_CMD_VAL_INDICATION_REGISTER,         qmi_nasi_indication_register ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SIGNAL_STRENGTH_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SIGNAL_STRENGTH,         qmi_nasi_get_signal_strength ),
    #endif
    #ifndef REMOVE_QMI_NAS_PERFORM_NETWORK_SCAN_V01
    NAS_HDLR( NASI_CMD_VAL_PERFORM_NETWORK_SCAN,        qmi_nasi_perform_network_scan ),
    #endif
    #ifndef REMOVE_QMI_NAS_INITIATE_NETWORK_REGISTER_V01
    NAS_HDLR( NASI_CMD_VAL_INITIATE_NETWORK_REGISTER,   qmi_nasi_initiate_network_register ),
    #endif
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    NAS_HDLR( NASI_CMD_VAL_INITIATE_ATTACH,             qmi_nasi_initiate_attach ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SERVING_SYSTEM,          qmi_nasi_get_serving_system ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_HOME_NETWORK_V01
    NAS_HDLR( NASI_CMD_VAL_GET_HOME_NETWORK,            qmi_nasi_get_home_network ),
    #endif
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    #ifndef REMOVE_QMI_NAS_GET_PREFERRED_NETWORKS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_PREFERRED_NETWORKS,      qmi_nasi_get_preferred_networks ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_PREFERRED_NETWORKS_V01
    NAS_HDLR( NASI_CMD_VAL_SET_PREFERRED_NETWORKS,      qmi_nasi_set_preferred_networks ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_FORBIDDEN_NETWORKS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_FORBIDDEN_NETWORKS,      qmi_nasi_get_forbidden_networks ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_FORBIDDEN_NETWORKS_V01
    NAS_HDLR( NASI_CMD_VAL_SET_FORBIDDEN_NETWORKS,      qmi_nasi_set_forbidden_networks ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_TECHNOLOGY_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_TECHNOLOGY_PREFERENCE,   qmi_nasi_set_technology_preference ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_TECHNOLOGY_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_TECHNOLOGY_PREFERENCE,   qmi_nasi_get_technology_preference ),
    #endif
#endif
    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    #ifndef REMOVE_QMI_NAS_GET_ACCOLC_V01
    NAS_HDLR( NASI_CMD_VAL_GET_ACCOLC,                  qmi_nasi_get_accolc ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_ACCOLC_V01
    NAS_HDLR( NASI_CMD_VAL_SET_ACCOLC,                  qmi_nasi_set_accolc ),
    #endif
    #endif
    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    #ifndef REMOVE_QMI_NAS_GET_NETWORK_SYSTEM_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SYSTEM_PREFERENCE,       qmi_nasi_get_system_preference ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DEVICE_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DEVICE_CONFIG,           qmi_nasi_get_device_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DEVICE_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DEVICE_CONFIG,           qmi_nasi_set_device_config ),
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_GET_RF_BAND_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_RF_BAND_INFO,            qmi_nasi_get_rf_band_info ),
    #endif
    #if defined(FEATURE_HDR)
    #ifndef REMOVE_QMI_NAS_GET_AN_AAA_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_AN_AAA_STATUS,           qmi_nasi_get_an_aaa_status ),
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_SYS_SEL_PREF,            qmi_nasi_set_sys_sel_pref ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SYS_SEL_PREF,            qmi_nasi_get_sys_sel_pref ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DDTM_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DDTM_PREFERENCE,         qmi_nasi_set_ddtm_preference ),
    #endif
    //#ifndef REMOVE_QMI_NAS_GET_OPERATOR_NAME_DATA_V01
    NAS_HDLR( NASI_CMD_VAL_GET_OPERATOR_NAME_DATA,      qmi_nasi_get_operator_name_data ),
    //#endif
    #ifndef REMOVE_QMI_NAS_GET_CSP_PLMN_MODE_BIT_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CSP_PLMN_MODE_BIT,       qmi_nasi_get_csp_plmn_mode_bit ),
    #endif
    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    #ifndef REMOVE_QMI_NAS_UPDATE_AKEY_V01
    NAS_HDLR( NASI_CMD_VAL_UPDATE_AKEY,                 qmi_nasi_update_akey ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_3GPP2_SUBSCRIPTION_INFO, qmi_nasi_get_3gpp2_subscription_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_3GPP2_SUBSCRIPTION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_SET_3GPP2_SUBSCRIPTION_INFO, qmi_nasi_set_3gpp2_subscription_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_MOB_CAI_REV_V01
    NAS_HDLR( NASI_CMD_VAL_GET_MOB_CAI_REV,             qmi_nasi_get_mob_cai_rev ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_RTRE_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_RTRE_CONFIG,             qmi_nasi_get_rtre_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RTRE_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RTRE_CONFIG,             qmi_nasi_set_rtre_config ),
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CELL_LOCATION_INFO_V01
     NAS_HDLR( NASI_CMD_VAL_GET_CELL_LOCATION_INFO,      qmi_nasi_get_cell_location_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_PLMN_NAME_V01
    NAS_HDLR( NASI_CMD_VAL_GET_PLMN_NAME,               qmi_nasi_get_plmn_name ),
    #endif
    #ifdef FEATURE_DUAL_SIM
    #ifndef REMOVE_QMI_NAS_BIND_SUBSCRIPTION_V01
    NAS_HDLR( NASI_CMD_VAL_BIND_SUBSCRIPTION,           qmi_nasi_bind_subscription ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_MODE_PREF_V01
    NAS_HDLR( NASI_CMD_VAL_GET_MODE_PREF,               qmi_nasi_get_mode_pref ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DUAL_STANDBY_PREF_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DUAL_STANDBY_PREF_NEW,   qmi_nasi_set_dual_standby_pref_new ),
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SYS_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SYS_INFO,                qmi_nasi_get_sys_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SIG_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SIG_INFO,                qmi_nasi_get_sig_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_CONFIG_SIG_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_CONFIG_SIG_INFO,             qmi_nasi_config_sig_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_ERR_RATE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_ERR_RATE,                qmi_nasi_get_err_rate ),
    #endif
    #ifdef FEATURE_QMI_NAS_HDR
    #ifndef REMOVE_QMI_NAS_GET_HDR_SUBTYPE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_HDR_SUBTYPE,             qmi_nasi_get_hdr_subtype ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_HDR_COLOR_CODE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_HDR_COLOR_CODE,          qmi_nasi_get_hdr_color_code ),
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CURRENT_ACQ_SYS_MODE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CURRENT_ACQ_SYS_MODE,    qmi_nasi_get_cm_acq_mode ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RX_DIVERSITY_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RX_DIVERSITY,            qmi_nasi_set_rx_diversity ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_TX_RX_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_TX_RX_INFO,              qmi_nasi_get_tx_rx_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_UPDATE_AKEY_EXT_V01
    NAS_HDLR( NASI_CMD_VAL_UPDATE_AKEY_EXT,             qmi_nasi_update_akey_ext ),
    #endif
    #ifdef FEATURE_DUAL_SIM
    #ifndef REMOVE_QMI_NAS_GET_DUAL_STANDBY_PREF_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DUAL_STANDBY_PREF,       qmi_nasi_get_dual_standby_pref ),
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_DETACH_LTE_V01
    NAS_HDLR( NASI_CMD_VAL_DETACH_LTE,                  qmi_nasi_detach_lte ),
    #endif
    #ifndef REMOVE_QMI_NAS_BLOCK_LTE_PLMN_V01
    NAS_HDLR( NASI_CMD_VAL_BLOCK_LTE_PLMN,              qmi_nasi_block_lte_plmn ),
    #endif
    #ifndef REMOVE_QMI_NAS_UNBLOCK_LTE_PLMN_V01
    NAS_HDLR( NASI_CMD_VAL_UNBLOCK_LTE_PLMN,            qmi_nasi_unblock_lte_plmn ),
    #endif
    #ifndef REMOVE_QMI_NAS_RESET_LTE_PLMN_BLOCKING_V01
    NAS_HDLR( NASI_CMD_VAL_RESET_LTE_PLMN_BLOCKING,     qmi_nasi_reset_lte_plmn_blocking ),
    #endif
    #ifndef REMOVE_QMI_NAS_CONFIG_EMBMS_V01
    NAS_HDLR( NASI_CMD_VAL_CONFIG_EMBMS,                qmi_nasi_config_embms ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_EMBMS_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_EMBMS_STATUS,            qmi_nasi_get_embms_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CDMA_POSITION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CDMA_POSITION_INFO,      qmi_nasi_get_cdma_position_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_FORCE_NETWORK_SEARCH_V01
    NAS_HDLR( NASI_CMD_VAL_FORCE_NETWORK_SEARCH,        qmi_nasi_force_network_search ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_MANAGED_ROAMING_CONFIG,  qmi_nasi_get_managed_roaming_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CENTRALIZED_EONS_SUPPORT_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CENTRALIZED_EONS_SUPPORT_STATUS,  qmi_nasi_get_centralized_eons_support_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_CONFIG_SIG_INFO2_V01
    NAS_HDLR( NASI_CMD_VAL_CONFIG_SIG_INFO2,            qmi_nasi_config_sig_info2 ),
    #endif
    #ifdef FEATURE_TDSCDMA
    #ifndef REMOVE_QMI_NAS_GET_TDS_CELL_AND_POSITION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_TDS_CELL_AND_POSITION_INFO,  qmi_nasi_get_tds_cell_and_position_info ),
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_SET_HPLMN_IRAT_SEARCH_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_SET_HPLMN_IRAT_SEARCH_TIMER,      qmi_nasi_set_hplmn_irat_search_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_EMBMS_SIG,                    qmi_nasi_get_embms_sig ),
    #endif
    #ifndef REMOVE_QMI_NAS_LIMIT_SYS_INFO_IND_REPORTING_V01
    NAS_HDLR( NASI_CMD_VAL_LIMIT_SYS_INFO_IND_REPORTING,  qmi_nasi_limit_sys_info_ind_reporting ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SYS_INFO_IND_REPORTING_LIMIT_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SYS_INFO_IND_REPORTING_LIMIT,  qmi_nasi_get_sys_info_ind_reporting_limit ),
    #endif
    #ifndef REMOVE_QMI_NAS_UPDATE_IMS_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_UPDATE_IMS_STATUS,         qmi_nasi_update_ims_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_IMS_PREF_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_IMS_PREF_STATUS,       qmi_nasi_get_ims_pref_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_CONFIG_PLMN_NAME_IND_REPORTING_V01
    NAS_HDLR( NASI_CMD_VAL_CONFIG_PLMN_NAME_IND_REPORTING, qmi_nasi_config_plmn_name_ind_reporting ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_RPM_PARAMETERS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_RPM_PARAMETERS,             qmi_nasi_get_rpm_parameters ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RPM_STATE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RPM_STATE,             qmi_nasi_set_rpm_state ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RPM_PARAMETERS_2_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RPM_PARAMETERS_2,             qmi_nasi_set_rpm_parameters_2 ),
    #endif
    #ifndef REMOVE_QMI_NAS_CDMA_AVOID_SYSTEM_V01
    NAS_HDLR( NASI_CMD_VAL_CDMA_AVOID_SYSTEM,                 qmi_nasi_cdma_avoid_system ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CDMA_AVOID_SYSTEM_LIST_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CDMA_AVOID_SYSTEM_LIST,        qmi_nasi_get_cdma_avoid_system_list ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_HPLMN_SEARCH_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_SET_HPLMN_SEARCH_TIMER,      qmi_nasi_set_hplmn_search_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_HPLMN_SEARCH_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_GET_HPLMN_SEARCH_TIMER,      qmi_nasi_get_hplmn_search_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_BUILTIN_PLMN_LIST_V01
    NAS_HDLR( NASI_CMD_VAL_SET_BUILTIN_PLMN_LIST,      qmi_nasi_set_builtin_plmn_list ),
    #endif
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
    #ifndef REMOVE_QMI_NAS_SET_E911_STATE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_E911_STATE,           qmi_nasi_set_e911_state ),
    #endif
#endif
    #ifndef REMOVE_QMI_NAS_GET_LTE_SIB16_NETWORK_TIME_V01
    NAS_HDLR( NASI_CMD_VAL_GET_LTE_SIB16_NETWORK_TIME,  qmi_nasi_get_lte_sib16_network_time ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_LTE_BAND_PRIORITY_V01
    NAS_HDLR( NASI_CMD_VAL_SET_LTE_BAND_PRIORITY,             qmi_nasi_set_lte_band_priority ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_EXT_V01
    NAS_HDLR( NASI_CMD_VAL_GET_EMBMS_SIG_EXT,             qmi_nasi_get_embms_sig_ext ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_LTE_BAND_PRIORITY_LIST_V01
    NAS_HDLR( NASI_CMD_VAL_GET_LTE_BAND_PRIORITY,             qmi_nasi_get_lte_band_priority_list ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SUBSCRIPTION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SUBSCRIPTION_INFO,      qmi_nasi_get_subscription_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
    NAS_HDLR( NASI_CMD_VAL_PERFORM_INCREMENTAL_NETWORK_SCAN, qmi_nasi_perform_incremental_network_scan ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_NETWORK_TIME_V01
    NAS_HDLR( NASI_CMD_VAL_GET_NETWORK_TIME,             qmi_nasi_get_network_time ),
    #endif
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
    #ifndef REMOVE_QMI_NAS_IMS_PROCEED_WITH_SUBSCRIPTION_CHANGE_V01
    NAS_HDLR( NASI_CMD_VAL_IMS_DEREGISTRATION,          qmi_nasi_ims_deregistration ),
    #endif
#endif
    #ifndef REMOVE_QMI_NAS_SET_DRX_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DRX,                  qmi_nasi_set_drx ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DRX_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DRX,                  qmi_nasi_get_drx ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_LTE_RRC_TX_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_LTE_RRC_TX_INFO,     qmi_nasi_get_lte_rrc_tx_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_GNSS_SESSION_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_SET_GNSS_SESSION_STATUS,     qmi_nasi_set_gnss_session_status ),
    #endif
    #ifdef FEATURE_FEMTO_CSG
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    #ifndef REMOVE_QMI_NAS_CSG_SEARCH_SELECTION_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_CSG_SEARCH_SELECTION_CONFIG,          qmi_nasi_csg_search_selection_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_CSG_IMMEDIATE_SEARCH_SELECTION_V01
    NAS_HDLR( NASI_CMD_VAL_CSG_IMMEDIATE_SEARCH_SELECTION,          qmi_nasi_csg_immediate_search_selection ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CSG_SEARCH_SELECTION_CONFIGURATION_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CSG_SEARCH_SELECTION_CONFIG,          qmi_nasi_get_csg_search_selection_config ),
    #endif
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_GET_LTE_EMBMS_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_LTE_EMBMS_INFO,          qmi_nasi_get_lte_embms_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SERV_CELL_SIB_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SERVING_CELL_SIB,          qmi_nasi_get_serving_cell_sib ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SSAC_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SSAC_INFO,             qmi_nasi_get_ssac_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_PERIODIC_SEARCH_ALLOWED_V01
    NAS_HDLR( NASI_CMD_VAL_SET_PERIODIC_SEARCH_ALLOWED,          qmi_nasi_set_periodic_search_allowed ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_ACB_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_ACB_INFO,                  qmi_nasi_get_acb_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SCAN_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SCAN_CONFIG,                  qmi_nasi_get_scan_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CURRENT_SCAN_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CURRENT_SCAN_INFO,                  qmi_nasi_get_current_scan_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DATA_SUBS_PRIORITY_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DATA_SUBS_PRIORITY,             qmi_nasi_set_data_subs_priority ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DATA_SUBS_PRIORITY_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DATA_SUBS_PRIORITY,             qmi_nasi_get_data_subs_priority ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_SRVCC_V01
    NAS_HDLR( NASI_CMD_VAL_SET_SRVCC,                          qmi_nasi_set_srvcc ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_BSR_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_SET_BSR_TIMER,             qmi_nasi_set_bsr_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_BSR_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_GET_BSR_TIMER,             qmi_nasi_get_bsr_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_AVOID_TUNEAWAY_V01
    NAS_HDLR( NASI_CMD_VAL_AVOID_TUNEAWAY_REQ,             qmi_nasi_avoid_tuneaway_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_MCC_V01
    NAS_HDLR( NASI_CMD_VAL_SET_MCC,             qmi_nasi_set_mcc ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DRX_SCALING_FACTOR_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DRX_SCALING_FACTOR,             qmi_nasi_set_drx_scaling_factor ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DATA_ROAMING_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DATA_ROAMING_STATUS,             qmi_nasi_set_data_roaming_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DATA_ROAMING_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DATA_ROAMING_STATUS,             qmi_nasi_get_data_roaming_status ),
    #endif
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
    #ifndef REMOVE_QMI_NAS_GET_CALL_MODE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CALL_MODE,             qmi_nasi_get_call_mode ),
    #endif
    #ifndef REMOVE_QMI_NAS_VOLTE_STATE_NOTIFICATION_V01
    NAS_HDLR( NASI_CMD_VAL_VOLTE_STATE_NOTIFICATION,             qmi_nasi_volte_state_notification ),
    #endif
    #ifndef REMOVE_QMI_NAS_IMS_CALL_STATE_NOTIFICATION_V01
    NAS_HDLR( NASI_CMD_VAL_IMS_CALL_STATE_NOTIFICATION,             qmi_nasi_ims_call_state_notification ),
    #endif
#endif
    #ifndef REMOVE_QMI_NAS_SET_CELL_LOCK_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_SET_CELL_LOCK_CONFIG,           qmi_nasi_set_cell_lock_config ),
    #endif
    #ifndef REMOVE_NASI_CMD_VAL_SET_EDRX_PARAMS_V01
    NAS_HDLR( NASI_CMD_VAL_SET_EDRX_PARAMS,             qmi_nasi_set_edrx_params ),
    #endif
    #ifndef REMOVE_NASI_CMD_VAL_GET_EDRX_PARAMS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_EDRX_PARAMS,             qmi_nasi_get_edrx_params ),
    #endif
    #ifdef FEATURE_ENABLE_QMI_DMS
    #ifndef REMOVE_QMI_NAS_SET_OPERATING_MODE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_OPERATING_MODE,              qmi_nasi_set_operating_mode ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_OPERATING_MODE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_OPERATING_MODE,              qmi_nasi_get_operating_mode ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_BAND_CAPABILITY_V01
    NAS_HDLR( NASI_CMD_VAL_GET_BAND_CAPABILITY,              qmi_nasi_get_band_capability ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_PSM_CONFIG_PARAMS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_PSM_CONFIG_PARAMS,              qmi_nasi_get_psm_config_params),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_PSM_CONFIG_PARAMS_V01
    NAS_HDLR( NASI_CMD_VAL_SET_PSM_CONFIG_PARAMS,              qmi_nasi_set_psm_config_params),
    #endif
    #ifndef REMOVE_QMI_NAS_PSM_ENTER_V01
    NAS_HDLR( NASI_CMD_VAL_PSM_ENTER,              qmi_nasi_psm_enter),
    #endif
    #endif
    #ifndef REMOVE_QMI_NAS_SET_APP_PRIORITY_V01
    NAS_HDLR( NASI_CMD_VAL_SET_APP_PRIORITY,             qmi_nasi_set_app_priority ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_CELL_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_SET_CELL_CONFIG,           qmi_nasi_set_cell_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_ABORT_SCAN_V01
    NAS_HDLR( NASI_CMD_VAL_ABORT_SCAN,    qmi_nasi_abort_scan ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_NEXT_SFN_REQ_V01
    NAS_HDLR( NASI_CMD_VAL_GET_NEXT_SFN_REQ,    qmi_nasi_get_next_sfn_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_SFN_CONFIG_REQ_V01
    NAS_HDLR( NASI_CMD_VAL_SET_SFN_CONFIG_REQ,    qmi_nasi_set_sfn_config_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_JAMMING_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_JAMMING_STATUS,    qmi_nasi_get_jamming_status ),
    #endif
    #ifdef FEATURE_FSK_TX
    #ifndef REMOVE_QMI_NAS_FSK_DATA_V01
    NAS_HDLR( NASI_CMD_VAL_FSK_DATA,    qmi_nasi_fsk_data_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_FSK_HOP_TABLE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_FSK_HOP_TABLE,    qmi_nasi_set_fsk_hop_table_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_FSK_HOP_TABLE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_FSK_HOP_TABLE,    qmi_nasi_get_fsk_hop_table_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_FSK_START_V01
    NAS_HDLR( NASI_CMD_VAL_FSK_START,    qmi_nasi_fsk_start_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_FSK_DEBUG_V01
    NAS_HDLR( NASI_CMD_VAL_SET_FSK_DEBUG,    qmi_nasi_set_fsk_debug_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_FSK_DEBUG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_FSK_DEBUG,    qmi_nasi_get_fsk_debug_req ),
    #endif   
    #ifndef REMOVE_QMI_NAS_FSK_STOP_V01
    NAS_HDLR( NASI_CMD_VAL_FSK_STOP,    qmi_nasi_fsk_stop_req ),
    #endif  
    #ifndef REMOVE_QMI_NAS_SET_FSK_PCL_V01
    NAS_HDLR( NASI_CMD_VAL_SET_FSK_PCL,    qmi_nasi_set_fsk_pcl_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_FSK_PCL_V01
    NAS_HDLR( NASI_CMD_VAL_GET_FSK_PCL,    qmi_nasi_get_fsk_pcl_req ),
    #endif  
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CE_LEVEL_INFO_REQ_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CE_LEVEL_INFO,    qmi_nasi_get_ce_level_info_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_WWAN_SLEEP_THRESHOLD_V01
    NAS_HDLR( NASI_CMD_VAL_GET_WWAN_SLEEP_THRESHOLD,    qmi_nasi_get_wwan_sleep_threshold ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_WWAN_SLEEP_THRESHOLD_V01
    NAS_HDLR( NASI_CMD_VAL_SET_WWAN_SLEEP_THRESHOLD,    qmi_nasi_set_wwan_sleep_threshold ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CELL_SELECT_INFO_REQ_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CELL_SELECT_INFO,    qmi_nasi_get_cell_select_info_req ),
    #endif
  #ifdef FEATURE_FMD_SPEED_INFO
    #ifndef REMOVE_QMI_NAS_GET_FMD_SPEED_INFO_REQ_V01
    NAS_HDLR( NASI_CMD_VAL_GET_FMD_SPEED_INFO,    qmi_nasi_get_fmd_speed_info_req ),
    #endif
   #endif
};

/*---------------------------------------------------------------------------
  Each QMI link (usb, BT etc) has its own NAS state
---------------------------------------------------------------------------*/
qmi_mmode_svc_info_type  qmi_nas_state;

/*---------------------------------------------------------------------------
  QMI_WS instance configurations
---------------------------------------------------------------------------*/
static void     qmi_nasi_reset_client(void *);

static qmi_mmode_svc_config_type  qmi_nasi_cfg;

/*===========================================================================

                   NEW FW FUNCTIONS

===========================================================================*/


/*===========================================================================
  FUNCTION QMI_NASI_GET_CL_SP_BY_CMD_BUF()

  DESCRIPTION
    Retrieve client sp from the command buffer

  PARAMETERS
    cmd_buf_p_in  :  command buffer

  RETURN VALUE
    cl_sp   :  client sp

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void* qmi_nasi_get_cl_sp_by_cmd_buf( qmi_mmode_qcsi_transaction_type* cmd_buf_p )
{

  return cmd_buf_p->clnt_info_ptr;
}

/*===========================================================================
  FUNCTION QMI_NASI_SEND_RESPONSE()

  DESCRIPTION
    Send the response to framework

  PARAMETERS
    clid: uint8

  RETURN VALUE
    TRUE if sent successfully, FALSE otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nasi_send_response
(
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  dsm_item_type *         msg_ptr
)
{

  qmi_csi_error                  err    = QMI_CSI_NO_ERR;

  if ( cmd_buf_p == NULL )
  {
    return FALSE;
  }

  /* Send the response */
  err = qmi_mmode_qcsi_send_resp_raw(&qmi_nas_state, &cmd_buf_p, msg_ptr);

  return ((err == QMI_CSI_NO_ERR)? TRUE: FALSE);
}

/*===========================================================================
  FUNCTION qmi_nasi_send_ind()

  DESCRIPTION
    This function is calls the QMI Framework API to send out the NAS service
    indication to client.
===========================================================================*/
void qmi_nasi_send_ind( qmi_nasi_client_state_type* cl_sp, qmi_nasi_cmd_val_e_type cmd, dsm_item_type* ind )
{

  qmi_csi_error                       err    = QMI_CSI_NO_ERR;

  if ( cl_sp )
  {
    err = qmi_mmode_qcsi_send_ind_raw(cl_sp->clnt, (unsigned int)cmd, ind);
  }
  else
  {
    dsm_free_packet( &ind );
  }
}

/*===========================================================================

                   INTERNAL FUNCTION FORWARD DECLARATIONS

===========================================================================*/
static void qmi_nasi_sys_sel_pref_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
  uint8         emergency_mode,
  #endif
  uint16        mode_pref,
  uint64        band_pref,
  uint16        prl_pref,
  uint16        roam_pref,
  sys_lte_band_mask_e_type        lte_band_pref,
  uint64        tds_band_pref,
  uint8         net_sel_mode_pref,
  uint32        srv_domain_pref,
  uint32        gw_acq_order_pref,
  sys_plmn_id_s_type plmn,
  cm_acq_pri_order_pref_s_type acq_order,
  sys_ue_usage_setting_e_type ue_usage_setting,
  sys_csg_id_type csg_id,
  sys_radio_access_tech_e_type csg_rat,
  sys_voice_domain_pref_e_type  voice_domain_pref,
  cm_ciot_lte_op_mode_e_type    ciot_lte_op_mode,
  sys_lte_band_mask_e_type      lte_m1_band_pref,
  sys_lte_band_mask_e_type      lte_nb1_band_pref
);

#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
static void qmi_nasi_current_nam_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         current_nam_index
);
#endif
static void qmi_nasi_ddtm_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         cur_ddtm_status,
  uint8         ddtm_pref,
  uint16        ddtm_act_mask,
  uint8         num_so_instances,
  uint16*       srv_option
);

static boolean qmi_nas_gen_report_ecio
(
  uint16        ecio,
  struct        report_status_s *p_rs,
  boolean       isHDR
);

static boolean qmi_nas_gen_report_sinr
(
 uint16 sinr,
 struct report_status_s *p_rs
);

#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
static boolean qmi_nasi_include_3GPP2_time_zone
(
  uint8 *lp_sec,
  int8  *ltm_offset,
  uint8 *daylt_savings,
  cm_mm_msim_ss_info_s_type *p_ss_info
);
#endif

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
static boolean nasi_convert_mm_info_oper_name(
  uint8 *, mmgsdi_eons_encoding_enum_type,
  char *, uint8 *, uint8, uint8 );

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE)
#ifndef FEATURE_MMODE_DISABLE_UIM
static void qmi_nasi_generate_get_preferred_nw_resp( mmgsdi_read_cnf_type *);
#endif
static void qmi_nasi_generate_get_forbidden_nw_resp( mmgsdi_read_cnf_type *);
static void qmi_nasi_generate_set_preferred_nw_resp( mmgsdi_write_cnf_type *);
static void qmi_nasi_generate_set_forbidden_nw_resp( mmgsdi_write_cnf_type *);
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
#endif
#ifdef FEATURE_DUAL_SIM
void qmi_nas_set_dual_standby_pref_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nas_gen_dual_standby_pref_ind( qmi_cm_ph_info_s_type *p_info );
void qmi_nas_gen_data_subs_priority_ind( qmi_cm_ph_info_s_type *p_info );
#endif
qmi_error_type_v01 qmi_nas_generate_sys_info_msg(
    cm_mm_ss_info_s_type *p_ss_info,
    qmi_cm_ph_info_s_type *p_ph_info,
  nas_get_sys_info_resp_msg_v01 * nas_get_sys_info_resp
    );

void qmi_nas_populate_sys_info_ind(
    cm_mm_ss_info_s_type *p_ss_info,
    qmi_cm_ph_info_s_type *p_ph_info,
  nas_sys_info_ind_msg_v01 * nas_sys_info_ind_msg
    );

void qmi_nas_gen_sys_info_ind( cm_mm_ss_info_s_type *p_ss_info, qmi_cm_ph_info_s_type *p_ph_info, boolean evt_reg_reject);
#if 0
boolean get_mode_pref( qmi_cm_ph_info_s_type *p_ph_info, struct access_tech_s *p );
#endif

#if defined (FEATURE_CDMA)
void convert_cdma_mcc_2_ascii_mcc     ( char * p_mcc, word src );
void convert_cdma_mnc_2_ascii_mnc     ( char * p_mnc, byte src );
#endif
void convert_3gpp_plmn_2_ascii_mcc_mnc( char * p_mcc, char * p_mnc, sys_plmn_id_s_type p_plmn );
#ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
void qmi_nas_gen_managed_roaming_ind( cm_mm_ss_info_s_type *p_ss_info, qmi_cm_ph_info_s_type *p_ph_info, enum qmi_nas_subs_e bound_subs );
#endif
void qmi_nas_set_plmn_blocking_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
sys_lac_type qmi_nas_get_lac( cm_mm_ss_info_s_type *p_ss_info);
boolean qmi_nas_populate_rf_band_info_ind(
  cm_mm_ss_info_s_type *p_ss_info,
  nas_rf_band_info_ind_msg_v01 *ind_msg
);
void qmi_nas_send_rf_band_info_ind(
  cm_mm_ss_info_s_type  *p_ss_info,
  qmi_nasi_client_state_type *cl_sp
);
void qmi_nas_gen_rf_band_info_ind( cm_mm_ss_info_s_type *p_ss_info );

void qmi_nas_populate_network_reject_ind(
  cm_mm_ss_info_s_type  *p_ss_info,
  struct nas_0068_ind_s *ind_msg
);
void qmi_nas_send_network_reject_ind(
  cm_mm_ss_info_s_type  *p_ss_info,
  qmi_nasi_client_state_type *cl_sp
);
void qmi_nas_gen_network_reject_ind( cm_mm_ss_info_s_type *p_ss_info );
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
void qmi_nasi_generate_get_plmn_name_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf );
#endif
void qmi_nasi_generate_perform_network_scan_resp_cell_search( sys_found_plmn_list_u_type *plmn_list_rec, sys_plmn_list_status_e_type available_networks_list_cnf);

#ifndef FEATURE_MMODE_DISABLE_UIM
void qmi_nasi_generate_perform_network_scan_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf );


#else
void qmi_nasi_generate_perform_network_scan_resp(   sys_detailed_plmn_list_s_type *available_networks,mmgsdi_session_get_operator_name_info_type *operator_name_info );
void qmi_nasi_generate_get_home_network_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf );
#endif
nas_lte_voice_status_enum_type_v01 qmi_nas_map_lte_voice_status_cm_to_qmi(cm_mm_ss_info_s_type *p_ss_info);
nas_possible_reg_domain_enum_type_v01 qmi_nas_map_available_plmn_type_cm_to_qmi( sys_reg_domain_e_type available_plmn_type );
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
void qmi_nasi_generate_get_se13_plmn_name_resp( const mmgsdi_get_se13_plmn_names_cnf_type *name_cnf );
#endif
nas_tri_state_boolean_type_v01 qmi_nas_map_lte_eb_status_cm_to_qmi( sys_ims_lte_emerg_supp_e_type lte_ims_emerg_avail );
nas_camped_ciot_lte_op_mode_enum_type_v01 qmi_nas_map_camped_lte_mode_cm_to_qmi
( 
  sys_sys_mode_e_type  ciot_lte_mode
);
nas_cp_sms_service_status_e_type_v01 qmi_nas_map_cp_sms_status_cm_to_qmi
(
  sys_cp_sms_service_status_e_type  cp_sms_service_status
);


#ifdef FEATURE_TDSCDMA
void qmi_nasi_generate_get_tds_cell_and_position_info_rsp ( qmi_mmodei_msgr_type * msg_p);
#endif
#ifdef FEATURE_LTE_EMBMS
void qmi_nasi_generate_get_embms_sig_rsp ( qmi_mmodei_msgr_type * msg_p);
#endif

#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
void qmi_nas_generate_rtre_config_ind( qmi_cm_ph_info_s_type *p_ph_info  );
#endif
boolean qmi_nas_compare_mmgsdi_cm_network_rat( mmgsdi_rat_enum_type  rat, sys_radio_access_tech_e_type available_rat);

boolean qmi_nas_populate_ims_pref_status_ind(
  cm_domain_sel_ims_pref_info_s_type *ims_pref,
  nas_ims_pref_status_ind_msg_v01    *ind_msg
);
void qmi_nas_gen_ims_pref_status_ind( cm_domain_sel_ims_pref_info_s_type *ims_pref );
void qmi_nas_generate_get_ims_pref_resp( cm_domain_sel_ims_pref_rsp_msg_type_ext *ims_pref );

void qmi_nas_generate_set_builtin_plmn_list_ind(qmi_error_type_v01 err, enum qmi_nas_subs_e as_id);

static sys_ue_usage_setting_e_type qmi_nas_map_ue_usage_qmi_to_cm( uint32 qmi_ue_usage );
nas_tri_state_boolean_type_v01 qmi_nas_map_lte_eab_status_cm_to_qmi( sys_lte_emerg_access_status_e_type cm_eab_status);
static void qmi_nas_update_lte_sib16_network_time_cache(lte_rrc_utc_time_update_ind_s *lte_sib16_nw_time);
static void qmi_nas_generate_lte_sib16_network_time_ind(void);
static uint8 qmi_nas_map_lte_sib16_dlsavingtime_lte_to_qmi( lte_rrc_utc_dayLightSaving_type_e dayLightSavingTime );
void qmi_nasi_generate_set_lte_band_priority_resp ( lte_rrc_band_pri_change_cnf_s * lte_band_pri_cnf );

#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
static void qmi_nas_generate_lte_cphy_ca_ind(lte_cphy_ca_event_ind_s *cphy_ca);
#endif
void qmi_nasi_generate_set_e911_state_resp ( cm_ac_info_ind_s_type * e911_state_ind );
void qmi_nasi_generate_e911_state_ready_ind( cm_ac_info_ind_s_type * e911_state_ind );
void qmi_nasi_generate_get_lte_band_priority_list_resp( lte_rrc_get_band_pri_list_cnf_s * lte_get_band_pri_cnf );
#ifndef REMOVE_QMI_NAS_GET_SERV_CELL_SIB_V01
void qmi_nasi_generate_get_serving_cell_sib_resp( lte_rrc_get_serv_cell_sib_cnf_s * lte_get_serv_cell_cnf );
void qmi_nasi_generate_get_serving_cell_sib_ind( lte_rrc_get_serv_cell_sib_cnf_s *lte_get_serv_cell_cnf, qmi_nasi_client_state_type *cl_sp );
#endif
#ifdef FEATURE_LTE_EMBMS
void qmi_nasi_generate_get_embms_sig_ext_rsp ( qmi_mmodei_msgr_type * msg_p);
#endif
boolean qmi_nas_populate_current_plmn_name_ind(
  nas_current_plmn_name_ind_msg_v01 *ind_msg,
  cm_mm_ss_info_s_type         *p_ss_info,
  boolean                            ign_disp,
  mmgsdi_session_type_enum_type      session
);

void qmi_nasi_generate_subscription_change_ind( cm_subsc_chgnd_ind_msg_type * subs_change_ind );
void qmi_nas_set_drx_resp( boolean result);
void qmi_nas_get_drx_resp( sys_drx_cn_coefficient_s1_e_type drx_coefficient );

void qmi_nasi_generate_t3346_timer_status_change_ind( qmi_mmodei_msgr_type * msg_p );
#ifdef FEATURE_DUAL_SIM
void qmi_nas_map_standby_pref_cm_to_qmi ( uint32* qmi_standby_pref, sys_modem_dual_standby_pref_e_type cm_standby_pref );
#endif
#ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
static void qmi_nasi_generate_perform_incremental_network_scan_resp( void *, cm_ph_cmd_err_e_type );
static void qmi_nasi_generate_perform_incremental_network_scan_ind( const mmgsdi_session_get_operator_name_cnf_type *name_cnf);
static void qmi_nasi_generate_perform_incremental_network_scan_err_ind( nas_scan_status_enum_v01 scan_status );
#endif
static nas_lte_cphy_ca_bandwidth_enum_v01 qmi_nas_map_lte_bw_to_qmi_bw( lte_bandwidth_e dl_bandwidth );

static lte_rrc_state_ext_e_type_v01 qmi_nas_map_lrrc_state_to_qmi_ext( lte_rrc_state_ext_e rrc_state );
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
static boolean qmi_nasi_get_csp_plmn_mode_val( qmi_nas_mmgsdi_session_e_type qmi_session, qmi_error_e_type* errval_p, uint8* plmn_mode_p );
void qmi_nasi_generate_get_csp_plmn_mode_bit_resp( void );
#endif
/*===========================================================================

                        EXTERNAL FUNCTION DEFINITIONS

===========================================================================*/
#ifdef FEATURE_MODEM_STATISTICS
struct qmi_nas_cmstats_evt_cb_s
{
  cm_stats_event_e_type       evt;
  sys_modem_stats_info_s_type info;
};

/*===========================================================================
  FUNCTION QMI_NAS_CMSTATS_EVT_CB()

  DESCRIPTION
    Handle CM modem stats event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmstats_evt_cb( cm_stats_event_e_type evt, const sys_modem_stats_info_s_type *p_info )
{
  struct qmi_nas_cmstats_evt_cb_s *ptr;

  if ( p_info )
  {
    ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
      {
      ptr->evt  = evt;
      ptr->info = *p_info;

      qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSTATS_EVT_CB, ptr);
      }
      else
      {
    qmi_voice_mem_error();      
      }
    }
}

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSTATS_EVT()

  DESCRIPTION
    Handle data queued for CM stats event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmstats_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmstats_evt_cb_s *ptr = (struct qmi_nas_cmstats_evt_cb_s *)user_data_ptr;

  if ( ptr )
  {
    qm_mstats_process_cm_modem_stats_event ( &ptr->info );
  }
}
#endif
#ifdef FEATURE_DUAL_SIM
struct qmi_nas_cmsubs_evt_cb_s
{
  cm_ph_event_e_type  evt;
  cm_subs_info_s_type info;
};

/*===========================================================================
  FUNCTION QMI_NAS_CMSUBS_EVT_CB()

  DESCRIPTION
    Handle CM subs event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmsubs_evt_cb( cm_ph_event_e_type evt, const cm_subs_info_s_type *p_info )
{
  struct qmi_nas_cmsubs_evt_cb_s *ptr;

  if ( p_info )
  {
    ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
    {
      ptr->evt  = evt;
      ptr->info = *p_info;

      QM_MSG_HIGH_5("qmi_nas_cmsubs_evt_cb: DDS - %d, VID - %d, IMS LTE VID- %d, subs id - %d, IMS WLAN VID - %d", 
            p_info->is_default_data, p_info->hw_id[SYS_VSID_APP_CS_VOICE],p_info->hw_id[SYS_VSID_APP_IMS_LTE], p_info->subscription_id, p_info->hw_id[SYS_VSID_APP_IMS_WLAN]);

      qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSUBS_EVT_CB, ptr);
      }
      else
      {
    qmi_voice_mem_error();
      }
    }
}

/*===========================================================================
  FUNCTION QMI_NAS_ASUBS_ID_MATCH_BOUND_SUBS()

  DESCRIPTION
    see if given asubs id and bound_subs match. assumption is that asubs id 1
    is always primary subs and 2 is always secondary

  RETURN VALUE
    TRUE if match, FALSE if not

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_asubs_id_match_bound_subs( sys_modem_as_id_e_type asubs_id, enum qmi_nas_subs_e bound_subs )
{
  if ( (asubs_id == SYS_MODEM_AS_ID_1 && bound_subs == QMI_NAS_SUBS_PRIMARY  ) 
  #ifdef  FEATURE_DUAL_SIM
      ||  (asubs_id == SYS_MODEM_AS_ID_2 && bound_subs == QMI_NAS_SUBS_SECONDARY) 
  #endif
  #ifdef FEATURE_TRIPLE_SIM
      ||  (asubs_id == SYS_MODEM_AS_ID_3 && bound_subs == QMI_NAS_SUBS_TERTIARY) 
  #endif
       )
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSUBS_EVT()

  DESCRIPTION
    Handle data queued for CM subs event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmsubs_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmsubs_evt_cb_s *ptr = (struct qmi_nas_cmsubs_evt_cb_s*)user_data_ptr;

  qmi_nasi_client_state_type        *cl_sp = NULL;
  int                               client;
  dsm_item_type                     *ind = NULL;
  nas_subscription_info_ind_msg_v01 *ind_msg = NULL;

  if ( ptr )
  {
    QM_MSG_HIGH_3("cm subs evt %d %d %d", ptr->evt, ptr->info.subscription_id, ptr->info.is_operational);

    switch ( ptr->evt )
    {
      case CM_PH_EVENT_SUBSCRIPTION_PREF_INFO:
        if ( ptr->info.subscription_id == SYS_MODEM_AS_ID_1 || ptr->info.subscription_id == SYS_MODEM_AS_ID_2  ||
             ptr->info.subscription_id == SYS_MODEM_AS_ID_3)
        {
          ind_msg = ( nas_subscription_info_ind_msg_v01 *)modem_mem_alloc(sizeof(nas_subscription_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

          if(ind_msg != NULL)
          {
            boolean send_ind = FALSE;
            memset( ind_msg, 0x00, sizeof(nas_subscription_info_ind_msg_v01) );

            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].is_priority_subs !=  ptr->info.is_priority_subs)
            {
              ind_msg->is_priority_subs = ptr->info.is_priority_subs ? NAS_PRIORITY_SUBSCRIPTION_TRUE_V01 : NAS_PRIORITY_SUBSCRIPTION_FALSE_V01;
              ind_msg->is_priority_subs_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("priority_subs info changed : %d", ptr->info.is_priority_subs);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].is_operational !=  ptr->info.is_operational)
            {
              ind_msg->is_active = ptr->info.is_operational ? NAS_SUBSCRIPTION_ACTIVE_V01 : NAS_SUBSCRIPTION_NOT_ACTIVE_V01;
              ind_msg->is_active_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("operational info changed: %d", ptr->info.is_operational);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].is_default_data !=  ptr->info.is_default_data)
            {
              ind_msg->is_default_data_subs = ptr->info.is_default_data;
              ind_msg->is_default_data_subs_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("default_data info changed : %d", ptr->info.is_default_data);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].hw_id[SYS_VSID_APP_CS_VOICE] !=  ptr->info.hw_id[SYS_VSID_APP_CS_VOICE])
            {  
              ind_msg->voice_system_id = (uint32) ptr->info.hw_id[SYS_VSID_APP_CS_VOICE];
              ind_msg->voice_system_id_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("voice_system_id info changed : %d", (uint32)ptr->info.hw_id[SYS_VSID_APP_CS_VOICE]);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].hw_id[SYS_VSID_APP_IMS_LTE] !=  ptr->info.hw_id[SYS_VSID_APP_IMS_LTE])
            {  
              ind_msg->lte_voice_system_id = (uint32) ptr->info.hw_id[SYS_VSID_APP_IMS_LTE];
              ind_msg->lte_voice_system_id_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("lte_voice_system_id info changed : %d", (uint32)ptr->info.hw_id[SYS_VSID_APP_IMS_LTE]);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].hw_id[SYS_VSID_APP_IMS_WLAN] !=  ptr->info.hw_id[SYS_VSID_APP_IMS_WLAN])
            {  
              ind_msg->wlan_voice_system_id = (uint32) ptr->info.hw_id[SYS_VSID_APP_IMS_WLAN];
              ind_msg->wlan_voice_system_id_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("wlan_voice_system_id info changed : %d", (uint32)ptr->info.hw_id[SYS_VSID_APP_IMS_WLAN]);
            }
            
            if( send_ind )
            {
              cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
              while ( cl_sp != NULL )
              {
                if ( qmi_nas_asubs_id_match_bound_subs( ptr->info.subscription_id, cl_sp->report_status.bound_subs ) )
                {
                  if ( cl_sp->report_status.report_subscription_info_ind )
                  {
                    ind = NULL;
                    if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                        QMI_IDL_INDICATION,
                                                        (uint16_t) QMI_NAS_SUBSCRIPTION_INFO_IND_MSG_V01,
                                                        (void *) ind_msg,
                                                        (uint32_t) sizeof( nas_subscription_info_ind_msg_v01 ),
                                                        &ind )
                                                      )
                    {
                      qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_SUBSCRIPTION_INFO_IND, ind );
                    }
                    else
                    {
                      QM_MSG_HIGH_1("qmi_nas_process_cmsubs_evt() idl_message_encode failed, no indication sent %p.", cl_sp->clnt);
                    }
                  }
                }

                cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
              }
            }
          }
          else
          {
            QM_MSG_ERROR_1("Alloc Failed for subsId:%d", ptr->info.subscription_id);
          }
          if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
          ind_msg = NULL;
          memscpy( &qmi_nasi_global.subs_info[ptr->info.subscription_id], sizeof(cm_subs_info_s_type), &ptr->info, sizeof(cm_subs_info_s_type) );
        }
        break;

      default:
        break;
    }
  }
}
#endif

struct qmi_nas_cmph_evt_cb_s
{
  cm_ph_event_e_type evt;
  qmi_cm_ph_info_s_type  info;
};

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMPH_EVT()

  DESCRIPTION
    Handle data queued for CM PH event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmph_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmph_evt_cb_s *ptr = (struct qmi_nas_cmph_evt_cb_s*)user_data_ptr;
  cm_ph_event_e_type *p_evt;
  qmi_cm_ph_info_s_type  *p_info;
  boolean             copy_info = TRUE;
  int                 i;

  if (ptr)
  {
    p_evt  = &ptr->evt;
    p_info = &ptr->info;

    #ifdef FEATURE_DUAL_SIM
    QM_MSG_HIGH_2("cm ph event %d asubs_id %d", *p_evt, p_info->asubs_id);
    #else
    QM_MSG_HIGH_1("cm ph event %d", *p_evt);
    #endif
    switch (*p_evt)
    {
      #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
      case CM_PH_EVENT_CURR_NAM:
        qmi_nas_generate_current_nam_ind( p_info );
        break;
      #endif
      
      #ifndef REMOVE_QMI_NAS_SET_DDTM_PREFERENCE_V01
      #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
      case CM_PH_EVENT_DDTM_STATUS:
        qmi_nas_generate_ddtm_ind( p_info );
        break;
      #endif
      #endif
      case CM_PH_EVENT_INFO_AVAIL:
        if ( !qmi_nasi_global.rcvd_ss_info )
        {
          if ( !cm_ss_cmd_get_ss_info(qmi_nas_cmss_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id) )
          {
            QM_MSG_ERROR("cm_ss_cmd_get_ss_info failed");
          }

#ifdef FEATURE_DUAL_SIM
          if ( !cm_ph_cmd_get_subs_pref_info(qmi_nas_cmph_cmd_cb, (void*)SYS_MODEM_AS_ID_1, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_1 ) )
          {
            memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_1], 0x00, sizeof(cm_subs_info_s_type) );
            QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_1);
          }

          if ( !cm_ph_cmd_get_subs_pref_info(qmi_nas_cmph_cmd_cb, (void*)SYS_MODEM_AS_ID_2, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_2 ) )
          {
            memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_2], 0x00, sizeof(cm_subs_info_s_type) );
            QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_2);
          }
#ifdef FEATURE_TRIPLE_SIM
         if ( !cm_ph_cmd_get_subs_pref_info(qmi_nas_cmph_cmd_cb, (void*)SYS_MODEM_AS_ID_3, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_3 ) )
         {
           memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_3], 0x00, sizeof(cm_subs_info_s_type) );
           QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_3);
         }
#endif

#endif
        }
        break;

      case CM_PH_EVENT_OPRT_MODE:
        
#ifdef FEATURE_DUAL_SIM
        if ( p_info->asubs_id == SYS_MODEM_AS_ID_2 )
        {
          if ( qmi_nasi_global.cm_ph_info2.oprt_mode != SYS_OPRT_MODE_ONLINE && p_info->oprt_mode == SYS_OPRT_MODE_ONLINE )
          {
            qmi_nas_generate_sys_sel_pref_ind( p_info );      
          }
        }
        else
#endif
#ifdef FEATURE_TRIPLE_SIM
        if (  p_info->asubs_id == SYS_MODEM_AS_ID_3 )
        {
           if ( qmi_nasi_global.cm_ph_info3.oprt_mode != SYS_OPRT_MODE_ONLINE && p_info->oprt_mode == SYS_OPRT_MODE_ONLINE )
           {
             qmi_nas_generate_sys_sel_pref_ind( p_info );      
           }
        }
        else
#endif
        {
          if ( qmi_nasi_global.cm_ph_info.oprt_mode != SYS_OPRT_MODE_ONLINE && p_info->oprt_mode == SYS_OPRT_MODE_ONLINE )
          {
            qmi_nas_generate_sys_sel_pref_ind( p_info );      
          }
          #ifdef FEATURE_ENABLE_QMI_DMS
          qmi_nasi_operating_mode_ind(p_info->oprt_mode);
          #endif
        }
        #ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
        if(p_info->oprt_mode == SYS_OPRT_MODE_LPM ||
           p_info->oprt_mode == SYS_OPRT_MODE_PWROFF ||
           p_info->oprt_mode == SYS_OPRT_MODE_RESET ||
           p_info->oprt_mode == SYS_OPRT_MODE_OFFLINE ||
           p_info->oprt_mode == SYS_OPRT_MODE_FTM)
        {
          QM_MSG_HIGH_3( "resetting call mode due to CM_PH_EVENT_OPRT_MODE %d - old valid: %d old call mode: %d", p_info->oprt_mode, qmi_nasi_global.call_mode_valid, qmi_nasi_global.call_mode );
          for(i = 0; i < QMI_NAS_SUBS_MAX; i++)
          {
            qmi_nasi_global.call_mode_valid[i] = FALSE;
            qmi_nasi_global.call_mode[i] = SYS_CALL_MODE_NORMAL;
          }
        }
        #endif
        break;

      case CM_PH_EVENT_SYS_SEL_PREF:
        qmi_nas_generate_sys_sel_pref_ind( p_info );
        break;

      case CM_PH_EVENT_INFO:
        if ( qmi_nasi_global.inited == INIT_STATE_PENDING_MODE_CAPABILITY )
        {
          qmi_nasi_global.inited = INIT_STATE_INITIALIZED;
          (void)cm_client_act( qmi_nasi_global.cm_clnt_id );
        }
        break;
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 

      case CM_PH_EVENT_NVRUIM_CONFIG_CHANGED:
        QM_MSG_HIGH_3("rtre_config prev %d new %d, rtre_control %d", qmi_nasi_global.cm_ph_info.rtre_config, p_info->rtre_config, p_info->rtre_control);
#ifndef REMOVE_QMI_NAS_SET_RTRE_CONFIG_V01
        if( qmi_nasi_global.rtre_set_status_pending == TRUE )
        {
          qmi_nasi_global.rtre_set_status_pending = FALSE;      // reset the RTRE config status
          qmi_nas_set_rtre_config_resp(TRUE);
        }
#endif
#ifndef REMOVE_QMI_NAS_GET_RTRE_CONFIG_V01
        qmi_nas_generate_rtre_config_ind( p_info );
#endif
        break;
#endif

      case CM_PH_EVENT_SUBSCRIPTION_AVAILABLE:
      case CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE:
      case CM_PH_EVENT_SUBSCRIPTION_CHANGED:
      case CM_PH_EVENT_TERMINATE_GET_NETWORKS:
        if ( qmi_nasi_global.net_scan_started )
        {
          #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
          if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
          {
            QM_MSG_HIGH_1( "Sending incremental network scan abort ind on PH evt %d", *p_evt );
            qmi_nasi_generate_perform_incremental_network_scan_err_ind(NAS_SCAN_STATUS_ABORT_V01);
          } 
          else 
          #endif
          {
            // use arbitrary error code to send RESP with failure
            qmi_nas_generate_net_scan_err_resp( NULL, CM_PH_CMD_ERR_GET_NETWORKS_S );
          }
        }
        break;

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
      case CM_PH_EVENT_AVAILABLE_NETWORKS_CONF:
      if(p_info->p_available_networks)
      {
            qmi_nas_generate_net_scan_resp_ext( p_info->p_available_networks, p_info->available_networks_list_cnf, p_info->network_list_type);
            modem_mem_free( p_info->p_available_networks, MODEM_MEM_CLIENT_QMI_MMODE );            
            p_info->p_available_networks = NULL;
          }
        break;
#endif

#ifndef REMOVE_QMI_NAS_GET_DATA_SUBS_PRIORITY_V01
      case CM_PH_EVENT_DATA_PRIORITY:
        qmi_nas_gen_data_subs_priority_ind( p_info );
        break;
#endif
#ifndef REMOVE_QMI_NAS_GET_DUAL_STANDBY_PREF_V01
      #ifdef FEATURE_DUAL_SIM
      case CM_PH_EVENT_DUAL_STANDBY_PREF:
        qmi_nas_gen_dual_standby_pref_ind( p_info );
        break;
      #endif
#endif
#ifndef REMOVE_QMI_NAS_GET_HPLMN_SEARCH_TIMER_V01
      case CM_PH_EVENT_GET_HPLMN_TIMER:
        qmi_nas_get_hplmn_search_timer_resp( p_info->hplmn_timer );
        break;
#endif
      case CM_PH_EVENT_EDRX_CHANGE_INFO_IND:
        qmi_nasi_edrx_change_info_ind(p_info);

      default:
        copy_info = FALSE;
        break;
    }

    if ( copy_info )
    {
      QM_MSG_LOW_1("cm_ph_evt->mode_capability = %d", p_info->mode_capability);
#ifdef FEATURE_DUAL_SIM
      if ( p_info->asubs_id == SYS_MODEM_AS_ID_2 ) // TODO: need to revisit this logic
      {
        qmi_nasi_global.rcvd_ph_info2 = TRUE;
        memscpy(&qmi_nasi_global.cm_ph_info2, sizeof(qmi_cm_ph_info_s_type),
                &ptr->info, sizeof(qmi_cm_ph_info_s_type));
        if ( p_info->mode_pref != CM_MODE_PREF_EMERGENCY )
          qmi_nasi_global.last_mode_pref2 = p_info->mode_pref;
      }
      else
#endif
#ifdef FEATURE_TRIPLE_SIM
      if ( p_info->asubs_id == SYS_MODEM_AS_ID_3 ) // TODO: need to revisit this logic
      {
        qmi_nasi_global.rcvd_ph_info3 = TRUE;
        memscpy( &qmi_nasi_global.cm_ph_info3, sizeof(qmi_cm_ph_info_s_type), &ptr->info, sizeof(qmi_cm_ph_info_s_type));
        if ( p_info->mode_pref != CM_MODE_PREF_EMERGENCY )
          qmi_nasi_global.last_mode_pref3 = p_info->mode_pref;
      }
      else
#endif
      {
        qmi_nasi_global.rcvd_ph_info = TRUE;
        memscpy(&qmi_nasi_global.cm_ph_info, sizeof(qmi_cm_ph_info_s_type), 
                &ptr->info, sizeof(qmi_cm_ph_info_s_type));
        if ( p_info->mode_pref != CM_MODE_PREF_EMERGENCY )
          qmi_nasi_global.last_mode_pref = p_info->mode_pref;
      }
    }
  }
  /*Else, ptr is NULL so we ignore the cm ph event*/
}

/*===========================================================================
  FUNCTION copy_cm_ph_info_to_qmi_cm_ph_info()

  DESCRIPTION
    Copy CM Ph Info into QMI data structure

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void copy_cm_ph_info_to_qmi_cm_ph_info(cm_ph_event_e_type evt, qmi_cm_ph_info_s_type  *info, const cm_ph_info_s_type *p_info)
{
  info->oprt_mode = p_info->oprt_mode;
  info->mode_capability = p_info->mode_capability;
  info->lte_band_capability = p_info->lte_band_capability;
  info->ue_usage_setting = p_info->ue_usage_setting;
  info->voice_domain_pref = p_info->voice_domain_pref;
  #ifdef FEATURE_DUAL_SIM
  info->asubs_id = p_info->asubs_id;
  #endif
  info->mode_pref = p_info->mode_pref;
  info->pref_term = p_info->pref_term;
  info->srv_domain_pref = p_info->srv_domain_pref;
  info->lte_band_pref = p_info->lte_band_pref;
  info->network_sel_mode_pref = p_info->network_sel_mode_pref;
  info->plmn = p_info->plmn;
  info->edrx_enabled = p_info->edrx_enabled;
  info->edrx_ptw = p_info->edrx_ptw;
  info->edrx_cycle_length = p_info->edrx_cycle_length;
  info->rat_type_edrx     = p_info->rat_type_edrx;


#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  if(evt == CM_PH_EVENT_AVAILABLE_NETWORKS_CONF)
  {
    info->p_available_networks = modem_mem_alloc( sizeof(sys_found_plmn_list_u_type), MODEM_MEM_CLIENT_QMI_MMODE );
    if(info->p_available_networks)
    {
      if(p_info->network_list_type != CM_NETWORK_LIST_CELL_SEARCH)
      {
        memscpy( info->p_available_networks, sizeof(p_info->available_networks),
                      &p_info->available_networks,  sizeof(p_info->available_networks));
      }
      else
      {
          memscpy( info->p_available_networks, sizeof(p_info->cell_info_list),
                           &p_info->cell_info_list,  sizeof(p_info->cell_info_list));
      }
    }
    else
    {
     qmi_voice_mem_error();
    }
  }
#endif

  info->network_list_type = p_info->network_list_type;
  info->available_networks_list_cnf = p_info->available_networks_list_cnf;
  info->drx_coefficient = p_info->drx_coefficient;

  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  info->band_capability = p_info->band_capability;
  #ifdef FEATURE_TDSCDMA
  info->tds_band_capability = p_info->tds_band_capability;
  info->tds_band_pref = p_info->tds_band_pref;
  #endif
//  info->curr_nam = p_info->curr_nam;
  info->acq_order_pref = p_info->acq_order_pref;
  info->band_pref = p_info->band_pref;
  #if !defined(FEATURE_MMODE_QMI_GPRS_LTE)
//  info->csg_id = p_info->csg_id;
  info->csg_rat = p_info->csg_rat;
  #endif
  info->hplmn_timer = p_info->hplmn_timer;
  #endif
  info->acq_pri_order_pref = p_info->acq_pri_order_pref;

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
  info->roam_pref = p_info->roam_pref;
  info->rtre_config = p_info->rtre_config;
  info->rtre_control = p_info->rtre_control;
  info->ddtm_pref = p_info->ddtm_pref;
  info->cur_ddtm_status = p_info->cur_ddtm_status;
  info->ddtm_act_mask = p_info->ddtm_act_mask;
  info->ddtm_num_srv_opt = p_info->ddtm_num_srv_opt;

  memscpy( info->ddtm_srv_opt_list, sizeof(info->ddtm_srv_opt_list),
                  p_info->ddtm_srv_opt_list,  sizeof(p_info->ddtm_srv_opt_list) );
  info->prl_pref = p_info->prl_pref;
  #endif

  #ifdef FEATURE_DUAL_SIM
  info->standby_pref = p_info->standby_pref;
  info->active_subs = p_info->active_subs;
  info->default_voice_subs = p_info->default_voice_subs;
  info->default_data_subs = p_info->default_data_subs;
  info->priority_subs = p_info->priority_subs;
  info->priority_type = p_info->priority_type;
  #endif

  info->ciot_lte_pref = p_info->ciot_lte_pref;
}

/*===========================================================================
  FUNCTION QMI_NAS_CMPH_EVT_CB()

  DESCRIPTION
    Queue CM PH events into DCC

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmph_evt_cb( cm_ph_event_e_type evt, const cm_ph_info_s_type *p_info)
{
  struct qmi_nas_cmph_evt_cb_s *ptr;

  if (p_info)
  {
    ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
    {
      memset( ptr, 0x00, sizeof(*ptr) );

      ptr->evt = evt;
      copy_cm_ph_info_to_qmi_cm_ph_info(evt, &ptr->info, p_info);

      qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMPH_EVT_CB, ptr);
    }
    else
      {
    qmi_voice_mem_error();
    }
      }
  }

struct qmi_nas_cmph_cmd_cb_s
{
  void                *p_data;
  cm_ph_cmd_e_type     cmd;
  cm_ph_cmd_err_e_type err;
};

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMPH_CMD()

  DESCRIPTION
    Handle CM PH command callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmph_cmd( qmi_mmode_cmd_enum_type cmd_type, void *user_data_ptr )
{
  struct qmi_nas_cmph_cmd_cb_s *ptr = (struct qmi_nas_cmph_cmd_cb_s*)user_data_ptr;
  void                *p_data;
  cm_ph_cmd_e_type     cmd;
  cm_ph_cmd_err_e_type err;

  if ( ptr )
  {
    // cache to local variables for readability
    p_data = ptr->p_data;
    cmd    = ptr->cmd;
    err    = ptr->err;
    QM_MSG_HIGH_1("ph_cmd (%d) received", cmd);
    switch (cmd)
    {

     #ifndef REMOVE_QMI_NAS_AVOID_TUNEAWAY_V01
      case CM_PH_CMD_SET_TRM_PRIORITY:
        qmi_nasi_avoid_tuneaway_resp(p_data, err);
        break;
     #endif
     #ifndef REMOVE_QMI_NAS_SET_DATA_SUBS_PRIORITY_V01
      case CM_PH_CMD_DATA_PRIORITY:
        qmi_nasi_set_data_subs_priority_resp(p_data, err);
        break;
     #endif
     #ifndef REMOVE_QMI_NAS_SET_SRVCC_V01
      case CM_PH_CMD_SET_SRVCC_CAPABILITY:
        qmi_nasi_set_srvcc_resp(p_data, err);
        break;
     #endif
     #ifndef REMOVE_QMI_NAS_SET_DATA_ROAMING_V01
      case CM_PH_CMD_DATA_ROAMING:
        qmi_nasi_set_data_roaming_status_resp(p_data, err);
        break;
     #endif

      case CM_PH_CMD_GET_NETWORKS:
        #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
        if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
        {
          QM_MSG_HIGH_1( "Sending incremental network scan resp with err: %d", err);
          qmi_nasi_generate_perform_incremental_network_scan_resp(p_data, err);
        }
        else
        #endif
        {
          qmi_nas_generate_net_scan_err_resp(p_data, err);
        }
        break;

      case CM_PH_CMD_SIGNAL_STRENGTH_DELTA:
        if( qmi_nasi_global.is_pending_config_sig_info && err == CM_PH_CMD_ERR_NOERR )
        {
          qmi_nasi_global.is_pending_config_sig_info = FALSE;
          qmi_nasi_global.is_set_cm_ph_cmd_signal_strength_delta = TRUE;
        }
        qmi_nas_generate_reg_attach_resp(p_data, err);
        break;

      case CM_PH_CMD_SYS_SEL_PREF:
      #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
      case CM_PH_CMD_NAM_SEL:
      case CM_PH_CMD_DDTM_PREF:
      #endif
        qmi_nas_generate_reg_attach_resp(p_data, err);
        break;

      case CM_PH_CMD_INFO_GET:
        break;
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 

      #ifndef REMOVE_QMI_NAS_SET_RTRE_CONFIG_V01
      case  CM_PH_CMD_CHANGE_RTRE_CONFIG:
        if(  err != CM_PH_CMD_ERR_NOERR )
        {
          if( qmi_nasi_global.rtre_set_status_pending == TRUE )
          {
            qmi_nasi_global.rtre_set_status_pending = FALSE;      // reset the RTRE config status
            qmi_nas_set_rtre_config_resp(FALSE);
          }
        }
        break;
      #endif
#endif
#ifdef FEATURE_DUAL_SIM
      
      #ifdef REMOVE_QMI_NAS_SET_DUAL_STANDBY_PREF_V01
      case CM_PH_CMD_DUAL_STANDBY_PREF:
        qmi_nas_set_dual_standby_pref_resp( (qmi_mmode_qcsi_transaction_type*)p_data, err );
        break;
      #endif //REMOVE_QMI_NAS_SET_DUAL_STANDBY_PREF_V01
     
      case CM_PH_CMD_SUBSCRIPTION_INFO_GET:
        if ( err != CM_PH_CMD_ERR_NOERR )
        {
          if ( p_data == (void*)SYS_MODEM_AS_ID_1 )
          {
            memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_1], 0x00, sizeof(cm_subs_info_s_type) );
            QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_1);
          }
          else if ( p_data == (void*)SYS_MODEM_AS_ID_2 )
          {
            memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_2], 0x00, sizeof(cm_subs_info_s_type) );
            QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_2);
          }
         #ifdef FEATURE_TRIPLE_SIM
         else if ( p_data == (void*)SYS_MODEM_AS_ID_3 )
         {
          memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_3], 0x00, sizeof(cm_subs_info_s_type) );
          MSG_ERROR( "cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_3, 0, 0 );
         }
         #endif  //FEATURE_TRIPLE_SIM
        }
        break;
#endif  //FEATURE_DUAL_SIM

      case CM_PH_CMD_PLMN_BLOCKING:
        qmi_nas_set_plmn_blocking_resp( (qmi_mmode_qcsi_transaction_type*)p_data, err );
        break;
#ifndef REMOVE_QMI_NAS_SET_HPLMN_IRAT_SEARCH_TIMER_V01
      case CM_PH_CMD_SET_TL_IRAT_SEARCH_TIMER_REQ:
        qmi_nas_set_hplmn_irat_search_timer_resp( (qmi_mmode_qcsi_transaction_type*)p_data, err );
        break;
#endif
#ifndef REMOVE_QMI_NAS_CDMA_AVOID_SYSTEM_V01
      #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
      case CM_PH_CMD_AVOID_SYS:
        qmi_nas_generate_cdma_avoid_system_resp(p_data, err);
        break;
      #endif
#endif
#ifndef REMOVE_QMI_NAS_SET_HPLMN_SEARCH_TIMER_V01
      case CM_PH_CMD_SET_HPLMN_TIMER:
        qmi_nas_set_hplmn_search_timer_resp( (qmi_mmode_qcsi_transaction_type*)p_data, err );
        break;
#endif
#ifndef REMOVE_QMI_NAS_GET_HPLMN_SEARCH_TIMER_V01
      case CM_PH_CMD_GET_HPLMN_TIMER:
        qmi_nas_get_hplmn_search_timer_err_resp( (qmi_mmode_qcsi_transaction_type*)p_data, err );
        break;
#endif
      #if defined(FEATURE_CIOT)
      case CM_PH_CMD_SET_LOCATION_INFO:
        qmi_nas_set_mcc_resp( (qmi_mmode_qcsi_transaction_type*)p_data, err );
        break;
      #endif
      #ifdef FEATURE_ENABLE_QMI_DMS
      case CM_PH_CMD_OPRT_MODE:
        qmi_nas_set_operating_mode_resp( (qmi_mmode_qcsi_transaction_type*)p_data, err );
      break;
      #endif
      default:
        /*[QMINAS] Unexpected ph_cmd (%d) received*/
        break;
    }
  }
  /*If cmd doesnot get printed, it means ptr is NULL*/
}

/*===========================================================================
  FUNCTION QMI_NAS_CMPH_CMD_CB()

  DESCRIPTION
    Handle CM PH command callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmph_cmd_cb( void *p_data, cm_ph_cmd_e_type cmd, cm_ph_cmd_err_e_type err)
{
  struct qmi_nas_cmph_cmd_cb_s *ptr;

  ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ptr )
    {
    ptr->p_data = p_data;
    ptr->cmd    = cmd;
    ptr->err    = err;

    qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMPH_CMD_CB, ptr);
  }
  else
  {
    qmi_voice_mem_error();
  }
}

#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 

struct qmi_nas_timer_cmd_cb_s
{
  uint32  timer_id;
};

/*===========================================================================
  FUNCTION QMI_NAS_TIMER_CMD_CB()

  DESCRIPTION
    Handle QMI NAS TIMER command callback, queues an item to MMODE_QMI task

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_timer_cmd_cb( timer_cb_data_type  user_data )
{  
  struct qmi_nas_timer_cmd_cb_s  *ptr = NULL;

  ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

  if (ptr) 
  {
    ptr->timer_id = (uint32)user_data;         
    // user data contains the timer event type, so convert to uint32 and assign to evt_type

    qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_TIMER_EVT_CB, ptr);

  }
  else 
  {
    qmi_voice_mem_error();
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_TIMER_EVT()

  DESCRIPTION
    Handle data queued for timer event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_timer_evt( qmi_mmode_cmd_enum_type cmd_type, void *user_data )
{
  struct qmi_nas_timer_cmd_cb_s *timer_cmd = (struct qmi_nas_timer_cmd_cb_s *)user_data;

  if(timer_cmd != NULL)
  {
    QM_MSG_HIGH_1("qmi_nas_process_timer_evt, timer_id :%d",timer_cmd->timer_id);
    switch (timer_cmd->timer_id)
    {
      case QM_TIMER_TIB:
        qm_tib_process_timer();
        break;

      default:
        /*unhandled timer id*/
        break;
    }
  }
  /*If Else, then else qmi_nas_process_timer_evt processing timer_cmd is NULL*/
}
#endif
#ifndef REMOVE_QMI_NAS_SET_BUILTIN_PLMN_LIST_V01
/*===========================================================================
  FUNCTION QMI_NAS_POST_INTERNAL_BUILTIN_PLMN_CMD()

  DESCRIPTION
    Post internal command 

  PARAMETERS
    as_id: uint8

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_post_internal_builtin_plmn_cmd
(
  uint8 as_id
)
{
  qmi_mmode_common_cmd_type* data_ptr;

  data_ptr = (qmi_mmode_common_cmd_type*) QMI_NAS_MEM_ALLOC( sizeof( qmi_mmode_common_cmd_type ) );
  if( NULL == data_ptr )
  {
    qmi_voice_mem_fatal();
    return;
  }

  data_ptr->id = QMI_MMODE_NAS_INT_BUILTIN_PLMN_CB;
  data_ptr->nas_int_info.bplmn_list_cb.as_id = as_id;

  qmi_mmode_send_cmd(QMI_MMODE_CMD_NAS_INTERNAL_CB, data_ptr);
}



/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_INTERNAL_CMD()

  DESCRIPTION
    Handle internal commands

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_internal_cmd( qmi_mmode_cmd_enum_type cmd_type, void *user_data )
{

  qmi_mmode_common_cmd_type* data_ptr = (qmi_mmode_common_cmd_type *) user_data;;

  if(data_ptr == NULL )
  {
    return;
  }

  switch(data_ptr->id)
  {
#ifndef REMOVE_QMI_NAS_SET_BUILTIN_PLMN_LIST_V01
     case QMI_MMODE_NAS_INT_BUILTIN_PLMN_CB:
      qmi_nas_generate_set_builtin_plmn_list_ind(QMI_ERR_NONE_V01, (enum qmi_nas_subs_e)data_ptr->nas_int_info.bplmn_list_cb.as_id);
      break;
#endif
    default:
      break;
  }

} /* qmi_nas_process_internal_cmd */ 
#endif

#ifdef FEATURE_MODEM_CONFIG_REFRESH
/*===========================================================================
  FUNCTION QMI_NAS_MCFG_REFRESH_EVT()

  DESCRIPTION:
  This function cmd handler to process NV refresh events

  INPUT/OUTPUT PARAMETERS:
  cmd - command ID
  user_data_ptr - User data provided by the caller routine

  RETURN VALUE:
  None

  SIDE EFFECTS:
  None
===========================================================================*/
void qmi_nas_mcfg_refresh_evt
(
  qmi_mmode_cmd_enum_type cmd,
  void                    * user_data_ptr
)
{
  mcfg_refresh_info_s_type     *event_info     = NULL;
  boolean                      refresh_status  = FALSE;
     
  if(NULL == user_data_ptr)
  {
    return;
  }
  
  event_info =  (mcfg_refresh_info_s_type  *) user_data_ptr;

  QM_MSG_HIGH_2("qmi_nas_mcfg_refresh_evt() updating NV/EFS cache for subs %d (ref %d)", (uint16)event_info->sub_index, event_info->reference_id);
  qmi_efs_refresh_mcfg((uint16)event_info->sub_index);

  refresh_status = mcfg_refresh_done(event_info->reference_id);
  
  QM_MSG_HIGH_2("qmi_nas_mcfg_refresh_evt() finished (ref %d) status %d", event_info->reference_id, refresh_status);
  

}/*qmi_nas_mcfg_refresh_evt*/
#endif // FEATURE_MODEM_CONFIG_REFRESH

#ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
/*===========================================================================
  FUNCTION qmi_nas_get_reg_state()

  DESCRIPTION
    get registration state based on CM SS event

  RETURN VALUE
    registration state

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_registration_state_enum_v01 qmi_nas_get_reg_state( cm_mm_ss_info_s_type *p_ss_info, qmi_cm_ph_info_s_type *p_ph_info )
{
  nas_registration_state_enum_v01 state;
  sys_sim_state_e_type      sim_state;
  sys_srv_status_e_type     srv_status       = p_ss_info->srv_status;
  boolean                   is_sys_forbidden = p_ss_info->plmn_forbidden;

  if ( p_ss_info->sim_state == SYS_SIM_STATE_NOT_AVAILABLE )
  {
    sim_state = qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_PRIMARY];
  }
  else
  {
    sim_state = p_ss_info->sim_state;
  }

  switch ( srv_status )
  {
    case SYS_SRV_STATUS_NO_SRV:
    case SYS_SRV_STATUS_LIMITED:
    case SYS_SRV_STATUS_LIMITED_REGIONAL:
      if ( sim_state == SYS_SIM_STATE_CS_INVALID || sim_state == SYS_SIM_STATE_CS_PS_INVALID || is_sys_forbidden )
      {
        state = NAS_REGISTRATION_DENIED_V01;
      }
      else
      {
        if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_LPM          ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_FTM          ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_OFFLINE      ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_OFFLINE_AMPS ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_OFFLINE_CDMA )
        {
          state = NAS_NOT_REGISTERED_V01;
        }
        else
        {
          state = NAS_NOT_REGISTERED_SEARCHING_V01;
        }
      }
      break;

    case SYS_SRV_STATUS_PWR_SAVE:
      if ( sim_state == SYS_SIM_STATE_CS_INVALID || sim_state == SYS_SIM_STATE_CS_PS_INVALID || is_sys_forbidden )
      {
        state = NAS_REGISTRATION_DENIED_V01;
      }
      else
      {
        state = NAS_NOT_REGISTERED_V01;
      }
      break;

    case SYS_SRV_STATUS_SRV:
      state = NAS_REGISTERED_V01;
      break;

    default:
      state = NAS_REGISTRATION_UNKNOWN_V01;
  }


  return state;
}

/*===========================================================================
  FUNCTION qmi_nas_get_cs_attach_state()

  DESCRIPTION
    get cs attach state based on CM SS event

  RETURN VALUE
    registration state

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_nasi_cs_attach_e_type qmi_nas_get_cs_attach_state( cm_mm_ss_info_s_type *p_info )
{
  qmi_nasi_cs_attach_e_type state;
  sys_srv_domain_e_type     srv_domain = p_info->srv_domain;

  switch ( srv_domain )
  {
    case SYS_SRV_DOMAIN_NO_SRV:
    case SYS_SRV_DOMAIN_CAMPED:
    case SYS_SRV_DOMAIN_PS_ONLY:
      state = NASI_CS_DETACHED;
      break;

    case SYS_SRV_DOMAIN_CS_ONLY:
    case SYS_SRV_DOMAIN_CS_PS:
      state = NASI_CS_ATTACHED;
      break;

    default:
      state = NASI_CS_UNKNOWN;
      break;
  }

  return state;
}

/*===========================================================================
  FUNCTION qmi_nas_get_ps_attach_state()

  DESCRIPTION
    get ps attach state based on CM SS event

  RETURN VALUE
    registration state

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_nasi_ps_attach_e_type qmi_nas_get_ps_attach_state( cm_mm_ss_info_s_type *p_info )
{
  qmi_nasi_ps_attach_e_type state;
  sys_srv_domain_e_type     srv_domain = p_info->srv_domain;

  switch ( srv_domain )
  {
    case SYS_SRV_DOMAIN_NO_SRV:
    case SYS_SRV_DOMAIN_CAMPED:
    case SYS_SRV_DOMAIN_CS_ONLY:
      state = NASI_PS_DETACHED;
      break;

    case SYS_SRV_DOMAIN_PS_ONLY:
    case SYS_SRV_DOMAIN_CS_PS:
      state = NASI_PS_ATTACHED;
      break;

    default:
      state = NASI_PS_UNKNOWN;
      break;
  }
  
  return state;
}

/*===========================================================================
  FUNCTION qmi_nas_get_reg_network()

  DESCRIPTION
    get registered network info based on CM SS event

  RETURN VALUE
    registration state

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_nasi_reg_net_e_type qmi_nas_get_reg_network( cm_mm_ss_info_s_type *p_info )
{
  qmi_nasi_reg_net_e_type network;
  sys_sys_mode_e_type     sys_mode = p_info->sys_mode;

  switch ( sys_mode )
  {
    case SYS_SYS_MODE_CDMA:
    case SYS_SYS_MODE_HDR:
      network = NASI_REG_NET_3GPP2;
      break;

    case SYS_SYS_MODE_GSM:
    case SYS_SYS_MODE_WCDMA:
    case SYS_SYS_MODE_GW:
    case SYS_SYS_MODE_LTE:
      network = NASI_REG_NET_3GPP;
      break;

    default:
      network = NASI_REG_NET_UNKNOWN;
      break;
  }

  return network;
}

/*===========================================================================
  FUNCTION qmi_nas_get_in_use_radio_if()

  DESCRIPTION
    get radio interfaces in use based on CM SS event

  RETURN VALUE
    number of radio interfaces in use

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
int qmi_nas_get_in_use_radio_if(
  cm_mm_ss_info_s_type * p_info,
  nas_radio_if_enum_v01     * p_radio_if_lst
)
{
  int i = 0;

  if ( qmi_nas_sys_mode_2_radio_if(p_info,FALSE) != QMI_NAS_RADIO_IF_NONE )
    {
    *(p_radio_if_lst+i) = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,FALSE);
      i++;
    }

  if ( i == 0 ) // if no service, populate QMI_NAS_RADIO_IF_NONE
  {
    *(p_radio_if_lst+i) = (uint8)QMI_NAS_RADIO_IF_NONE;
    i++;
  }

  return i;
}
/*===========================================================================
  FUNCTION qmi_nas_get_data_capability()

  DESCRIPTION
    get data capabilities in use based on CM SS event

  RETURN VALUE
    number of data capabilities in use

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
int qmi_nas_get_data_capability(
  cm_mm_ss_info_s_type     * p_info,
  nas_data_capabilites_enum_v01 * p_data_capa_lst
)
{
  int cnt = 0;
  sys_hs_ind_e_type        hs_ind;
  sys_srv_domain_e_type    srv_capability = p_info->srv_capability;
  sys_egprs_support_e_type egprs_supp = p_info->cell_srv_ind.egprs_supp;

  hs_ind = p_info->cell_srv_ind.hs_ind;

  switch ( qmi_nas_sys_mode_2_radio_if(p_info,FALSE) )
  {
    case QMI_NAS_RADIO_IF_GSM:

      switch ( srv_capability )
      {
        case SYS_SRV_DOMAIN_PS_ONLY:
        case SYS_SRV_DOMAIN_CS_PS:
          if ( egprs_supp )
            p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EDGE_V01;
          else
            p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_GPRS_V01;
          break;

        case SYS_SRV_DOMAIN_CS_ONLY:
          p_data_capa_lst[cnt++]   = NAS_DATA_CAPABILITIES_GSM_V01;
          break;

        default:
          break;
      }
      break;

    #if defined(FEATURE_WCDMA)

    case QMI_NAS_RADIO_IF_UMTS:

      switch ( srv_capability )
      {
        case SYS_SRV_DOMAIN_PS_ONLY:
        case SYS_SRV_DOMAIN_CS_PS:

          switch ( hs_ind )
          {
            case SYS_HS_IND_HSDPA_SUPP_CELL: /* Cell supports HSDPA */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              break;

            case SYS_HS_IND_HSUPA_SUPP_CELL: /* Cell supports HSUPA. assume DPA as default */
            case SYS_HS_IND_HSDPA_HSUPA_SUPP_CELL: /* Cell supports HSDPA and HSUPA */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSUPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              break;

            case SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              break;

            case SYS_HS_IND_HSDPAPLUS_SUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01;
              break;

            case SYS_HS_IND_HSDPAPLUS_HSUPA_SUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSUPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01;
              break;

            case SYS_HS_IND_DC_HSDPAPLUS_SUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_DC_HSDPA_PLUS_V01;
              break;

            case SYS_HS_IND_DC_HSDPAPLUS_HSUPA_SUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSUPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_DC_HSDPA_PLUS_V01;
              break;

            default: /* Add support for any new values */
              break;
          }
          break;

        default:
          break;
      }
      break;
      #endif

    #if defined(FEATURE_CDMA)
    case QMI_NAS_RADIO_IF_CDMA20001X:
      // P_rev: 3-5 => Low speed data
      // P_rev: 6 and greater => High speed data
      if ( p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use >= 3 )
      {
        p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_CDMA_V01;
      }
      break;
    #endif
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    case QMI_NAS_RADIO_IF_CDMA20001XEVDO:

      switch ( p_info->stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_active_prot )
      {
        case SYS_ACTIVE_PROT_NONE:
        case SYS_ACTIVE_PROT_HDR_START:
          break;

        case SYS_ACTIVE_PROT_HDR_REL0: /* Cell supports HDR Rev0 */
          p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_O_V01;
          break;

        case SYS_ACTIVE_PROT_HDR_RELA: /* Cell supports HDR RevA */
          p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_A_V01;
          break;

        case SYS_ACTIVE_PROT_HDR_RELB: /* Cell supports HDR RevB */
          p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_B_V01;
          break;

        default: /* Add support for any new values */
          break;
      }
      break;
    #endif
    case QMI_NAS_RADIO_IF_LTE:

      p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_LTE_V01;
      break;

    default:
      //service status received is 0
      break;
  }

  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  if ( p_info->asubs_id == SYS_MODEM_AS_ID_1 )
  {
    switch ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) )
    {
      case QMI_NAS_RADIO_IF_CDMA20001XEVDO:

        if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE) != QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          switch ( p_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_active_prot )
          {
            case SYS_ACTIVE_PROT_HDR_REL0: /* Cell supports HDR Rev0 */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_O_V01;
              break;

            case SYS_ACTIVE_PROT_HDR_RELA: /* Cell supports HDR RevA */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_A_V01;
              break;

            case SYS_ACTIVE_PROT_HDR_RELB: /* Cell supports HDR RevB */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_B_V01;
              break;

            default: /* Add support for any new values */
              break;
          }
        }
        break;

      default:
        break;
    }
  }
  #endif

  return cnt;
}

/*===========================================================================
  FUNCTION qmi_nas_get_roaming_indicator()

  DESCRIPTION
    get roaming indicator based on CM SS event

  RETURN VALUE
    roaming indicator

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8 qmi_nas_get_roaming_indicator( cm_mm_ss_info_s_type *p_info )
{
  uint8                  roam_ind;
  sys_roam_status_e_type roam_status = p_info->roam_status;

  switch ( roam_status )
  {
    case SYS_ROAM_STATUS_OFF: roam_ind = 1; /* home */       break;
    case SYS_ROAM_STATUS_ON:  roam_ind = 0; /*roaming */     break;
    default:                  roam_ind = (uint8)roam_status; break;
  }

  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  if ( p_info->asubs_id == SYS_MODEM_AS_ID_1 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
      switch ( p_info->stack_info[STACK_INDEX_1].roam_status )
      {
        case SYS_ROAM_STATUS_OFF: roam_ind = 1; /* home */                   break;
        case SYS_ROAM_STATUS_ON:  roam_ind = 0; /*roaming */                 break;
        default:                  roam_ind = (uint8)p_info->stack_info[STACK_INDEX_1].roam_status; break;
      }
    }
  }
  #endif

  return roam_ind;
}

/*===========================================================================
  FUNCTION qmi_nas_get_roaming_ind_list()

  DESCRIPTION
    get roaming indicator list based on CM SS event

  RETURN VALUE
    number of elements

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8 qmi_nas_get_roaming_ind_list(
  cm_mm_ss_info_s_type      * p_info,
  nas_roaming_indicator_type_v01 * p_roam_ind
)
{
  uint8                  cnt         = 0;
  sys_roam_status_e_type roam_status = p_info->roam_status;
  sys_srv_status_e_type  srv_status  = p_info->srv_status;
  //enum qmi_nas_radio_if_e my_radio_if;

  if ( srv_status != SYS_SRV_STATUS_NO_SRV && srv_status != SYS_SRV_STATUS_PWR_SAVE )
  {
    if ( roam_status != SYS_ROAM_STATUS_UNKNOWN )
  {
      p_roam_ind->radio_if = (nas_radio_if_enum_v01) qmi_nas_sys_mode_2_radio_if( p_info, FALSE );

    switch ( roam_status )
    {
      case SYS_ROAM_STATUS_OFF:   
        p_roam_ind->roaming_indicator = NAS_ROAMING_IND_OFF_V01;
        break; /* home */
      case SYS_ROAM_STATUS_ON:    
        p_roam_ind->roaming_indicator = NAS_ROAMING_IND_ON_V01;
        break; /* roaming */
      default:
        p_roam_ind->roaming_indicator = (nas_roaming_indicator_enum_v01) roam_status;
        QM_MSG_HIGH_1("ENUM, %d, being returned as roaming indicator.", p_roam_ind->roaming_indicator);
        break;
    }

    cnt++;
    p_roam_ind++;
  }
  }

  return cnt;
}

/*===========================================================================
  FUNCTION qmi_nas_get_def_roam_ind()

  DESCRIPTION
    Gives the default roaming indicator based on CM SS event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8 qmi_nas_get_def_roam_ind( cm_mm_msim_ss_info_s_type *p_info )
{
  uint8 def_roam_ind;

  switch ( p_info->def_roam_ind )
  {
    case SYS_ROAM_STATUS_OFF: def_roam_ind = 1; /* home */                break;
    case SYS_ROAM_STATUS_ON:  def_roam_ind = 0; /* roaming */             break;
    default:                  def_roam_ind = (uint8)p_info->def_roam_ind; break;
  }

  return def_roam_ind;
}
#ifdef FEATURE_MMODE_DISABLE_UIM
/*===========================================================================
  FUNCTION qmi_nas_populate_serving_system_ind_msg()

  DESCRIPTION
    populatest serving system ind msg structure based on given
    CM SS and CM PH event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_serving_system_ind_msg(
  cm_mm_ss_info_s_type           * p_ss_info,
  qmi_cm_ph_info_s_type              * p_ph_info,
  nas_serving_system_ind_msg_v01 * p_msg,
  boolean                          recreating_msg
)
{
  sys_sys_id_s_type         sys_id         = p_ss_info->sys_id;
  sys_mm_information_s_type mm_information = p_ss_info->mm_information;
  sys_lac_type              lac            = qmi_nas_get_lac( p_ss_info);
  sys_lac_type              lac_tac        = p_ss_info->sys_mode == SYS_SYS_MODE_LTE ? p_ss_info->tac : qmi_nas_get_lac(p_ss_info);
  sys_cell_id_type          cell_id        = p_ss_info->cell_info.cell_id;
  uint16                    psc            = p_ss_info->cell_info.psc;
  sys_dtm_support_e_type    dtm_supp       = p_ss_info->cell_srv_ind.dtm_supp;
  sys_srv_status_e_type     srv_status     = p_ss_info->srv_status;
  sys_srv_domain_e_type     srv_capability = p_ss_info->srv_capability;
  mmgsdi_session_type_enum_type session    = MMGSDI_GW_PROV_PRI_SESSION;
  sys_domain_access_bar_s_type  cell_access_info = p_ss_info->cell_access_info;

  #ifdef FEATURE_DUAL_SIM
  if( p_ss_info->asubs_id == SYS_MODEM_AS_ID_2 )
  {
    session        = MMGSDI_GW_PROV_SEC_SESSION;
  }
  #endif
  {
    p_msg->serving_system.registration_state = qmi_nas_get_reg_state( p_ss_info, p_ph_info );
    p_msg->serving_system.cs_attach_state    = (uint8) qmi_nas_get_cs_attach_state( p_ss_info );
    p_msg->serving_system.ps_attach_state    = (uint8) qmi_nas_get_ps_attach_state( p_ss_info );
    p_msg->serving_system.selected_network   = (uint8) qmi_nas_get_reg_network( p_ss_info );
    p_msg->serving_system.radio_if_len       = (uint8) qmi_nas_get_in_use_radio_if( p_ss_info, &p_msg->serving_system.radio_if[0] );
  } // TLV 01 Serving System

  if ( p_ss_info->srv_status     != SYS_SRV_STATUS_NO_SRV && p_ss_info->srv_status  != SYS_SRV_STATUS_PWR_SAVE )
  {
    p_msg->roaming_indicator       = qmi_nas_get_roaming_indicator( p_ss_info );
    if ( (uint8)p_msg->roaming_indicator != (uint8)SYS_ROAM_STATUS_UNKNOWN )
    {
      p_msg->roaming_indicator_valid = TRUE;
    }
  }

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    p_msg->data_capabilities_len   = (uint8) qmi_nas_get_data_capability( p_ss_info, &p_msg->data_capabilities[0] );
    p_msg->data_capabilities_valid = TRUE;
  }
  else
  {
    p_msg->data_capabilities_len = 0;
    p_msg->data_capabilities_valid = TRUE;
  }// TLV 11

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  if ( srv_status ==  SYS_SRV_STATUS_SRV     ||
       srv_status ==  SYS_SRV_STATUS_LIMITED ||
       srv_status ==  SYS_SRV_STATUS_LIMITED_REGIONAL )
  {
    sys_plmn_id_s_type plmn;
    sys_mcc_type       mcc;
    sys_mnc_type       mnc;
    boolean            plmn_undefined, plmn_includes_pcs_digit_ptr;

    if ( sys_id.id_type == SYS_SYS_ID_TYPE_UMTS )
    {
      plmn = sys_id.id.plmn;

      sys_plmn_get_mcc_mnc( plmn, &plmn_undefined, &plmn_includes_pcs_digit_ptr, &mcc, &mnc );

      (void) hput16( (byte *) &p_msg->current_plmn.mobile_country_code, (uint16) mcc );
      (void) hput16( (byte *) &p_msg->current_plmn.mobile_network_code, (uint16) mnc );
      (void) hput16( (byte *) &p_msg->mnc_includes_pcs_digit.mcc,       (uint16) mcc );
      (void) hput16( (byte *) &p_msg->mnc_includes_pcs_digit.mnc,       (uint16) mnc );
      p_msg->mnc_includes_pcs_digit.mnc_includes_pcs_digit = plmn_includes_pcs_digit_ptr;

      if ( recreating_msg ) // purpose is to read last reported network name
      {
        strlcpy( p_msg->current_plmn.network_description, (char *) qmi_nasi_global.prev_nw_desc[SYS_MODEM_AS_ID_1].desc, MIN( NAS_NETWORK_DESCRIPTION_MAX_V01 + 1, QMI_NAS_NET_DESC_LEN_MAX ) );
        p_msg->current_plmn_valid = TRUE;
      }
      else if ( !plmn_undefined )
      {
        mmgsdi_eons_evt_info_type *eons;

        if( (eons = qmi_nas_nw_name_find( session, plmn, lac_tac, 
                                                                  qmi_nas_rat_cm_mode_to_mmgsdi(p_ss_info->sys_mode), 
                                                                  #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
                                                                  qm_util_retrieve_csg_id(p_ss_info, STACK_INDEX_0)
                                                                  #else
                                                                  SYS_CSG_ID_INVALID
                                                                  #endif
                                                                  )) != NULL )
          {
          memscpy( p_msg->current_plmn.network_description, 
                   eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len,
                   eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, 
                   eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len );
        }
        p_msg->current_plmn_valid = TRUE;
        p_msg->mnc_includes_pcs_digit_valid = TRUE;
      }
    }
  } // TLV 12 (Current PLMN)
#endif

#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
      {
        p_msg->cdma_system_id.sid   = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.sid;
        p_msg->cdma_system_id.nid   = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.nid;
        p_msg->cdma_system_id_valid = TRUE;
      }
    }
  } // TLV 13 (CDMA System ID)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
      {
        p_msg->cdma_base_station_info.base_id   = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_id;
        p_msg->cdma_base_station_info.base_lat  = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_lat;
        p_msg->cdma_base_station_info.base_long = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_long;
        p_msg->cdma_base_station_info_valid     = TRUE;
      }
    }
  } // TLV 14 (CDMA Base Station Information)

  p_msg->roaming_indicator_list_len = qmi_nas_get_roaming_ind_list( p_ss_info, &p_msg->roaming_indicator_list[0] );

  if ( p_msg->roaming_indicator_list_len > 0 )
  {
    p_msg->roaming_indicator_list_valid = TRUE;
  } // TLV 15 (Roaming Indicator List)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO 
           #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
           || qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
           #endif
           )
      {
        p_msg->def_roam_ind = qmi_nas_get_def_roam_ind( p_ss_info );
        p_msg->def_roam_ind_valid = TRUE;
      }
    }
  } // TLV 16 (Default Roaming Indicator)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO 
           #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
           || qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
           #endif
           )
      {
        if ( qmi_nasi_include_3GPP2_time_zone( &p_msg->nas_3gpp_time_zone.lp_sec, &p_msg->nas_3gpp_time_zone.ltm_offset, &p_msg->nas_3gpp_time_zone.daylt_savings, p_ss_info ) )
        {
          p_msg->nas_3gpp_time_zone_valid = TRUE;
        }
      }
    }
  } // TLV 17 (3GPP2 Time Zone)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
      {
        p_msg->p_rev_in_use = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use;
        p_msg->p_rev_in_use_valid = TRUE;
      }
    }
  } // TLV 18 (CDMA P_Rev In Use)
#endif
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 && !recreating_msg ) // don't include tlv when recreating
  {
    sys_plmn_id_s_type plmn;
    boolean                     plmn_name_changed = FALSE;
    mmgsdi_eons_evt_info_type *eons;

    if ( sys_id.id_type == SYS_SYS_ID_TYPE_UMTS )
    {
      plmn = sys_id.id.plmn;

      if( (eons = qmi_nas_nw_name_find( session, plmn, lac_tac, 
                                                                 qmi_nas_rat_cm_mode_to_mmgsdi(p_ss_info->sys_mode), 
                                                                 #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
                                                                 qm_util_retrieve_csg_id(p_ss_info, STACK_INDEX_0) 
                                                                 #else
                                                                 SYS_CSG_ID_INVALID
                                                                 #endif
                                                                 )) != NULL )
      {
//        QM_MSG_LOW_3("SPN=%d, short=%d, long=%d", eons->spn.eons_data.data_len, eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len, eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len);

        if ( (qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_encoding != eons->spn.eons_encoding) ||
             (qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len != eons->spn.eons_data.data_len) ||
             memcmp( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr, eons->spn.eons_data.data_ptr, eons->spn.eons_data.data_len ) )
        {
          QM_MSG_HIGH("SPN has changed from cached value");
          if ( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr != NULL )
          {
            modem_mem_free( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
            qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr = NULL;
          }
          qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_encoding = eons->spn.eons_encoding;
          qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len = eons->spn.eons_data.data_len;
          if( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len > 0 )
          {
             qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr = modem_mem_alloc(qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len, MODEM_MEM_CLIENT_QMI_MMODE);
             if( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr != NULL )
             {
               memscpy( (void*)qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr, 
                        qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len, 
                        (void*)eons->spn.eons_data.data_ptr, 
                        eons->spn.eons_data.data_len );
             }
          }
          plmn_name_changed = TRUE;
        }

        if ( (qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name_spare_bits          != eons->first_stack_info.operator_info.plmn_short_name.plmn_name_spare_bits)         ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name_ci                  != eons->first_stack_info.operator_info.plmn_short_name.plmn_name_ci)                 ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_encoding       != eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_encoding)      ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len != eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len) ||
             memcmp( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr, eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len ) ) 
        {
          QM_MSG_HIGH("PLMN short name has changed from cached value");
          if ( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr != NULL )
          {
            modem_mem_free( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
            qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr = NULL;
          }
          qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name_spare_bits = eons->first_stack_info.operator_info.plmn_short_name.plmn_name_spare_bits;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name_ci = eons->first_stack_info.operator_info.plmn_short_name.plmn_name_ci;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_encoding = eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_encoding;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len = eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len;
          if( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len > 0 )
          {
             qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr = modem_mem_alloc(qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len, MODEM_MEM_CLIENT_QMI_MMODE);
             if( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr != NULL )
             {
               memscpy( (void*)qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr, 
                        qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len, 
                       (void*)eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, 
                       eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len );
             }
          }
          plmn_name_changed = TRUE;
        }

        if ( (qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name_spare_bits          != eons->first_stack_info.operator_info.plmn_long_name.plmn_name_spare_bits)         ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name_ci                  != eons->first_stack_info.operator_info.plmn_long_name.plmn_name_ci)                 ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_encoding       != eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_encoding)      ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len != eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len) ||
             memcmp( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr, eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_ptr, eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len ) )
        {
          QM_MSG_LOW( "PLMN long name has changed from cached value" );
          if ( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr != NULL )
          {
            modem_mem_free( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
            qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr = NULL;
          }
          qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name_spare_bits = eons->first_stack_info.operator_info.plmn_long_name.plmn_name_spare_bits;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name_ci = eons->first_stack_info.operator_info.plmn_long_name.plmn_name_ci;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_encoding = eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_encoding;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len = eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len;
          if( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len > 0 )
          {
             qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr = modem_mem_alloc(qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len, MODEM_MEM_CLIENT_QMI_MMODE);
             if( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr != NULL )
             {
               memscpy( (void*)qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr, 
                        qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len, 
                       (void*)eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_ptr, 
                       eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len );
             }
          }
          plmn_name_changed = TRUE;
        }

        if ( plmn_name_changed )
        {
          QM_MSG_LOW_3("SPN=%d, short=%d, long=%d", eons->spn.eons_data.data_len, eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len, eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len);
        
          p_msg->plmn_description_changed_valid = TRUE;
          p_msg->plmn_description_changed       = 0x01;
        }
      }
    }
  } // TLV 19 (3GPP PLMN Name Flag)
#endif //#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         #if defined(FEATURE_WCDMA)
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         #endif
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      if ( mm_information.time_zone_avail )
      {
        p_msg->time_zone       = (int8) mm_information.time_zone;
        p_msg->time_zone_valid = TRUE;
      }
    }
  } // TLV 1A 3GPP time_zone

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         #if defined(FEATURE_WCDMA)
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         #endif
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      if ( mm_information.daylight_saving_adj_avail )
      {
        p_msg->adj       = (uint8) mm_information.daylight_saving_adj;
        p_msg->adj_valid = TRUE;
      }
    }
  } // TLV 1B 3GPP daylight savings time adjustments

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         #if defined(FEATURE_WCDMA)
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         #endif
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      if( mm_information.univ_time_and_time_zone_avail )
      {
        p_msg->universal_time_and_local_time_3gpp_zone.year      = mm_information.univ_time_and_time_zone.year + 2000; // NITZ sends 2011 as 11
        p_msg->universal_time_and_local_time_3gpp_zone.month     = mm_information.univ_time_and_time_zone.month;
        p_msg->universal_time_and_local_time_3gpp_zone.day       = mm_information.univ_time_and_time_zone.day;
        p_msg->universal_time_and_local_time_3gpp_zone.hour      = mm_information.univ_time_and_time_zone.hour;
        p_msg->universal_time_and_local_time_3gpp_zone.minute    = mm_information.univ_time_and_time_zone.minute;
        p_msg->universal_time_and_local_time_3gpp_zone.second    = mm_information.univ_time_and_time_zone.second;
        p_msg->universal_time_and_local_time_3gpp_zone.time_zone = (int8) mm_information.univ_time_and_time_zone.time_zone;
        p_msg->universal_time_and_local_time_3gpp_zone_valid     = TRUE;
      }
    }
  } // TLV 1C 3GPP UTC time and time_zone (i.e offset from UTC)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         #if defined(FEATURE_WCDMA)
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         #endif
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      if( lac != QMI_NAS_INVALID_LAC )
      {
        p_msg->lac       = lac;
        p_msg->lac_valid = TRUE;
      }
    }
  } // TLV 1D Location Area Code

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         #if defined(FEATURE_WCDMA)
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         #endif
         qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      p_msg->cell_id       = cell_id;
      p_msg->cell_id_valid = TRUE;
    }
  } // TLV 1E cell id

#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))

#if defined (FEATURE_IS2000_REL_A_SVD)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO 
           #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
           || qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
           #endif
           )
      {
        p_msg->ccs       = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.ccs_supported;
        p_msg->ccs_valid = TRUE;
      }
    }
  } // TLV 1F Concurrent Service Info
#endif

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO 
           #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
           || qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
           #endif
           )
      {
        p_msg->prl_ind       = p_ss_info->stack_info[STACK_INDEX_0].is_sys_prl_match;
        p_msg->prl_ind_valid = TRUE;
      }
    }
  } // TLV 20 PRL indicator
#endif

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM )
    {
      p_msg->dtm_ind       = (uint8) dtm_supp;
      p_msg->dtm_ind_valid = TRUE;
    }
  } // TLV 21 DTM indicator

  {
    p_msg->detailed_service_info.srv_status       = (uint8) srv_status;
    p_msg->detailed_service_info.srv_capability   = (uint8) srv_capability;
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    if ( p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR )
    {
      p_msg->detailed_service_info.hdr_srv_status   = (uint8) p_ss_info->stack_info[STACK_INDEX_1].srv_status;
      p_msg->detailed_service_info.hdr_hybrid       = p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_hybrid;
    }
    #endif
    p_msg->detailed_service_info.is_sys_forbidden = p_ss_info->plmn_forbidden;
    p_msg->detailed_service_info_valid            = TRUE;
  } // TLV 22 Detailed Service Info
  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
      {
        p_msg->cdma_system_id_ext.mcc        = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc;
        p_msg->cdma_system_id_ext.imsi_11_12 = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12;
        p_msg->cdma_system_id_ext_valid      = TRUE;
      }
    }
  } // TLV 23 CDMA System ID - ext

  #if defined(FEATURE_HDR)
  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0 ,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
        p_msg->hdr_personality       = (uint8) qmi_nas_cm_2_qmi_hdr_personality( p_ss_info->stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_personality);
        p_msg->hdr_personality_valid = TRUE;
      }
      else if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
      {
        p_msg->hdr_personality       = (uint8) qmi_nas_cm_2_qmi_hdr_personality( p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_personality);
        p_msg->hdr_personality_valid = TRUE;
      }
  } // TLV 24 HDR personality
  #endif
  #endif
  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      p_msg->tac       = p_ss_info->tac;
      p_msg->tac_valid = TRUE;
    }
  } // TLV 25 Tracking Area Code

  if ( srv_status != SYS_SRV_STATUS_PWR_SAVE &&
       srv_status != SYS_SRV_STATUS_NO_SRV )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM 
           #if defined(FEATURE_WCDMA)
           || qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS 
           #endif
         )
      {
        if ( cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
             cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
          p_msg->call_barring_status.cs_bar_status = (uint32) cell_access_info.cs_bar_status;
        }
        else
        {
          p_msg->call_barring_status.cs_bar_status = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
        if ( cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
             cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
          p_msg->call_barring_status.ps_bar_status = (uint32) cell_access_info.ps_bar_status;
        }
        else
        {
          p_msg->call_barring_status.ps_bar_status = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
        p_msg->call_barring_status_valid = TRUE;
      }
    } // TLV 26 Call Barring

  if ( p_ss_info->changed_fields & CM_SS_EVT_NO_CHANGE_MASK )
  {
    p_msg->srv_sys_no_change_valid = TRUE;
    p_msg->srv_sys_no_change = TRUE;
  }  // TLV 27

  #if defined(FEATURE_WCDMA)
  if ( qmi_nas_sys_mode_2_radio_if( p_ss_info, FALSE ) == QMI_NAS_RADIO_IF_UMTS && psc != 0xFFFF )
  {
    p_msg->umts_psc       = psc;
    p_msg->umts_psc_valid = TRUE;
  } // TLV 28 PSC

  if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,FALSE) == QMI_NAS_RADIO_IF_UMTS )
  {
    p_msg->hs_call_status = (nas_hs_support_enum_type_v01)p_ss_info->cell_srv_ind.hs_call_status;
    p_msg->hs_call_status_valid = TRUE;
  } // TLV 2A HS call status
  #endif
}
#endif
/*===========================================================================
  FUNCTION qmi_nas_gen_serving_system_ind()

  DESCRIPTION
    Generate and send serving system IND message

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_serving_system_ind(
  cm_mm_ss_info_s_type * p_ss_info,
  qmi_cm_ph_info_s_type    * p_ph_info,
  qmi_cm_ph_info_s_type    * p_ph_info2
)
{
  nas_serving_system_ind_msg_v01 * new_ind;
  nas_serving_system_ind_msg_v01 * old_ind;

  qmi_cm_ph_info_s_type              * p_new_ph_info;
  qmi_cm_ph_info_s_type              * p_old_ph_info;

  dsm_item_type                  * indication      = NULL;
  boolean                          send_indication = TRUE;     // replaces new_ind->t01_valid, which ALWAYS comes back TRUE from call to qmi_nas_populate_serving_system_ind_msg();

  qmi_nasi_client_state_type *cl_sp;

  new_ind = (nas_serving_system_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_serving_system_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  old_ind = (nas_serving_system_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_serving_system_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( new_ind != NULL && old_ind != NULL )
  {
    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {
      if ( !cl_sp->report_status.not_report_serving_system )
      {
        p_new_ph_info = p_ph_info;
        p_old_ph_info = &qmi_nasi_global.cm_ph_info;

        memset( new_ind, 0x00, sizeof(nas_serving_system_ind_msg_v01) );
        memset( old_ind, 0x00, sizeof(nas_serving_system_ind_msg_v01) );

        qmi_nas_populate_serving_system_ind_msg( p_ss_info,                   p_new_ph_info, new_ind, FALSE );
        qmi_nas_populate_serving_system_ind_msg( &qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY], p_old_ph_info, old_ind, TRUE );

        if ( !qmi_nasi_global.rcvd_ss_info )
        {
          send_indication = TRUE;
        }
        else if ( memcmp( old_ind, new_ind, sizeof(nas_serving_system_ind_msg_v01) ) )
        {
          if ( old_ind->universal_time_and_local_time_3gpp_zone_valid && ! memcmp( &old_ind->universal_time_and_local_time_3gpp_zone,
                                                                                       &new_ind->universal_time_and_local_time_3gpp_zone,
                                                                                       sizeof(new_ind->universal_time_and_local_time_3gpp_zone) )
             ) new_ind->universal_time_and_local_time_3gpp_zone_valid = FALSE;

          if ( old_ind->data_capabilities_valid        && ! memcmp( &old_ind->data_capabilities,
                                                                        &new_ind->data_capabilities,
                                                                        MAX( new_ind->data_capabilities_len,      old_ind->data_capabilities_len      ) * sizeof(nas_data_capabilites_enum_v01) )
             ) new_ind->data_capabilities_valid        = FALSE;

          if ( old_ind->roaming_indicator_list_valid   && ! memcmp( &old_ind->roaming_indicator_list,
                                                                        &new_ind->roaming_indicator_list,
                                                                        MAX( new_ind->roaming_indicator_list_len, old_ind->roaming_indicator_list_len ) * sizeof(nas_roaming_indicator_type_v01) )
             ) new_ind->roaming_indicator_list_valid   = FALSE;

          if (                                            ! memcmp( &old_ind->serving_system,           &new_ind->serving_system,           sizeof(new_ind->serving_system) )
             ) send_indication                         = FALSE;
          if ( old_ind->roaming_indicator_valid        && ! memcmp( &old_ind->roaming_indicator,        &new_ind->roaming_indicator,        sizeof(new_ind->roaming_indicator) )
             ) new_ind->roaming_indicator_valid        = FALSE;
          if ( old_ind->current_plmn_valid             && ! memcmp( &old_ind->current_plmn,             &new_ind->current_plmn,             sizeof(new_ind->current_plmn) )
             ) new_ind->current_plmn_valid             = FALSE;
          #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
          if ( old_ind->cdma_system_id_valid           && ! memcmp( &old_ind->cdma_system_id,           &new_ind->cdma_system_id,           sizeof(new_ind->cdma_system_id) )
             ) new_ind->cdma_system_id_valid           = FALSE;
          if ( old_ind->cdma_base_station_info_valid   && ! memcmp( &old_ind->cdma_base_station_info,   &new_ind->cdma_base_station_info,   sizeof(new_ind->cdma_base_station_info) )
             ) new_ind->cdma_base_station_info_valid   = FALSE;
          #endif
          if ( old_ind->def_roam_ind_valid             && ! memcmp( &old_ind->def_roam_ind,             &new_ind->def_roam_ind,             sizeof(new_ind->def_roam_ind) )
             ) new_ind->def_roam_ind_valid             = FALSE;
          if ( old_ind->nas_3gpp_time_zone_valid       && ! memcmp( &old_ind->nas_3gpp_time_zone,       &new_ind->nas_3gpp_time_zone,       sizeof(new_ind->nas_3gpp_time_zone) )
             ) new_ind->nas_3gpp_time_zone_valid       = FALSE;
          #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
          if ( old_ind->p_rev_in_use_valid             && ! memcmp( &old_ind->p_rev_in_use,             &new_ind->p_rev_in_use,             sizeof(new_ind->p_rev_in_use) )
             ) new_ind->p_rev_in_use_valid             = FALSE;
          #endif
          if ( old_ind->plmn_description_changed_valid && ! memcmp( &old_ind->plmn_description_changed, &new_ind->plmn_description_changed, sizeof(new_ind->plmn_description_changed) )
             ) new_ind->plmn_description_changed_valid = FALSE;
          if ( old_ind->time_zone_valid                && ! memcmp( &old_ind->time_zone,                &new_ind->time_zone,                sizeof(new_ind->time_zone) )
             ) new_ind->time_zone_valid                = FALSE;
          if ( old_ind->adj_valid                      && ! memcmp( &old_ind->adj,                      &new_ind->adj,                      sizeof(new_ind->adj) )
             ) new_ind->adj_valid                      = FALSE;
          if ( old_ind->lac_valid                      && ! memcmp( &old_ind->lac,                      &new_ind->lac,                      sizeof(new_ind->lac) )
             ) new_ind->lac_valid                      = FALSE;
          if ( old_ind->cell_id_valid                  && ! memcmp( &old_ind->cell_id,                  &new_ind->cell_id,                  sizeof(new_ind->cell_id) )
             ) new_ind->cell_id_valid                  = FALSE;
          #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
          if ( old_ind->ccs_valid                      && ! memcmp( &old_ind->ccs,                      &new_ind->ccs,                      sizeof(new_ind->ccs) )
             ) new_ind->ccs_valid                      = FALSE;
          if ( old_ind->prl_ind_valid                  && ! memcmp( &old_ind->prl_ind,                  &new_ind->prl_ind,                  sizeof(new_ind->prl_ind) )
             ) new_ind->prl_ind_valid                  = FALSE;
          #endif
          if ( old_ind->dtm_ind_valid                  && ! memcmp( &old_ind->dtm_ind,                  &new_ind->dtm_ind,                  sizeof(new_ind->dtm_ind) )
             ) new_ind->dtm_ind_valid                  = FALSE;
          if ( old_ind->detailed_service_info_valid    && ! memcmp( &old_ind->detailed_service_info,    &new_ind->detailed_service_info,    sizeof(new_ind->detailed_service_info) )
             ) new_ind->detailed_service_info_valid    = FALSE;
          #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
          if ( old_ind->cdma_system_id_ext_valid       && ! memcmp( &old_ind->cdma_system_id_ext,       &new_ind->cdma_system_id_ext,       sizeof(new_ind->cdma_system_id_ext) )
             ) new_ind->cdma_system_id_ext_valid       = FALSE;
          if ( old_ind->hdr_personality_valid          && ! memcmp( &old_ind->hdr_personality,          &new_ind->hdr_personality,          sizeof(new_ind->hdr_personality) )
             ) new_ind->hdr_personality_valid          = FALSE;
          #endif
          if ( old_ind->tac_valid                      && ! memcmp( &old_ind->tac,                      &new_ind->tac,                      sizeof(new_ind->tac) )
             ) new_ind->tac_valid                      = FALSE;
          if ( old_ind->call_barring_status_valid      && ! memcmp( &old_ind->call_barring_status,      &new_ind->call_barring_status,      sizeof(new_ind->call_barring_status) )
             ) new_ind->call_barring_status_valid      = FALSE;
          #ifdef FEATURE_WCDMA
          if ( old_ind->hs_call_status_valid           && ! memcmp( &old_ind->hs_call_status,           &new_ind->hs_call_status,           sizeof(new_ind->hs_call_status) )
             ) new_ind->hs_call_status_valid           = FALSE;
          #endif
          // Don't comapre TLV 0x27. Always send if available in new_ind msg
          // Only sending t29 when t12 is also sent

          if ( new_ind->current_plmn_valid == FALSE ) new_ind->mnc_includes_pcs_digit_valid = FALSE;

          if ( new_ind->roaming_indicator_valid                         || new_ind->data_capabilities_valid        ||
               new_ind->current_plmn_valid                              
               #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
               || new_ind->cdma_system_id_valid           || new_ind->cdma_base_station_info_valid                 
               #endif
               || new_ind->roaming_indicator_list_valid   || new_ind->def_roam_ind_valid                           || 
               new_ind->nas_3gpp_time_zone_valid       ||
               #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
               new_ind->p_rev_in_use_valid                              || 
               #endif
               new_ind->plmn_description_changed_valid ||
               new_ind->time_zone_valid                                 || new_ind->adj_valid                      ||
               new_ind->universal_time_and_local_time_3gpp_zone_valid   || new_ind->lac_valid                      ||
               new_ind->cell_id_valid                                   ||
               #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
               new_ind->ccs_valid                      ||
               new_ind->prl_ind_valid                                   || 
               #endif
               new_ind->dtm_ind_valid                  ||
               new_ind->detailed_service_info_valid                     || 
               #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
               new_ind->cdma_system_id_ext_valid       || new_ind->hdr_personality_valid                           || 
               #endif
               new_ind->tac_valid                      ||
               new_ind->call_barring_status_valid                       || new_ind->srv_sys_no_change_valid        
               #if defined(FEATURE_WCDMA)
               || new_ind->hs_call_status_valid 
               #endif
               )
          {
            send_indication = TRUE;
          }

          if ( send_indication )
          {
            new_ind->data_capabilities_valid = TRUE;                                                 // If we have anything to send, data caps TLV must be included.
          }
//informtion changed but nothing to send
          }
//No change in contents of serving system indication
        if ( send_indication )
        {
          indication = NULL;                                                                         // Important!  When multiple encode calls may be made.
          if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_SERVING_SYSTEM_IND_MSG_V01,          // message_id = 0x0024 for _IND
                                             (void *)   new_ind,
                                             (uint32_t) sizeof(nas_serving_system_ind_msg_v01),
                                             &indication ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_GET_SERVING_SYSTEM, indication );
          }
          else
          {
            QM_MSG_HIGH_1("qmi_nas_gen_serving_system_ind(): idl_message_encode() failed, no indication sent. %p", cl_sp->clnt);
          }
      }
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }
  
    p_new_ph_info = p_ph_info;
    memset( new_ind, 0x00, sizeof(nas_serving_system_ind_msg_v01) );
  
    qmi_nas_populate_serving_system_ind_msg( p_ss_info, p_new_ph_info, new_ind, FALSE );
  
    if ( new_ind->serving_system.registration_state != NAS_REGISTERED_V01 )
    {
      memset( qmi_nasi_global.prev_nw_desc[SYS_MODEM_AS_ID_1].desc, 0x00, QMI_NAS_NET_DESC_LEN_MAX );
    }
    else if ( new_ind->current_plmn_valid )
    {
      /*NAS_NETWORK_DESCRIPTION_MAX_V01+1 or QMI_NAS_NET_DESC_LEN_MAX*/
      memscpy( qmi_nasi_global.prev_nw_desc[SYS_MODEM_AS_ID_1].desc, QMI_NAS_NET_DESC_LEN_MAX, 
                 new_ind->current_plmn.network_description, QMI_NAS_NET_DESC_LEN_MAX );         
    }
    if ( !qmi_nasi_global.rcvd_ss_info )
    {
      qmi_nasi_global.rcvd_ss_info = TRUE;
    }
  }

  if ( new_ind != NULL ) { modem_mem_free( (void *) new_ind, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( old_ind != NULL ) { modem_mem_free( (void *) old_ind, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

#endif

#if defined(FEATURE_HDR)
/*===========================================================================
  FUNCTION qmi_nas_crossed_hdr_rssi_threashold()

  DESCRIPTION
    check whether hdr_rssi in argument passed threshold compared to last reported hdr rssi

  RETURN VALUE
    TRUE if new hdr rssi value crossed threshold. FALSE if not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_crossed_hdr_rssi_threashold( cm_mm_msim_ss_info_s_type *p_info, qmi_nasi_client_state_type *cl_sp )
{
  struct report_status_s *p_rs = &cl_sp->report_status;
  uint16 i, rssi; // cm saves rssi as positive value by multiplying (-1)

  rssi = qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,FALSE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ? p_info->stack_info[STACK_INDEX_1].rssi 
                                                                                                    : p_info->stack_info[STACK_INDEX_0].rssi;

  for ( i=0; i<p_rs->num_thresholds; i++)
  {
    /*-----------------------------------------------------------------
      If current_rssi < threshold <= last_reported_hdr_rssi (eg -75>=-85>-95)
      -----------------------------------------------------------------*/
    if ( (-1)*(char)rssi < p_rs->sig_str_thresholds[i] && p_rs->sig_str_thresholds[i] <= (-1)*(char)p_rs->last_reported_hdr_rssi_ex )
      return TRUE;

    /*-----------------------------------------------------------------
      If last_reported_hdr_rssi < threshold <= current_rssi(eg -125<-85<=-75)
      -----------------------------------------------------------------*/
    if ( (-1)*(char)p_rs->last_reported_hdr_rssi_ex < p_rs->sig_str_thresholds[i] && p_rs->sig_str_thresholds[i] <= (-1)*(char)rssi )
      return TRUE;
  }

  return FALSE;
}
#endif

/*===========================================================================
  FUNCTION qmi_nas_crossed_rssi_threashold()

  DESCRIPTION
    check whether rssi in argument passed threshold compared to last reported rssi

  RETURN VALUE
    TRUE if new rssi value crossed threshold. FALSE if not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_crossed_rssi_threashold( cm_mm_msim_ss_info_s_type const *p_info, qmi_nasi_client_state_type *cl_sp )
{
  struct report_status_s *p_rs = &cl_sp->report_status;
  int    i;

  for ( i=0; i<p_rs->num_thresholds; i++)
  {
    /*-----------------------------------------------------------------
      If current_rssi < threshold <= last_reported_rssi (eg -75>=-85>-95)
      -----------------------------------------------------------------*/
    if ( (-1)*(char)p_info->stack_info[STACK_INDEX_0].rssi < p_rs->sig_str_thresholds[i] && p_rs->sig_str_thresholds[i] <= (-1)*(char)p_rs->last_reported_rssi_ex )
      return TRUE;

    /*-----------------------------------------------------------------
      If last_reported_rssi < threshold <= current_rssi(eg -125<-85<=-75)
      -----------------------------------------------------------------*/
    if ( (-1)*(char)p_rs->last_reported_rssi_ex < p_rs->sig_str_thresholds[i] && p_rs->sig_str_thresholds[i] <= (-1)*(char)p_info->stack_info[STACK_INDEX_0].rssi )
      return TRUE;
  }

  return FALSE;
}

#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES

/*===========================================================================
  FUNCTION qmi_nas_gen_event_report_ind()

  DESCRIPTION
    Generate and send event report IND message

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_event_report_ind( cm_ss_event_e_type *p_evt, cm_mm_msim_ss_info_s_type *p_info )
{
  nas_event_report_ind_msg_v01       *ind_msg;
  int                         i = 0;
  qmi_nasi_client_state_type *cl_sp;
  struct report_status_s     *p_rs;
  uint16                      rssi=NASI_SIG_STRENGTH_INACTIVE_RSSI;
  // ecio;
 // int                         io;
 // byte                        sinr;
  uint8                       stack_idx = STACK_INDEX_0;

  ind_msg = (nas_event_report_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_event_report_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if( ind_msg == NULL)
  {
    qmi_voice_mem_error();
    return;
  }

  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {
    if ( cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)p_info->asubs_id )
    {
        p_rs = &cl_sp->report_status; // shortcut
        memset( ind_msg, 0x00, sizeof(nas_event_report_ind_msg_v01) );
        switch ( *p_evt )
        {
          case CM_SS_EVENT_SRV_CHANGED:
          case CM_SS_EVENT_DCH_CELL_ID_RSP:
            if ( p_rs->report_rf_band_info )
            {
              if ( p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_ACTIVE_BAND_MASK           || // active_band
                   p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_CELL_INFO_MASK             || // cell_info
                   p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_SRV_STATUS_MASK            
                   #if defined(FEATURE_HDR)
                   || // srv_status
                   (p_info->number_of_stacks > 1 && p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR &&
                    (p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_ACTIVE_BAND_MASK           || // active_band
                     p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_SRV_STATUS_MASK
                    )
                   )
                   #endif
                  )
              {
                #if defined(FEATURE_HDR)
                if ( p_info->number_of_stacks > 1 && qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
                {
                  ind_msg->rf_band_info_list[i].radio_if       = (uint8)QMI_NAS_RADIO_IF_CDMA20001XEVDO;
                  ind_msg->rf_band_info_list[i].active_band    = qmi_nas_cm_bc_2_qmi_bc( p_info->stack_info[STACK_INDEX_1].active_band );
                  ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_1].active_channel;
                  i++;
                }
                #endif

                if ( ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE) != QMI_NAS_RADIO_IF_NONE ) &&
                     ( p_info->stack_info[STACK_INDEX_0].srv_status != SYS_SRV_STATUS_NO_SRV && p_info->stack_info[STACK_INDEX_0].srv_status != SYS_SRV_STATUS_PWR_SAVE ) )
                {
                  ind_msg->rf_band_info_list[i].radio_if       = (uint8)qmi_nas_sys_mode_2_radio_if( p_info, STACK_INDEX_0, FALSE );
                  ind_msg->rf_band_info_list[i].active_band    = qmi_nas_cm_bc_2_qmi_bc( p_info->stack_info[STACK_INDEX_0].active_band );
                  switch ( ind_msg->rf_band_info_list[i].radio_if )
                  {
                    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) || defined(FEATURE_HDR)
                    case QMI_NAS_RADIO_IF_CDMA20001X:
                    case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
                      ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_0].active_channel;
                      break;
                    #endif

                    #if defined(FEATURE_GSM) 
                    case QMI_NAS_RADIO_IF_GSM:
                      ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_0].cell_info.arfcn;
                      break;
                    #endif

                    #if defined(FEATURE_WCDMA) || defined(FEATURE_TDSCDMA)
                    case QMI_NAS_RADIO_IF_UMTS:
                    case QMI_NAS_RADIO_IF_TDSCDMA:
                      ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_0].cell_info.uarfcn_dl;
                      break;
                    #endif

                    case QMI_NAS_RADIO_IF_LTE:
                      ind_msg->rf_band_info_list[i].active_channel = (uint16) p_info->stack_info[STACK_INDEX_0].cell_info.earfcn_dl;
                        // DSDS not possible for LTE yet
                      break;

                    default:
                      break;
                  }
                  i++;
                }

                if ( i > 0 )
                {
                  ind_msg->rf_band_info_list_len     = (uint8)i;
                  ind_msg->rf_band_info_list_valid   = TRUE;
                }
              }
            }

            break;

          case CM_SS_EVENT_RSSI:
            if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE) == QMI_NAS_RADIO_IF_NONE )
            {
              QM_MSG_LOW_1("not sending rssi inds %d", p_info->stack_info[STACK_INDEX_0].rssi);
              break;
            }

            if ( p_rs->report_sig_str && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_RSSI_MASK )
            {
              if ( qmi_nas_crossed_rssi_threashold( p_info, cl_sp ) )
              {
                ind_msg->signal_strength.sig_strength = (int8)p_info->stack_info[STACK_INDEX_0].rssi;
                ind_msg->signal_strength.radio_if     = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->signal_strength_valid        = TRUE;
                // save value to p_rs->last_reported_rssi_ex later
              }
            }

            if ( p_rs->report_rssi && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_RSSI_MASK )
            {
              if ( abs(p_info->stack_info[STACK_INDEX_0].rssi - p_rs->last_reported_rssi_ex) >= p_rs->report_rssi_delta )
              {
                ind_msg->rssi.rssi     = (uint8)p_info->stack_info[STACK_INDEX_0].rssi;
                ind_msg->rssi.radio_if = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->rssi_valid    = TRUE;
                // save value to p_rs->last_reported_rssi_ex later
              }
            }

            if ( ind_msg->signal_strength_valid || ind_msg->rssi_valid )
              p_rs->last_reported_rssi_ex = p_info->stack_info[STACK_INDEX_0].rssi;

            if ( p_rs->report_sinr && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_SINR_MASK )
            {
              if ( qmi_nas_gen_report_sinr(p_info->stack_info[STACK_INDEX_0].sinr, p_rs) )
              {
                ind_msg->sinr  = (uint8)p_info->stack_info[STACK_INDEX_0].sinr;
                ind_msg->sinr_valid = TRUE;

                p_rs->last_reported_sinr = p_info->stack_info[STACK_INDEX_0].sinr;
              }
            }

            if ( p_rs->report_rsrq && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_RSRQ_MASK )
            {
              if ( abs(p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrq - p_rs->last_reported_rsrq) >= p_rs->report_rsrq_delta )
              {
                ind_msg->rsrq.rsrq  = (uint8)p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrq;
                ind_msg->rsrq.radio_if = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->rsrq_valid = TRUE;

                p_rs->last_reported_rsrq = p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrq;
              }
            }

            if( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,TRUE)   == QMI_NAS_RADIO_IF_LTE )
            {
              if ( p_rs->report_lte_snr && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_SINR_MASK )
              {
                if ( (abs(p_info->stack_info[STACK_INDEX_0].sinr - p_rs->last_reported_lte_snr)*2) >= p_rs->report_lte_snr_delta )
                {
                  ind_msg->snr = (2 * (p_info->stack_info[STACK_INDEX_0].sinr) ) - 200;
                  ind_msg->snr_valid = TRUE;

                  p_rs->last_reported_lte_snr = p_info->stack_info[STACK_INDEX_0].sinr;
                }
              }
            }

            if( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,TRUE)   == QMI_NAS_RADIO_IF_LTE )
            {
              if ( p_rs->report_lte_rsrp && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_RSRP_MASK )
              {
                if ( abs(p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrp - p_rs->last_reported_lte_rsrp) >= p_rs->report_lte_rsrp_delta )
                {
                  ind_msg->rsrp  = p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrp;
                  ind_msg->rsrp_valid = TRUE;

                  p_rs->last_reported_lte_rsrp = p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrp;
                }
              }
            }

            if ( p_rs->report_error_rate )
            {
              #if defined(FEATURE_HDR)
              if ( p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_HDR_PER_MASK )
              {
                ind_msg->error_rate.error_rate = p_info->stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
                ind_msg->error_rate.radio_if   = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->error_rate_valid      = TRUE;
              }
              else 
              #endif
              #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
              if ( p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_FER_MASK )
              {
                ind_msg->error_rate.error_rate = p_info->stack_info[STACK_INDEX_0].rat_mode_info.cdma_mode_info.frame_err_rate;
                ind_msg->error_rate.radio_if   = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->error_rate_valid      = TRUE;
              }
              else 
              #endif
              if ( p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_BER_MASK )
              {
                ind_msg->error_rate.error_rate = p_info->stack_info[STACK_INDEX_0].mode_info.gw_info.bit_err_rate * 100; // 100 is for normalization
                ind_msg->error_rate.radio_if   = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->error_rate_valid      = TRUE;
              }
            }
            break;

          #if defined(FEATURE_HDR)
          case CM_SS_EVENT_HDR_RSSI:
            if( p_info->number_of_stacks > 1 && 
                qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,FALSE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
            {
              stack_idx = STACK_INDEX_1;
            }
            else
            {
              stack_idx = STACK_INDEX_0;
            }
            
            if ( p_rs->report_sig_str && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_RSSI_MASK )
            {
              rssi = p_info->stack_info[stack_idx].rssi;

              if ( qmi_nas_crossed_hdr_rssi_threashold( p_info, cl_sp ) )
              {
                ind_msg->signal_strength.sig_strength = (int8)rssi;
                ind_msg->signal_strength.radio_if     = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001XEVDO;
                ind_msg->signal_strength_valid        = TRUE;
                // save value to p_rs->last_reported_hdr_rssi_ex later
              }
            }

            if ( p_rs->report_rssi && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_RSSI_MASK )
            {
              rssi = p_info->stack_info[stack_idx].rssi;

              if ( abs(rssi - p_rs->last_reported_hdr_rssi_ex) >= p_rs->report_rssi_delta )
              {
                ind_msg->rssi.rssi     = (uint8)rssi;
                ind_msg->rssi.radio_if = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001XEVDO;
                ind_msg->rssi_valid    = TRUE;
                // save value to p_rs->last_reported_hdr_rssi_ex later
              }
            }

            if ( ind_msg->signal_strength_valid || ind_msg->rssi_valid )
              p_rs->last_reported_hdr_rssi_ex = rssi;

            if ( p_rs->report_ecio && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_ECIO_MASK )
            {
              ecio = p_info->stack_info[stack_idx].ecio;

              if ( qmi_nas_gen_report_ecio(ecio, p_rs, TRUE) )
              {
                ind_msg->ecio.ecio     = (uint8)ecio;
                ind_msg->ecio.radio_if = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001XEVDO;
                ind_msg->ecio_valid    = TRUE;

                p_rs->last_reported_hdr_ecio = ecio;
              }
            }

            if ( p_rs->report_io && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_IO_MASK )
            {
              io = p_info->stack_info[stack_idx].io;

              if ( abs(io - p_rs->last_reported_io) >= p_rs->report_io_delta )
              {
                ind_msg->io    = (int32)io;
                ind_msg->io_valid = TRUE;

                p_rs->last_reported_io = io;
              }
            }

            if ( p_rs->report_sinr && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_SINR_MASK )
            {
              sinr = p_info->stack_info[stack_idx].sinr;

              if ( qmi_nas_gen_report_sinr(sinr, p_rs) )
              {
                ind_msg->sinr  = (uint8)sinr;
                ind_msg->sinr_valid = TRUE;

                p_rs->last_reported_sinr = sinr;
              }
            }

            if ( p_rs->report_error_rate && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_HDR_PER_MASK )
            {
              ind_msg->error_rate.error_rate = p_info->stack_info[stack_idx].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
              ind_msg->error_rate.radio_if   = (uint8)QMI_NAS_RADIO_IF_CDMA20001X;
              ind_msg->error_rate_valid      = TRUE;
            }
            break;
         #endif

          case CM_SS_EVENT_REG_REJECT:
            if ( p_rs->report_reg_reject_reason )
            {
              ind_msg->registration_reject_reason.service_domain = (nas_network_service_domain_enum_v01)p_info->stack_info[stack_idx].reg_reject_info.reject_srv_domain;
              ind_msg->registration_reject_reason.reject_cause   = p_info->stack_info[stack_idx].reg_reject_info.reject_cause;
              ind_msg->registration_reject_reason_valid          = TRUE;
            }
            break;

          default:
            break;
        }

        if ( ind_msg->signal_strength_valid || ind_msg->rf_band_info_list_valid || ind_msg->registration_reject_reason_valid || 
          ind_msg->rssi_valid || ind_msg->ecio_valid || ind_msg->io_valid || ind_msg->sinr_valid || ind_msg->error_rate_valid ||
             ind_msg->rsrq_valid || ind_msg->snr_valid || ind_msg->rsrp_valid )
        {
          dsm_item_type                         *ind = NULL;
          if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                              (uint16_t) QMI_NAS_EVENT_REPORT_IND_MSG_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_event_report_ind_msg_v01 ),
                                             &ind ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_SET_EVENT_REPORT, ind );
        }
      }
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#endif

#ifndef FEATURE_MMODE_QMI_LTE_ONLY
/*===========================================================================
  FUNCTION QMI_NAS_GEN_REPORT_ECIO()

  DESCRIPTION
    Utility function to decide whether or to send ecio value

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nas_gen_report_ecio
(
 uint16 ecio,
 struct report_status_s *p_rs,
 boolean   isHDR
)
{
  boolean report_ecio = FALSE;
  int i;
  #if defined(FEATURE_HDR)
  uint16 last_reported_ecio = isHDR ? p_rs->last_reported_hdr_ecio : p_rs->last_reported_ecio;
  #else
  uint16 last_reported_ecio = p_rs->last_reported_ecio;
  #endif
  if ( p_rs->reporting_mode_ecio == NASI_EVENT_REPORT_MODE_DELTA )
  {
    if( abs(ecio - last_reported_ecio) >= p_rs->report_ecio_delta)
    {
      report_ecio = TRUE;
    }
  }
  else if( p_rs->reporting_mode_ecio == NASI_EVENT_REPORT_MODE_THRESHOLD )
  {
    for ( i=0 ; i < p_rs->num_thresholds_ecio ; i++ )
    {
      /*-----------------------------------------------------------------
        current EcIo < Threshold <= last reported EcIo
      -----------------------------------------------------------------*/
      if( ecio < p_rs->ecio_thresholds[i]  &&
          p_rs->ecio_thresholds[i] <= last_reported_ecio)
      {
        report_ecio = TRUE;
        break;
      }

    /*-----------------------------------------------------------------
      last reported EcIo  <= Threshold < current EcIo
    -----------------------------------------------------------------*/
      if( last_reported_ecio <= p_rs->ecio_thresholds[i]  &&
          p_rs->ecio_thresholds[i] < ecio )
      {
        report_ecio = TRUE;
        break;
      }
    }
  }
  return report_ecio;
}
#endif
/*===========================================================================
  FUNCTION QMI_NAS_GEN_REPORT_SINR()

  DESCRIPTION
    Utility function to decide whether or to send sinr value

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nas_gen_report_sinr
(
 uint16 sinr,
 struct report_status_s *p_rs
)
{
  boolean report_sinr = FALSE;
  int i;
  uint16 last_reported_sinr =  p_rs->last_reported_sinr;

  if ( p_rs->reporting_mode_sinr == NASI_EVENT_REPORT_MODE_DELTA )
  {
    if( abs(sinr - last_reported_sinr) >= p_rs->report_sinr_delta)
    {
      report_sinr = TRUE;
    }
  }
  else if( p_rs->reporting_mode_sinr == NASI_EVENT_REPORT_MODE_THRESHOLD )
  {
    for ( i=0 ; i < p_rs->num_thresholds_sinr ; i++ )
    {
      /*-----------------------------------------------------------------
        current sinr < Threshold <= last reported sinr
      -----------------------------------------------------------------*/
      if( sinr < p_rs->sinr_thresholds[i]  &&
          p_rs->sinr_thresholds[i] <= last_reported_sinr)
      {
        report_sinr = TRUE;
        break;
      }

    /*-----------------------------------------------------------------
      last reported sinr  <= Threshold < current sinr
    -----------------------------------------------------------------*/
      if( last_reported_sinr <= p_rs->sinr_thresholds[i]  &&
          p_rs->sinr_thresholds[i] < sinr )
      {
        report_sinr = TRUE;
        break;
      }
    }
  }
  return report_sinr;
}

/*===========================================================================
  FUNCTION qmi_nas_gen_network_time_ind()

  DESCRIPTION
    send QMI_NAS_NETWORK_TIME_IND

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_network_time_ind( cm_mm_ss_info_s_type *p_info )
{
  time_genoff_args_struct_type time_genoff_args;
  time_julian_type             jul_val;
  time_type                    ts_val_secs; // genoff time in secs
  uint32                       secs; // genoff time in secs temp var
  byte                         lp_sec = 0;

  struct nas_004C_ind_s        ind_msg;
  dsm_item_type               *ind;

  qmi_nasi_client_state_type  *cl_sp;
  enum qmi_nas_subs_e          bound_subs = QMI_NAS_SUBS_PRIMARY;
  time_bases_type              time_base  = ATS_RTC;

#ifdef FEATURE_DUAL_SIM
  bound_subs = (p_info->asubs_id == SYS_MODEM_AS_ID_1) ? QMI_NAS_SUBS_PRIMARY : QMI_NAS_SUBS_SECONDARY;
#endif
  memset( &ind_msg, 0x00, sizeof(ind_msg) );

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) || defined(FEATURE_HDR)

  if ( (p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_CDMA_TIME_CHGD_MASK) &&
       (p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA || p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_HDR) )
  {
    time_base = ATS_TOD;

    if ( p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_CDMA )
    {
      lp_sec            = p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.lp_sec;
      ind_msg.t01_valid = TRUE;

      ind_msg.t10.time_zone = QMI_NAS_6BIT_2_8BIT( p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.ltm_offset ) * 2; // cdma reports in units of 30 min
      ind_msg.t10_valid     = TRUE;

      ind_msg.t11.daylt_sav_adj = (enum nas_daylt_sav_adj_e)p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.daylt_savings;
      ind_msg.t11_valid         = TRUE;

      ind_msg.t12.radio_if = QMI_NAS_RADIO_IF_CDMA20001X;
      ind_msg.t12_valid = TRUE;
    }
    else   if ( p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_HDR )
    {
      lp_sec            = p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.hdr_time.lp_sec;
      ind_msg.t01_valid = TRUE;

      ind_msg.t10.time_zone = (uint8)(p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.hdr_time.ltm_offset/15); // hdr reports in units of 1 min
      ind_msg.t10_valid     = TRUE;

      ind_msg.t11.daylt_sav_adj = NAS_DAYLT_SAV_ADJ_NONE;
      ind_msg.t11_valid         = TRUE;

      ind_msg.t12.radio_if = QMI_NAS_RADIO_IF_CDMA20001XEVDO;
      ind_msg.t12_valid = TRUE;
    }
  }
  else 
  #endif
  if ( (p_info->changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK) &&
    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
            (p_info->sys_mode == SYS_SYS_MODE_GSM 
            #ifdef FEATURE_WCDMA
            || p_info->sys_mode == SYS_SYS_MODE_WCDMA 
            #endif
            || p_info->sys_mode == SYS_SYS_MODE_LTE 
            #ifdef FEATURE_TDSCDMA
            || p_info->sys_mode == SYS_SYS_MODE_TDS
            #endif
            ) )
    #else
            (p_info->sys_mode == SYS_SYS_MODE_LTE ) )
    #endif
  {
    ind_msg.t12.radio_if = qmi_nas_sys_mode_2_radio_if( p_info,FALSE);
    ind_msg.t12_valid = TRUE;

    time_base = ATS_3GPP;

    if ( p_info->mm_information.univ_time_and_time_zone_avail )
    {
      ind_msg.t01_valid = TRUE;

      ind_msg.t10.time_zone = (int8)p_info->mm_information.univ_time_and_time_zone.time_zone;
      ind_msg.t10_valid     = TRUE;
    }
    else if ( p_info->mm_information.time_zone_avail )
    {
      ind_msg.t01_valid = TRUE;

      ind_msg.t10.time_zone = (int8)p_info->mm_information.time_zone;
      ind_msg.t10_valid     = TRUE;
    }

    if ( p_info->mm_information.daylight_saving_adj_avail )
    {
      ind_msg.t01_valid = TRUE;

      ind_msg.t11.daylt_sav_adj = (enum nas_daylt_sav_adj_e)p_info->mm_information.daylight_saving_adj;
      ind_msg.t11_valid         = TRUE;
    }
  }
  
  #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && ((defined(FEATURE_CDMA) || defined(FEATURE_HDR)) )
  else if ( p_info->number_of_stacks > 1 && p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK ) // for 2nd subscription in DSDS
  {
    if( p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM || p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_WCDMA || p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE || p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_TDS )
    {
      ind_msg.t12.radio_if = qmi_nas_sys_mode_2_radio_if( p_info, STACK_INDEX_1, FALSE );
      ind_msg.t12_valid = TRUE;

      time_base = ATS_3GPP;

      if ( p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.univ_time_and_time_zone_avail )
      {
        ind_msg.t01_valid = TRUE;

        ind_msg.t10.time_zone = (int8)p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.univ_time_and_time_zone.time_zone;
        ind_msg.t10_valid     = TRUE;

      }
      else if ( p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.time_zone_avail )
      {
        ind_msg.t01_valid = TRUE;

        ind_msg.t10.time_zone = (int8)p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.time_zone;
        ind_msg.t10_valid     = TRUE;
      }

      if ( p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.daylight_saving_adj_avail )
      {
        ind_msg.t11.daylt_sav_adj = (enum nas_daylt_sav_adj_e)p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.daylight_saving_adj;
        ind_msg.t11_valid         = TRUE;
      }
    }
  }
  #endif
  
  if ( ind_msg.t01_valid )
  {
    // read time from time service
    time_genoff_args.base        = time_base;
    time_genoff_args.base_source = TIME_SCLK;
    time_genoff_args.ts_val      = (void *)&ts_val_secs;
    time_genoff_args.unit        = TIME_SECS;
    time_genoff_args.operation   = T_GET;

    time_genoff_opr( &time_genoff_args );

    secs  = ts_val_secs[0];
    secs -= lp_sec; // subtract leap seconds

    time_jul_from_secs( secs, &jul_val ); // convert to julian
    QM_MSG_HIGH_8("secs %d lp_sec %d y %d m %d d %d h %d m %d s %d", secs, lp_sec, jul_val.year, jul_val.month, jul_val.day,
    jul_val.hour, jul_val.minute, jul_val.second);


    ind_msg.t01.year        = jul_val.year;
    ind_msg.t01.month       = jul_val.month;
    ind_msg.t01.day         = jul_val.day;
    ind_msg.t01.hour        = jul_val.hour;
    ind_msg.t01.minute      = jul_val.minute;
    ind_msg.t01.second      = jul_val.second;
    ind_msg.t01.day_of_week = jul_val.day_of_week;

    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {
      if ( cl_sp->report_status.report_network_time && cl_sp->report_status.bound_subs == bound_subs )
      {
        ind = NULL;

        if ( qmi_nas_004C_ind_write ( &ind_msg, &ind ) == QMI_ERR_NONE )
        {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_NETWORK_TIME_IND, ind );
        }
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_COPY_TO_RSSI_STRUCT()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_copy_to_rssi_struct(
  qmi_nasi_rssi_info_type    *p_nas_info,
  const cm_mm_ss_info_s_type *p_ss_info
)
{
  int i = 0;
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  p_nas_info->number_of_stacks = p_ss_info->number_of_stacks;
  #endif
  
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  for( i = 0; i < p_ss_info->number_of_stacks && i < STACK_INDEX_MAX; i++ )
#endif
  {
    p_nas_info->stack_info[i].signal_strength_changed_fields = p_ss_info->signal_strength_changed_fields;
    p_nas_info->stack_info[i].sys_mode = p_ss_info->sys_mode;
    p_nas_info->stack_info[i].rssi = p_ss_info->rssi;
    p_nas_info->stack_info[i].sinr = p_ss_info->sinr;
    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    p_nas_info->stack_info[i].ecio = p_ss_info->stack_info[i].ecio;
    p_nas_info->stack_info[i].io = p_ss_info->stack_info[i].io;
    #endif
    #endif

    if( p_ss_info->sys_mode == SYS_SYS_MODE_LTE )
    {
      p_nas_info->stack_info[i].rsrp = p_ss_info->rsrp;
      p_nas_info->stack_info[i].rsrq = p_ss_info->rsrq;
    }
    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    if( p_ss_info->stack_info[i].sys_mode == SYS_SYS_MODE_CDMA )
    {
      p_nas_info->stack_info[i].frame_err_rate = p_ss_info->stack_info[i].rat_mode_info.cdma_mode_info.frame_err_rate;
    }
    else 
    #endif
    #if defined(FEATURE_HDR)
    if( p_ss_info->stack_info[i].sys_mode == SYS_SYS_MODE_HDR )
    {
      p_nas_info->stack_info[i].hdr_hybrid = p_ss_info->stack_info[i].rat_mode_info.hdr_mode_info.hdr_hybrid;
      p_nas_info->stack_info[i].hdr_packet_err_rate = p_ss_info->stack_info[i].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
    }
    else
    #endif
    {
      p_nas_info->stack_info[i].bit_err_rate = p_ss_info->bit_err_rate;
    }
  }
}


/*===========================================================================
  FUNCTION QMI_NAS_COPY_FROM_RSSI_STRUCT()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_copy_from_rssi_struct(
  cm_mm_ss_info_s_type    *p_ss_info,
  qmi_nasi_rssi_info_type *p_nas_info
)
{
  int i = 0;
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  p_ss_info->number_of_stacks = p_nas_info->number_of_stacks;

#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  for( i = 0; i < p_nas_info->number_of_stacks && i < STACK_INDEX_MAX; i++ )
#endif
#endif
  {
    p_ss_info->signal_strength_changed_fields = p_nas_info->stack_info[i].signal_strength_changed_fields;
    p_ss_info->sys_mode = p_nas_info->stack_info[i].sys_mode;
    p_ss_info->rssi = p_nas_info->stack_info[i].rssi;
    p_ss_info->sinr = p_nas_info->stack_info[i].sinr;
    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    p_ss_info->stack_info[i].ecio = p_nas_info->stack_info[i].ecio;
    p_ss_info->stack_info[i].io = p_nas_info->stack_info[i].io;
    #endif
    #endif

    if( p_nas_info->stack_info[i].sys_mode == SYS_SYS_MODE_LTE )
    {
      p_ss_info->rsrp = p_nas_info->stack_info[i].rsrp;
      p_ss_info->rsrq = p_nas_info->stack_info[i].rsrq;
    }
    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    if( p_nas_info->stack_info[i].sys_mode == SYS_SYS_MODE_CDMA )
    {
      p_ss_info->stack_info[i].rat_mode_info.cdma_mode_info.frame_err_rate = p_nas_info->stack_info[i].frame_err_rate;
    }
    else 
    #endif
    #if defined(FEATURE_HDR)
    if( p_nas_info->stack_info[i].sys_mode == SYS_SYS_MODE_HDR )
    {
      p_ss_info->stack_info[i].rat_mode_info.hdr_mode_info.hdr_hybrid = p_nas_info->stack_info[i].hdr_hybrid;
      p_ss_info->stack_info[i].rat_mode_info.hdr_mode_info.hdr_packet_err_rate = p_nas_info->stack_info[i].hdr_packet_err_rate;
    }
    else
    #endif
    {
      p_ss_info->bit_err_rate = p_nas_info->stack_info[i].bit_err_rate;
    }
  }
}
/*===========================================================================
  FUNCTION QMI_NAS_COPY_TX_INFO_STRUCT()

  DESCRIPTION
    Handle data queued for CM SS event callback - helper API to copy only relevant tx_info to qmi_nas global

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_copy_tx_info_struct(
  cm_ss_lte_rrc_tx_info_s_type    *p_ss_info,
  cm_ss_lte_rrc_tx_info_s_type *p_nas_info
)

{
  if(p_ss_info != NULL && p_nas_info != NULL)
  {
    p_ss_info->lte_tx_band = p_nas_info->lte_tx_band;
    p_ss_info->lte_tx_is_active = p_nas_info->lte_tx_is_active;
  } 
}

/*===========================================================================
  FUNCTION QMI_NAS_COPY_FROM_GLOBAL_SYS_MODE()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_copy_from_global_sys_mode(
  cm_mm_ss_info_s_type *p_ss_info_from,
  cm_mm_ss_info_s_type *p_ss_info_to
)
{
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  int i=0;
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  for( i = 0; i < p_ss_info_to->number_of_stacks && i < STACK_INDEX_MAX; i++ )
#endif
#endif
  {
    p_ss_info_to->sys_mode = p_ss_info_from->sys_mode;

    #if defined(FEATURE_HDR)
    if( p_ss_info_from->stack_info[i].sys_mode == SYS_SYS_MODE_HDR )
    {
      p_ss_info_to->stack_info[i].rat_mode_info.hdr_mode_info.hdr_hybrid = p_ss_info_from->stack_info[i].rat_mode_info.hdr_mode_info.hdr_hybrid;
    }
    #endif
  }
}

#ifdef FEATURE_DUAL_SIM
struct qmi_nas_cmss_msim_evt_cb_s
{
  cm_ss_event_e_type   evt;
  cm_mm_msim_ss_info_s_type  info;
};
#else
struct qmi_nas_cmss_evt_cb_s
{
  cm_ss_event_e_type   evt;
  cm_mm_ss_info_s_type  info;
};
#endif

/*===========================================================================
  FUNCTION QMI_NAS_CHECK_AND_UPDATE_CELL_ID()

  DESCRIPTION
    Verify if NAS and RRC PLMN ID and LAC match.  If not, use old cell id
    information.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_check_and_update_cell_id(
  cm_mm_ss_info_s_type *p_ss_info
)
{

  if ( (p_ss_info->sys_mode == p_ss_info->cell_info.as_sys_mode)
       #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
       ||  (p_ss_info->sys_mode == SYS_SYS_MODE_TDS && p_ss_info->cell_info.as_sys_mode == SYS_SYS_MODE_WCDMA) 
       #endif
     )
  {
    if ( !memcmp( p_ss_info->sys_id.id.plmn.identity, p_ss_info->cell_info.plmn_id.identity, sizeof(p_ss_info->sys_id.id.plmn.identity) ) )
    {
      if ( (p_ss_info->sys_mode == SYS_SYS_MODE_LTE) &&
           p_ss_info->tac != p_ss_info->cell_info.tac )
      {
        p_ss_info->cell_info = qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].cell_info;
      }
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY
      else if ( (
                  #ifdef FEATURE_WCDMA
                  (p_ss_info->sys_mode == SYS_SYS_MODE_WCDMA) || 
                  #endif
                  (p_ss_info->sys_mode == SYS_SYS_MODE_GSM)
                  #ifdef FEATURE_TDSCDMA
                  || (p_ss_info->sys_mode == SYS_SYS_MODE_TDS)
                  #endif
                  ) &&
                p_ss_info->sys_id.id.plmn_lac.lac != p_ss_info->cell_info.lac_id )
      {
        p_ss_info->cell_info = qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].cell_info;
      }
      #endif
    }
    else
    {
      p_ss_info->cell_info = qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].cell_info;
    }
  }
  else
  {
    QM_MSG_HIGH_2("RRC sys_mode %d not matching NAS %d", p_ss_info->cell_info.as_sys_mode, p_ss_info->sys_mode);
    p_ss_info->cell_info = qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].cell_info;
  }
}

#ifdef FEATURE_DUAL_SIM
/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSS_MSIM_EVT()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmss_msim_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmss_msim_evt_cb_s *ptr = (struct qmi_nas_cmss_msim_evt_cb_s*)user_data_ptr;
  cm_ss_event_e_type         *p_evt;
  cm_mm_msim_ss_info_s_type       *p_info;
  qmi_nasi_rssi_info_type     rssi_info;
  mmgsdi_session_type_enum_type session = MMGSDI_GW_PROV_PRI_SESSION;
  boolean             copy_info = TRUE;
  uint8 stack_index=0, i=0;
  uint8 asubs_max   = sizeof(qmi_nasi_global.cm_msim_ss_info)/sizeof(qmi_nasi_global.cm_msim_ss_info[0]);
  if ( ptr )
  {
    p_evt  = &ptr->evt;
    p_info = &ptr->info;

    // Set up asubs id in case of single sim target
    if(p_info->asubs_id <= SYS_MODEM_AS_ID_NONE || p_info->asubs_id >= asubs_max)
    {
      p_info->asubs_id = SYS_MODEM_AS_ID_1;
    }
    
    //Verify if NAS and RRC PLMN ID and LAC match only if SS event is reported for CELL_INFO
    if(
        (p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_CELL_INFO_MASK) ||
        !(p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_SYS_ID_MASK)
      )
    {
      //Calling qmi_nas_check_and_update_cell_id, STACK_INDEX_0
      qmi_nas_check_and_update_cell_id(p_info, STACK_INDEX_0);
    }
#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    //Verify if NAS and RRC PLMN ID and LAC match only if SS event is reported for CELL_INFO
    if(
        (p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_CELL_INFO_MASK) ||
        !(p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_SYS_ID_MASK)
      )
    {
      //Calling qmi_nas_check_and_update_cell_id, STACK_INDEX_1
      qmi_nas_check_and_update_cell_id(p_info, STACK_INDEX_1);
    }
#endif
    // Check MM Info PLMN ID
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    for (stack_index=0;stack_index < p_info->number_of_stacks && stack_index < STACK_INDEX_MAX;stack_index++)
    #endif
    {
      enum qmi_nas_radio_if_e rat = qmi_nas_sys_mode_2_radio_if(p_info,stack_index,FALSE);
      if ( (  rat == QMI_NAS_RADIO_IF_GSM 
            #if defined(FEATURE_WCDMA)
            || rat == QMI_NAS_RADIO_IF_UMTS 
            #endif
            || rat == QMI_NAS_RADIO_IF_LTE ) &&
           p_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn_avail &&
           memcmp( &p_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn, &p_info->stack_info[stack_index].sys_id.id.plmn, sizeof(p_info->stack_info[stack_index].sys_id.id.plmn) ) )
      {
        p_info->stack_info[stack_index].mode_info.gw_info.mm_information.short_name_avail = FALSE;
        p_info->stack_info[stack_index].mode_info.gw_info.mm_information.full_name_avail = FALSE;
    }
    }

    QM_MSG_HIGH_1("cm ss evt %d", *p_evt);
    switch ( *p_evt )
            {
      case CM_SS_EVENT_INFO:
      case CM_SS_EVENT_SRV_CHANGED:
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY      
      case CM_SS_EVENT_DCH_CELL_ID_RSP:
      #endif
 
#ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
#ifdef FEATURE_DUAL_SIM
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, FALSE );
        #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
        qmi_nas_gen_event_report_ind( p_evt, p_info );
        #endif
       #ifndef REMOVE_QMI_NAS_GET_OPERATOR_NAME_DATA_V01
        for( stack_index = 0; stack_index < p_info->number_of_stacks; stack_index++ )
        {
          if ( qmi_nas_sys_mode_2_radio_if(p_info,stack_index,FALSE) == QMI_NAS_RADIO_IF_GSM ||
               #if defined(FEATURE_WCDMA)
               qmi_nas_sys_mode_2_radio_if(p_info,stack_index,FALSE) == QMI_NAS_RADIO_IF_UMTS ||
               #endif
               qmi_nas_sys_mode_2_radio_if(p_info,stack_index,FALSE) == QMI_NAS_RADIO_IF_LTE )
          {
            sys_mm_information_s_type *p_new_mm_info = &p_info->stack_info[stack_index].mode_info.gw_info.mm_information;
            sys_mm_information_s_type *p_old_mm_info = &qmi_nasi_global.cm_msim_ss_info[p_info->asubs_id].stack_info[stack_index].mode_info.gw_info.mm_information;
          boolean                    send_ind = FALSE;

          if ( p_new_mm_info->short_name_avail )
          {
            if ( !p_old_mm_info->short_name_avail ||
                 memcmp( &p_old_mm_info->short_name, &p_new_mm_info->short_name, sizeof(sys_network_short_name_s_type) ) )
            {
                QM_MSG_HIGH_3("nitz updated short name %d %d %d", p_old_mm_info->short_name_avail, p_new_mm_info->short_name_avail, p_new_mm_info->short_name.length);
              send_ind = TRUE;
            }
          }

          if ( p_new_mm_info->full_name_avail )
          {
            if ( !p_old_mm_info->full_name_avail ||
                 memcmp( &p_old_mm_info->full_name, &p_new_mm_info->full_name, sizeof(sys_network_full_name_s_type) ) )
            {
                QM_MSG_HIGH_3("nitz updated full name %d %d %d", p_old_mm_info->full_name_avail, p_new_mm_info->full_name_avail, p_new_mm_info->full_name.length);
              send_ind = TRUE;
            }
          }
            //TODO: map Mmgsdi session based on asubs_id
          #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
          if ( send_ind )
          {
            qmi_nas_operator_name_data_ind( MMGSDI_GW_PROV_PRI_SESSION, p_new_mm_info );
          }
          #endif
        }
        }
        #endif 

#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
        qm_tib_check_and_invalidate_cdma_hdr_cache(p_info);
#endif
        if (  p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK  
             #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && ((defined(FEATURE_CDMA) || defined(FEATURE_HDR)))
             || ( p_info->number_of_stacks > 1 && p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK ) 
             #endif
           )
        {
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
          // compare CDMA time data with global cache, send ind and start timer
          if ( p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_CDMA_TIME_CHGD_MASK )
          { 
            if( qm_tib_is_enabled() )    // check if time ind blocking module is valid to use
            {
              if( qm_tib_is_time_info_changed(p_info) )
              {
                if( qm_tib_is_time_ind_blocked() )
                {
                  qm_tib_unblock_time_ind();
                }
                qmi_nas_update_cached_time_info(p_info);
                qmi_nas_gen_network_time_ind( p_info );
                qm_tib_update_time_info(p_info);
                qm_tib_block_time_ind();
                QM_MSG_HIGH("sent time ind and blocked tib");
              }
              else
              {
                if( !qm_tib_is_time_ind_blocked() )
                {
                  qmi_nas_update_cached_time_info(p_info);
                  qmi_nas_gen_network_time_ind( p_info );
                  qm_tib_update_time_info(p_info);       // after oos we land here so need to update cache as well
                  qm_tib_block_time_ind();
                  QM_MSG_HIGH("CM SS EVENT Time changed, network_time_ind sent and blocked tib");
                }
                else
                {
                  QM_MSG_HIGH("CM SS EVENT Time changed, dropping network_time_ind");
                }
              }
            }
            else
            {
              qmi_nas_update_cached_time_info(p_info);
              qmi_nas_gen_network_time_ind(p_info); // default behavior send ind
              QM_MSG_HIGH("tib not valid to use, sending network_time_ind rightaway");
            }
          }
          else
#endif
          {
            qmi_nas_update_cached_time_info(p_info);
            qmi_nas_gen_network_time_ind(p_info); // send ind for 3gpp networks
//            QM_MSG_HIGH("network_time_ind sent for 3GPP networks");
          }
        }

        if( *p_evt == CM_SS_EVENT_SRV_CHANGED )
        {
#ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info, QMI_NAS_SUBS_PRIMARY );
#ifdef FEATURE_DUAL_SIM
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info2, QMI_NAS_SUBS_SECONDARY );
#ifdef FEATURE_TRIPLE_SIM
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info3, QMI_NAS_SUBS_TERTIARY );
#endif
#endif
#endif
        }

#ifndef FEATURE_MMODE_QMI_LTE_ONLY
        if( p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA ||
            p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM ||
            p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE ||
            p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_TDS
            #ifndef FEATURE_MMODE_QMI_GPRS_LTE
            || ( p_info->number_of_stacks > 1 
            #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
            &&
              ( p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE ||
                p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM )
             #endif   
             )
            #endif
            )
#else
        if( p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE)
#endif
        {
          session = qmi_nas_map_cm_asubs_to_mmgsdi_session( p_info->asubs_id );
          qmi_nas_gen_current_plmn_name_ind( p_info, session );
        }
#ifdef FEATURE_DUAL_SIM
        // Need second call for secondary subscription
#endif

        qmi_nas_gen_rf_band_info_ind( p_info );

        qmi_nas_update_global_ims_pref( p_info );

        qm_si_process_cm_ss_event( p_info, *p_evt );

        break;

      #if defined(FEATURE_HDR)
      case CM_SS_EVENT_HDR_RSSI:
      #endif
      case CM_SS_EVENT_RSSI:
      case CM_SS_EVENT_GW_RSSI:
        qm_meas_process_cm_measurement_event(p_info, *p_evt);
        qmi_nas_copy_to_rssi_struct( &rssi_info, p_info );
        memscpy( p_info, sizeof(cm_mm_msim_ss_info_s_type), &qmi_nasi_global.cm_msim_ss_info[p_info->asubs_id], sizeof(cm_mm_msim_ss_info_s_type));
        qmi_nas_copy_from_rssi_struct( p_info, &rssi_info );
        #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
        qmi_nas_gen_event_report_ind( p_evt, p_info );
        #endif
        qmi_nas_copy_from_global_sys_mode( &qmi_nasi_global.cm_msim_ss_info[p_info->asubs_id], p_info );
        break;

    case CM_SS_EVENT_REG_REJECT:
#ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
#ifdef FEATURE_DUAL_SIM
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, TRUE );
        qmi_nas_gen_network_reject_ind( p_info );
        #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
        qmi_nas_gen_event_report_ind( p_evt, p_info );
        #endif
        break;

#ifndef FEATURE_MMODE_QMI_LTE_ONLY
      case CM_SS_EVENT_CELL_ACCESS_IND:
#ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
#ifdef FEATURE_DUAL_SIM
       qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
       qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, FALSE );
        break;
#endif

#ifndef REMOVE_QMI_NAS_GET_LTE_RRC_TX_INFO_V01
      case CM_SS_EVENT_LTE_RRC_TX_INFO:
        qmi_nas_gen_lte_rrc_tx_info_ind(p_info);
        break;
#endif        
      default:
        copy_info = FALSE;
        // do nothing for now
        (void)p_info;
        break;
    }

    if ( copy_info )
    {
      memscpy(&qmi_nasi_global.cm_msim_ss_info[p_info->asubs_id], sizeof(cm_mm_msim_ss_info_s_type),
              &ptr->info, sizeof(cm_mm_msim_ss_info_s_type));
    }
  }
  /*Else, null pointer. ignoring cm ss event*/
}
#else
/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSS_EVT()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmss_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmss_evt_cb_s *ptr = (struct qmi_nas_cmss_evt_cb_s*)user_data_ptr;
  cm_ss_event_e_type         *p_evt;
  cm_mm_ss_info_s_type       *p_info;
  qmi_nasi_rssi_info_type     rssi_info;
  cm_ss_lte_rrc_tx_info_s_type lte_tx_info;
  mmgsdi_session_type_enum_type session = MMGSDI_GW_PROV_PRI_SESSION;
  boolean             copy_info = TRUE;
  uint8 i=0;

  if ( ptr )
  {
    p_evt  = &ptr->evt;
    p_info = &ptr->info;

    //Verify if NAS and RRC PLMN ID and LAC match only if SS event is reported for CELL_INFO
    if(
        (p_info->changed_fields & CM_SS_EVT_CELL_INFO_MASK) ||
        !(p_info->changed_fields & CM_SS_EVT_SYS_ID_MASK)
      )
    {
      //Calling qmi_nas_check_and_update_cell_id
      qmi_nas_check_and_update_cell_id(p_info);
    }
#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    //Verify if NAS and RRC PLMN ID and LAC match only if SS event is reported for CELL_INFO
    if(
        (p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_CELL_INFO_MASK) ||
        !(p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_SYS_ID_MASK)
      )
    {
      //Calling qmi_nas_check_and_update_cell_id, STACK_INDEX_1
      qmi_nas_check_and_update_cell_id(p_info, STACK_INDEX_1);
    }
#endif
    // Check MM Info PLMN ID
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    for (stack_index=0;stack_index < p_info->number_of_stacks && stack_index < STACK_INDEX_MAX;stack_index++)
    #endif
    {
      enum qmi_nas_radio_if_e rat = qmi_nas_sys_mode_2_radio_if(p_info,FALSE);
      if ( (  rat == QMI_NAS_RADIO_IF_GSM 
            #if defined(FEATURE_WCDMA)
            || rat == QMI_NAS_RADIO_IF_UMTS 
            #endif
            || rat == QMI_NAS_RADIO_IF_LTE ) &&
           p_info->mm_information.plmn_avail &&
           memcmp( &p_info->mm_information.plmn, &p_info->sys_id.id.plmn, sizeof(p_info->sys_id.id.plmn) ) )
      {
        p_info->mm_information.short_name_avail = FALSE;
        p_info->mm_information.full_name_avail = FALSE;
      }
    }

    QM_MSG_HIGH_1("cm ss evt %d", *p_evt);
    switch ( *p_evt )
            {
      case CM_SS_EVENT_INFO:
      case CM_SS_EVENT_SRV_CHANGED:
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY      
      case CM_SS_EVENT_DCH_CELL_ID_RSP:
      #endif
 
#ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
#ifdef FEATURE_DUAL_SIM
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, FALSE );
        #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
        qmi_nas_gen_event_report_ind( p_evt, p_info );
        #endif
       #ifndef REMOVE_QMI_NAS_GET_OPERATOR_NAME_DATA_V01
        {
          if ( qmi_nas_sys_mode_2_radio_if(p_info,FALSE) == QMI_NAS_RADIO_IF_GSM ||
               #if defined(FEATURE_WCDMA)
               qmi_nas_sys_mode_2_radio_if(p_info,FALSE) == QMI_NAS_RADIO_IF_UMTS ||
               #endif
               qmi_nas_sys_mode_2_radio_if(p_info,FALSE) == QMI_NAS_RADIO_IF_LTE )
          {
            sys_mm_information_s_type *p_new_mm_info = &p_info->mm_information;
            sys_mm_information_s_type *p_old_mm_info = &qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].mm_information;
          boolean                    send_ind = FALSE;

          if ( p_new_mm_info->short_name_avail )
          {
            if ( !p_old_mm_info->short_name_avail ||
                 memcmp( &p_old_mm_info->short_name, &p_new_mm_info->short_name, sizeof(sys_network_short_name_s_type) ) )
            {
                QM_MSG_HIGH_3("nitz updated short name %d %d %d", p_old_mm_info->short_name_avail, p_new_mm_info->short_name_avail, p_new_mm_info->short_name.length);
              send_ind = TRUE;
            }
          }

          if ( p_new_mm_info->full_name_avail )
          {
            if ( !p_old_mm_info->full_name_avail ||
                 memcmp( &p_old_mm_info->full_name, &p_new_mm_info->full_name, sizeof(sys_network_full_name_s_type) ) )
            {
                QM_MSG_HIGH_3("nitz updated full name %d %d %d", p_old_mm_info->full_name_avail, p_new_mm_info->full_name_avail, p_new_mm_info->full_name.length);
              send_ind = TRUE;
            }
          }
            //TODO: map Mmgsdi session based on asubs_id
          #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
          if ( send_ind )
          {
            qmi_nas_operator_name_data_ind( MMGSDI_GW_PROV_PRI_SESSION, p_new_mm_info );
          }
          #endif
        }
        }
        #endif 

#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
        qm_tib_check_and_invalidate_cdma_hdr_cache(p_info);
#endif
        if (  p_info->changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK  
             #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && ((defined(FEATURE_CDMA) || defined(FEATURE_HDR)))
             || ( p_info->number_of_stacks > 1 && p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK ) 
             #endif
           )
        {
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
          // compare CDMA time data with global cache, send ind and start timer
          if ( p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_CDMA_TIME_CHGD_MASK )
          { 
            if( qm_tib_is_enabled() )    // check if time ind blocking module is valid to use
            {
              if( qm_tib_is_time_info_changed(p_info) )
              {
                if( qm_tib_is_time_ind_blocked() )
                {
                  qm_tib_unblock_time_ind();
                }
                qmi_nas_update_cached_time_info(p_info);
                qmi_nas_gen_network_time_ind( p_info );
                qm_tib_update_time_info(p_info);
                qm_tib_block_time_ind();
                QM_MSG_HIGH("sent time ind and blocked tib");
              }
              else
              {
                if( !qm_tib_is_time_ind_blocked() )
                {
                  qmi_nas_update_cached_time_info(p_info);
                  qmi_nas_gen_network_time_ind( p_info );
                  qm_tib_update_time_info(p_info);       // after oos we land here so need to update cache as well
                  qm_tib_block_time_ind();
                  QM_MSG_HIGH("CM SS EVENT Time changed, network_time_ind sent and blocked tib");
                }
                else
                {
                  QM_MSG_HIGH("CM SS EVENT Time changed, dropping network_time_ind");
                }
              }
            }
            else
            {
              qmi_nas_update_cached_time_info(p_info);
              qmi_nas_gen_network_time_ind(p_info); // default behavior send ind
              QM_MSG_HIGH("tib not valid to use, sending network_time_ind rightaway");
            }
          }
          else
#endif
          {
            qmi_nas_update_cached_time_info(p_info);
            qmi_nas_gen_network_time_ind(p_info); // send ind for 3gpp networks
//            QM_MSG_HIGH("network_time_ind sent for 3GPP networks");
          }
        }

        if( *p_evt == CM_SS_EVENT_SRV_CHANGED )
        {
#ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info, QMI_NAS_SUBS_PRIMARY );
#ifdef FEATURE_DUAL_SIM
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info2, QMI_NAS_SUBS_SECONDARY );
#ifdef FEATURE_TRIPLE_SIM
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info3, QMI_NAS_SUBS_TERTIARY );
#endif
#endif
#endif
        }

#ifndef FEATURE_MMODE_QMI_LTE_ONLY
        if( 
            #ifdef FEATURE_WCDMA
            p_info->sys_mode == SYS_SYS_MODE_WCDMA ||
            #endif
            p_info->sys_mode == SYS_SYS_MODE_GSM ||
            p_info->sys_mode == SYS_SYS_MODE_LTE 
            #ifdef FEATURE_TDSCDMA
            || p_info->sys_mode == SYS_SYS_MODE_TDS
            #endif
            #ifndef FEATURE_MMODE_QMI_GPRS_LTE
            || ( p_info->number_of_stacks > 1 
            #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
            &&
              ( p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE ||
                p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM )
             #endif   
             )
            #endif
            )
#else
        if( p_info->sys_mode == SYS_SYS_MODE_LTE)
#endif
        {
          #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
          session = qmi_nas_map_cm_asubs_to_mmgsdi_session( p_info->asubs_id );
          #endif
          qmi_nas_gen_current_plmn_name_ind( p_info, MMGSDI_GW_PROV_PRI_SESSION );
        }
#ifdef FEATURE_DUAL_SIM
        // Need second call for secondary subscription
#endif

        qmi_nas_gen_rf_band_info_ind( p_info );

        qmi_nas_update_global_ims_pref( p_info );

        qm_si_process_cm_ss_event( p_info, *p_evt );

        break;

      #if defined(FEATURE_HDR)
      case CM_SS_EVENT_HDR_RSSI:
      #endif
      case CM_SS_EVENT_RSSI:
      case CM_SS_EVENT_GW_RSSI:
        qm_meas_process_cm_measurement_event(p_info, *p_evt);
        qmi_nas_copy_to_rssi_struct( &rssi_info, p_info );
        memscpy( p_info, sizeof(cm_mm_ss_info_s_type), &qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY], sizeof(cm_mm_ss_info_s_type));
        qmi_nas_copy_from_rssi_struct( p_info, &rssi_info );
        #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
        qmi_nas_gen_event_report_ind( p_evt, p_info );
        #endif
        qmi_nas_copy_from_global_sys_mode( &qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY], p_info );
        break;

    case CM_SS_EVENT_REG_REJECT:
#ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
#ifdef FEATURE_DUAL_SIM
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, TRUE );
        qmi_nas_gen_network_reject_ind( p_info );
        #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
        qmi_nas_gen_event_report_ind( p_evt, p_info );
        #endif
        break;

#ifndef FEATURE_MMODE_QMI_LTE_ONLY
      case CM_SS_EVENT_CELL_ACCESS_IND:
#ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
#ifdef FEATURE_DUAL_SIM
       qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
       qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, FALSE );
        break;
#endif

#ifndef REMOVE_QMI_NAS_GET_LTE_RRC_TX_INFO_V01
      case CM_SS_EVENT_LTE_RRC_TX_INFO:

        qmi_nas_copy_tx_info_struct( &lte_tx_info, &p_info->lte_rrc_tx_info );
        memscpy( p_info, sizeof(cm_mm_ss_info_s_type), &qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY], sizeof(cm_mm_ss_info_s_type));
        qmi_nas_copy_tx_info_struct( &p_info->lte_rrc_tx_info, &lte_tx_info );

        qmi_nas_gen_lte_rrc_tx_info_ind(p_info);
        break;
#endif        
      default:
        copy_info = FALSE;
        // do nothing for now
        (void)p_info;
        break;
    }

    if ( copy_info )
    {
      memscpy(&qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY], sizeof(cm_mm_ss_info_s_type),
              &ptr->info, sizeof(cm_mm_ss_info_s_type));
    }
  }
  /*Else, null pointer. ignoring cm ss event*/
}
#endif

#ifdef FEATURE_DUAL_SIM
/*===========================================================================
  FUNCTION qmi_nas_cmss_msim_evt_cb()

  DESCRIPTION
    Queue CM MSIM SS events into MMODE_QMI

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmss_msim_evt_cb( cm_ss_event_e_type evt, const cm_mm_msim_ss_info_s_type *p_info)
{
  struct qmi_nas_cmss_msim_evt_cb_s *ptr;

  if ( p_info )
    {
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    if ( evt == CM_SS_EVENT_CELL_ACCESS_IND && p_info->number_of_stacks >= 1 &&
         ( p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_NO_SRV || p_info->stack_info[STACK_INDEX_0].srv_status == SYS_SRV_STATUS_PWR_SAVE ||
           p_info->stack_info[STACK_INDEX_0].srv_status == SYS_SRV_STATUS_NO_SRV ) )
    {
      QM_MSG_HIGH("Dropping Cell Access due to no service");
    }
    else
    #endif
    {
      ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

      if ( ptr )
      {
        ptr->evt  = evt;
        ptr->info = *p_info;
        qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSS_MSIM_EVT_CB, ptr);
      }
      else
      {
    qmi_voice_mem_error();        
      }
    }
  }

}
#else
/*===========================================================================
  FUNCTION qmi_nas_cmss_evt_cb()

  DESCRIPTION
    Queue CM MSIM SS events into MMODE_QMI

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmss_evt_cb( cm_ss_event_e_type evt, const cm_mm_ss_info_s_type *p_info)
{
  struct qmi_nas_cmss_evt_cb_s *ptr;
  if ( p_info )
   {
     #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
       if ( evt == CM_SS_EVENT_CELL_ACCESS_IND && //p_info->number_of_stacks >= 1 &&
          ( p_info->sys_mode == SYS_SYS_MODE_NO_SRV || p_info->srv_status == SYS_SRV_STATUS_PWR_SAVE ||
           p_info->srv_status == SYS_SRV_STATUS_NO_SRV ) )
       {
         QM_MSG_HIGH("Dropping Cell Access due to no service");
       }
       else
     #endif
     {
       ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );
       if(ptr)
       {
         ptr->evt  = evt;
         ptr->info = *p_info;
         qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSS_EVT_CB, ptr);
       }
       else
       {
         qmi_voice_mem_error();
       }
     }
   }
}
#endif

struct qmi_nas_cmss_cmd_cb_s
      {
  void                *p_data;
  cm_ss_cmd_e_type     cmd;
  cm_ss_cmd_err_e_type err;
};

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSS_CMD()

  DESCRIPTION
    Handle CM SS command callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmss_cmd( qmi_mmode_cmd_enum_type cmd_type, void *user_data_ptr )
{
  struct qmi_nas_cmss_cmd_cb_s *ptr = (struct qmi_nas_cmss_cmd_cb_s*)user_data_ptr;
  void                *p_data;
  cm_ss_cmd_e_type     cmd;
  cm_ss_cmd_err_e_type err;
  boolean              success=FALSE;

  if ( ptr )
  {
    // cache to local variables for readability
    p_data = ptr->p_data;
    cmd    = ptr->cmd;
    err    = ptr->err;

    QM_MSG_HIGH_3("cm ss cmd cb %d err %d user_data %d", cmd, err, (int)p_data );

    success = TRUE;

    switch (cmd)
    {
      case CM_SS_CMD_INFO_GET: // cm_ss_cmd_get_ss_info()
        break;

    #ifndef REMOVE_QMI_NAS_SET_GNSS_SESSION_STATUS_V01
      case CM_SS_CMD_SEND_GNSS_SESSION_STATUS:
           qmi_nas_set_gnss_session_status_resp(p_data,err);
        break;
    #endif        

      default:
        // do nothing for now
        (void)p_data;
        (void)err;
        break;
    }
  }
  /*Success will be set to TRUE if no error in handling CM SS cmd*/
}

/*===========================================================================
  FUNCTION QMI_NAS_CMSS_CMD_CB()

  DESCRIPTION
    Handle CM SS command callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmss_cmd_cb( void *p_data, cm_ss_cmd_e_type cmd, cm_ss_cmd_err_e_type err)
{
  struct qmi_nas_cmss_cmd_cb_s *ptr;

  ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ptr )
  {
    ptr->p_data = p_data;
    ptr->cmd    = cmd;
    ptr->err    = err;

    qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSS_CMD_CB, ptr);
  }
  else
    {
    qmi_voice_mem_error();
  }
    }

struct qmi_nas_cmph_event_s
{
  cm_ph_event_e_type beg;
  cm_ph_event_e_type end;
};

struct qmi_nas_cmss_event_s
{
  cm_ss_event_e_type beg;
  cm_ss_event_e_type end;
};

/*===========================================================================
  FUNCTION QMI_NAS_REGISTER_TO_AMSS()

  DESCRIPTION
    Perform necessary registration to AMSS modules (e.g., CM)

  RETURN VALUE
    TRUE for success, FALSE for failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    QMI_NAS global variables will be updated
===========================================================================*/
static boolean qmi_nas_register_to_amss(void)
{
  cm_client_status_e_type ret_val;
  int                     i;
  bit_mask_256_t          event_mask;

  const cm_ph_event_e_type ph_event_list[] = {
     CM_PH_EVENT_OPRT_MODE,
     CM_PH_EVENT_SYS_SEL_PREF,
     CM_PH_EVENT_INFO,
     CM_PH_EVENT_INFO_AVAIL,
     CM_PH_EVENT_SUBSCRIPTION_AVAILABLE,
     CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE,
     CM_PH_EVENT_SUBSCRIPTION_CHANGED,
     CM_PH_EVENT_AVAILABLE_NETWORKS_CONF,
   #ifdef FEATURE_MMODE_QMI_LTE_ONLY
     CM_PH_EVENT_TERMINATE_GET_NETWORKS,
   #elif defined(FEATURE_MMODE_QMI_GPRS_LTE)
     CM_PH_EVENT_CURR_NAM,
     CM_PH_EVENT_TERMINATE_GET_NETWORKS,
     CM_PH_EVENT_GET_HPLMN_TIMER,
   #else
     CM_PH_EVENT_CURR_NAM,
     CM_PH_EVENT_NVRUIM_CONFIG_CHANGED,
     CM_PH_EVENT_TERMINATE_GET_NETWORKS,
     CM_PH_EVENT_DDTM_STATUS, 
     CM_PH_EVENT_DUAL_STANDBY_PREF,
     CM_PH_EVENT_GET_HPLMN_TIMER,
   #endif
     CM_PH_EVENT_GET_DRX_CNF,
     CM_PH_EVENT_GET_EDRX_CNF,
     CM_PH_EVENT_SET_EDRX_CNF,
     CM_PH_EVENT_EDRX_CHANGE_INFO_IND,
  };

  const cm_ss_event_e_type ss_event_list[] = {
     CM_SS_EVENT_SRV_CHANGED,
     CM_SS_EVENT_RSSI,
     CM_SS_EVENT_INFO,
    #if defined(FEATURE_HDR)
     CM_SS_EVENT_HDR_RSSI,
    #endif
     CM_SS_EVENT_GW_RSSI,
     CM_SS_EVENT_REG_REJECT,
    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
     CM_SS_EVENT_CELL_ACCESS_IND,
     CM_SS_EVENT_DCH_CELL_ID_RSP, 
    #endif
     CM_SS_EVENT_LTE_RRC_TX_INFO 
    };

  ret_val = cm_client_init( CM_CLIENT_TYPE_RM_NETWORK_INTERFACE, &qmi_nasi_global.cm_clnt_id);

  if ( ret_val == CM_CLIENT_OK ) {
    for ( i=0; i<QMI_NAS_ARR_SIZE(ph_event_list); i++ )
    {
      bit_mask_256_set_bit(&event_mask,ph_event_list[i]);
    }
    ret_val = cm_client_ph_reg( qmi_nasi_global.cm_clnt_id,
                              qmi_nas_cmph_evt_cb,
                              CM_CLIENT_EVENT_REG,
                              event_mask,
                              NULL );
    if( ret_val != CM_CLIENT_OK )
        {
          QM_MSG_ERROR_1("cm_client_ph_reg registration failed %d", ret_val);
        }
  }


  if ( ret_val == CM_CLIENT_OK ) 
  {
    bit_mask_256_clear_all(&event_mask);
    for ( i=0; i<QMI_NAS_ARR_SIZE(ss_event_list); i++ )
    {
      bit_mask_256_set_bit(&event_mask,ss_event_list[i]);
    }
    ret_val = cm_mm_client_ss_reg( qmi_nasi_global.cm_clnt_id,
                                   qmi_nas_cmss_evt_cb,
                                   CM_CLIENT_EVENT_REG,
                                   event_mask,
                                   NULL);
      if ( ret_val != CM_CLIENT_OK )
      {
        QM_MSG_ERROR_1("cm_mm_client_ss_reg_msim registration failed %d", ret_val);
     }
  }
#ifdef FEATURE_MODEM_STATISTICS
  if ( ret_val == CM_CLIENT_OK )
  {
    ret_val = cm_client_stats_reg( qmi_nasi_global.cm_clnt_id,
                                   qmi_nas_cmstats_evt_cb,
                                   CM_CLIENT_EVENT_REG,
                                   CM_STATS_EVENT_MODEM_INFO,
                                   CM_STATS_EVENT_MODEM_INFO,
                                   NULL );

    if ( ret_val != CM_CLIENT_OK )
      QM_MSG_ERROR_1("cm stats registratio failed %d", ret_val);

    if ( !cm_stats_set_modem_info_mask( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_GSM,
                                        CM_GERAN_ENG_MODE_NMR_INFO       |
                                        CM_GERAN_ENG_MODE_TIMING_ADVANCE |
                                        CM_GERAN_ENG_MODE_SCELL_INFO     |
                                        CM_GERAN_ENG_MODE_SCELL_MEASUREMENTS  |
                                        SYS_GERAN_ENG_MODE_CURRENT_L1_TIMESLOT |
                                        SYS_GERAN_ENG_SCELL_CONFIG) )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem GSM info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }

#ifdef FEATURE_WCDMA    
    if ( !cm_stats_set_modem_info_mask( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_WCDMA,
                                        CM_WCDMA_MONITORED_SET_BIT_MASK     |
                                        CM_WCDMA_SERVING_CELL_INFO_BIT_MASK |
                                        CM_WCDMA_SERVING_CELL_POWER_INFO_BIT_MASK |
                                        CM_WCDMA_ACTIVE_SET_REFERENCE_CELL_INFO_BIT_MASK | 
                                        CM_WCDMA_RRC_STATE | 
                                        CM_WCDMA_ACTIVE_SET_INFO_BIT_MASK
                                      )
       )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem WCDMA info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
#endif
    if ( !cm_stats_set_modem_info_mask( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_NAS,
                                        SYS_NAS_EMM_INFO_MASK
                                      )
       )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem NAS info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
    
#ifdef FEATURE_DUAL_SIM
    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_GSM,
                                        CM_GERAN_ENG_MODE_NMR_INFO       |
                                        CM_GERAN_ENG_MODE_TIMING_ADVANCE |
                                        CM_GERAN_ENG_MODE_SCELL_INFO     |
                                        CM_GERAN_ENG_MODE_SCELL_MEASUREMENTS, 
                    SYS_MODEM_AS_ID_2) )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem GSM info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }

    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_WCDMA,
                                        CM_WCDMA_MONITORED_SET_BIT_MASK     |
                                        CM_WCDMA_SERVING_CELL_INFO_BIT_MASK |
                                        CM_WCDMA_SERVING_CELL_POWER_INFO_BIT_MASK |
                                        CM_WCDMA_ACTIVE_SET_REFERENCE_CELL_INFO_BIT_MASK | 
                                        CM_WCDMA_RRC_STATE | 
                                        CM_WCDMA_ACTIVE_SET_INFO_BIT_MASK,
                                        SYS_MODEM_AS_ID_2
                                      )
       )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem WCDMA info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }

    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_NAS,
                                        SYS_NAS_EMM_INFO_MASK,
                                        SYS_MODEM_AS_ID_2
                                      )
       )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem NAS info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
    
   #endif
   #ifdef FEATURE_TRIPLE_SIM
    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_GSM,
                                        CM_GERAN_ENG_MODE_NMR_INFO       |
                                        CM_GERAN_ENG_MODE_TIMING_ADVANCE |
                                        CM_GERAN_ENG_MODE_SCELL_INFO     |
                                        CM_GERAN_ENG_MODE_SCELL_MEASUREMENTS,
                                        SYS_MODEM_AS_ID_3) )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem GSM info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_WCDMA,
                                        CM_WCDMA_MONITORED_SET_BIT_MASK     |
                                        CM_WCDMA_SERVING_CELL_INFO_BIT_MASK |
                                        CM_WCDMA_SERVING_CELL_POWER_INFO_BIT_MASK |
                                        CM_WCDMA_ACTIVE_SET_REFERENCE_CELL_INFO_BIT_MASK | 
                                        CM_WCDMA_RRC_STATE | 
                                        CM_WCDMA_ACTIVE_SET_INFO_BIT_MASK,
                                        SYS_MODEM_AS_ID_3
                                      )
       )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem WCDMA info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
   #endif
  }
#endif

#ifdef FEATURE_DUAL_SIM
  if ( ret_val == CM_CLIENT_OK )
  {
    ret_val = cm_client_subs_reg( qmi_nasi_global.cm_clnt_id,
                                  qmi_nas_cmsubs_evt_cb );
    if ( ret_val != CM_CLIENT_OK )
      QM_MSG_ERROR_1("cm_client_subs_reg failed %d", ret_val);
  }
#endif
#ifndef FEATURE_MMODE_DISABLE_UIM
  if ( ret_val == CM_CLIENT_OK ) {
    ret_val = qmi_nas_mmgsdi_register_to_amss() ? CM_CLIENT_OK : CM_CLIENT_ERR_CLIENT_ID_PTR;
  }
#endif
#ifdef FEATURE_HDR
  if ( ret_val == CM_CLIENT_OK ) {
    ret_val = qmi_nas_register_to_hdr() ? CM_CLIENT_OK : CM_CLIENT_ERR_CLIENT_ID_PTR;
  }
#endif

  if ( ret_val != CM_CLIENT_OK ) {
    (void)cm_client_release( qmi_nasi_global.cm_clnt_id );
    return FALSE;
  }
  else {
    return TRUE;
  }
}

static int qmi_nas_qcsi_compare_pending_req_for_client
( 
  void *item_ptr,
  void *compare_val 
)
{
  qmi_nasi_client_state_type *clnt_info_ptr;
  qmi_mmode_qcsi_transaction_type *req_node;
  qmi_client_handle clnt;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if((item_ptr == NULL) || (compare_val == NULL))
  {
    return FALSE;
  }
  req_node = (qmi_mmode_qcsi_transaction_type *)item_ptr;
  clnt_info_ptr = (qmi_nasi_client_state_type *)req_node->clnt_info_ptr;
  clnt = (qmi_client_handle)compare_val;

  return ( (clnt_info_ptr->clnt == (clnt))? 1 : 0 );
} /* qmi_nas_qcsi_compare_pending_req_for_client */


/*===========================================================================
  FUNCTION qmi_nas_qcsi_svc_disconnect_cb()

  DESCRIPTION
    CallBack function to be registered with QCSI for disconnecting a client

  PARAMETERS
    connection_handle : QCSI client connection handle
    service_handle : QCSI service handle

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nas_qcsi_svc_disconnect_cb
(
  void                      *connection_handle,
  void                      *service_handle
)
{
  qmi_nasi_client_state_type       *clnt_info_ptr;
  qmi_mmode_svc_info_type          *svc_ptr;
  qmi_csi_error                     err = QMI_CSI_NO_ERR;
  qmi_mmode_qcsi_transaction_type  *pending_req = NULL;
  void                             *temp_ptr = NULL;
  int num_deleted_pending_txs = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(connection_handle && service_handle);
  svc_ptr = (qmi_mmode_svc_info_type *)service_handle;
  clnt_info_ptr = (qmi_nasi_client_state_type *)connection_handle;

  do
  {
    if( svc_ptr == NULL || svc_ptr->service_type != QMI_MMODE_SERVICE_NAS ||
        svc_ptr->service_handle != qmi_nas_state.service_handle )
    {
      err = QMI_CSI_INVALID_HANDLE;
      QM_MSG_HIGH("Invalid service received");
      break;
    }
    
    if ( TRUE != q_delete_ext( &svc_ptr->client_q,
                               &clnt_info_ptr->link ) )
    {
      err = QMI_CSI_CONN_REFUSED;
      break;
    }

    /* Delete any pending transactions for this client */
    if(q_cnt(&svc_ptr->pending_req) > 0)
    {
      do
      {
        pending_req = q_linear_delete_new(&svc_ptr->pending_req,
                                          qmi_nas_qcsi_compare_pending_req_for_client,
                                          (void*)&clnt_info_ptr->clnt,
                                           NULL,
                                           NULL );
        if (pending_req != NULL)
        {
          temp_ptr = (void *)pending_req;
          modem_mem_free( temp_ptr, MODEM_MEM_CLIENT_QMI );
          num_deleted_pending_txs++;
        }
      }while(pending_req != NULL);

      if(num_deleted_pending_txs > 0)
      {
        QM_MSG_HIGH_2("nas_qcsi_disconnect_cb: Deleted %d pending txs of clnt 0x%p",
                       num_deleted_pending_txs, 
                       clnt_info_ptr->clnt);
      }
    }
    
  } while(0);

  if( err == QMI_CSI_NO_ERR )
  {
    modem_mem_free( clnt_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  
  QM_MSG_HIGH_2("nas_qcsi_disconnect_cb: Releasing client 0x%p err %d",
                  connection_handle, err);
} /* qmi_nas_qcsi_svc_disconnect_cb() */

/*===========================================================================
  FUNCTION alloc_cl_sp()

  DESCRIPTION
    Allocate the client data buffer

  PARAMETERS
    clid: uint8

  RETURN VALUE
    ptr to malloc'ed client pointer in case of success. NULL otherwise.
===========================================================================*/
static qmi_nasi_client_state_type* alloc_cl_sp
( 
  qmi_client_handle          client_handle 
)
{
  qmi_nasi_client_state_type *cl_sp = NULL;

  QM_MSG_MED_1("In alloc_cl_sp(): client_handle = %p", client_handle);

  cl_sp = modem_mem_alloc( sizeof(qmi_nasi_client_state_type), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( cl_sp )
  {
    memset( cl_sp, 0x00, sizeof(qmi_nasi_client_state_type) );
    (void) q_link ( cl_sp, &cl_sp->link );
    cl_sp->clnt = client_handle;
  }
  else
  {
   qmi_voice_mem_error();
  }

  return cl_sp;
  }

int qmi_nas_qcsi_compare_client_handle
( 
  void *item_ptr,
  void *compare_val 
)
{
  qmi_nasi_client_state_type *clnt_info = (qmi_nasi_client_state_type*)item_ptr;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  return ( (clnt_info->clnt == 
                          (qmi_client_handle)compare_val) ? 1 : 0 );
} /* qmi_nas_qcsi_compare_client_handle */

/*===========================================================================
  FUNCTION qmi_nas_qcsi_connect_cb()

  DESCRIPTION
    CallBack function to be registered with QCSI for connecting a client

  PARAMETERS
    Client Handle
    Service Handle
    Connection Handle

  RETURN VALUE
    QMI_ERR_NONE - Success
    QMI_CSI_CB_CONN_REFUSED - Failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_csi_cb_error qmi_nas_qcsi_svc_connect_cb
(
  qmi_client_handle          client_handle,
  void                      *service_handle,
  void                     **connection_handle
)
{

  qmi_nasi_client_state_type        *cl_sp = NULL;
  qmi_csi_cb_error                   err = QMI_CSI_CB_NO_ERR;
  qmi_mmode_svc_info_type           *svc_ptr;

  ASSERT(connection_handle && service_handle);

  svc_ptr = (qmi_mmode_svc_info_type *)service_handle;

  do
  {
    if( svc_ptr == NULL || svc_ptr->service_type != QMI_MMODE_SERVICE_NAS ||
        svc_ptr->service_handle != qmi_nas_state.service_handle )
    {
      err = QMI_CSI_CB_UNSUPPORTED_ERR;

      break;
    }
    if ( NULL != q_linear_search( &svc_ptr->client_q,
                                    qmi_nas_qcsi_compare_client_handle,
                                    client_handle ) )
    {
      QM_MSG_ERROR_1("nas_qcsi_connect_cb: client 0x%p present", client_handle);
      err = QMI_CSI_CB_CONN_REFUSED;
      break;
    }

    if( q_cnt(&svc_ptr->client_q) == NASI_MAX_CLIDS )
    {
      QM_MSG_ERROR_1("nas_qcsi_connect_cb: max num clients reached rejected client_handle %p", 
                        client_handle);
      err = QMI_CSI_CB_CONN_REFUSED;
      break;
    }
  
    cl_sp = alloc_cl_sp( client_handle );
    
    if ( cl_sp )
    {
      /* Add client node to the queue of clients */
      q_put( &(svc_ptr->client_q), &(cl_sp->link) );
          
      /*-----------------------------------------------------------------------
        Initialize client state variables
        - last reported signal strength to inactive
      -----------------------------------------------------------------------*/
      cl_sp->report_status.last_reported_rssi_ex = NASI_SIG_STRENGTH_INACTIVE_RSSI;
    
    
      cl_sp->report_status.last_reported_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR;
      cl_sp->report_status.last_reported_rsrq = NASI_SIG_STRENGTH_INACTIVE_RSRQ;
      cl_sp->report_status.last_reported_lte_rsrp = NASI_SIG_STRENGTH_INACTIVE_RSRP;
      cl_sp->report_status.last_reported_lte_snr  = NASI_LTE_SNR_STRENGTH_INACTIVE;
      cl_sp->report_status.reporting_mode_sinr    = NASI_EVENT_REPORT_MODE_DELTA;
      cl_sp->report_status.bound_subs             = QMI_NAS_SUBS_PRIMARY;
    
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY
      cl_sp->report_status.last_reported_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO;
      cl_sp->report_status.last_reported_io   = NASI_SIG_STRENGTH_INACTIVE_IO;
      #if defined(FEATURE_HDR)
      cl_sp->report_status.last_reported_hdr_rssi = NASI_SIG_STRENGTH_INACTIVE_RSSI;
      cl_sp->report_status.last_reported_hdr_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO;
      cl_sp->report_status.last_reported_hdr_io   = NASI_SIG_STRENGTH_INACTIVE_IO;
      cl_sp->report_status.last_reported_hdr_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR;
      #endif
      cl_sp->report_status.reporting_mode_ecio    = NASI_EVENT_REPORT_MODE_DELTA;
    
      #ifdef FEATURE_DUAL_SIM
      cl_sp->report_status.report_dual_standby_pref_ind   = FALSE;
      cl_sp->report_status.report_subscription_info_ind   = FALSE;
      #endif
      #if !defined(FEATURE_MMODE_QMI_GPRS_LTE)
      cl_sp->report_status.report_thermal_emergency_state = FALSE;
      #endif
      cl_sp->report_status.report_network_time            = FALSE;
      cl_sp->report_status.report_sys_info                = FALSE;
    cl_sp->report_status.report_psm_config_params_change_ind = FALSE;
    cl_sp->report_status.report_psm_status_ind = FALSE;
    cl_sp->report_status.report_operating_mode_ind = FALSE;

      cl_sp->report_status.report_sig_info                = FALSE;
      cl_sp->report_status.report_err_rate                = FALSE;
      cl_sp->report_status.report_current_plmn_name       = FALSE;
      cl_sp->report_status.report_operator_name_data      = TRUE;

      cl_sp->report_status.report_csp_plmn_mode_bit       = TRUE;
          cl_sp->report_status.report_sinr                    = FALSE;
      cl_sp->report_status.report_rsrq                            = FALSE;
      cl_sp->report_status.report_lte_snr                        = FALSE;
      cl_sp->report_status.limit_sys_info_reporting_mask  = QMI_NAS_LIMIT_NONE;
      cl_sp->report_status.ignore_plmn_display_cond_in_ind = FALSE;
      cl_sp->report_status.network_reject.report_network_reject_ind = FALSE;
      cl_sp->report_status.network_reject.suppress_sys_info_on_reject = FALSE;
    
      cl_sp->report_status.report_sig_str = FALSE;
      cl_sp->report_status.num_thresholds = 0;
      cl_sp->report_status.num_thresholds_ecio = 0;
      cl_sp->report_status.num_thresholds_sinr = 0;
      #else
      cl_sp->report_status.report_operator_name_data      = TRUE;

      cl_sp->report_status.report_csp_plmn_mode_bit       = TRUE;
      #endif
    
      *connection_handle = cl_sp;
      QM_MSG_HIGH_2("nas_qcsi_connect_cb: Alloc client 0x%p client_handle %p", 
                      cl_sp, client_handle);
  
    }
    else
    {
      err = QMI_CSI_CB_NO_MEM;
    }
  } while(0);

  if (err != QMI_CSI_CB_NO_ERR)
  {  
    QM_MSG_ERROR_3("nas_qcsi_connect_cb: Error processing err = %d client_handle %p svc handle %p", 
                    err, client_handle, service_handle);
  }
  else
  {
    QM_MSG_HIGH_2("nas_qcsi_connect_cb: client connect client_handle %p connection_handle %p",
                    client_handle, *connection_handle);
  }

  return err;
  
}/* qmi_nas_qcsi_connect_cb */

/*===========================================================================
  FUNCTION qmi_nas_process_init_cback()

  DESCRIPTION
    Process init from Framework
===========================================================================*/
void qmi_nas_process_init_cback( void )
{

  int i;
  
  /*-------------------------------------------------------------------------
  Initialize the global NAS service parameters
  -------------------------------------------------------------------------*/
  if(qmi_nasi_global.inited == INIT_STATE_NOT_INITIALIZED)
  {
    boolean success;
    
    memset(&qmi_nasi_global, 0, sizeof(qmi_nasi_global));
    memset(&qmi_nasi_nitz_time,0,sizeof(qmi_nasi_nitz_time));
    memset(&qmi_nasi_ssac_info,0 , sizeof(qmi_nasi_ssac_info));
    
    #ifndef FEATURE_MMODE_DISABLE_UIM
    qmi_nas_mmgsdi_init(&qmi_nasi_global.mmgsdi);
    #else
    //qmi_nas_mmgsdi_init(qmi_nasi_global.mmgsdi);
    #endif
    qmi_nas_nw_name_init();
    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    qm_tib_init( qmi_nas_timer_cmd_cb ); 
    #endif
    
    #ifdef FEATURE_QMI_NAS_HDR
    #ifdef FEATURE_HDR
    // init HDR module
    qmi_nas_init_hdr();
    #endif
    #endif
    
    success = qmi_nas_register_to_amss();
    
    if ( success ) 
    {
      (void)cm_ph_cmd_get_ph_info( qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id );
    
      #ifdef FEATURE_DUAL_SIM
      (void)cm_ph_cmd_get_ph_info_per_subs( qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_2 ); // dwbeacon
       #ifdef FEATURE_TRIPLE_SIM
      (void)cm_ph_cmd_get_ph_info_per_subs( qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_3 );
      #endif
      #endif
    
      qmi_nasi_global.net_scan_started = FALSE;
      #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
      qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;
      #endif
      qmi_nasi_global.inited = INIT_STATE_PENDING_MODE_CAPABILITY;
      #ifndef REMOVE_QMI_NAS_SET_EVENT_REPORT_V01
      qmi_nasi_global.min_rssi_delta = NASI_DEFAULT_RSSI_DELTA;
      qmi_nasi_global.min_io_delta   = NASI_DEFAULT_IO_DELTA;
      qmi_nasi_global.min_rsrq_delta = NASI_DEFAULT_RSRQ_DELTA;
      qmi_nasi_global.min_rsrp_delta = NASI_DEFAULT_RSRP_DELTA;
      #endif
      #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
      #ifndef REMOVE_QMI_NAS_SET_RTRE_CONFIG_V01
      qmi_nasi_global.rtre_set_status_pending = FALSE;
      #endif
      #endif
      memset( &qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY],  0x00, sizeof(qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY]) );
      memset( &qmi_nasi_global.cm_ph_info,  0x00, sizeof(qmi_cm_ph_info_s_type) );
      
      #ifdef FEATURE_DUAL_SIM
      memset( &qmi_nasi_global.cm_ph_info2, 0x00, sizeof(qmi_cm_ph_info_s_type) );
      qmi_nasi_global.rcvd_ph_info2     = FALSE;
      qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_SECONDARY] = SYS_SIM_STATE_NOT_AVAILABLE;
      #endif
      #ifdef FEATURE_TRIPLE_SIM
      memset( &qmi_nasi_global.cm_ph_info3, 0x00, sizeof(qmi_cm_ph_info_s_type) );
      qmi_nasi_global.rcvd_ph_info3     = FALSE;
      qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_TERTIARY] = SYS_SIM_STATE_NOT_AVAILABLE;
      #endif
      qmi_nasi_global.rcvd_ss_info      = FALSE;
      qmi_nasi_global.rcvd_ph_info      = FALSE;
	  /* Default value is 5 sec in msec */
      qmi_nasi_global.wwan_sleep_theshold = 5000;
      
      qmi_nasi_global.current_plmn_name_cache.current_plmn_valid = FALSE;
    
    
      #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      #ifdef FEATURE_LTE_EMBMS
      qmi_nasi_global.embms_status      = FALSE;
      qmi_nasi_global.trace_id                = -1;
      #endif
      #endif
      qmi_nasi_global.cmd_buf_p               = NULL;
      qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_PRIMARY] = SYS_SIM_STATE_NOT_AVAILABLE;
      qmi_nasi_global.svc_obj = nas_get_service_object_v01();
    
      #ifdef FEATURE_DUAL_SIM
      for ( i=QMI_NAS_SUBS_PRIMARY; i<QMI_NAS_SUBS_MAX; i++ )
      {
        memset( qmi_nasi_global.prev_nw_desc[i].desc, 0x00, QMI_NAS_NET_DESC_LEN_MAX );
        memset( &qmi_nasi_global.subs_info[i], 0x00, sizeof(cm_subs_info_s_type) );
      }
      #else
      #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
      memset( qmi_nasi_global.prev_nw_desc[QMI_NAS_SUBS_PRIMARY].desc, 0x00, QMI_NAS_NET_DESC_LEN_MAX );
      #endif
      #endif
      qmi_nasi_ssac_info.is_valid = FALSE;
      qmi_nasi_ssac_info.ssac_cache.ssac_param_voice_valid = FALSE;
      qmi_nasi_ssac_info.ssac_cache.ssac_param_video_valid = FALSE;
      qmi_nasi_ssac_info.ssac_cache.barring_factor_mmtel_voice = 0xFF;
      qmi_nasi_ssac_info.ssac_cache.barring_factor_mmtel_video = 0xFF;
      qmi_nasi_ssac_info.ssac_cache.barring_time_mmtel_voice = 0xFFFF;
      qmi_nasi_ssac_info.ssac_cache.barring_time_mmtel_video = 0xFFFF;
      qmi_nasi_ssac_info.ssac_cache.sib2_barring_factor_mmtel_voice = 0xFF;
      qmi_nasi_ssac_info.ssac_cache.sib2_barring_factor_mmtel_video = 0xFF;
      qmi_nasi_ssac_info.ssac_cache.sib2_barring_time_mmtel_voice = 0xFFFF;
      qmi_nasi_ssac_info.ssac_cache.sib2_barring_time_mmtel_video = 0xFFFF;
    
      #if !defined(REMOVE_QMI_NAS_GET_DATA_ROAMING_V01 ) || !defined(REMOVE_QMI_NAS_SET_DATA_ROAMING_V01)
      for( i = 0; i < QMI_NAS_SUBS_MAX; i++)
      {
        qmi_nasi_global.data_roam_cache_valid[i] = qm_efs_read_data_roaming_status(i, &qmi_nasi_global.data_roam_cache[i]);
      }
      #endif
      
      #ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
      QM_MSG_HIGH_2( "resetting call mode due to initialization - old valid: %d old call mode: %d", qmi_nasi_global.call_mode_valid, qmi_nasi_global.call_mode);
      for(i = 0; i < QMI_NAS_SUBS_MAX; i++)
      {
        qmi_nasi_global.call_mode_valid[i] = FALSE;
        qmi_nasi_global.call_mode[i] = SYS_CALL_MODE_NORMAL;
      }
      
      #endif
    }
    else 
    {
      QM_MSG_ERROR("CM/MMGSDI client registration failed");
    }
  }

}

/*===========================================================================
  FUNCTION QMI_NAS_INIT()

  DESCRIPTION
    Register the Netowrk Access Service with QMUX for all applicable QMI links
===========================================================================*/
void qmi_nas_init( void )
{
  qmi_csi_error                 err;
  qmi_sap_error                 serr;

#ifdef FEATURE_MODEM_CONFIG_REFRESH
  mcfg_refresh_registration_s_type mcfg_refresh_reg;
#endif // FEATURE_MODEM_CONFIG_REFRESH

  /* Set the cmd handlers in QMI MMODE task */  
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMPH_EVT_CB,    qmi_nas_process_cmph_evt       );
  #ifdef FEATURE_DUAL_SIM
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSS_MSIM_EVT_CB, qmi_nas_process_cmss_msim_evt);
  #else
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSS_EVT_CB,    qmi_nas_process_cmss_evt);
  #endif
#ifdef FEATURE_MODEM_STATISTICS
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSTATS_EVT_CB, qmi_nas_process_cmstats_evt    );
#endif
#ifdef FEATURE_DUAL_SIM
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSUBS_EVT_CB,  qmi_nas_process_cmsubs_evt     );
#endif
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSS_CMD_CB,    qmi_nas_process_cmss_cmd       );
#ifndef FEATURE_MMODE_DISABLE_UIM
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_MMGSDI_CMD_CB,  qmi_nas_mmgsdi_process_cmd_rsp );
#endif
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_MMGSDI_EVT_CB,  qmi_nas_mmgsdi_process_evt     );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMPH_CMD_CB,    qmi_nas_process_cmph_cmd       );
  #if defined(FEATURE_HDR)
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_HDR_EVT_CB,     qmi_nas_cmd_handler            );
  #endif
  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_TIMER_EVT_CB,   qmi_nas_process_timer_evt      );
  #endif
  #ifndef REMOVE_QMI_NAS_SET_BUILTIN_PLMN_LIST_V01
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_INTERNAL_CB,    qmi_nas_process_internal_cmd   );
  #endif
#ifdef FEATURE_MODEM_CONFIG_REFRESH 
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_MCFG_REFRESH_EVT_CB, qmi_nas_mcfg_refresh_evt  );
#endif // FEATURE_MODEM_CONFIG_REFRESH
  memset( &qmi_nas_state, 0x00, sizeof(qmi_mmode_svc_info_type) );
  memset( &qmi_nasi_cfg, 0x00, sizeof(qmi_nasi_cfg) );
  qmi_nasi_global.inited = INIT_STATE_NOT_INITIALIZED;
  
#ifdef FEATURE_MODEM_CONFIG_REFRESH
  /*-------------------------------------------------------------------------
      Register with MCFG for NV/EFS refresh event
   -------------------------------------------------------------------------*/

  memset(&mcfg_refresh_reg,0,sizeof(mcfg_refresh_registration_s_type));
  mcfg_refresh_reg.order       = MCFG_REFRESH_ORDER_50;
  mcfg_refresh_reg.slot_mask   = MCFG_REFRESH_INDEX_MASK_ALL;
  mcfg_refresh_reg.sub_mask    = MCFG_REFRESH_INDEX_MASK_ALL;
  mcfg_refresh_reg.cb          = qmi_nas_mcfg_refresh_evt_cb;

  if(mcfg_refresh_register(&mcfg_refresh_reg) == FALSE)
  {
    QM_MSG_ERROR("qmi_nas_init() mcfg_refresh_register failed");
  }
#endif // FEATURE_MODEM_CONFIG_REFRESH
  /*-----------------------------------------------------------------------
    Populate QMI NAS Config
  -----------------------------------------------------------------------*/

  qmi_nasi_cfg.cmd_hdlr_array                = qmi_nasi_cmd_callbacks;
  qmi_nasi_cfg.cmd_num_entries               = NASI_CMD_MAX;

  /* Initialize QMI NAS state */
  qmi_nas_process_init_cback();
  qmi_nas_state.svc_config                   = (void *)&qmi_nasi_cfg;
  qmi_nas_state.service_type                 = QMI_MMODE_SERVICE_NAS;
  qmi_nas_state.uses_raw_msgs                = TRUE;
  
  err = qmi_mmode_svc_qcsi_register(QMI_MMODE_SERVICE_NAS,
                                  qmi_nas_qcsi_svc_connect_cb,
                                  qmi_nas_qcsi_svc_disconnect_cb,
                                  qmi_mmode_qcsi_svc_handle_req_cb,
                                  &qmi_nas_state);

  //register with SAP
  serr = qmi_sap_register(nas_get_service_object_v01(), 
                         NULL, 
                         &qmi_nas_state.sap_client_handle);

  if ( serr != QMI_SAP_NO_ERR || err != QMI_CSI_NO_ERR )
  {
    QM_MSG_ERROR_2("qmi_nas_init() qmi_csi_register/sap_register failed %d", err, serr);
    return;
  }
} /* qmi_nas_init() */

#ifdef FEATURE_MODEM_CONFIG_REFRESH
/*===========================================================================

FUNCTION  QMI_NAS_MCFG_REFRESH_EVT_CB

DESCRIPTION
   This function is the callback to process mcfg refresh ind.
   CB returns TRUE- MCFG will wait for DONE api.
   CB returns FALSE- MCFG will not wait for DONE api
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
boolean qmi_nas_mcfg_refresh_evt_cb
(
  mcfg_refresh_info_s_type *mcfg_refresh_info_ptr
)
{
  mcfg_refresh_info_s_type     *event_info = NULL;
   
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  if(NULL == mcfg_refresh_info_ptr)
  {
    return FALSE;
  }
  
  /*-----------------------------------------------------------------------
     Allocate buffer for NV refresh event
    -----------------------------------------------------------------------*/
  event_info = (mcfg_refresh_info_s_type *) modem_mem_alloc( sizeof( mcfg_refresh_info_s_type ), MODEM_MEM_CLIENT_QMI_MMODE );

  if(NULL == event_info)
  {
    qmi_voice_mem_error();
    return FALSE;
  }
  
  /*-----------------------------------------------------------------------
     Copy the refresh info
    -----------------------------------------------------------------------*/
    (void) memscpy(event_info,
                   sizeof(mcfg_refresh_info_s_type),
                   mcfg_refresh_info_ptr,
                   sizeof(mcfg_refresh_info_s_type));
  
 /*-------------------------------------------------------------------------
      Post a command to QMI_NAS task to handle this event
  -------------------------------------------------------------------------*/
  qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_MCFG_REFRESH_EVT_CB, event_info);

  return TRUE;

}/*qmi_nas_mcfg_refresh_evt_cb*/
#endif // FEATURE_MODEM_CONFIG_REFRESH

/*===========================================================================
  FUNCTION QMI_NAS_MAP_CIOT_LTE_OP_MODE_PREF_QMI_TO_CM()

  DESCRIPTION
    Map  QMI lte op mode pref to cm_ciot_lte_op_mode_e_type

  PARAMETERS
    qmi_val: mode pref value from QMI

  RETURN VALUE
    mode pref value in CM format (bitmask). Return CM_LTE_IOT_OP_MODE_PREF_NONE
    for error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static cm_ciot_lte_op_mode_e_type qmi_nas_map_ciot_lte_op_mode_pref_qmi_to_cm (uint16 qmi_val)
{
  cm_ciot_lte_op_mode_e_type retval = CM_LTE_IOT_OP_MODE_PREF_NONE;
  
  switch( qmi_val )
  {
    case QMI_NAS_LTE_IOT_OP_MODE_PREF_WB:     retval = CM_LTE_IOT_OP_MODE_PREF_WB;         break;
	#ifdef FEATURE_MMODE_M1
    case QMI_NAS_LTE_IOT_OP_MODE_PREF_M1:     retval = CM_LTE_IOT_OP_MODE_PREF_M1;         break;
	#endif
    case QMI_NAS_LTE_IOT_OP_MODE_PREF_NB1:    retval = CM_LTE_IOT_OP_MODE_PREF_NB1;         break;
    case QMI_NAS_LTE_IOT_OP_MODE_PREF_M1_NB1: retval = CM_LTE_IOT_OP_MODE_PREF_M1_NB1;     break;
    case QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_M1:  retval = CM_LTE_IOT_OP_MODE_PREF_WB_M1;      break;
    case QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_NB1:  retval = CM_LTE_IOT_OP_MODE_PREF_WB_NB1;      break;
    case QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_M1_NB1:  retval = CM_LTE_IOT_OP_MODE_PREF_WB_M1_NB1;      break;

    default:
      /*unsupported QMI mode pref value*/
      retval = CM_LTE_IOT_OP_MODE_PREF_NONE;
      break;
  }

  QM_MSG_HIGH_2("QMI CIOT LTE OP mode pref value %d, CM mode pref value %d", qmi_val, retval);
  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_MODE_PREF_QMI_TO_CM()

  DESCRIPTION
    Map uint16 QMI mode pref to cm_mode_pref_e_type

  PARAMETERS
    qmi_val: mode pref value from QMI

  RETURN VALUE
    mode pref value in CM format (bitmask). Return CM_MODE_PREF_NONE
    for error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static cm_mode_pref_e_type qmi_nas_map_mode_pref_qmi_to_cm (uint16 qmi_val)
{
  cm_mode_pref_e_type retval = CM_MODE_PREF_NONE;
  
  #if defined(FEATURE_MMODE_QMI_LTE_ONLY)
  if( qmi_val == QMI_NAS_MODE_PREF_L)
  {
     retval = CM_MODE_PREF_LTE_ONLY;
  }
  #elif defined(FEATURE_MMODE_QMI_GPRS_LTE)
  if( qmi_val == QMI_NAS_MODE_PREF_L)
  {
     retval = CM_MODE_PREF_LTE_ONLY; 
  }
  else if(qmi_val == QMI_NAS_MODE_PREF_G)
  {
     retval = CM_MODE_PREF_GSM_ONLY; 
  }
  else if( qmi_val == QMI_NAS_MODE_PREF_GL)
  {
     retval = CM_MODE_PREF_GSM_LTE; 
  }
  #else
  switch( qmi_val )
  {
    case QMI_NAS_MODE_PREF_C:     retval = CM_MODE_PREF_CDMA_ONLY;         break;
    case QMI_NAS_MODE_PREF_CG:    retval = CM_MODE_PREF_CDMA_GSM;          break;
    case QMI_NAS_MODE_PREF_CGL:   retval = CM_MODE_PREF_CDMA_GSM_LTE;      break;
    case QMI_NAS_MODE_PREF_CGW:   retval = CM_MODE_PREF_CDMA_GW;           break;
    case QMI_NAS_MODE_PREF_CH:    retval = CM_MODE_PREF_CDMA_HDR_ONLY;     break;
    case QMI_NAS_MODE_PREF_CHG:   retval = CM_MODE_PREF_CDMA_HDR_GSM;      break;
    case QMI_NAS_MODE_PREF_CHGW:  retval = CM_MODE_PREF_CDMA_HDR_GW;       break;
    case QMI_NAS_MODE_PREF_CHL:   retval = CM_MODE_PREF_CDMA_HDR_LTE_ONLY; break;
    case QMI_NAS_MODE_PREF_CL:    retval = CM_MODE_PREF_CDMA_LTE_ONLY;     break;
    case QMI_NAS_MODE_PREF_CWL:   retval = CM_MODE_PREF_CDMA_WCDMA_LTE;    break;
    case QMI_NAS_MODE_PREF_G:     retval = CM_MODE_PREF_GSM_ONLY;          break;
    case QMI_NAS_MODE_PREF_GL:    retval = CM_MODE_PREF_GSM_LTE;           break;
    case QMI_NAS_MODE_PREF_GW:    retval = CM_MODE_PREF_GSM_WCDMA_ONLY;    break;
    case QMI_NAS_MODE_PREF_GWL:   retval = CM_MODE_PREF_GWL;               break;
    case QMI_NAS_MODE_PREF_GT:    retval = CM_MODE_PREF_TDS_GSM;           break;
    case QMI_NAS_MODE_PREF_H:     retval = CM_MODE_PREF_HDR_ONLY;          break;
    case QMI_NAS_MODE_PREF_HGL:   retval = CM_MODE_PREF_HDR_GSM_LTE;       break;
    case QMI_NAS_MODE_PREF_HL:    retval = CM_MODE_PREF_HDR_LTE_ONLY;      break;
    case QMI_NAS_MODE_PREF_HWL:   retval = CM_MODE_PREF_HDR_WCDMA_LTE;     break;
    case QMI_NAS_MODE_PREF_L:     retval = CM_MODE_PREF_LTE_ONLY;          break;
    case QMI_NAS_MODE_PREF_T:     retval = CM_MODE_PREF_TDS_ONLY;          break;
    case QMI_NAS_MODE_PREF_TGWL:  retval = CM_MODE_PREF_TDS_GSM_WCDMA_LTE; break;
    case QMI_NAS_MODE_PREF_TGW:   retval = CM_MODE_PREF_TDS_GSM_WCDMA;     break;
    case QMI_NAS_MODE_PREF_W:     retval = CM_MODE_PREF_WCDMA_ONLY;        break;
    case QMI_NAS_MODE_PREF_WL:    retval = CM_MODE_PREF_WCDMA_LTE;         break;
    case QMI_NAS_MODE_PREF_TCHGWL: retval = CM_MODE_PREF_AUTOMATIC;    break;
    case QMI_NAS_MODE_PREF_TL:    retval = CM_MODE_PREF_TDS_LTE;           break;
    case QMI_NAS_MODE_PREF_TGL:   retval = CM_MODE_PREF_TDS_GSM_LTE;       break;
    case QMI_NAS_MODE_PREF_TW:     retval = CM_MODE_PREF_TDS_WCDMA;        break;
    case QMI_NAS_MODE_PREF_TWL:   retval = CM_MODE_PREF_TDS_WCDMA_LTE;     break;
    case QMI_NAS_MODE_PREF_TCHGL: retval = CM_MODE_PREF_CDMA_HDR_GSM_TDS_LTE; break;
    case QMI_NAS_MODE_PREF_TCHGW: retval = CM_MODE_PREF_CDMA_HDR_GW_TDS;      break;
    case QMI_NAS_MODE_PREF_TCGW:  retval = CM_MODE_PREF_CDMA_GW_TDS;          break;
    case QMI_NAS_MODE_PREF_CHGL:  retval = CM_MODE_PREF_CDMA_HDR_GSM_LTE;     break;
    case QMI_NAS_MODE_PREF_CGWL:  retval = CM_MODE_PREF_CDMA_GSM_WCDMA_LTE; break;
    case QMI_NAS_MODE_PREF_CHGWL:
      if(TARGET_SUPPORTS_TDS)
      {
        retval = CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE;
        break;
      }
      else
      {
        retval = CM_MODE_PREF_AUTOMATIC;
        break;
      }

    default:
      /*unsupported QMI mode pref value*/
      retval = CM_MODE_PREF_NONE;
      break;
  }
  #endif

  QM_MSG_HIGH_2("QMI mode pref value %d, CM mode pref value %d", qmi_val, retval);
  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_MODE_PREF_CM_TO_QMI()

  DESCRIPTION
    Map cm_mode_pref_e_type to uint16 QMI mode pref

  PARAMETERS
    cm_val: mode pref value from CM

  RETURN VALUE
    mode pref value in QMI format (bitmask). Return QMI_NAS_MODE_PREF_NONE
    for error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint16 qmi_nas_map_mode_pref_cm_to_qmi (cm_mode_pref_e_type cm_val)
{
  uint16 retval = 0;


  switch( cm_val )
  {
    case CM_MODE_PREF_CDMA_ONLY:         retval = QMI_NAS_MODE_PREF_C;     break;
    case CM_MODE_PREF_CDMA_GSM:          retval = QMI_NAS_MODE_PREF_CG;    break;
    case CM_MODE_PREF_CDMA_GW:           retval = QMI_NAS_MODE_PREF_CGW;   break;
    case CM_MODE_PREF_CDMA_GSM_LTE:      retval = QMI_NAS_MODE_PREF_CGL;   break;
    case CM_MODE_PREF_CDMA_HDR_ONLY:     retval = QMI_NAS_MODE_PREF_CH;    break;
    case CM_MODE_PREF_CDMA_HDR_GSM:      retval = QMI_NAS_MODE_PREF_CHG;   break;
    case CM_MODE_PREF_CDMA_HDR_GW:       retval = QMI_NAS_MODE_PREF_CHGW;  break;
    case CM_MODE_PREF_CDMA_HDR_LTE_ONLY: retval = QMI_NAS_MODE_PREF_CHL;   break;
    case CM_MODE_PREF_CDMA_LTE_ONLY:     retval = QMI_NAS_MODE_PREF_CL;    break;
    case CM_MODE_PREF_CDMA_WCDMA_LTE:    retval = QMI_NAS_MODE_PREF_CWL;   break;
    case CM_MODE_PREF_GSM_ONLY:          retval = QMI_NAS_MODE_PREF_G;     break;
    case CM_MODE_PREF_GSM_LTE:           retval = QMI_NAS_MODE_PREF_GL;    break;
    case CM_MODE_PREF_GSM_WCDMA_ONLY:    retval = QMI_NAS_MODE_PREF_GW;    break;
    case CM_MODE_PREF_GWL:               retval = QMI_NAS_MODE_PREF_GWL;   break;
    case CM_MODE_PREF_HDR_ONLY:          retval = QMI_NAS_MODE_PREF_H;     break;
    case CM_MODE_PREF_HDR_GSM_LTE:       retval = QMI_NAS_MODE_PREF_HGL;   break;
    case CM_MODE_PREF_HDR_LTE_ONLY:      retval = QMI_NAS_MODE_PREF_HL;    break;
    case CM_MODE_PREF_HDR_WCDMA_LTE:     retval = QMI_NAS_MODE_PREF_HWL;   break;
    case CM_MODE_PREF_WCDMA_ONLY:        retval = QMI_NAS_MODE_PREF_W;     break;
    case CM_MODE_PREF_WCDMA_LTE:         retval = QMI_NAS_MODE_PREF_WL;    break;
    case CM_MODE_PREF_LTE_ONLY:          retval = QMI_NAS_MODE_PREF_L;     break;
    case CM_MODE_PREF_TDS_ONLY:          retval = QMI_NAS_MODE_PREF_T;     break;
    case CM_MODE_PREF_TDS_GSM:           retval = QMI_NAS_MODE_PREF_GT;    break;
    case CM_MODE_PREF_TDS_GSM_WCDMA_LTE: retval = QMI_NAS_MODE_PREF_TGWL;  break;
    case CM_MODE_PREF_TDS_GSM_WCDMA:     retval = QMI_NAS_MODE_PREF_TGW;   break;
    case CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE: retval = QMI_NAS_MODE_PREF_CHGWL;  break;
    case CM_MODE_PREF_TDS_LTE:           retval = QMI_NAS_MODE_PREF_TL;    break;
    case CM_MODE_PREF_TDS_GSM_LTE:       retval = QMI_NAS_MODE_PREF_TGL;   break;
    case CM_MODE_PREF_TDS_WCDMA:              retval = QMI_NAS_MODE_PREF_TW;     break;
    case CM_MODE_PREF_TDS_WCDMA_LTE:     retval = QMI_NAS_MODE_PREF_TWL;   break;
    case CM_MODE_PREF_CDMA_HDR_GSM_TDS_LTE: retval = QMI_NAS_MODE_PREF_TCHGL; break;
      case CM_MODE_PREF_CDMA_HDR_GW_TDS:      retval = QMI_NAS_MODE_PREF_TCHGW; break;
      case CM_MODE_PREF_CDMA_GW_TDS:          retval = QMI_NAS_MODE_PREF_TCGW;  break;
    case CM_MODE_PREF_CDMA_HDR_GSM_LTE:   retval = QMI_NAS_MODE_PREF_CHGL;     break;

    case CM_MODE_PREF_ANY_BUT_CDMA_HDR:
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;
    
    case CM_MODE_PREF_ANY_BUT_HDR_TDS:
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      break;
      
    case CM_MODE_PREF_ANY_BUT_LTE_TDS:
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_HDR  ) { retval |= QMI_NAS_MODE_PREF_H;}
      break;
    
    case CM_MODE_PREF_ANY_BUT_TDS:
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_HDR  ) { retval |= QMI_NAS_MODE_PREF_H;}
      break;
    
    case CM_MODE_PREF_ANY_BUT_HDR:
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;
    
    case CM_MODE_PREF_ANY_BUT_LTE:
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_HDR  ) { retval |= QMI_NAS_MODE_PREF_H;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;
    case CM_MODE_PREF_ANY_BUT_HDR_LTE:
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;

    // CM_MODE_PREF_DIGITAL_ONLY means different between LTE and non-LTE targets
    case CM_MODE_PREF_DIGITAL_ONLY:
    case CM_MODE_PREF_AUTOMATIC:
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_HDR  ) { retval |= QMI_NAS_MODE_PREF_H;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;

    default:
      /*unsupported CM Mode Pref value */
      retval = QMI_NAS_MODE_PREF_NONE;
      break;
  }
  
  QM_MSG_HIGH_2("CM mode Pref value %d, QMI mode pref value %d", cm_val, retval);
  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_CIOT_LTE_OP_MODE_PREF_CM_TO_QMI()

  DESCRIPTION
    Map  CM's lte op mode pref to uint16 QMI

  PARAMETERS
    cm_val: ciot lte op mode pref value from CM

  RETURN VALUE
    lte iot mode pref value in QMI format (bitmask). Return QMI_NAS_LTE_IOT_OP_MODE_PREF_NONE
    for error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint16 qmi_nas_map_ciot_lte_op_mode_pref_cm_to_qmi (cm_ciot_lte_op_mode_e_type cm_val)
{
  uint16 retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_NONE;
  
  switch( cm_val )
  {
    case CM_LTE_IOT_OP_MODE_PREF_WB:     retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_WB;         break;
	#ifdef FEATURE_MMODE_M1
    case CM_LTE_IOT_OP_MODE_PREF_M1:     retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_M1;         break;
	#endif
    case CM_LTE_IOT_OP_MODE_PREF_NB1:    retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_NB1;        break;
    case CM_LTE_IOT_OP_MODE_PREF_M1_NB1: retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_M1_NB1;     break;
    case CM_LTE_IOT_OP_MODE_PREF_WB_M1:  retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_M1;      break;
    case CM_LTE_IOT_OP_MODE_PREF_WB_NB1:  retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_NB1;    break;
    case CM_LTE_IOT_OP_MODE_PREF_WB_M1_NB1:  retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_WB_M1_NB1;    break;

    default:
      /*unsupported QMI mode pref value*/
      retval = QMI_NAS_LTE_IOT_OP_MODE_PREF_NONE;
      break;
  }

  QM_MSG_HIGH_2("QMI CIOT LTE OP mode pref value %d, CM mode pref value %d", retval, cm_val);
  return retval;
}

#ifndef FEATURE_MMODE_QMI_LTE_ONLY
/*===========================================================================
  FUNCTION QMI_NAS_MAP_MODE_PREF_NV_TO_QMI()

  DESCRIPTION
    Map nv_mode_enum_type to uint16 QMI mode pref

  PARAMETERS
    nv_val: mode pref value from NV

  RETURN VALUE
    mode pref value in QMI format (bitmask). Return QMI_NAS_MODE_PREF_NONE
    for error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint16 qmi_nas_map_mode_pref_nv_to_qmi (nv_mode_enum_type nv_val)
{
  int    i;
  uint16 retval = 0;

  // DIGITAL_ONLY and AUTOMATIC means different between LTE and non-LTE targets
  #if defined(FEATURE_MMODE_QMI_GPRS_LTE)
  if (nv_val == NV_MODE_DIGITAL_ONLY || nv_val == NV_MODE_AUTOMATIC)
  {
    retval = QMI_NAS_MODE_PREF_GL;
  }
  #else
  if (nv_val == NV_MODE_DIGITAL_ONLY || nv_val == NV_MODE_AUTOMATIC)
  {
    retval = QMI_NAS_MODE_PREF_BIT_ALL;
  }
  else if (nv_val == NV_MODE_DIGITAL_LESS_HDR_ONLY)
  {
    retval = QMI_NAS_MODE_PREF_BIT_ALL & ~QMI_NAS_MODE_PREF_BIT_HDR;
  }
  #endif
  else
  {
    for (i=0; i<QMI_NAS_ARR_SIZE(qmi_nas_allowed_nv_mode_pref); i++)
    {
      if (nv_val == qmi_nas_allowed_nv_mode_pref[i].nv_val)
      {
        retval = qmi_nas_allowed_nv_mode_pref[i].qmi_val;
        break;
      }
    }
  }

  if ( !TARGET_SUPPORTS_GSM   ) { retval &= ~QMI_NAS_MODE_PREF_BIT_GSM;  }
  if ( !TARGET_SUPPORTS_WCDMA ) { retval &= ~QMI_NAS_MODE_PREF_BIT_UMTS; }
  if ( !TARGET_SUPPORTS_CDMA  ) { retval &= ~QMI_NAS_MODE_PREF_BIT_CDMA; }
  if ( !TARGET_SUPPORTS_HDR   ) { retval &= ~QMI_NAS_MODE_PREF_BIT_HDR;  }
  if ( !TARGET_SUPPORTS_LTE   ) { retval &= ~QMI_NAS_MODE_PREF_BIT_LTE;  }

  return retval;
}
#endif
#ifdef FEATURE_DUAL_SIM
/*===========================================================================
   FUNCTION QMI_NAS_MAP_STANDBY_PREF_CM_TO_QMI()

   DESCRIPTION
     Map sys_modem_dual_standby_pref_e_type to uint8 QMI standby_pref

   PARAMETERS
     cm_val: mode pref value from CM

   RETURN VALUE
     mode pref value in QMI format (bitmask). Return QMI_NAS_MODE_PREF_NONE
     for error

   DEPENDENCIES
     None

   SIDE EFFECTS
     None
 ===========================================================================*/
void qmi_nas_map_standby_pref_cm_to_qmi
(
  uint32* qmi_standby_pref,
  sys_modem_dual_standby_pref_e_type cm_standby_pref
)
{
  switch(cm_standby_pref)
  {
    case SYS_MODEM_DS_PREF_SINGLE_STANDBY:
      *qmi_standby_pref = NAS_SINGLE_STANDBY_V01;
      break;

    case SYS_MODEM_DS_PREF_DUAL_STANDBY:
     *qmi_standby_pref = NAS_DUAL_STANDBY_WITH_TUNE_AWAY_V01;
     break;

    case SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY:
      *qmi_standby_pref = NAS_DUAL_STANDBY_WITHOUT_TUNE_AWAY_V01;
      break;

    case SYS_MODEM_DS_PREF_TRIPLE_STANDBY:
      *qmi_standby_pref = NAS_TRIPLE_STANDBY_V01;
      break;

    case SYS_MODEM_DS_PREF_AUTO:
      *qmi_standby_pref = NAS_AUTOMATIC_WITH_TUNE_AWAY_V01;
      break;

    case SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY:
      *qmi_standby_pref = NAS_AUTOMATIC_WITHOUT_TUNE_AWAY_V01;
      break;

    case SYS_MODEM_DS_PREF_NO_CHANGE:
    case SYS_MODEM_DS_PREF_NONE:
    default:
      *qmi_standby_pref = NAS_STANDBY_PREF_ENUM_MIN_ENUM_VAL_V01;
  }

  QM_MSG_HIGH_2("CM standby pref value %d, QMI standby pref value %d",
                cm_standby_pref, *qmi_standby_pref);
}
#endif
/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_SYS_SEL_PREF_IND()

  DESCRIPTION
    Called when the serving system info changes. Causes
    sys sel pref_ind to be sent to all clients

  PARAMETERS
    CM PH event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_sys_sel_pref_ind
(
  qmi_cm_ph_info_s_type  *p_info
)
{
  qmi_nasi_client_state_type *  cl_sp;
  #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
  uint8                         emergency_mode;
  #endif
  uint16                        nasi_mode_pref;

  /*-------------------------------------------------------------------------
    collect information required to generate indication
    - emergency mode and mode preference
    - Band preference
    - prl and roam preference
  -------------------------------------------------------------------------*/
  #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
  if ( p_info->mode_pref == CM_MODE_PREF_EMERGENCY )
  {
    emergency_mode = NASI_MODE_EMERGENCY_MODE_ON;

#ifdef FEATURE_DUAL_SIM
    if ( p_info->asubs_id == SYS_MODEM_AS_ID_2 )
    {
      nasi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref2 );
    }
    else 
#endif
#ifdef FEATURE_TRIPLE_SIM
    if ( p_info->asubs_id == SYS_MODEM_AS_ID_3 )
    {
      nasi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref3 );
    }
    else
#endif
    {
      nasi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref );
    }
  }
  else
  {
    emergency_mode = NASI_MODE_EMERGENCY_MODE_OFF;
  #endif
    nasi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( p_info->mode_pref );
  #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
  }
  #endif


  /*-------------------------------------------------------------------------
    broadcast system selection pref indication to all registered clients
  -------------------------------------------------------------------------*/
  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {

    if ( cl_sp->report_status.reg_sys_sel_pref &&
           #ifdef FEATURE_DUAL_SIM
           cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)p_info->asubs_id
           #else
           cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY
           #endif
         )
    {
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY
      qmi_nasi_sys_sel_pref_ind( cl_sp,
                                  #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
                                   emergency_mode,
                                   #endif
                                   nasi_mode_pref,
                                   (uint64)p_info->band_pref,
                                   #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
                                   (uint16)p_info->prl_pref,
                                   (uint16)p_info->roam_pref,
                                   #else
                                   (uint16)CM_PRL_PREF_NO_CHANGE,
                                   (uint16)CM_ROAM_PREF_NO_CHANGE,
                                   #endif
                                   p_info->lte_band_pref,
                                   #ifdef FEATURE_TDSCDMA
                                   (uint64)p_info->tds_band_pref,
                                   #else
                                   CM_BAND_PREF_TDS_ANY,
                                   #endif
                                   (uint8)p_info->network_sel_mode_pref,
                                   (uint32)p_info->srv_domain_pref,
                                   (uint32)p_info->acq_order_pref,
                                   p_info->plmn,
                                   p_info->acq_pri_order_pref,
                                   p_info->ue_usage_setting,
                                   #if !defined(FEATURE_MMODE_QMI_GPRS_LTE)
                                   p_info->csg_id,
                                   p_info->csg_rat,
                                   #else
                                   SYS_CSG_ID_INVALID,
                                   SYS_RAT_NONE,
                                   #endif
                                   p_info->voice_domain_pref,
                                   p_info->ciot_lte_pref.lte_op_mode_pref,
                                   p_info->ciot_lte_pref.lte_m1_band_pref,
                                   p_info->ciot_lte_pref.lte_nb1_band_pref
                                  );
      #else
      {
       cm_acq_pri_order_pref_s_type      acq_pri_order_pref = {0};

      qmi_nasi_sys_sel_pref_ind( cl_sp,
                                   #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
                                   emergency_mode,
                                   #endif
                                   nasi_mode_pref,
                                   (uint64)CM_BAND_PREF_NO_CHANGE,
                                   (uint16)CM_PRL_PREF_NO_CHANGE,
                                   (uint16)CM_ROAM_PREF_NO_CHANGE,
                                   p_info->lte_band_pref,
                                   (uint64)CM_BAND_PREF_NO_CHANGE,
                                   (uint8)p_info->network_sel_mode_pref,
                                   (uint32)p_info->srv_domain_pref,
                                   (uint32)CM_GW_ACQ_ORDER_PREF_NO_CHANGE ,
                                   p_info->plmn,
                                   acq_pri_order_pref,
                                   p_info->ue_usage_setting,
                                   SYS_CSG_ID_INVALID ,
                                   SYS_RAT_NONE ,
                                   p_info->voice_domain_pref,
                                   p_info->ciot_lte_pref.lte_op_mode_pref,
                                   p_info->ciot_lte_pref.lte_m1_band_pref,
                                    p_info->ciot_lte_pref.lte_nb1_band_pref
                                  );
      }
      #endif
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }
} /* qmi_nas_generate_sys_sel_pref_ind() */
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_CURRENT_NAM_IND()

  DESCRIPTION
    Called when the curent name changes.
    Causes current_nam_ind to be sent to all clients

  PARAMETERS
    CM PH event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_current_nam_ind ( qmi_cm_ph_info_s_type  *p_info )
{
  qmi_nasi_client_state_type *  cl_sp;
  int                           client;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    broadcast current nam indication to all registered clients
  -------------------------------------------------------------------------*/
  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {
    if( cl_sp->report_status.reg_current_nam )
    {
      qmi_nasi_current_nam_ind( cl_sp, (uint8) p_info->curr_nam );
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }
} /* qmi_nas_generate_current_nam_ind() */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_DDTM_IND()

  DESCRIPTION
    Called when the ddtm status changes.
    Causes ddtm_ind to be sent to all clients

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_ddtm_ind
(
  qmi_cm_ph_info_s_type  *p_info
)
{
  qmi_nasi_client_state_type *  cl_sp;
  int                           client;

  /*-------------------------------------------------------------------------
    broadcast DDTM indication to all registered clients
  -------------------------------------------------------------------------*/
  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {
    if(cl_sp->report_status.reg_ddtm_events )
    {
        qmi_nasi_ddtm_ind(
            cl_sp,
              p_info->cur_ddtm_status,
              p_info->ddtm_pref,
              p_info->ddtm_act_mask,
              (uint8)p_info->ddtm_num_srv_opt,
              p_info->ddtm_srv_opt_list);
      }

     cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
   }
} /* qmi_nas_generate_ddtm_ind() */
#endif
#ifdef FEATURE_DUAL_SIM
/*===========================================================================
  FUNCTION QMI_NAS_GEN_DUAL_STANDBY_PREF_IND()

  DESCRIPTION
    generate QMI_NAS_DUAL_STANDBY_PREF_IND by comparing new CM PH event and
    last CM PH event cache

  PARAMETERS
    pointer to new CM PH event
===========================================================================*/
void qmi_nas_gen_dual_standby_pref_ind( qmi_cm_ph_info_s_type *p_info )
{
  qmi_cm_ph_info_s_type                     *p_old_info;
  boolean                               info_changed = FALSE;
  nas_dual_standby_pref_ind_msg_v01     *ind_msg;
  dsm_item_type                         *ind;
  int                                   client;
  qmi_nasi_client_state_type            *cl_sp;

  ind_msg = (nas_dual_standby_pref_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_dual_standby_pref_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if(ind_msg != NULL)
  {
  memset( ind_msg, 0x00, sizeof(nas_dual_standby_pref_ind_msg_v01) );

  switch ( p_info->asubs_id )
  {
#ifdef FEATURE_TRIPLE_SIM
    case SYS_MODEM_AS_ID_3:
      p_old_info = &qmi_nasi_global.cm_ph_info3;
      break;
#endif
#ifdef FEATURE_DUAL_SIM
    case SYS_MODEM_AS_ID_2:  // TODO: need to revisit this logic
      p_old_info = &qmi_nasi_global.cm_ph_info2;
      break;
#endif
    case SYS_MODEM_AS_ID_1:
      p_old_info = &qmi_nasi_global.cm_ph_info;
      break;
    default:
      p_old_info = NULL;
      break;
  }

  // check if we need to send indication
  if (   p_old_info != NULL &&
       ( p_old_info->standby_pref      != p_info->standby_pref  ||
         p_old_info->active_subs       != p_info->active_subs   ||
         p_old_info->priority_subs     != p_info->priority_subs ||
         p_old_info->default_data_subs != p_info->default_data_subs ||
         p_old_info->default_voice_subs != p_info->default_voice_subs )
       )
  {
    info_changed = TRUE;
  }

  if ( info_changed )
  {
    // fill out the message
    qmi_nas_map_standby_pref_cm_to_qmi((uint32*)&ind_msg->standby_pref.standby_pref, p_info->standby_pref );
    ind_msg->standby_pref.priority_subs      = (nas_subs_type_enum_v01)p_info->priority_subs;
    ind_msg->standby_pref.active_subs        = (nas_subs_type_enum_v01)p_info->active_subs;
    ind_msg->standby_pref.default_data_subs  = (nas_subs_type_enum_v01)p_info->default_data_subs;
    ind_msg->default_voice_subs              = (nas_subs_type_enum_v01)p_info->default_voice_subs;
    ind_msg->standby_pref_valid              = TRUE;
    ind_msg->default_voice_subs_valid        = TRUE;

    ind_msg->active_subs_mask_valid = TRUE;
    if ( p_info->standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF )
    {
      ind_msg->active_subs_mask = 0;
    }
    else if ( p_info->standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY )
    {
#ifdef FEATURE_TRIPLE_SIM
      if ( p_info->active_subs == SYS_MODEM_AS_ID_3 )
      {
        ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
      } 
      else 
#endif
      if ( p_info->active_subs == SYS_MODEM_AS_ID_2 )
      {
        ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
      }
      else
      {
        ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      }
    }
    else if ( p_info->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY ||
              p_info->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY )
    {
      ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      ind_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( p_info->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY ||
              p_info->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY )
    {
      ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      ind_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
      ind_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
    }
#endif
    else
    {
      ind_msg->active_subs_mask_valid = FALSE;
    }

    // then send the message
    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {

      if ( cl_sp->report_status.report_dual_standby_pref_ind ) // need to send all clients regardless they are bound to primary or secondary
      {
        // TODO: dwbeacon: send indication to primary subs for asubs_id 1 and secondary subs for asubs_id 2

        ind = NULL;                                                                         // Important!  When multiple encode calls may be made.
        if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_INDICATION,
                                           (uint16_t) QMI_NAS_DUAL_STANDBY_PREF_IND_MSG_V01,
                                           (void *) ind_msg,
                                           (uint32_t) sizeof( nas_dual_standby_pref_ind_msg_v01 ),
                                           &ind ) )
        {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_DUAL_STANDBY_PREF_IND, ind );
        }
      }
      else
      {
        if( cl_sp != NULL )
        {
          QM_MSG_HIGH_3("not sending DUAL_STANDBY_PREF_IND for client %p %d %d", 
            cl_sp->clnt, cl_sp->report_status.bound_subs, cl_sp->report_status.report_dual_standby_pref_ind);
        }
        else
        {
          //QM_MSG_ERROR("not sending DUAL_STANDBY_PREF_IND cl_sp is NULL");
        }
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
  else
  {
    QM_MSG_HIGH("no effective change in dual standby pref");
  }
}
  else
  {
    qmi_voice_mem_error();
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#endif
/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_REG_ATTACH_RESP()

  DESCRIPTION
    Called when error_cb() supplied in cm_ph functions are called
    by CM. Sends response to control point for the correspoding
    Register, Attach and other Ph cmd related requests.

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_reg_attach_resp
(
  void *               user_data,
  cm_ph_cmd_err_e_type ph_cmd_err
)
{
  dsm_item_type *        response = NULL;
  qmi_mmode_qcsi_transaction_type *     cmd_buf_p;
  qmi_error_e_type       errval;
  qmi_result_e_type      result;
  boolean                retval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) user_data;

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
  {
    return;
  }
  else if(cmd_buf_p == NULL)
  {
    return;
  }

  /*-------------------------------------------------------------------------
    Send SUCCESS or FAILURE response to control point based on ph_cmd_err

    SUCCESS => For all phone related operations, the control point must not
    assume SUCCESS here, only with the corresponding state changes in inds
    sent after this can success be assumed. E.g. CM register or attach has
    been initiated, the actual result will be conveyed through serving system
    indication.

    FAILURE => There was an error. E.g register or attach action failed
  -------------------------------------------------------------------------*/
  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;

      /* For REGISTER & ATTACH */
    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE;
      break;

      /* For Register */
    case CM_PH_CMD_ERR_PLMN_P:
      errval = QMI_ERR_NO_NETWORK_FOUND;
      break;

    case CM_PH_CMD_ERR_SYS_SEL_PREF_S:
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
      break;

      /* For SET_SYS_SEL_PREF */
    case CM_PH_CMD_ERR_API_NOT_SUPPORTED_S:
    case CM_PH_CMD_ERR_PS_LOCAL_DETACH_NOT_ALLOWED_S:
      errval = QMI_ERR_INVALID_OPERATION;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);

  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
    /*Send Network Scan response*/
  }
} /* qmi_nas_generate_reg_attach_err_resp() */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_NET_SCAN_ERR_RESP()

  DESCRIPTION
    Called when error_cb() supplied in cm_ph_cmd_get_networks() is called
    by CM. Sends error response to control point if error is reported by CM

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : Error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_net_scan_err_resp
(
  void *               user_data,
  cm_ph_cmd_err_e_type ph_cmd_err
)
{
  dsm_item_type      *response;
  qmi_mmode_qcsi_transaction_type   *cmd_buf_p;
  qmi_error_e_type    errval;
  qmi_result_e_type   result;
  boolean             retval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    If no error reported, then Don't send any response now. Response will be
    sent when corresponding CM event(AVAILABLE_NETWROKS_CONF) occurs
  -------------------------------------------------------------------------*/
  if (ph_cmd_err == CM_PH_CMD_ERR_NOERR)
  {
    return;
  }

  /*-------------------------------------------------------------------------
    Return response with appropriate error code
  -------------------------------------------------------------------------*/
  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NET_TYPE_P:
      errval = QMI_ERR_INVALID_OPERATION;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = QMI_RESULT_FAILURE;
  qmi_nasi_global.net_scan_started = FALSE;

  /*-------------------------------------------------------------------------
    Complete pending network_scan transaction
  -------------------------------------------------------------------------*/
  while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      continue;
    }
    response = NULL;
    retval = qmi_svc_put_result_tlv(&response, result, errval);
    if(FALSE == retval)
    {
      dsm_free_packet(&response);
      qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
      continue;
    }
    qmi_nasi_send_response( cmd_buf_p, response);
     /*Send Network Scan response*/
  }
} /* qmi_nas_generate_net_scan_err_resp() */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_NET_SCAN_RESP_EXT()

  DESCRIPTION
    Used to send the network scan response to the control point when CM calls
    qmi_nas_network_scan_cb() with async response

  PARAMETERS
    available_networks : List of networks resulting from the network scan
    available_networks_list_cnf: Scan result

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_net_scan_resp_ext
(
  sys_found_plmn_list_u_type *available_networks,
  sys_plmn_list_status_e_type    available_networks_list_cnf,
  cm_network_list_type_e_type list_type
)
{
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  qmi_error_type_v01       errval = QMI_ERR_NONE_V01;
  boolean gen_resp_now = FALSE;
  qmi_nas_mmgsdi_session_e_type qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_plmn_id_list_type      plmn_id_list;
  #ifndef FEATURE_MMODE_DISABLE_UIM
  struct qmi_nasi_mmgsdi_client_data_s *callback_data;
  #else
  mmgsdi_session_get_operator_name_info_type *operator_name_info_ptr=NULL;
  mmgsdi_session_id_type session_id=(mmgsdi_session_id_type)-1;
  #endif
  uint32 sys_plmn_list_index;  
  mmgsdi_eons_ignore_disp_cond_enum_type ignore_disp = MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND;

  if(list_type != CM_NETWORK_LIST_CELL_SEARCH)
  {
    QM_MSG_HIGH_3("generate_net_scan resp/ind(list_cnf=%d, length=%d,incremental status=%d)",
                 available_networks_list_cnf, available_networks->plmn_list.length,0 );
  }
  else
  {
    QM_MSG_HIGH_1("generate_net_scan resp/ind(list_cnf=%d)", available_networks_list_cnf);
  }

  #ifdef FEATURE_DUAL_SIM
  if ( qmi_nasi_global.net_scan_asubs_id == SYS_MODEM_AS_ID_2 )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_SEC_SESSION;
  }
  #endif
  #ifdef FEATURE_TRIPLE_SIM
  else if ( qmi_nasi_global.net_scan_asubs_id == SYS_MODEM_AS_ID_3 )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_TER_SESSION;
  }
  #endif


  plmn_id_list.num_of_plmn_ids = MIN( NAS_3GPP_NETWORK_INFO_LIST_MAX_V01, available_networks->plmn_list.length);


  if( list_type != CM_NETWORK_LIST_CELL_SEARCH &&
      plmn_id_list.num_of_plmn_ids > 0 && 
     ( available_networks_list_cnf == SYS_PLMN_LIST_SUCCESS 
     #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
     ||  ( ( available_networks_list_cnf == SYS_PLMN_LIST_PARTIAL 
               || available_networks_list_cnf == SYS_PLMN_LIST_AS_ABORT ) 
             &&   qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_INPROGRESS ) 
     #endif
      )
    )
  {
    mmgsdi_plmn_id_type plmn_list[NAS_3GPP_NETWORK_INFO_LIST_MAX_V01];

   #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
    if( qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_INPROGRESS)
    {
      QM_MSG_HIGH_1("net_list_cnf %d", available_networks_list_cnf);
      if(available_networks_list_cnf == SYS_PLMN_LIST_SUCCESS)
      {
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_DONE;
        
      }
      else if( available_networks_list_cnf == SYS_PLMN_LIST_AS_ABORT )
      {
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_AS_ABORT;       
      }
    }
    #endif
              
    // Put plmn list into mmgsdi structure for get_operator_name call
    for(sys_plmn_list_index=0; sys_plmn_list_index < plmn_id_list.num_of_plmn_ids; sys_plmn_list_index++)
    {
      memscpy( &plmn_list[sys_plmn_list_index].plmn_id_val, MMGSDI_PLMN_ID_SIZE * sizeof(uint8), &available_networks->plmn_list.info[sys_plmn_list_index].plmn.identity, MMGSDI_PLMN_ID_SIZE * sizeof(uint8) );
#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      if ( qm_efs_csg_supported() )
      {
      plmn_list[sys_plmn_list_index].csg_id = available_networks->plmn_list.info[sys_plmn_list_index].csg_info.csg_id;
      }
      else
      {
        plmn_list[sys_plmn_list_index].csg_id = SYS_CSG_ID_INVALID;
      }
#endif
#else 
        plmn_list[sys_plmn_list_index].csg_id = SYS_CSG_ID_INVALID;
#endif
      plmn_list[sys_plmn_list_index].rat = qmi_nas_rat_cm_scan_to_mmgsdi( available_networks->plmn_list.info[sys_plmn_list_index].rat );
    }
    plmn_id_list.plmn_list_ptr = plmn_list;

    #ifndef FEATURE_MMODE_DISABLE_UIM
    callback_data = (struct qmi_nasi_mmgsdi_client_data_s*)modem_mem_alloc(sizeof(struct qmi_nasi_mmgsdi_client_data_s), MODEM_MEM_CLIENT_QMI_MMODE);
    if( callback_data != NULL )
    {
      callback_data->cmd_buf_ptr = (void *)modem_mem_alloc(sizeof(sys_detailed_plmn_list_s_type), MODEM_MEM_CLIENT_QMI_MMODE);

      if( callback_data->cmd_buf_ptr != NULL )
      {
        memscpy(callback_data->cmd_buf_ptr, sizeof(sys_detailed_plmn_list_s_type), 
                      &available_networks->plmn_list, sizeof(sys_detailed_plmn_list_s_type));
      }
      callback_data->reason      = NAS_CMD_PERFORM_NETWORK_SCAN;

      if( MMGSDI_SUCCESS != mmgsdi_session_get_operator_name_ext ( qmi_nasi_global.mmgsdi->session_id[qmi_session],
                                                              plmn_id_list,
                                                                   ignore_disp,
                                                              qmi_nas_mmgsdi_cmd_rsp_cb,
                                                              (uint32) callback_data ) )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_HIGH("network_scan: get_operator_name failed");
        gen_resp_now = TRUE;
        if( callback_data->cmd_buf_ptr != NULL )
        {
          modem_mem_free( callback_data->cmd_buf_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
        }
        modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
      }
    }
    else
    {
      qmi_voice_mem_error();
      errval = QMI_ERR_INTERNAL_V01;
      gen_resp_now = TRUE;
    }
    #else
    /*Allocate memory for output param*/
    operator_name_info_ptr=(mmgsdi_session_get_operator_name_info_type*)modem_mem_alloc(sizeof(mmgsdi_session_get_operator_name_info_type), MODEM_MEM_CLIENT_QMI_MMODE);
    if(operator_name_info_ptr == NULL)
    {
       qmi_voice_mem_error();
       return;
    }
    memset(operator_name_info_ptr, 0, sizeof(mmgsdi_session_get_operator_name_info_type));
    /*Allocate memory for PLMN List*/
    operator_name_info_ptr->plmn_info_ptr=(mmgsdi_plmn_info_static_type*)modem_mem_alloc((plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)), MODEM_MEM_CLIENT_QMI_MMODE);

    if(operator_name_info_ptr->plmn_info_ptr == NULL)
    {
       qmi_voice_mem_error();
       modem_mem_free( operator_name_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
       return;
    }
    memset(operator_name_info_ptr->plmn_info_ptr, 0, (plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)));
    if( (cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id)!= CM_MMGSDI_SUCCESS) ||
        ( MMGSDI_SUCCESS != mmgsdi_session_get_operator_name_ext_sync( session_id,
                                                                      plmn_id_list,
                                                                      ignore_disp,
                                                                      operator_name_info_ptr) ))
    {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_HIGH("network_scan: get_operator_name failed");
        gen_resp_now = TRUE;
        modem_mem_free( operator_name_info_ptr->plmn_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
        modem_mem_free( operator_name_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    else
    {
      /*Process name info*/
      qmi_nasi_generate_perform_network_scan_resp(&available_networks->plmn_list,operator_name_info_ptr);
      modem_mem_free( operator_name_info_ptr->plmn_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
      modem_mem_free( operator_name_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    #endif
  }
  else
  {
    gen_resp_now = TRUE;
  }

  if( gen_resp_now )
  {
    #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
    if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
    {
      nas_scan_status_enum_v01 scan_status = NAS_SCAN_STATUS_ABORT_V01;

      /*Wait for next report insted of sending error indication in case if incremental scan is still going on*/
      if(available_networks_list_cnf == SYS_PLMN_LIST_PARTIAL )
      {
        QM_MSG_HIGH("Wait for next scan result");
        return;
      }
      if ( errval == QMI_ERR_NONE_V01 )
      {
        switch( available_networks_list_cnf )
        {
          case SYS_PLMN_LIST_AS_ABORT:
            scan_status = NAS_SCAN_STATUS_ABORT_V01;
            break;
          case SYS_PLMN_LIST_REJ_IN_RLF:
            scan_status = NAS_SCAN_STATUS_REJ_IN_RLF_V01;
            break;
          default:
            break;
        }
      } // End if QMI_ERR_NONE_V01
      qmi_nasi_generate_perform_incremental_network_scan_err_ind(scan_status);

    } // !QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE
    else
    #endif //REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
    if(list_type == CM_NETWORK_LIST_CELL_SEARCH &&
        (available_networks_list_cnf == SYS_PLMN_LIST_PARTIAL || available_networks_list_cnf == SYS_PLMN_LIST_SUCCESS))
    {
      qmi_nasi_generate_perform_network_scan_resp_cell_search( available_networks, available_networks_list_cnf);
    }
    else
    {
      qmi_mmode_qcsi_transaction_type      *cmd_buf_p = NULL;
      nas_perform_network_scan_resp_msg_v01 *rsp_msg   = NULL;
      dsm_item_type *        response   = NULL;

      if( available_networks_list_cnf == SYS_PLMN_LIST_PARTIAL ) 
      {
        QM_MSG_HIGH( "Ignoring partial results!!!");
        return;
      }

      // Clear pending network scan global var
      qmi_nasi_global.net_scan_started = FALSE;

      rsp_msg = (nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
      if( rsp_msg == NULL)
      {
        qmi_voice_mem_error();
        errval = QMI_ERR_NO_MEMORY_V01;
      }

      while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
      {
        if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
        {
          continue;
        }

        if( errval != QMI_ERR_NO_MEMORY_V01 )
        {
          memset(rsp_msg, 0, sizeof(nas_perform_network_scan_resp_msg_v01));

          // Populate TLV 0x02 (Mandatory error code)
          rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;
          rsp_msg->resp.error  = errval;

          if ( errval == QMI_ERR_NONE_V01 )
          {
            if(list_type != CM_NETWORK_LIST_CELL_SEARCH)
            {  
              rsp_msg->nas_3gpp_network_info_len = available_networks->plmn_list.length;

              // TLV 0x10 will be available at all times. including for num_instances = 0
              // (Gobi backward compatibility)
              rsp_msg->nas_3gpp_network_info_valid = TRUE;
            }

            rsp_msg->scan_result_valid = TRUE;
            switch( available_networks_list_cnf )
            {
              case SYS_PLMN_LIST_SUCCESS:
                rsp_msg->scan_result = NAS_SCAN_SUCCESS_V01;
                break;
  
              case SYS_PLMN_LIST_AS_ABORT:
                rsp_msg->nas_3gpp_network_info_len = 0;
                rsp_msg->scan_result = NAS_SCAN_AS_ABORT_V01;
                break;
 
              case SYS_PLMN_LIST_REJ_IN_RLF:
                rsp_msg->nas_3gpp_network_info_len = 0;
                rsp_msg->scan_result = NAS_SCAN_REJ_IN_RLF_V01;
                break;
 
              default:
                rsp_msg->scan_result_valid = FALSE;
                break;
            }
          }

          response = NULL;

          if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_RESPONSE,
                                             (uint16_t)cmd_buf_p->msg_id,
                                             (void *) rsp_msg,
                                             (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
                                             &response
                                           ) )
          {
              qmi_nasi_send_response( cmd_buf_p, response);
          }
          else
          {
            dsm_free_packet(&response);
            qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
          }
        } // End if
      }// end while (cmd buf queue is empty)

      if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    }
  }
#endif /* #if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */ 
} /* qmi_nas_generate_network_scan_resp_ext */
#ifdef FEATURE_DUAL_SIM
/*===========================================================================
  FUNCTION QMI_NAS_SET_DUAL_STANDBY_PREF_RESP()

  DESCRIPTION
    Send response for SET_DUAL_STANDBY_PREF_REQ

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_dual_standby_pref_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_dual_standby_pref_resp_msg_v01 *resp_msg;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf )
  {
    /*Null cmd_buf ptr*/
    return;
  }

  switch (err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

    case CM_PH_CMD_ERR_NET_TYPE_P:
      errval = QMI_ERR_INVALID_OPERATION_V01;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

    case CM_PH_CMD_ERR_DDS_REJECT_NETWORK_NOT_ALLOWED:
      errval = QMI_ERR_OP_NETWORK_UNSUPPORTED_V01;
      break;

    default:
      errval = QMI_ERR_INTERNAL_V01;
      break;
  }
  resp_msg = (nas_set_dual_standby_pref_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_dual_standby_pref_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_dual_standby_pref_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)p_cmd_buf->msg_id,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_dual_standby_pref_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_HIGH("QMI_NAS_SET_DUAL_STANDBY_PREF_RESP send failed");
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_set_dual_standby_pref_resp() */
#endif
/*===========================================================================
  FUNCTION QMI_NAS_SET_PLMN_BLOCKING_RESP()

  DESCRIPTION
    Send response for DETACH_LTE, BLOCK_LTE_PLMN, UNBLOCK_LTE_PLMN and
    RESET_LTE_PLMN_BLOCKING

  PARAMETERS
    p_cmd_buf   : user data
    err         : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_plmn_blocking_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *        response = NULL;
  qmi_error_e_type       errval;
  qmi_result_e_type      result;
  boolean                retval;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf )
  {
    /*Null cmd_buf ptr*/
    return;
  }

  errval = ( err == CM_PH_CMD_ERR_NOERR ) ? QMI_ERR_NONE : QMI_ERR_INTERNAL;

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_HIGH("QMI NAS PLMN Blocking Response send failed");
  }
} /* qmi_nas_set_plmn_blocking_resp() */
#ifndef FEATURE_MMODE_QMI_LTE_ONLY
/*===========================================================================
  FUNCTION QMI_NAS_SET_HPLMN_IRAT_SEARCH_TIMER_RESP()

  DESCRIPTION
    Send response for HPLMN_IRAT_SEARCH_TIMER

  PARAMETERS
    p_cmd_buf   : user data
    err         : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_hplmn_irat_search_timer_resp(qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type          errval;
  qmi_result_e_type         result;
  boolean                   retval;
  qmi_mmode_qcsi_transaction_type          *cmd_buf_p;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) p_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    return;
  }

  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
  }
}
#endif
#ifndef FEATURE_MMODE_DISABLE_UIM

#if defined(FEATURE_MMGSDI_SESSION_LIB)
/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_MMGSDI_OPERATION_COMPLETE()

  DESCRIPTION
    Callback function called by mmgsdi to return response

  PARAMETERS
    status  : return status
    cnf     : type of cnf response
    cnf_ptr : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_mmgsdi_operation_complete
(
  mmgsdi_cnf_enum_type    cnf_type,
  mmgsdi_cnf_type        *cnf_data
)
{
  qmi_mmode_qcsi_transaction_type        *cmd_buf_p;
  qmi_nasi_cmd_val_e_type  cmd;

  if (cnf_data == NULL)
  {
    return;
  }

  switch (cnf_type)
  {
    case MMGSDI_READ_CNF:

      cmd_buf_p = (qmi_mmode_qcsi_transaction_type *)cnf_data->read_cnf.response_header.client_data;

      if (cmd_buf_p == NULL)
      {
        return;
      }
      cmd = (qmi_nasi_cmd_val_e_type)cmd_buf_p->msg_id;

      QM_MSG_MED_1("MMGSDI READ CNF, cmd:%d", cmd);

      switch (cmd)
      {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
#ifndef REMOVE_QMI_NAS_GET_PREFERRED_NETWORKS_V01
        case NASI_CMD_VAL_GET_PREFERRED_NETWORKS:
        #ifndef FEATURE_MMODE_DISABLE_UIM
          qmi_nasi_generate_get_preferred_nw_resp( &cnf_data->read_cnf );
        #endif
          break;
#endif
#ifndef REMOVE_QMI_NAS_GET_FORBIDDEN_NETWORKS_V01
        case NASI_CMD_VAL_GET_FORBIDDEN_NETWORKS:
          qmi_nasi_generate_get_forbidden_nw_resp( &cnf_data->read_cnf );
          break;
#endif
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
        default:
          QM_MSG_ERROR_1("Received unsolicited read confirmation for command %d", (int)cmd);
          break;
      }
      break;

    case MMGSDI_WRITE_CNF:

      cmd_buf_p = (qmi_mmode_qcsi_transaction_type *)cnf_data->write_cnf.response_header.client_data;

      if (cmd_buf_p == NULL)
      {
        return;
      }
      cmd = (qmi_nasi_cmd_val_e_type)cmd_buf_p->msg_id;

      switch (cmd)
      {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
#ifndef REMOVE_QMI_NAS_SET_PREFERRED_NETWORKS_V01
        case NASI_CMD_VAL_SET_PREFERRED_NETWORKS:
          qmi_nasi_generate_set_preferred_nw_resp( &cnf_data->write_cnf );
          break;
#endif
#ifndef REMOVE_QMI_NAS_SET_FORBIDDEN_NETWORKS_V01
        case NASI_CMD_VAL_SET_FORBIDDEN_NETWORKS:
          qmi_nasi_generate_set_forbidden_nw_resp( &cnf_data->write_cnf );
          break;
#endif
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
        default:
          QM_MSG_ERROR_1("Received unsolicited write confirmation for command %d", (int)cmd);
          break;
      }
      break;

    case MMGSDI_GET_FILE_ATTR_CNF:
      switch (cnf_data->get_file_attr_cnf.access.file.file_enum)
      {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
        case MMGSDI_GSM_PLMNWACT:
        case MMGSDI_USIM_PLMNWACT:
          if ( (cnf_data->response_header.mmgsdi_status ==
                  MMGSDI_SUCCESS) &&
               (cnf_data->get_file_attr_cnf.file_attrib.file_size > 0) )
          {
            qmi_nasi_global.mmgsdi_ef_info.plmn_wact =
              QMI_NASI_MMGSDI_PLMN_EF_FOUND;
          }
          else
          {
            qmi_nasi_global.mmgsdi_ef_info.plmn_wact =
              QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
          }
          break;

        case MMGSDI_GSM_OPLMNWACT:
        case MMGSDI_USIM_OPLMNWACT:
          if ( (cnf_data->response_header.mmgsdi_status ==
                  MMGSDI_SUCCESS) &&
               (cnf_data->get_file_attr_cnf.file_attrib.file_size > 0) )
          {
            qmi_nasi_global.mmgsdi_ef_info.oplmn_wact =
              QMI_NASI_MMGSDI_PLMN_EF_FOUND;
          }
          else
          {
            qmi_nasi_global.mmgsdi_ef_info.oplmn_wact =
              QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
          }
          break;

        case MMGSDI_GSM_PLMN:
          if ( (cnf_data->response_header.mmgsdi_status ==
                  MMGSDI_SUCCESS) &&
               (cnf_data->get_file_attr_cnf.file_attrib.file_size > 0) )
          {
            qmi_nasi_global.mmgsdi_ef_info.plmn =
              QMI_NASI_MMGSDI_PLMN_EF_FOUND;
          }
          else
          {
            qmi_nasi_global.mmgsdi_ef_info.plmn =
              QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
          }
          break;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
        default:
          QM_MSG_ERROR("Received unsolicited GET_FILE_ATTR confirmation");
          break;
      }
      break;

    default:
      QM_MSG_ERROR_1("Received unsolicited confirmation %d", (int)cnf_type);
      break;
  }
} /* qmi_nas_process_mmgsdi_operation_complete */

#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */


/*===========================================================================
  FUNCTION qmi_nas_process_mmgsdi_get_operator_name()

  DESCRIPTION
    Process information from mmgsdi_get_operator_name

  PARAMETERS
    p_nas: pointer to nas structure in command queue item

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_mmgsdi_get_operator_name (
  const mmgsdi_cnf_type        *cnf_data
)
{
  struct qmi_nasi_mmgsdi_client_data_s *callback_data;
  enum qmi_nasi_calling_cmd             cmd;

  if (cnf_data == NULL)
  {
    return;
  }

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *)cnf_data->session_get_operator_name_cnf.response_header.client_data;

  if (callback_data == NULL)
  {
    return;
  }
  cmd = callback_data->reason;

  switch (cmd)
  {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
    case NAS_CMD_PERFORM_NETWORK_SCAN:
      #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
      if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
      {
        qmi_nasi_generate_perform_incremental_network_scan_ind( &cnf_data->session_get_operator_name_cnf );
      }
      else
      #endif
      {
        #ifndef FEATURE_MMODE_DISABLE_UIM
        qmi_nasi_generate_perform_network_scan_resp( &cnf_data->session_get_operator_name_cnf );
        #endif
      }
      break;
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    case NAS_CMD_GET_PLMN_NAME:
      qmi_nasi_generate_get_plmn_name_resp( &cnf_data->session_get_operator_name_cnf );
      break;
    #endif
    case NAS_CMD_GET_HOME_NETWORK:
      qmi_nasi_generate_get_home_network_resp( &cnf_data->session_get_operator_name_cnf );
      break;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
    default:
      ERR( "Received unsolicited read confirmation for command %d", (int)cmd, 0, 0 );
      break;
  }
} /* qmi_nas_process_mmgsdi_get_operator_name */

/*===========================================================================
  FUNCTION qmi_nas_process_mmgsdi_get_se13_plmn_names()

  DESCRIPTION
    Process information from mmgsdi_get_se13_plmn_names

  PARAMETERS
    p_nas: pointer to nas structure in command queue item

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_mmgsdi_get_se13_plmn_names (
  const mmgsdi_cnf_type        *cnf_data
)
{
  struct qmi_nasi_mmgsdi_client_data_s *callback_data;
  enum qmi_nasi_calling_cmd             cmd;

  if (cnf_data != NULL)
  {
    callback_data = (struct qmi_nasi_mmgsdi_client_data_s *)cnf_data->get_se13_plmn_names_cnf.response_header.client_data;

    if (callback_data != NULL)
    {
      cmd = callback_data->reason;

      switch (cmd)
      {
        case NAS_CMD_GET_PLMN_NAME:
          qmi_nasi_generate_get_se13_plmn_name_resp( &cnf_data->get_se13_plmn_names_cnf );
          break;

        default:
          QM_MSG_ERROR_1("Received unsolicited read confirmation for command %d", (int)cmd);
          break;
      }
    }
    else
    {
      QM_MSG_HIGH("Received NULL cmd_buf in MMGSDI GET OPERATOR NAME CNF callback for NAS");
    }
  }
}
#endif
/*===========================================================================

                             INTERNAL FUNCTIONS

===========================================================================*/

/*=============================================================================
FUNCTION: QMI_NAS_GET_HOME_MCC_MNC

DESCRIPTION: Reads the MCC and MNC from SIM.

PARAMETERS:
  None

RETURN VALUE:
  None

DEPENDENCIES:
  None

SIDE EFFECTS:
  None
=============================================================================*/
void qmi_nas_get_home_mcc_mnc( void )
{
  // dummy just to aleviate dependency from ds_qmi_task.c.
  // TODO: remove
}

/*===========================================================================
  FUNCTION QMI_NASI_RESET()

  DESCRIPTION
    Reset the issuing client's NAS state

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_reset
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type          * response = NULL;
  qmi_error_type_v01       errval   = QMI_ERR_NONE_V01;
//nas_reset_req_msg_v01  * nas_reset_req;
  nas_reset_resp_msg_v01 * nas_reset_resp;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

//nas_reset_req  = (nas_reset_req_msg_v01  *) modem_mem_alloc( sizeof( nas_reset_req_msg_v01  ), MODEM_MEM_CLIENT_QMI_MMODE );
  nas_reset_resp = (nas_reset_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_reset_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  QM_MSG_HIGH("qmi_nasi_reset resetting client");
  qmi_nasi_reset_client( cl_sp );

  if ( nas_reset_resp != NULL )
  {
    memset( nas_reset_resp, 0x00, sizeof( nas_reset_resp_msg_v01 ) );

    nas_reset_resp->resp.error  = errval;
    nas_reset_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) nas_reset_resp,
                                  (uint32_t) sizeof( nas_reset_resp_msg_v01 ),
                                  &response
                                );
  }
  else
{
    qmi_voice_mem_error();
}

//if ( nas_reset_req  != NULL ) { modem_mem_free( (void *) nas_reset_req,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( nas_reset_resp != NULL ) { modem_mem_free( (void *) nas_reset_resp, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_reset() */

#ifndef REMOVE_QMI_NAS_ABORT_V01
/*===========================================================================
  FUNCTION QMI_NASI_NETWORK_SCAN_ABORT_HDLR()

  DESCRIPTION
    Abort handler for the network scan operation

  PARAMETERS
    nas_sp     : Service provided state pointer
    cmd_buf_p  : Ptr to the cmd buf to be aborted

  RETURN VALUE
    TRUE       : Abort succeeded
    FALSE      : Abort Failed

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nasi_network_scan_abort_hdlr
(
  qmi_mmode_qcsi_transaction_type *     cmd_buf_p
)
{
  qmi_mmode_qcsi_transaction_type *  aborted_cmd_buf_p;
  dsm_item_type *     aborted_cmd_response;
  boolean             retval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    extract cmd_buf_p under queue function (mutexed) to ensure that
     CM task concurrent cm_network_scan_cb doesn't mess things up.
  -------------------------------------------------------------------------*/
  aborted_cmd_buf_p = qm_cbpq_del_specific_item( QM_CBPQ_QTYPE_NW_SCAN, cmd_buf_p );

  if(aborted_cmd_buf_p == NULL)
  {
    QM_MSG_HIGH("Network Scan completed but response still pending transaction completion!");
    return FALSE;
  }

  if(qm_cbpq_count( QM_CBPQ_QTYPE_NW_SCAN ) == 0)
  {
    /*-----------------------------------------------------------------------
      Issue terminate req to CM, Don't bother about success of terminate
      req irrespective send ABORT SUCCESS to client and ignore any
      network scan result that comes (AVALIABLE_CONF event)
    -----------------------------------------------------------------------*/
#ifdef FEATURE_DUAL_SIM
    {
      qmi_nasi_client_state_type  *cl_sp = NULL;
      
      cl_sp = (qmi_nasi_client_state_type*)qmi_nasi_get_cl_sp_by_cmd_buf( cmd_buf_p );
      if( cl_sp )
      {
         QM_MSG_HIGH_1("terminate_get_networks Sub:%d",cl_sp->report_status.bound_subs );
         (void) cm_ph_cmd_terminate_get_networks_per_subs(NULL,
                                            NULL,
                                            qmi_nasi_global.cm_clnt_id,
                                            (sys_modem_as_id_e_type)cl_sp->report_status.bound_subs  );
      }
    }
#else
    (void) cm_ph_cmd_terminate_get_networks(NULL,
                                            NULL,
                                            qmi_nasi_global.cm_clnt_id);
#endif
    /*-----------------------------------------------------------------------
      reset net_scan_started state variable, so that any new scan requests
      result in issuing a cmd to CM
    -----------------------------------------------------------------------*/
    qmi_nasi_global.net_scan_started = FALSE;
  }
  else
  {
    QM_MSG_HIGH("More net scan requests pending, returning abort success");
  }

  /*-----------------------------------------------------------------------
    Send a response for the aborted cmd with ERR_ABORTED
  -----------------------------------------------------------------------*/
  aborted_cmd_response = NULL;
  retval = qmi_svc_put_result_tlv(&aborted_cmd_response,
                                  QMI_RESULT_FAILURE,
                                  QMI_ERR_ABORTED);
  if(FALSE == retval)
  {
    dsm_free_packet(&aborted_cmd_response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &aborted_cmd_buf_p );
    return FALSE;
  }

   qmi_nasi_send_response( aborted_cmd_buf_p, aborted_cmd_response);

  return TRUE;
} /* qmi_nasi_network_scan_abort_hdlr */

/*===========================================================================
  FUNCTION QMI_NASI_ABORT()

  DESCRIPTION
    Abort an outstanding NAS command specified by transaction ID

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_abort
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_nasi_client_state_type * nas_client_sp = (qmi_nasi_client_state_type *) cl_sp;
  uint8                        tx_ix         = 0;
  //uint8                      cmd;

  qmi_error_type_v01           errval        = QMI_ERR_NONE_V01;
  nas_abort_req_msg_v01      * nas_abort_req;
  nas_abort_resp_msg_v01     * nas_abort_resp;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  nas_abort_req  = (nas_abort_req_msg_v01  *) modem_mem_alloc( sizeof(nas_abort_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  nas_abort_resp = (nas_abort_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_abort_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( nas_abort_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( nas_abort_req, 0x00, sizeof(nas_abort_req_msg_v01) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) nas_abort_req,
                                           (uint32_t) sizeof(nas_abort_req_msg_v01)
                                         );

  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    errval = qmi_nas_0001_req_check( nas_abort_req );
    #else
    if (nas_abort_req->tx_id == 0)
    {
      errval = QMI_ERR_INVALID_TX_ID_V01;
    }
    #endif
    
    QM_MSG_HIGH_2("Transaction (0x%x) errval %d", nas_abort_req->tx_id, errval);
  }

  if ( nas_abort_resp != NULL )
  {
    memset( nas_abort_resp, 0x00, sizeof(nas_abort_resp_msg_v01) );

    nas_abort_resp->resp.error  = errval;
    nas_abort_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) nas_abort_resp,
                                  (uint32_t) sizeof(nas_abort_resp_msg_v01),
                                  &response
                                );
    }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_abort_req  != NULL ) { modem_mem_free( (void *) nas_abort_req,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( nas_abort_resp != NULL ) { modem_mem_free( (void *) nas_abort_resp, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_abort() */
#endif

#ifndef REMOVE_QMI_NAS_SET_EVENT_REPORT_V01
/*===========================================================================
  FUNCTION QMI_NASI_SET_EVENT_REPORT()

  DESCRIPTION
    To set state for event reporting

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_event_report
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_nasi_client_state_type *  nasi_client_sp;

  qmi_error_e_type               errval = QMI_ERR_NONE;
  boolean                        call_cm_api = FALSE;

  nas_set_event_report_req_msg_v01    *req_msg;
  nas_set_event_report_resp_msg_v01   rsp_msg;
  dsm_item_type  *response = NULL;
  
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  nasi_client_sp = (qmi_nasi_client_state_type *)cl_sp;

  req_msg = (nas_set_event_report_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_event_report_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    return NULL;

  }

  memset (req_msg, 0x00, sizeof(nas_set_event_report_req_msg_v01));
  // extract information from REQ message
  errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         sdu_in,
                                         (void *) req_msg,
                                         (uint32_t) sizeof(nas_set_event_report_req_msg_v01)
                                       );
  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0002_req_check (req_msg);
  }

  if (errval == QMI_ERR_NONE)
  {
    struct report_status_s *p_rs = &nasi_client_sp->report_status; // shorthand

    // change signal strength reporting if tlv included in request
    if (req_msg->signal_strength_valid)
    {
      if ( req_msg->signal_strength.report_signal_strength == NAS_0002_REQ_REPORT )
      {
        p_rs->report_sig_str = TRUE;
        p_rs->num_thresholds =  (uint8) req_msg->signal_strength.report_signal_strength_threshold_list_len;
        memscpy((void*)p_rs->sig_str_thresholds, 
              sizeof(p_rs->sig_str_thresholds),
                       (const void*)req_msg->signal_strength.report_signal_strength_threshold_list, 
                       req_msg->signal_strength.report_signal_strength_threshold_list_len * sizeof(int8_t) );

        qsort( (void*)p_rs->sig_str_thresholds, p_rs->num_thresholds, sizeof(signed char), qmi_nas_byte_array_compare );
      }
      else
      {
        p_rs->report_sig_str     = FALSE;
        p_rs->last_reported_rssi_ex = NASI_SIG_STRENGTH_INACTIVE_RSSI;
      }
    }

    // change RF info (band/chan) reporting if tlv included in request
    if (req_msg->report_rf_band_info_valid)
      p_rs->report_rf_band_info = req_msg->report_rf_band_info;

    // change registration reject info reporting if tlv included in request
    if (req_msg->report_reg_reject_valid)
      p_rs->report_reg_reject_reason = req_msg->report_reg_reject;

    // setting rssi delta reporting if tlv included in request
    if (req_msg->rssi_indicator_valid)
    {
      call_cm_api             = TRUE;
      p_rs->report_rssi         = req_msg->rssi_indicator.report_rssi;
      p_rs->report_rssi_delta = req_msg->rssi_indicator.rssi_delta;

      if ( !p_rs->report_rssi )
      {
        p_rs->last_reported_rssi_ex = NASI_SIG_STRENGTH_INACTIVE_RSSI;
      }

      if ( req_msg->rssi_indicator.rssi_delta < qmi_nasi_global.min_rssi_delta )
        qmi_nasi_global.min_rssi_delta = req_msg->rssi_indicator.rssi_delta;
    }

    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
    // setting io delta reporting if tlv included in request
    if (req_msg->io_indicator_valid)
    {
      call_cm_api           = TRUE;
      p_rs->report_io       = req_msg->io_indicator.report_io;
      p_rs->report_io_delta = req_msg->io_indicator.io_delta;

      if( !p_rs->report_io  )
      {
        p_rs->last_reported_io = NASI_SIG_STRENGTH_INACTIVE_IO;
      }

      if ( req_msg->io_indicator.io_delta < qmi_nasi_global.min_io_delta )
        qmi_nasi_global.min_io_delta =  req_msg->io_indicator.io_delta;
    }
    #endif



    if (req_msg->report_error_rate_valid)
      p_rs->report_error_rate = req_msg->report_error_rate;

    if (req_msg->rsrq_indicator_valid)
    {
      call_cm_api           = TRUE;
      p_rs->report_rsrq = req_msg->rsrq_indicator.report_rsrq;
      p_rs->report_rsrq_delta = req_msg->rsrq_indicator.rsrq_delta;

      if ( req_msg->rsrq_indicator.rsrq_delta < qmi_nasi_global.min_rsrq_delta )
      {
        qmi_nasi_global.min_rsrq_delta = req_msg->rsrq_indicator.rsrq_delta;
      }
    }

    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
    // setting ecio delta reporting if tlv included in request
    if (req_msg->ecio_indicator_valid && !req_msg->ecio_threshold_indicator_valid )
    {
      call_cm_api             = TRUE;
      p_rs->report_ecio               = req_msg->ecio_indicator.report_ecio;
      p_rs->report_ecio_delta      = req_msg->ecio_indicator.ecio_delta;
      p_rs->reporting_mode_ecio = NASI_EVENT_REPORT_MODE_DELTA;

      if( !p_rs->report_ecio  )
      {
        p_rs->last_reported_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO;
      }
    }
    else if ( req_msg->ecio_threshold_indicator_valid )
    {

      if ( req_msg->ecio_threshold_indicator.report_ecio == NAS_0002_REQ_REPORT )
      {
        call_cm_api               = TRUE;
        p_rs->report_ecio               = req_msg->ecio_threshold_indicator.report_ecio;
        p_rs->reporting_mode_ecio = NASI_EVENT_REPORT_MODE_THRESHOLD;
        p_rs->num_thresholds_ecio = (uint8) req_msg->ecio_threshold_indicator.threshold_list_len;

        if( !p_rs->report_ecio  )
        {
          p_rs->last_reported_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO;
        }

        if ( req_msg->ecio_threshold_indicator.threshold_list_len <= NAS_ECIO_THRESHOLD_LIST_MAX_V01 )
        {
         memscpy((void *)p_rs->ecio_thresholds, 
                 (sizeof(req_msg->ecio_threshold_indicator.threshold_list[0]) * req_msg->ecio_threshold_indicator.threshold_list_len),
                 (const void *) req_msg->ecio_threshold_indicator.threshold_list, 
                 (sizeof(req_msg->ecio_threshold_indicator.threshold_list[0])  * req_msg->ecio_threshold_indicator.threshold_list_len) );
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG;
        }
      }
      else
      {
        p_rs->report_ecio        = FALSE;
        p_rs->last_reported_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO ;
      }
    }
    #endif

    // setting sinr delta reporting if tlv included in request
    if (req_msg->sinr_indicator_valid && !req_msg->sinr_threshold_indicator_valid)
    {
      call_cm_api           = TRUE;
      p_rs->report_sinr               = req_msg->sinr_indicator.report_sinr;
      p_rs->report_sinr_delta      = req_msg->sinr_indicator.sinr_delta;
      p_rs->reporting_mode_sinr = NASI_EVENT_REPORT_MODE_DELTA;
      if( !p_rs->report_sinr  )
      {
        p_rs->last_reported_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR;
      }
    }
    else if ( req_msg->sinr_threshold_indicator_valid)
    {
      if( req_msg->sinr_threshold_indicator.report_sinr == NAS_0002_REQ_REPORT )
      {
        call_cm_api               = TRUE;
        p_rs->report_sinr         = req_msg->sinr_threshold_indicator.report_sinr;
        p_rs->reporting_mode_sinr = NASI_EVENT_REPORT_MODE_THRESHOLD;
        p_rs->num_thresholds_sinr = (uint8) req_msg->sinr_threshold_indicator.threshold_list_len;

        if( !p_rs->report_sinr  )
        {
          p_rs->last_reported_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR;
        }

        if ( req_msg->sinr_threshold_indicator.threshold_list_len <= NAS_SINR_THRESHOLD_LIST_MAX_V01 )
        {
          memscpy((void *)p_rs->sinr_thresholds, (sizeof(req_msg->sinr_threshold_indicator.threshold_list[0]) * req_msg->sinr_threshold_indicator.threshold_list_len),
                  (const void *) req_msg->sinr_threshold_indicator.threshold_list, (sizeof(req_msg->sinr_threshold_indicator.threshold_list[0]) * req_msg->sinr_threshold_indicator.threshold_list_len) );
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG;
        }
      }
      else
      {
        p_rs->report_sinr        = FALSE;
        p_rs->last_reported_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR ;
      }
    }

    if ( req_msg->lte_snr_delta_indicator_valid )
    {
      call_cm_api                  = TRUE;
      p_rs->report_lte_snr            = req_msg->lte_snr_delta_indicator.report_lte_snr;
      p_rs->report_lte_snr_delta   = (uint8) req_msg->lte_snr_delta_indicator.lte_snr_delta;

      if( !p_rs->report_lte_snr )
      {
        p_rs->last_reported_lte_snr = NASI_LTE_SNR_STRENGTH_INACTIVE;
      }

    }

    if ( req_msg->lte_rsrp_delta_indicator_valid )
    {
      call_cm_api                   = TRUE;
      p_rs->report_lte_rsrp         =  req_msg->lte_rsrp_delta_indicator.report_lte_rsrp;
      p_rs->report_lte_rsrp_delta   =  req_msg->lte_rsrp_delta_indicator.lte_rsrp_delta;

      if( !p_rs->report_lte_rsrp )
      {
        p_rs->last_reported_lte_rsrp = NASI_SIG_STRENGTH_INACTIVE_RSRP;
      }
    }

    // Set the RSSI/ECIO/IO/SIR delta value by calling cm function
    if ( errval == QMI_ERR_NONE )
    {
      if (call_cm_api)
      {
        if (!cm_ph_cmd_signal_strength_delta_lte( qmi_nas_cmph_cmd_cb,
                                          (void *)cmd_buf_p,
                                          qmi_nasi_global.cm_clnt_id,
                                          qmi_nasi_global.min_rssi_delta,
                                          NASI_MIN_ECIO_DELTA,
                                          qmi_nasi_global.min_io_delta,
                                          NASI_MIN_SINR_DELTA,
                                          NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //pathloss_delta
                                          NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //cqi_delta
                                          (uint8)qmi_nasi_global.min_rsrp_delta,    //rsrp_delta
                                          qmi_nasi_global.min_rsrq_delta ))
        {
          errval = QMI_ERR_INTERNAL;
        }
        QM_MSG_HIGH("Response pending for Set rssi, ecio, io, sinr and rsrq delta ");
      }
    }
  }

  if (call_cm_api && errval == QMI_ERR_NONE)
  {
    response = (dsm_item_type*) QMI_SVC_RESPONSE_PENDING; 
  }
  else if( cmd_buf_p != NULL )
  {
    rsp_msg.resp.error  = (qmi_error_type_v01)errval;
    rsp_msg.resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) &rsp_msg,
                                  (uint32_t) sizeof(nas_set_event_report_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
} /* qmi_nasi_set_event_report() */

#endif

/*===========================================================================
  FUNCTION QMI_NASI_INDICATION_REGISTER()

  DESCRIPTION
    Set the registration state for the following QMI NAS indciation
    1. System selection preference indication
    2. Current nam indication
    3. DDTM events indication

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_indication_register
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                 *response  = NULL;
  qmi_nasi_client_state_type    *nasi_client_sp;

  qmi_error_type_v01             errval = QMI_ERR_NONE_V01;

  nas_indication_register_req_msg_v01  *nas_ind_reg_req;
  nas_indication_register_resp_msg_v01 *nas_ind_reg_resp;


  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  nasi_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  nas_ind_reg_req  = ( nas_indication_register_req_msg_v01  *)modem_mem_alloc(sizeof(nas_indication_register_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);
  nas_ind_reg_resp = ( nas_indication_register_resp_msg_v01 *)modem_mem_alloc(sizeof(nas_indication_register_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( nas_ind_reg_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(nas_ind_reg_req, 0, sizeof(nas_indication_register_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)nas_ind_reg_req,
                                           (uint32_t)sizeof(nas_indication_register_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_0003_req_check(nas_ind_reg_req);
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    struct report_status_s *p_rs = &nasi_client_sp->report_status;

    if ( nas_ind_reg_req->reg_sys_sel_pref_valid ) // system selection preference TLV 0x10
    {
      if ( nas_ind_reg_req->reg_sys_sel_pref == FALSE )
      {
        p_rs->reg_sys_sel_pref = FALSE;
      }
      else if ( nas_ind_reg_req->reg_sys_sel_pref == TRUE )
      {
        p_rs->reg_sys_sel_pref = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    if ( nas_ind_reg_req->reg_ddtm_events_valid ) // DDTM events TLV 0x12
    {
      if ( nas_ind_reg_req->reg_ddtm_events == FALSE )
      {
        p_rs->reg_ddtm_events = FALSE;
      }
      else if ( nas_ind_reg_req->reg_ddtm_events == TRUE )
      {
        p_rs->reg_ddtm_events = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif

    #ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
    if ( nas_ind_reg_req->req_serving_system_valid ) // serving system events TLV 0x13
    {
      if ( nas_ind_reg_req->req_serving_system == FALSE )
      {
        p_rs->not_report_serving_system = TRUE;
      }
      else if ( nas_ind_reg_req->req_serving_system == TRUE )
      {
        p_rs->not_report_serving_system = FALSE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif

   #ifdef FEATURE_DUAL_SIM
    if ( nas_ind_reg_req->dual_standby_pref_valid ) // dual standby pref TLV 0x14
    {
      if ( nas_ind_reg_req->dual_standby_pref == FALSE )
      {
        p_rs->report_dual_standby_pref_ind = FALSE;
      }
      else if ( nas_ind_reg_req->dual_standby_pref == TRUE )
      {
        p_rs->report_dual_standby_pref_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->subscription_info_valid ) // subscription info TLV 0x15
    {
      if ( nas_ind_reg_req->subscription_info == FALSE )
      {
        p_rs->report_subscription_info_ind = FALSE;
      }
      else if ( nas_ind_reg_req->subscription_info == TRUE )
      {
        p_rs->report_subscription_info_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif
    if ( nas_ind_reg_req->reg_network_time_valid ) // reg_network_time TLV 0x17
    {
      if (nas_ind_reg_req->reg_network_time == FALSE )
      {
        p_rs->report_network_time = FALSE;
      }
      else if (nas_ind_reg_req->reg_network_time == TRUE )
      {
        p_rs->report_network_time = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->sys_info_valid ) // sys_info TLV 0x18
    {
      if (nas_ind_reg_req->sys_info == FALSE )
      {
        p_rs->report_sys_info = FALSE;
      }
      else if (nas_ind_reg_req->sys_info== TRUE )
      {
        p_rs->report_sys_info = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->sig_info_valid ) // sig_info TLV 0x19
    {
      if (nas_ind_reg_req->sig_info == FALSE )
      {
        p_rs->report_sig_info = FALSE;
      }
      else if (nas_ind_reg_req->sig_info== TRUE )
      {
        p_rs->report_sig_info = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->err_rate_valid ) // err_rate TLV 0x1A
    {
      if (nas_ind_reg_req->err_rate == FALSE )
      {
        p_rs->report_err_rate = FALSE;
      }
      else if (nas_ind_reg_req->err_rate== TRUE )
      {
        p_rs->report_err_rate = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #if defined(FEATURE_HDR)
    if ( nas_ind_reg_req->reg_hdr_uati_valid ) // reg_hdr_uati TLV 0x1B
    {
      if (nas_ind_reg_req->reg_hdr_uati == FALSE )
      {
        p_rs->report_uati = FALSE;
      }
      else if (nas_ind_reg_req->reg_hdr_uati == TRUE )
      {
        p_rs->report_uati = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_hdr_session_close_valid ) // reg_hdr_session_close TLV 0x1C
    {
      if (nas_ind_reg_req->reg_hdr_session_close == FALSE )
      {
        p_rs->report_session_close = FALSE;
      }
      else if (nas_ind_reg_req->reg_hdr_session_close == TRUE )
      {
        p_rs->report_session_close = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif

    #ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
    if ( nas_ind_reg_req->reg_managed_roaming_valid ) // reg_managed_roaming TLV 0x1D
    {
      if ( nas_ind_reg_req->reg_managed_roaming == FALSE )
      {
        p_rs->report_managed_roaming = FALSE;
      }
      else if ( nas_ind_reg_req->reg_managed_roaming == TRUE )
      {
        p_rs->report_managed_roaming = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif

    if ( nas_ind_reg_req->reg_current_plmn_name_valid ) // reg_current_plmn_name TLV 0x1E
    {
      if ( nas_ind_reg_req->reg_current_plmn_name == FALSE )
      {
        p_rs->report_current_plmn_name = FALSE;
      }
      else if ( nas_ind_reg_req->reg_current_plmn_name == TRUE )
      {
        p_rs->report_current_plmn_name = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    #ifdef FEATURE_LTE_EMBMS
    if ( nas_ind_reg_req->reg_embms_status_valid ) // reg_embms_status TLV 0x1F
    {
      if ( nas_ind_reg_req->reg_embms_status == FALSE )
      {
        p_rs->report_embms_status = FALSE;
      }
      else if ( nas_ind_reg_req->reg_embms_status == TRUE )
      {
        p_rs->report_embms_status = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif  //FEATURE_LTE_EMBMS
    #endif  //#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))

    if ( nas_ind_reg_req->reg_rf_band_info_valid ) // reg_rf_band_info TLV 0x20
    {
      if ( nas_ind_reg_req->reg_rf_band_info == FALSE )
      {
        p_rs->report_rf_band_info_ind = FALSE;
      }
      else if ( nas_ind_reg_req->reg_rf_band_info == TRUE )
      {
        p_rs->report_rf_band_info_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->network_reject_valid ) // network_reject TLV 0x21
    {
      if ( nas_ind_reg_req->network_reject.reg_network_reject == FALSE )
      {
        p_rs->network_reject.report_network_reject_ind = FALSE;
        p_rs->network_reject.suppress_sys_info_on_reject = FALSE;
      }
      else if ( nas_ind_reg_req->network_reject.reg_network_reject == TRUE )
      {
        p_rs->network_reject.report_network_reject_ind = TRUE;
        if ( nas_ind_reg_req->network_reject.suppress_sys_info == TRUE )
        {
          p_rs->network_reject.suppress_sys_info_on_reject = TRUE;
        }
        else
        {
          p_rs->network_reject.suppress_sys_info_on_reject = FALSE;
        }
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_operator_name_data_valid ) // reg_operator_name_data TLV 0x22
    {
      if ( nas_ind_reg_req->reg_operator_name_data == FALSE )
      {
        p_rs->report_operator_name_data = FALSE;
      }
      else if ( nas_ind_reg_req->reg_operator_name_data == TRUE )
      {
        p_rs->report_operator_name_data = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_csp_plmn_mode_bit_valid ) // reg_csp_plmn_mode_bit TLV 0x23
    {
      if ( nas_ind_reg_req->reg_csp_plmn_mode_bit == FALSE )
      {
        p_rs->report_csp_plmn_mode_bit = FALSE;
      }
      else if ( nas_ind_reg_req->reg_csp_plmn_mode_bit == TRUE )
      {
        p_rs->report_csp_plmn_mode_bit = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    if ( nas_ind_reg_req->reg_rtre_cfg_valid ) // reg_rtre_cfg TLV 0x24
    {
      if ( nas_ind_reg_req->reg_rtre_cfg == FALSE )
      {
        p_rs->report_rtre_config = FALSE;
      }
      else if ( nas_ind_reg_req->reg_rtre_cfg == TRUE )
      {
        p_rs->report_rtre_config = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif

    if ( nas_ind_reg_req->reg_ims_pref_status_valid )
    {
      if ( nas_ind_reg_req->reg_ims_pref_status == FALSE )
      {
        p_rs->report_ims_pref_status = FALSE;
      }
      else if ( nas_ind_reg_req->reg_ims_pref_status == TRUE )
      {
        p_rs->report_ims_pref_status = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    #ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
    if ( nas_ind_reg_req->reg_e911_state_ready_status_valid )
    {
      if ( nas_ind_reg_req->reg_e911_state_ready_status == FALSE )
      {
        p_rs->report_e911_state_ready = FALSE;
      }
      else if ( nas_ind_reg_req->reg_e911_state_ready_status == TRUE )
      {
        p_rs->report_e911_state_ready = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif //FEATURE_MMODE_QMI_DISABLE_IMS_EXT


    if ( nas_ind_reg_req->reg_lte_cphy_ca_valid )
    {
      if ( nas_ind_reg_req->reg_lte_cphy_ca == FALSE )
      {
        p_rs->report_lte_cphy_ca_status = FALSE;
      }
      else if ( nas_ind_reg_req->reg_lte_cphy_ca == TRUE )
      {
        p_rs->report_lte_cphy_ca_status = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_lte_sib16_network_time_valid )
    {
      if ( nas_ind_reg_req->reg_lte_sib16_network_time == FALSE )
      {
        p_rs->report_lte_sib16_network_time = FALSE;
      }
      else if ( nas_ind_reg_req->reg_lte_sib16_network_time == TRUE )
      {
        p_rs->report_lte_sib16_network_time = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
  }

    if ( nas_ind_reg_req->reg_ssac_info_valid )
    {
      if ( nas_ind_reg_req->reg_ssac_info == FALSE )
      {
        p_rs->report_ssac_info = FALSE;
      }
      else if ( nas_ind_reg_req->reg_ssac_info == TRUE )
      {
        p_rs->report_ssac_info = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
    if ( nas_ind_reg_req->reg_subscription_change_valid )
    {
      if ( nas_ind_reg_req->reg_subscription_change == FALSE )
      {
        p_rs->report_subscription_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_subscription_change == TRUE )
      {
        p_rs->report_subscription_change = TRUE;
      }
    }

    
    if ( nas_ind_reg_req->reg_emm_t3402_change_valid )
    {
      if ( nas_ind_reg_req->reg_emm_t3402_change == FALSE )
      {
        p_rs->report_t3402_timer_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_emm_t3402_change == TRUE )
      {
        p_rs->report_t3402_timer_change = TRUE;
      }
    }
    #endif
    if ( nas_ind_reg_req->reg_acb_info_change_valid )
    {
      if ( nas_ind_reg_req->reg_acb_info_change == FALSE )
      {
        p_rs->reg_acb_info_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_acb_info_change == TRUE )
      {
        p_rs->reg_acb_info_change = TRUE;
      }
    }

    #ifndef REMOVE_QMI_NAS_GET_DATA_SUBS_PRIORITY_V01
    if ( nas_ind_reg_req->reg_data_subs_priority_change_valid )
    {
      if ( nas_ind_reg_req->reg_data_subs_priority_change == FALSE )
      {
        p_rs->report_data_priority_subs_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_data_subs_priority_change == TRUE )
      {
        p_rs->report_data_priority_subs_change = TRUE;
      }
    }
    #endif

    if ( nas_ind_reg_req->reg_t3346_timer_status_change_valid )
    {
      if ( nas_ind_reg_req->reg_t3346_timer_status_change == FALSE )
      {
        p_rs->report_t3346_timer_status_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_t3346_timer_status_change == TRUE )
      {
        p_rs->report_t3346_timer_status_change = TRUE;
      }
    }
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
    if ( nas_ind_reg_req->reg_call_mode_change_valid )
    {
      if ( nas_ind_reg_req->reg_call_mode_change == FALSE )
      {
        p_rs->report_call_mode_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_call_mode_change == TRUE )
      {
        p_rs->report_call_mode_change = TRUE;
      }
    }
#endif

    if ( nas_ind_reg_req->reg_ssac_change_info_valid )
    {
      if ( nas_ind_reg_req->reg_ssac_change_info == FALSE )
      {
        p_rs->report_ssac_change_info = FALSE;
      }
      else if ( nas_ind_reg_req->reg_ssac_change_info == TRUE )
      {
        p_rs->report_ssac_change_info = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_edrx_change_info_ind_valid )
    {
      if ( nas_ind_reg_req->reg_edrx_change_info_ind == FALSE )
      {
        p_rs->report_edrx_change_info_ind = FALSE;
      }
      else if ( nas_ind_reg_req->reg_edrx_change_info_ind == TRUE )
      {
        p_rs->report_edrx_change_info_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    if ( nas_ind_reg_req->reg_manual_scan_fail_valid )
    {
      if ( nas_ind_reg_req->reg_manual_scan_fail == FALSE )
      {
        p_rs->report_manual_scan_fail = FALSE;
      }
      else if ( nas_ind_reg_req->reg_manual_scan_fail == TRUE )
      {
        p_rs->report_manual_scan_fail = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    #endif

#ifndef REMOVE_QMI_NAS_GET_LTE_RRC_TX_INFO_V01
    if (nas_ind_reg_req->lte_rrc_tx_info_ind_valid) // TLV 36
    {
        if (nas_ind_reg_req->lte_rrc_tx_info_ind_valid == FALSE)
        {
            p_rs->report_lte_rrc_tx_info_ind = FALSE;
        }
        else if (nas_ind_reg_req->lte_rrc_tx_info_ind_valid == TRUE)
        {
            p_rs->report_lte_rrc_tx_info_ind = TRUE;
        }
        else
        {
            errval = QMI_ERR_INVALID_ARG_V01;
        }
    }
#endif
#ifdef FEATURE_ENABLE_QMI_DMS
    if ( nas_ind_reg_req->reg_psm_config_params_change_ind_valid)
    {
      if (nas_ind_reg_req->reg_psm_config_params_change_ind == FALSE )
      {
        p_rs->report_psm_config_params_change_ind = FALSE;
      }
      else if (nas_ind_reg_req->reg_psm_config_params_change_ind== TRUE )
      {
        p_rs->report_psm_config_params_change_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_psm_status_ind_valid)
    {
      if (nas_ind_reg_req->reg_psm_status_ind == FALSE )
      {
        p_rs->report_psm_status_ind = FALSE;
      }
      else if (nas_ind_reg_req->reg_psm_status_ind== TRUE )
      {
        p_rs->report_psm_status_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

  if ( nas_ind_reg_req->reg_operating_mode_ind_valid)
  {
    if (nas_ind_reg_req->reg_operating_mode_ind == FALSE )
    {
      p_rs->report_operating_mode_ind = FALSE;
    }
    else if (nas_ind_reg_req->reg_operating_mode_ind== TRUE )
    {
      p_rs->report_operating_mode_ind = TRUE;
    }
    else
    {
      errval = QMI_ERR_INVALID_ARG_V01;
    }
  }
#endif

  
  
  if ( nas_ind_reg_req->reg_sfn_threshold_ind_valid)
   {
     if (nas_ind_reg_req->reg_sfn_threshold_ind == FALSE )
     {
       p_rs->reg_sfn_threshold_ind = FALSE;
     }
     else if (nas_ind_reg_req->reg_sfn_threshold_ind == TRUE )
     {
       p_rs->reg_sfn_threshold_ind = TRUE;
     }
     else
     {
       errval = QMI_ERR_INVALID_ARG_V01;
     }
   }
if ( nas_ind_reg_req->reg_jamming_status_ind_valid)
   {
     if (nas_ind_reg_req->reg_jamming_status_ind == FALSE )
     {
       p_rs->reg_jamming_status_ind = FALSE;
     }
     else if (nas_ind_reg_req->reg_jamming_status_ind == TRUE )
     {
       p_rs->reg_jamming_status_ind = TRUE;
     }
     else
     {
       errval = QMI_ERR_INVALID_ARG_V01;
     }
   }
  if(nas_ind_reg_req->reg_wwan_sleep_info_ind_valid)
  	{
  	  if (nas_ind_reg_req->reg_wwan_sleep_info_ind == FALSE)
  	  {
  	    p_rs->reg_wwan_sleep_info_ind = FALSE;
  	  }
	  else if (nas_ind_reg_req->reg_wwan_sleep_info_ind == TRUE)
	  {
	    p_rs->reg_wwan_sleep_info_ind = TRUE;
	  }
	  else
      {
       errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
  }

  if ( nas_ind_reg_resp != NULL )
  {
    memset(nas_ind_reg_resp, 0, sizeof(nas_indication_register_resp_msg_v01) );
    nas_ind_reg_resp->resp.error  = errval;
    nas_ind_reg_resp->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)nas_ind_reg_resp,
                                  (uint32_t)sizeof(nas_indication_register_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_ind_reg_req  != NULL ){ modem_mem_free((void *)nas_ind_reg_req,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( nas_ind_reg_resp != NULL ){ modem_mem_free((void *)nas_ind_reg_resp, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_indication_register() */

#ifndef REMOVE_QMI_NAS_GET_SIGNAL_STRENGTH_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_SIGNAL_STRENGTH()

  DESCRIPTION
    Gives the current signal strength measured by the device

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_signal_strength
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type  *response = NULL;

  qmi_error_e_type        errval = QMI_ERR_NONE;

  nas_get_signal_strength_req_msg_v01   *req_msg;
  nas_get_signal_strength_resp_msg_v01  *rsp_msg;

  enum qmi_nas_radio_if_e main_svc, sec_svc = QMI_NAS_RADIO_IF_NONE;

  sys_modem_as_id_e_type     asubs_id = SYS_MODEM_AS_ID_1;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  req_msg = (nas_get_signal_strength_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_signal_strength_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_signal_strength_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_signal_strength_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL || rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_signal_strength;
  }
  
  memset(req_msg, 0, sizeof(nas_get_signal_strength_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_get_signal_strength_resp_msg_v01));


  // extract information from REQ message
  errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         sdu_in,
                                         (void *) req_msg,
                                         (uint32_t) sizeof(nas_get_signal_strength_req_msg_v01)
                                       );


  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0020_req_check( req_msg );
  }

  if (errval == QMI_ERR_NONE)
  {
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#endif
    main_svc   = qmi_nas_sys_mode_2_radio_if(&qmi_nasi_global.cm_msim_ss_info[asubs_id],STACK_INDEX_0,FALSE);
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    if( qmi_nasi_global.cm_msim_ss_info[asubs_id].number_of_stacks > 1 )
    {
      sec_svc = qmi_nas_sys_mode_2_radio_if(&qmi_nasi_global.cm_msim_ss_info[asubs_id],STACK_INDEX_1,FALSE);
    }
    #endif

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_LTE_RSRP_MASK_V01 )
    {
      if ( main_svc == QMI_NAS_RADIO_IF_LTE && asubs_id == SYS_MODEM_AS_ID_1 )
      {
        rsp_msg->lte_rsrp_valid    = TRUE;
        rsp_msg->lte_rsrp = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrp;
      } // LTE RSRP
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_LTE_SNR_MASK_V01 )
    {
      if ( main_svc == QMI_NAS_RADIO_IF_LTE && asubs_id == SYS_MODEM_AS_ID_1 )
      {
        rsp_msg->snr_valid    = TRUE;
        rsp_msg->snr  = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].sinr * 2 - 200;
      } // LTE SNR
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_RSRQ_MASK_V01 )
    {
      if ( main_svc == QMI_NAS_RADIO_IF_LTE && asubs_id == SYS_MODEM_AS_ID_1 )
      {
        rsp_msg->rsrq_valid    = TRUE;
        rsp_msg->rsrq.rsrq     = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrq;
        rsp_msg->rsrq.radio_if = main_svc;
      } // RSRQ
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_ERROR_RATE_MASK_V01 )
    {
      int i = 0;

        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
          #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
          if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
            {
              rsp_msg->error_rate[i  ].error_rate = 0xFFFF; // unknown err rate
              rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001X;
            }
            else
          #endif
            {
              rsp_msg->error_rate[i  ].error_rate = 0xFFFF; // unknown err rate
              rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            }
            break;
#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
          case QMI_NAS_RADIO_IF_CDMA20001X:
          rsp_msg->error_rate[i  ].error_rate = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rat_mode_info.cdma_mode_info.frame_err_rate;
            rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            break;

          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->error_rate[i  ].error_rate = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
            rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            break;
#endif
          case QMI_NAS_RADIO_IF_GSM:
          #if defined(FEATURE_WCDMA)
          case QMI_NAS_RADIO_IF_UMTS:
          #endif
          rsp_msg->error_rate[i  ].error_rate = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].mode_info.gw_info.bit_err_rate;
            rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            break;

          case QMI_NAS_RADIO_IF_LTE:
            rsp_msg->error_rate[i  ].error_rate = 0xFFFF; // unknown err rate
            rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }

      #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
      switch ( sec_svc )
        {
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->error_rate[i  ].error_rate = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
          rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)sec_svc;
            break;

          default:
            break;
        }
      #endif

      if ( i > 0 )
      {
        rsp_msg->error_rate_valid         = TRUE;
        rsp_msg->error_rate_len            = i;
      }
    } // ERR_RATE

    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_SINR_MASK_V01 )
      {
        if ( main_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->sinr_valid = TRUE;
          rsp_msg->sinr = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].sinr;
        }
        #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
        else if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->sinr_valid = TRUE;
          rsp_msg->sinr  = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].sinr;
        }
        #endif
        else
        {
          rsp_msg->sinr_valid = TRUE;
#define QMI_NAS_SINR_VALUE_NO_SIGNAL 8
          rsp_msg->sinr  = QMI_NAS_SINR_VALUE_NO_SIGNAL;
        }
      } // SINR
    }

    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_IO_MASK_V01 )
      {
        if ( main_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->io_valid = TRUE;
          rsp_msg->io    = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].io;
        }
        #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
        else if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->io_valid = TRUE;
          rsp_msg->io    = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].io;
        }
        #endif
        else
        {
          rsp_msg->io_valid= TRUE;
#define QMI_NAS_IO_VALUE_NO_SIGNAL       (-106)
          rsp_msg->io    = QMI_NAS_IO_VALUE_NO_SIGNAL;
        }
      } // IO
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_ECIO_MASk_V01 )
    {
      int i = 0;

        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
          #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
          if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
            {
              rsp_msg->ecio[i  ].ecio     = 5; // unknown ecio
              rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001X;
            }
            else
          #endif
            {
              rsp_msg->ecio[i  ].ecio     = 5; // unknown ecio
              rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            }
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->ecio[i  ].ecio     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].ecio;
            rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            break;

          case QMI_NAS_RADIO_IF_GSM:
          #if defined(FEATURE_WCDMA)
          case QMI_NAS_RADIO_IF_UMTS:
          #endif
          case QMI_NAS_RADIO_IF_LTE:
          rsp_msg->ecio[i  ].ecio     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].ecio;
            rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }

      #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
      switch ( sec_svc )
        {
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->ecio[i  ].ecio     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].ecio;
          rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)sec_svc;
            break;

          default:
            break;
        }
      #endif

      if ( i > 0 )
      {
        rsp_msg->ecio_valid     = TRUE;
        rsp_msg->ecio_len       = i;
      }
    } // ECIO

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_RSSI_MASK_V01 )
    {
      int i = 0;

        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
          #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
          if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
            {
              rsp_msg->rssi[i  ].rssi     = 128; // unknown rssi
              rsp_msg->rssi[i++].radio_if = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001X;
            }
            else
          #endif
            {
              rsp_msg->rssi[i  ].rssi     = 128; // unknown rssi
              rsp_msg->rssi[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            }
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          case QMI_NAS_RADIO_IF_GSM:
          #if defined(FEATURE_WCDMA)
          case QMI_NAS_RADIO_IF_UMTS:
          #endif
          case QMI_NAS_RADIO_IF_LTE:
          rsp_msg->rssi[i  ].rssi     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi;
            rsp_msg->rssi[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }

      #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
      switch ( sec_svc )
        {
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->rssi[i  ].rssi     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].rssi;
          rsp_msg->rssi[i++].radio_if = (nas_radio_if_enum_v01)sec_svc;
            break;

          default:
            break;
        }
      #endif

      if ( i > 0 )
      {
        rsp_msg->rssi_valid     = TRUE;
        rsp_msg->rssi_len        = i;
      }
    } // RSSI

    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    {
      int i = 0;

      if ( asubs_id == SYS_MODEM_AS_ID_1 && sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
      {
        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
            rsp_msg->signal_strength_list[i  ].sig_strength = -128; // unknown sig_strength
            rsp_msg->signal_strength_list[i++].radio_if     = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001X;
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
            rsp_msg->signal_strength_list[i  ].sig_strength = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi > 127 ? -128 : (int8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi*(-1);
            rsp_msg->signal_strength_list[i++].radio_if     = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }

        rsp_msg->signal_strength_list[i  ].sig_strength = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].rssi > 127 ? -128 : (int8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].rssi*(-1);
        rsp_msg->signal_strength_list[i++].radio_if     = (nas_radio_if_enum_v01)sec_svc;

        rsp_msg->signal_strength_list_valid    = TRUE;
        rsp_msg->signal_strength_list_len       = i;
      }
    } // Signal Strength list
    #endif

    {
        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
            rsp_msg->signal_strength.radio_if = (nas_radio_if_enum_v01)( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO ? QMI_NAS_RADIO_IF_CDMA20001X : QMI_NAS_RADIO_IF_NONE);
            rsp_msg->signal_strength.sig_strength = -128; // unknown sig_strength
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          case QMI_NAS_RADIO_IF_GSM:
          #if defined(FEATURE_WCDMA)
          case QMI_NAS_RADIO_IF_UMTS:
          #endif
          case QMI_NAS_RADIO_IF_LTE:
          rsp_msg->signal_strength.sig_strength = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi > 127 ? -128 : (int8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi*(-1);
            rsp_msg->signal_strength.radio_if     = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }
    } // Signal Strength

  }

  if( cmd_buf_p != NULL )
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    /*-------------------------------------------------------------------------
     * Pack message
     -------------------------------------------------------------------------*/
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_signal_strength_resp_msg_v01),
                                  &response
                                );
  }
end_get_signal_strength:
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_signal_strength() */
#endif

/*===========================================================================
  FUNCTION FILTER_NETWORKS_TO_SCAN()

  DESCRIPTION
    Given QMI_NAS_PERFORM_NETWORK_SCAN_REQ 0x2100 t10 network_type,
    filter mask based on networks supported by target,
    masking off bits of unsupported networks.

  PARAMETERS
    network_type - Bitmask representing the network types to scan. Values:
      Bit 0 -- GSM  (lsb)
      Bit 1 -- UMTS
      Bit 2 -- LTE
      Bit 3 -- TD-SCDMA (>= MPSS.NI.3.2)
      (from network_access_service_wireformat_v01.html#QMI_NAS_PERFORM_NETWORK_SCAN_REQ Field Type 0x10)

  RETURN VALUE
    modified network scan mask (see parameter above)

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 filter_networks_to_scan( uint8 network_type )
{
  // mask off network scan bits that the target does not support
  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  if ( ! TARGET_SUPPORTS_GSM   ) { network_type &= ~ NAS_NETWORK_TYPE_GSM_ONLY_V01;   }

  if ( ! TARGET_SUPPORTS_WCDMA ) { network_type &= ~ NAS_NETWORK_TYPE_WCDMA_ONLY_V01; }

  if ( ! TARGET_SUPPORTS_LTE   ) { network_type &= ~ NAS_NETWORK_TYPE_LTE_ONLY_V01;   }

  // NOTE:  NI-3.2 and beyond supports TD-SCDMA, so we test and mask it, like the RATS above.

  if ( ! TARGET_SUPPORTS_TDS   ) { network_type &= ~ NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01;   }

  // NOTE:  For pre-NI-3.2, TD-SCDMA is not supported, so we need to mask off the bit for TDS network scan also

  network_type &= ( NAS_NETWORK_TYPE_GSM_ONLY_V01 | NAS_NETWORK_TYPE_WCDMA_ONLY_V01 | NAS_NETWORK_TYPE_LTE_ONLY_V01 | NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01 );
  #else

  if ( ! TARGET_SUPPORTS_LTE   ) { network_type &= ~ NAS_NETWORK_TYPE_LTE_ONLY_V01;   }

  network_type &= ( NAS_NETWORK_TYPE_LTE_ONLY_V01 );

  #endif

  QM_MSG_HIGH_2("mode_capability = %d, filter network type %d",
                qmi_nasi_global.cm_ph_info.mode_capability, network_type);
  return network_type;
}

/*===========================================================================
  FUNCTION QMI_NASI_PERFORM_NETWORK_SCAN()

  DESCRIPTION
    Returns a list of network providers that have been scanned.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_perform_network_scan
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type             * response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  boolean                     retval   = TRUE;
  nas_perform_network_scan_req_msg_v01  * req_msg;
  nas_perform_network_scan_resp_msg_v01 * rsp_msg;
  int                         i;
  cm_mode_pref_e_type         mode_pref = CM_MODE_PREF_GWL;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  cm_network_list_type_e_type list_type = CM_NETWORK_LIST_AVAILABLE;
  cm_band_pref_e_type         band_pref     = CM_BAND_PREF_ANY,
                              lte_band_pref = CM_BAND_PREF_LTE_ANY,
                              tds_band_pref = CM_BAND_PREF_TDS_ANY;

  #if defined(FEATURE_CIOT)
  cm_ciot_user_lte_pref_s_type  ciot_lte_pref;
  #endif
  
  uint8                       filtered_network_type;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  QM_MSG_HIGH("perform_network_scan processing");
  
  req_msg = (nas_perform_network_scan_req_msg_v01  *) modem_mem_alloc( sizeof(nas_perform_network_scan_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#endif
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    asubs_id = SYS_MODEM_AS_ID_3;
  }
#endif

  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  if ( ! TARGET_SUPPORTS_GSM && ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE && ! TARGET_SUPPORTS_TDS )
  #else
  if ( ! TARGET_SUPPORTS_LTE )
  #endif
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
    QM_MSG_HIGH("Failed due to capability check");
  }

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset( req_msg, 0x00, sizeof(nas_perform_network_scan_req_msg_v01) );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_perform_network_scan_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0021_req_check( req_msg );
  }

  QM_MSG_HIGH_1("perform_network_scan errval %d", errval);


  if( (errval == QMI_ERR_NONE_V01) && req_msg->scan_type_valid )
  {
    if( req_msg->scan_type == NAS_SCAN_TYPE_CELL_SEARCH_V01 )
      {
        list_type = CM_NETWORK_LIST_CELL_SEARCH;
      }
  }


#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  if( (errval == QMI_ERR_NONE_V01) && req_msg->scan_type_valid )
  {
    if( req_msg->scan_type == NAS_SCAN_TYPE_CSG_V01 )
    {
      if ( qm_efs_csg_supported() )
      {
      list_type = CM_NETWORK_LIST_CSG;
      }
      else
  {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      }
    }
  }
#endif
#endif

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( qmi_nasi_global.net_scan_started )
    {
      #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
      if ( asubs_id == qmi_nasi_global.net_scan_asubs_id )
      #endif
      {
        if( req_msg->scan_type_valid &&  (list_type != qmi_nasi_global.net_scan_type )) 
        { /* previous scan and current scan type is not same */
          errval = QMI_ERR_INVALID_OPERATION_V01;
          QM_MSG_HIGH_2("Net Scan already started with different scan type(prev :%d, curr :%d)", qmi_nasi_global.net_scan_type, req_msg->scan_type);
        } 
        else if( !req_msg->scan_type_valid &&  (qmi_nasi_global.net_scan_type != CM_NETWORK_LIST_AVAILABLE)) 
        { /* previous scan is CSG & scan type is not provided in the curr scan */
          errval = QMI_ERR_INVALID_OPERATION_V01;
          QM_MSG_HIGH_1("Net Scan already started with different scan type(prev :%d)", qmi_nasi_global.net_scan_type);
        }
        #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
        else if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
        {
          QM_MSG_HIGH( "Incremental Net Scan already started earlier,waiting for response");
          errval = QMI_ERR_INVALID_OPERATION_V01;
        }
        #endif
        else
        {
        qm_cbpq_add( QM_CBPQ_QTYPE_NW_SCAN, cmd_buf_p, ((qmi_nasi_client_state_type *)cl_sp)->clnt );
        //Net Scan already started earlier,waiting for response
        }
      }
      #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_HIGH_2("net scan ongoing on other subscription:%d %d", qmi_nasi_global.net_scan_asubs_id, asubs_id);
      }
      #endif
    }
    else
    {
      QM_MSG_HIGH_1("perform_network_scan is network_type valid %d", req_msg->network_type_valid);
      
      if( req_msg->network_type_valid )
      {
        QM_MSG_HIGH_1("perform_network_scan network_type %d",req_msg->network_type);
        
        if ( req_msg->network_type == 0 )
        {
          mode_pref = CM_MODE_PREF_NO_CHANGE;
        }
        else
        {
          filtered_network_type = filter_networks_to_scan( req_msg->network_type );
          retval = FALSE; // assume no match, until proven otherwise by the loop below...

          for( i = 0 ; i < QMI_NAS_ARR_SIZE(qmi_nas_allowed_network_types) ; i++ )
          {
            if ( filtered_network_type == qmi_nas_allowed_network_types[i].network_type )
            {
              mode_pref = qmi_nas_allowed_network_types[i].cm_val;
              retval = TRUE; // a match has been found, proceed as before.
              break;
            }
          }

          if ( ! retval ) { errval = QMI_ERR_INTERNAL_V01; }

          QM_MSG_HIGH_3("qmi_nasi_perform_network_scan() network_type = %d, filtered = %d, change = %d.", req_msg->network_type, filtered_network_type, req_msg->network_type ^ filtered_network_type);
      }
      }

      QM_MSG_HIGH_3("network_type_valid = %d mode_pref = %d retval = %d (T/F)", req_msg->network_type_valid, mode_pref, retval);
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY
      if ( req_msg->band_pref_valid )
      {
        band_pref = (cm_band_pref_e_type) req_msg->band_pref;
      }
      #endif

      if ( req_msg->lte_band_pref_valid )
      {
        lte_band_pref = (cm_band_pref_e_type) req_msg->lte_band_pref;
      }
      #if defined(FEATURE_TDSCDMA)
      if ( req_msg->tdscdma_band_pref_valid )
      {
        tds_band_pref = (cm_band_pref_e_type) req_msg->tdscdma_band_pref;
      }
      #endif

      #if defined(FEATURE_CIOT)
      ciot_lte_pref.lte_m1_band_pref = SYS_LTE_BAND_MASK_CONST_NO_CHG;
      ciot_lte_pref.lte_nb1_band_pref = SYS_LTE_BAND_MASK_CONST_NO_CHG;
      ciot_lte_pref.lte_op_mode_pref = CM_LTE_IOT_OP_MODE_PREF_NO_CHANGE;
      
      if (req_msg->ciot_lte_op_mode_pref_valid)
      {
        ciot_lte_pref.lte_op_mode_pref = qmi_nas_map_ciot_lte_op_mode_pref_qmi_to_cm((uint16)req_msg->ciot_lte_op_mode_pref);
      }

      if (req_msg->lte_m1_band_pref_valid)
      {
        memset(&ciot_lte_pref.lte_m1_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
        memscpy(&ciot_lte_pref.lte_m1_band_pref, sizeof(uint64), &req_msg->lte_m1_band_pref, sizeof(uint64));
      }
      else if (req_msg->lte_m1_band_pref_ext_valid)
      {
        memset(&ciot_lte_pref.lte_m1_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
        memscpy(&ciot_lte_pref.lte_m1_band_pref, sizeof(sys_lte_band_mask_e_type), &req_msg->lte_m1_band_pref_ext, sizeof(sys_lte_band_mask_e_type));
      }

      if (req_msg->lte_nb1_band_pref_valid)
      {
        memset(&ciot_lte_pref.lte_nb1_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
        memscpy(&ciot_lte_pref.lte_nb1_band_pref, sizeof(uint64), &req_msg->lte_nb1_band_pref, sizeof(uint64));
      }
      else if (req_msg->lte_nb1_band_pref_ext_valid)
      {
        memset(&ciot_lte_pref.lte_nb1_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
        memscpy(&ciot_lte_pref.lte_nb1_band_pref, sizeof(sys_lte_band_mask_e_type), &req_msg->lte_nb1_band_pref_ext, sizeof(sys_lte_band_mask_e_type));
      }

      #endif
      
      if ( errval == QMI_ERR_NONE_V01 )
      {
        #ifndef FEATURE_CIOT
          if ( asubs_id == SYS_MODEM_AS_ID_1 )
          {
          retval = cm_ph_cmd_get_networks_extn(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref, band_pref, lte_band_pref, tds_band_pref);
          }
          #ifdef FEATURE_DUAL_SIM
          else if ( asubs_id == SYS_MODEM_AS_ID_2
          #ifdef FEATURE_TRIPLE_SIM
                    || ( asubs_id == SYS_MODEM_AS_ID_3 )
          #endif
                  )
          {
          retval = cm_ph_cmd_get_networks_per_subs_extn(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref, asubs_id, band_pref, lte_band_pref, tds_band_pref );
          }
          #endif
        #else
        retval = cm_ph_cmd_get_networks_per_subs_ciot(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref, 
                        asubs_id, band_pref, lte_band_pref, tds_band_pref, ciot_lte_pref);
        #endif
      }

      if ( retval )
      {
        qm_cbpq_add ( QM_CBPQ_QTYPE_NW_SCAN, cmd_buf_p, ( (qmi_nasi_client_state_type *) cl_sp)->clnt );

        QM_MSG_HIGH("Starting Net Scan, waiting for response");
        qmi_nasi_global.net_scan_started  = TRUE;
        #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
        qmi_nasi_global.net_scan_asubs_id = asubs_id;
        #endif
        qmi_nasi_global.net_scan_type = list_type;
        #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;
        #endif
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = (dsm_item_type*) QMI_SVC_RESPONSE_PENDING;
    // shall react to CM_PH_CMD_GET_NETWORKS and CM_PH_EVENT_AVAILABLE_NETWORKS_CONF later
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_perform_network_scan_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_perform_network_scan() */

#ifndef REMOVE_QMI_NAS_INITIATE_NETWORK_REGISTER_V01
/*===========================================================================
  FUNCTION QMI_NASI_INITIATE_NETWORK_REGISTER()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_initiate_network_register (
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  struct nas_0022_req_s      req_msg;
  cm_cmd_user_pref_update_type  *user_pref_ptr;

  cm_network_sel_mode_pref_e_type  net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_NO_CHANGE;
  cm_mode_pref_e_type              cm_mode_pref = CM_MODE_PREF_NONE;
  cm_pref_term_e_type              cm_term_pref = CM_PREF_TERM_PWR_CYCLE;
  sys_plmn_id_s_type               plmn, *plmn_ptr = NULL;
  boolean                          register_req = FALSE;
  qmi_error_e_type                 errval = QMI_ERR_NONE;

  sys_modem_as_id_e_type           asubs_id = SYS_MODEM_AS_ID_1;
  mmgsdi_session_type_enum_type    session;
  boolean                          mnc_includes_pcs_digit;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
   QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#endif

  if ( errval == QMI_ERR_NONE )
  {
    #ifdef FEATURE_DUAL_SIM
    session = asubs_id == SYS_MODEM_AS_ID_1 ? MMGSDI_GW_PROV_PRI_SESSION : MMGSDI_GW_PROV_SEC_SESSION;
    #else
    session = MMGSDI_GW_PROV_PRI_SESSION;
    #endif

    if ( qmi_nasi_global.mmgsdi->operation_ready[session] == FALSE )
    {
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    memset( &req_msg, 0x00, sizeof(struct nas_0022_req_s) );

    errval = qmi_nas_0022_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0022_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( req_msg.t11.change_duration == QMI_NAS_CHANGE_DURATION_POWER_CYCLE )
    {
      cm_term_pref = CM_PREF_TERM_PWR_CYCLE;
    }
    else if ( req_msg.t11.change_duration == QMI_NAS_CHANGE_DURATION_PERMANENT )
    {
      cm_term_pref = CM_PREF_TERM_PERMANENT;
    }

    switch ( req_msg.t01.register_action )
    {
      case QMI_NAS_REGISTER_ACTION_AUTOMATIC:
          register_req = TRUE;
          net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
          cm_mode_pref = CM_MODE_PREF_DIGITAL_ONLY;
        break;

      case QMI_NAS_REGISTER_ACTION_MANUAL:
        // Process MNC 3rd digit include status
        if ( req_msg.t12_valid )
        {
          mnc_includes_pcs_digit = req_msg.t12.mnc_includes_pcs_digit;

          if ( req_msg.t10.mobile_network_code>99 && mnc_includes_pcs_digit == FALSE)
          {
            errval = QMI_ERR_INVALID_ARG;
          }
        }
        else
        {
          mnc_includes_pcs_digit = req_msg.t10.mobile_network_code>99 ? TRUE : FALSE;
        }

        if( errval == QMI_ERR_NONE )
        {
          if ( !sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit, req_msg.t10.mobile_country_code, req_msg.t10.mobile_network_code, &plmn) )
          {
            errval = QMI_ERR_INVALID_ARG;
          }
          else
          {
            register_req = TRUE;
            net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL;
            plmn_ptr = &plmn;

            switch ( req_msg.t10.radio_access_technology )
            {
              case QMI_NAS_RADIO_IF_GSM:
                if (TARGET_SUPPORTS_GSM) {
                  cm_mode_pref = CM_MODE_PREF_GSM_ONLY;
                }
                break;
              #if defined(FEATURE_WCDMA)
              case QMI_NAS_RADIO_IF_UMTS:
                if (TARGET_SUPPORTS_WCDMA) {
                  cm_mode_pref = CM_MODE_PREF_WCDMA_ONLY;
                }
                break;
              #endif

              case QMI_NAS_RADIO_IF_LTE:
                if (TARGET_SUPPORTS_LTE) {
                  cm_mode_pref = CM_MODE_PREF_LTE_ONLY;
                }
                break;

              case QMI_NAS_RADIO_IF_NO_CHANGE:
                cm_mode_pref = CM_MODE_PREF_NO_CHANGE;
                break;

              default:
                break;
            }

            if ( cm_mode_pref == CM_MODE_PREF_NONE )
            {
              errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
            }
          }
        }
        break;

      default:
        errval = QMI_ERR_INVALID_REGISTER_ACTION;
        break;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( register_req == TRUE )
    {
      boolean ret_val = FALSE;

      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        user_pref_ptr = (cm_cmd_user_pref_update_type*)cm_mem_malloc(sizeof(cm_cmd_user_pref_update_type));
        cm_user_pref_init( user_pref_ptr);
        user_pref_ptr->plmn_ptr = plmn_ptr;
        user_pref_ptr->client_id = qmi_nasi_global.cm_clnt_id;
        user_pref_ptr->mode_pref = cm_mode_pref;
        user_pref_ptr->pref_term = cm_term_pref;
        user_pref_ptr->pref_duration = 0;
        user_pref_ptr->network_sel_mode_pref = net_sel_mode_pref;
        ret_val = cm_user_pref_update_req( user_pref_ptr,
                                           qmi_nas_cmph_cmd_cb,
                                           (void *)cmd_buf_p
                                         );
      }
#ifdef FEATURE_DUAL_SIM
      else if ( asubs_id == SYS_MODEM_AS_ID_2 )
      {
        ret_val = cm_ph_cmd_sys_sel_pref_per_subs( qmi_nas_cmph_cmd_cb,
                                                   (void *)cmd_buf_p,
                                                   qmi_nasi_global.cm_clnt_id,
                                                   asubs_id,
                                                   cm_mode_pref,
                                                   cm_term_pref,
                                                   0,
                                                   CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                   CM_BAND_PREF_NO_CHANGE,
                                                   CM_PRL_PREF_NO_CHANGE,
                                                   CM_ROAM_PREF_NO_CHANGE,
                                                   CM_HYBR_PREF_NO_CHANGE,
                                                   CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                   net_sel_mode_pref,
                                                   plmn_ptr );
      }
#endif

      QM_MSG_HIGH_1("init_net_reg ret_val %d",ret_val);
      if ( ret_val )
      {        
        return QMI_SVC_RESPONSE_PENDING;
      }
      else
      {
        errval = QMI_ERR_NO_EFFECT;
      }
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_0022_rsp_s rsp_msg;

    memset( &rsp_msg, 0x00, sizeof(struct nas_0022_rsp_s) );

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_0022_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
} /* qmi_nasi_initiate_network_register() */
#endif 

#ifndef REMOVE_QMI_NAS_INITIATE_ATTACH_V01
/*===========================================================================
  FUNCTION QMI_NASI_INITIATE_ATTACH()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_initiate_attach
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_error_e_type           errval    = QMI_ERR_NONE;
  cm_srv_domain_pref_e_type  srv_domain_pref = CM_SRV_DOMAIN_PREF_NO_CHANGE;
  cm_srv_domain_pref_e_type  curr_srv_domain_pref = CM_SRV_DOMAIN_PREF_NO_CHANGE;
  struct nas_0023_req_s      req_msg;
  cm_cmd_user_pref_update_type  *user_pref_ptr;

  sys_modem_as_id_e_type     asubs_id = SYS_MODEM_AS_ID_1;
  mmgsdi_session_type_enum_type    session;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
  QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( !TARGET_SUPPORTS_GSM && !TARGET_SUPPORTS_WCDMA && !TARGET_SUPPORTS_LTE )
  {
    errval = QMI_ERR_OP_NETWORK_UNSUPPORTED;
  }

  if (errval == QMI_ERR_NONE)
  {
    memset(&req_msg, 0, sizeof(req_msg));

    errval = qmi_nas_0023_req_read(&req_msg, sdu_in);
  }

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0023_req_check(&req_msg);
  }

  if ( errval == QMI_ERR_NONE )
  {
  
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
      curr_srv_domain_pref = qmi_nasi_global.cm_ph_info2.srv_domain_pref;
    }
    else
#endif
    {
      curr_srv_domain_pref = qmi_nasi_global.cm_ph_info.srv_domain_pref;
    }
    QM_MSG_HIGH_1("curr_srv_domain_pref:%d", curr_srv_domain_pref);
  }

  if ( errval == QMI_ERR_NONE )
  {
    #ifdef FEATURE_DUAL_SIM
    session = asubs_id == SYS_MODEM_AS_ID_1 ? MMGSDI_GW_PROV_PRI_SESSION : MMGSDI_GW_PROV_SEC_SESSION;
    #else
        session = MMGSDI_GW_PROV_PRI_SESSION;
    #endif

    if ( qmi_nasi_global.mmgsdi->operation_ready[session] == FALSE )
    {
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      QM_MSG_HIGH("QMI_ERR_SIM_NOT_INITIALIZED");
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    if(req_msg.t10_valid)
    {
      QM_MSG_HIGH_1("ps_attach_action:%d", req_msg.t10.ps_attach_action);
      switch(req_msg.t10.ps_attach_action)
      {
        case NASI_PS_ATTACHED:
          if ( curr_srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS ||
               curr_srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY )
          {
            errval = QMI_ERR_NO_EFFECT;
          }
          else
          {
            srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_ATTACH;
          }
          break;

        case NASI_PS_DETACHED:
          if ( curr_srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_ONLY &&
               curr_srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_PS )
          {
            errval = QMI_ERR_NO_EFFECT;
          }
          else
          {
            srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_DETACH;
          }
          break;

        default:
          //should never occur
          errval = QMI_ERR_INVALID_PS_ATTACH_ACTION;
      }
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    if (req_msg.t10_valid == TRUE)
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        user_pref_ptr = (cm_cmd_user_pref_update_type*)cm_mem_malloc(sizeof(cm_cmd_user_pref_update_type));
        cm_user_pref_init( user_pref_ptr);
        user_pref_ptr->plmn_ptr = NULL;
        user_pref_ptr->client_id = qmi_nasi_global.cm_clnt_id;
        user_pref_ptr->pref_term = CM_PREF_TERM_PWR_CYCLE;
        user_pref_ptr->pref_duration = 0;
        user_pref_ptr->srv_domain_pref = srv_domain_pref;
        if(!cm_user_pref_update_req( user_pref_ptr,
                                    qmi_nas_cmph_cmd_cb,
                                    (void *)cmd_buf_p
                                   ))
        {
        errval = QMI_ERR_NO_EFFECT;
        }
      }
#ifdef FEATURE_DUAL_SIM
      else if ( asubs_id == SYS_MODEM_AS_ID_2 )
      {
        if (!cm_ph_cmd_sys_sel_pref_per_subs( qmi_nas_cmph_cmd_cb,
                                              (void *)cmd_buf_p,
                                              qmi_nasi_global.cm_clnt_id,
                                              asubs_id,
                                              CM_MODE_PREF_NO_CHANGE,
                                              CM_PREF_TERM_PWR_CYCLE,
                                              0,
                                              CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                              CM_BAND_PREF_NO_CHANGE,
                                              CM_PRL_PREF_NO_CHANGE,
                                              CM_ROAM_PREF_NO_CHANGE,
                                              CM_HYBR_PREF_NO_CHANGE,
                                              srv_domain_pref,
                                              CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                              NULL))
        {
          errval = QMI_ERR_NO_EFFECT;
        }
      }
#endif
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    QM_MSG_HIGH("Response pending for NAS Attach");
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( qmi_svc_put_result_tlv(&response, QMI_RESULT_FAILURE, errval) == FALSE )
    {
      dsm_free_packet(&response);
      response = NULL;
    }
  }

  return response;
} /* qmi_nasi_initiate_attach() */
#endif
#ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_SERVING_SYSTEM()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_serving_system
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;

  qmi_error_type_v01                    errval           = QMI_ERR_NONE_V01;

  nas_get_serving_system_resp_msg_v01 * rsp_msg;

  cm_mm_ss_info_s_type *p_ss_info = &qmi_nasi_global.cm_ss_info[0];
  qmi_cm_ph_info_s_type        *p_ph_info = &qmi_nasi_global.cm_ph_info;
  mmgsdi_session_id_type    session_id;

  enum qm_stack_index_e stack          = STACK_INDEX_0;
  sys_sys_id_s_type         sys_id         = p_ss_info->sys_id;
  sys_mm_information_s_type mm_information = p_ss_info->mm_information;
  sys_lac_type              lac            = qmi_nas_get_lac( p_ss_info );
  sys_lac_type              lac_tac        = p_ss_info->sys_mode == SYS_SYS_MODE_LTE ? p_ss_info->tac : qmi_nas_get_lac( p_ss_info );
  sys_cell_id_type          cell_id        = p_ss_info->cell_info.cell_id;
  uint16                    psc            = p_ss_info->cell_info.psc;
  sys_dtm_support_e_type    dtm_supp       = p_ss_info->cell_srv_ind.dtm_supp;
  sys_srv_status_e_type     srv_status     = p_ss_info->srv_status;
  sys_srv_domain_e_type     srv_capability = p_ss_info->srv_capability;
  boolean                   is_sys_forbidden = p_ss_info->plmn_forbidden;
  mmgsdi_session_type_enum_type session    = MMGSDI_GW_PROV_PRI_SESSION;
  sys_domain_access_bar_s_type  cell_access_info = p_ss_info->cell_access_info;
  mmgsdi_session_get_operator_name_info_type *operator_name_info_ptr=NULL;
  mmgsdi_plmn_id_list_type      plmn_id_list;
  mmgsdi_plmn_id_type       plmn_id;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg = (nas_get_serving_system_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_serving_system_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset(rsp_msg, 0x00, sizeof(nas_get_serving_system_resp_msg_v01));
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !qmi_nasi_global.rcvd_ss_info )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    rsp_msg->serving_system.registration_state = qmi_nas_get_reg_state( p_ss_info, p_ph_info );
    rsp_msg->serving_system.cs_attach_state    = (uint8) qmi_nas_get_cs_attach_state( p_ss_info );
    rsp_msg->serving_system.ps_attach_state    = (uint8) qmi_nas_get_ps_attach_state( p_ss_info );
    rsp_msg->serving_system.selected_network   = (uint8) qmi_nas_get_reg_network( p_ss_info );
    rsp_msg->serving_system.radio_if_len       = (uint8) qmi_nas_get_in_use_radio_if( p_ss_info, &rsp_msg->serving_system.radio_if[0] );

    if ( p_ss_info->srv_status != SYS_SRV_STATUS_NO_SRV && p_ss_info->srv_status != SYS_SRV_STATUS_PWR_SAVE )
    {
      rsp_msg->roaming_indicator       = qmi_nas_get_roaming_indicator( p_ss_info );
      if ( (uint8)rsp_msg->roaming_indicator != (uint8)SYS_ROAM_STATUS_UNKNOWN )
      {
        rsp_msg->roaming_indicator_valid = TRUE;
      }
    } // TLV 10 (roaming indicator)

    rsp_msg->data_capabilities_valid = TRUE;
    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      rsp_msg->data_capabilities_len   = (uint8) qmi_nas_get_data_capability( p_ss_info, &rsp_msg->data_capabilities[0] );
    }
    else
    {
      rsp_msg->data_capabilities_len   = 0;
    }// TLV 11 (Data Service Capability)

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
    if ( srv_status ==  SYS_SRV_STATUS_SRV     ||
         srv_status ==  SYS_SRV_STATUS_LIMITED ||
         srv_status ==  SYS_SRV_STATUS_LIMITED_REGIONAL )
    {
      sys_plmn_id_s_type plmn;
      sys_mcc_type       mcc;
      sys_mnc_type       mnc;
      boolean            plmn_undefined, plmn_includes_pcs_digit_ptr;

      if ( sys_id.id_type == SYS_SYS_ID_TYPE_UMTS )
      {
        plmn = sys_id.id.plmn;

        sys_plmn_get_mcc_mnc( plmn, &plmn_undefined, &plmn_includes_pcs_digit_ptr, &mcc, &mnc );

        (void) hput16( (byte *) &rsp_msg->current_plmn.mobile_country_code, (uint16) mcc);
        (void) hput16( (byte *) &rsp_msg->current_plmn.mobile_network_code, (uint16) mnc);
        (void) hput16( (byte *) &rsp_msg->mnc_includes_pcs_digit.mcc,       (uint16) mcc);       // T27
        (void) hput16( (byte *) &rsp_msg->mnc_includes_pcs_digit.mnc,       (uint16) mnc);       // T27
        rsp_msg->mnc_includes_pcs_digit.mnc_includes_pcs_digit = plmn_includes_pcs_digit_ptr;    // T27
 
        if ( !plmn_undefined )
        {
          plmn_id_list.num_of_plmn_ids = 1;
          memscpy(&plmn_id.plmn_id_val, sizeof(plmn_id.plmn_id_val), 
                  &plmn.identity, sizeof(plmn_id.plmn_id_val));
          plmn_id.csg_id = SYS_CSG_ID_INVALID;
          plmn_id_list.plmn_list_ptr = &plmn_id;
          operator_name_info_ptr=(mmgsdi_session_get_operator_name_info_type*)modem_mem_alloc(sizeof(mmgsdi_session_get_operator_name_info_type), MODEM_MEM_CLIENT_QMI_MMODE);
          if ( operator_name_info_ptr == NULL )
          {
            qmi_voice_mem_error();
            modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); 
            return NULL;
          }

          memset(operator_name_info_ptr, 0, sizeof(mmgsdi_session_get_operator_name_info_type));
            
          /*Allocate memory for PLMN List*/
          operator_name_info_ptr->plmn_info_ptr=(mmgsdi_plmn_info_static_type*)modem_mem_alloc((plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)), MODEM_MEM_CLIENT_QMI_MMODE);

          if ( operator_name_info_ptr->plmn_info_ptr == NULL )
          {
            qmi_voice_mem_error();
            modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); 
            modem_mem_free((void *)operator_name_info_ptr,MODEM_MEM_CLIENT_QMI_MMODE);
            return NULL;
          }
          
            memset(operator_name_info_ptr->plmn_info_ptr, 0, (plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)));
          
            if( cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id)== CM_MMGSDI_SUCCESS
            &&
            MMGSDI_SUCCESS == mmgsdi_session_get_operator_name_ext_sync( session_id,
                                                                              plmn_id_list,
                                                                              MMGSDI_EONS_IGNORE_DISPLAY_COND_NONE,
                                                                              operator_name_info_ptr))
            {
               memscpy( rsp_msg->current_plmn.network_description,
                     operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len,
                     operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data,
                     operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len);
            }

             modem_mem_free( (void *) operator_name_info_ptr->plmn_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
             modem_mem_free( (void *) operator_name_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
          
             rsp_msg->current_plmn_valid           = TRUE;
             rsp_msg->mnc_includes_pcs_digit_valid = TRUE;    // T27
           }
          }
    } // TLV 12 (Current PLMN)
#endif
    #ifdef FEATURE_MMODE_3GPP2
    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
        {
          rsp_msg->cdma_system_id.sid   = p_ss_info->stack_info[stack].sys_id.id.is95.sid;
          rsp_msg->cdma_system_id.nid   = p_ss_info->stack_info[stack].sys_id.id.is95.nid;
          rsp_msg->cdma_system_id_valid = TRUE;
        }
      }
    } // TLV 13 (CDMA System ID)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
        {
          rsp_msg->cdma_base_station_info.base_id   = p_ss_info->stack_info[stack].mode_info.cdma_info.base_id;
          rsp_msg->cdma_base_station_info.base_lat  = p_ss_info->stack_info[stack].mode_info.cdma_info.base_lat;
          rsp_msg->cdma_base_station_info.base_long = p_ss_info->stack_info[stack].mode_info.cdma_info.base_long;
          rsp_msg->cdma_base_station_info_valid     = TRUE;
        }
      }
    } // TLV 14 (CDMA Base Station Information)

    rsp_msg->roaming_indicator_list_len = qmi_nas_get_roaming_ind_list( p_ss_info, &rsp_msg->roaming_indicator_list[0] );

    if ( rsp_msg->roaming_indicator_list_len > 0 )
    {
      rsp_msg->roaming_indicator_list_valid = TRUE;
    } // TLV 15 (Roaming Indicator List)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
             #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
             || qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
             #endif
             )
        {
          rsp_msg->def_roam_ind       = qmi_nas_get_def_roam_ind( p_ss_info );
          rsp_msg->def_roam_ind_valid = TRUE;
        }
      }
    } // TLV 16 (Default Roaming Indicator)


    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
             #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
             || qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
             #endif
             )
        {
          if ( qmi_nasi_include_3GPP2_time_zone( &rsp_msg->nas_3gpp_time_zone.lp_sec, &rsp_msg->nas_3gpp_time_zone.ltm_offset, &rsp_msg->nas_3gpp_time_zone.daylt_savings, p_ss_info ) )
          {
            rsp_msg->nas_3gpp_time_zone_valid = TRUE;
          }
        }
      }
    } // TLV 17 (3GPP2 Time Zone)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
        {
          rsp_msg->p_rev_in_use       = p_ss_info->stack_info[stack].mode_info.cdma_info.p_rev_in_use;
          rsp_msg->p_rev_in_use_valid = TRUE;
        }
      }
    } // TLV 18 (CDMA P_Rev In Use)
    #endif

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           #if defined(FEATURE_WCDMA)
           qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
           #endif
           qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        if ( mm_information.time_zone_avail )
        {
          rsp_msg->time_zone       = (int8) mm_information.time_zone;
          rsp_msg->time_zone_valid = TRUE;
        }
      }
    } // TLV 1A (3GPP Time Zone)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           #if defined(FEATURE_WCDMA)
           qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
           #endif
           qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        if ( mm_information.daylight_saving_adj_avail )
        {
          rsp_msg->adj       = mm_information.daylight_saving_adj;
          rsp_msg->adj_valid = TRUE;
        }
      }
    } // TLV 1B (3GPP Network Daylight Saving Adjustment)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           #if defined(FEATURE_WCDMA)
           qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
           #endif
           qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        if( lac != QMI_NAS_INVALID_LAC )
        {
          rsp_msg->lac       = lac;
          rsp_msg->lac_valid = TRUE;
        }
      }
    } // TLV 1C (Location Area Code)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           #if defined(FEATURE_WCDMA)
           qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
           #endif
           qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        rsp_msg->cell_id       = cell_id;
        rsp_msg->cell_id_valid = TRUE;
      }
    } // TLV 1D (3GPP Cell ID)

#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))

#if defined (FEATURE_IS2000_REL_A_SVD)
    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
             #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
             || qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
             #endif
             )
        {
          rsp_msg->ccs       = p_ss_info->stack_info[stack].mode_info.cdma_info.ccs_supported;
          rsp_msg->ccs_valid = TRUE;
        }
      }
    } // TLV 1E (Concurrent Service Info)
#endif

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
             #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
             || qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO
             #endif
             )
        {
          rsp_msg->prl_ind       = p_ss_info->stack_info[stack].is_sys_prl_match;
          rsp_msg->prl_ind_valid = TRUE;
        }
      }
    } // TLV 1F (PRL indicator)
#endif
    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM )
      {
        rsp_msg->dtm_ind = dtm_supp;
        rsp_msg->dtm_ind_valid   = TRUE;
      }
    } // TLV 20 (Dual Transfer Mode (DTM) Indication (GSM Only))

    {
      rsp_msg->detailed_service_info.srv_status       = srv_status;
      rsp_msg->detailed_service_info.srv_capability   = srv_capability;
      #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
      if( p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR )
      {
        rsp_msg->detailed_service_info.hdr_srv_status   = p_ss_info->stack_info[STACK_INDEX_1].srv_status;
        rsp_msg->detailed_service_info.hdr_hybrid       = p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_hybrid;
      }
      #endif
      rsp_msg->detailed_service_info.is_sys_forbidden = is_sys_forbidden;

      rsp_msg->detailed_service_info_valid = TRUE;
    } // TLV 21 (Detailed Service Information)

#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
        {
          rsp_msg->cdma_system_id_ext.mcc        = p_ss_info->stack_info[stack].sys_id.id.is95.mcc;
          rsp_msg->cdma_system_id_ext.imsi_11_12 = p_ss_info->stack_info[stack].sys_id.id.is95.imsi_11_12;
          rsp_msg->cdma_system_id_ext_valid      = TRUE;
        }
      }
    } // TLV 22 (CDMA System Info - ext)

    #if defined(FEATURE_HDR)
    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->hdr_personality       = (uint8) qmi_nas_cm_2_qmi_hdr_personality( p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_personality );
          rsp_msg->hdr_personality_valid = TRUE;
        }
        else if( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->hdr_personality       = (uint8) qmi_nas_cm_2_qmi_hdr_personality( p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_personality );
          rsp_msg->hdr_personality_valid = TRUE;
        }
      }
    } // TLV 23 (HDR Personality)
   #endif
#endif
    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        rsp_msg->tac       = p_ss_info->tac;
        rsp_msg->tac_valid = TRUE;
      }
    } // TLV 24 (Tracking Area Code (TAC) Information for LTE)

    if ( srv_status != SYS_SRV_STATUS_PWR_SAVE &&
         srv_status != SYS_SRV_STATUS_NO_SRV )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_GSM 
           #if defined(FEATURE_WCDMA)
           || qmi_nas_sys_mode_2_radio_if(p_ss_info,TRUE) == QMI_NAS_RADIO_IF_UMTS 
           #endif
         )
      {
        if( (cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY) &&
            (cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS) )
        {
          rsp_msg->call_barring_status.cs_bar_status = (uint32) cell_access_info.cs_bar_status;
        }
        else
        {
          rsp_msg->call_barring_status.cs_bar_status = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
        if( (cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY) &&
            (cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS) )
        {
          rsp_msg->call_barring_status.ps_bar_status = (uint32) cell_access_info.ps_bar_status;
        }
        else
        {
          rsp_msg->call_barring_status.ps_bar_status = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
        rsp_msg->call_barring_status_valid = TRUE;
      }
    } // TLV 25 (Call Barring Status)

    #if defined(FEATURE_WCDMA)
    if ( qmi_nas_sys_mode_2_radio_if( p_ss_info, FALSE ) == QMI_NAS_RADIO_IF_UMTS && psc != 0xFFFF )
    {
      rsp_msg->umts_psc       = psc;
      rsp_msg->umts_psc_valid = TRUE;
    } // TLV 26 (UMTS Primary Scrambling Code (PSC))

    // TLV 27 (MNC PCS Digit Include Status)
    // Scattered above, see:
    //   rsp_msg->mnc_includes_pcs_digit.mcc
    //   rsp_msg->mnc_includes_pcs_digit.mnc
    //   rsp_msg->mnc_includes_pcs_digit.mnc_includes_pcs_digit
    //   rsp_msg->mnc_includes_pcs_digit_valid

    if (  qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,FALSE) == QMI_NAS_RADIO_IF_UMTS )
    {
      rsp_msg->hs_call_status       = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack].cell_srv_ind.hs_call_status;
      rsp_msg->hs_call_status_valid = TRUE;
    } // TLV 28 (HS Call Status)
    #endif
  } // end-if ( errval == QMI_ERR_NONE_V01 )

  if ( rsp_msg == NULL )
  {
    QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_GET_SERVING_SYSTEM response.  %d", errval);
  }
  else if ( cmd_buf_p != NULL )
  {
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_serving_system_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

#if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
/*===========================================================================
  FUNCTION qmi_nasi_include_3GPP2_time_zone()

  DESCRIPTION
    Gives the current cdma system informations like Base station information
    and 3GPP2 timezone.

  PARAMETERS
    Pointers to lp_sec, ltm_offset, and daylt_savings to be returned

  RETURN VALUE
     boolean:
         TRUE if CDMA or HDR
         FALSE otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nasi_include_3GPP2_time_zone
(
  uint8 *lp_sec,
  int8  *ltm_offset,
  uint8 *daylt_savings,
  cm_mm_msim_ss_info_s_type *p_ss_info
)
{
  boolean is_cdma_or_hdr = FALSE;

  if ( lp_sec == NULL || ltm_offset == NULL || daylt_savings == NULL)
  {
    return FALSE;
  }
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
     CDMA time is reported in 30minute increments.
     Convert units to minutes and return in the tlv.
  */
  if( SYS_SYS_MODE_CDMA == p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.sys_mode )
  {
    *lp_sec = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.lp_sec;

    *ltm_offset = QMI_NAS_6BIT_2_8BIT( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.ltm_offset );

    // cdma ltm_offset is already in increments of 30 min
    *daylt_savings = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.daylt_savings;

    is_cdma_or_hdr = TRUE;
  }
  else if( SYS_SYS_MODE_HDR == p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.sys_mode )
  {
    *lp_sec = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.hdr_time.lp_sec;

    *ltm_offset = (uint8)(p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.hdr_time.ltm_offset/30);

    /* for HDR day light saving is always off */
    *daylt_savings = (uint8) (0x00FF & SYS_DAYLT_SAVINGS_OFF);

    is_cdma_or_hdr = TRUE;
  }

  return is_cdma_or_hdr;
}
#endif
#endif
/*===========================================================================
  FUNCTION QMI_NASI_GET_HOME_NETWORK()

  DESCRIPTION
    Returns a list of HOME network providers.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_home_network
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type          *response      = NULL;
  sys_plmn_id_s_type     home_plmn_id;
  boolean                mnc_includes_pcs_digit = FALSE;

  nas_get_home_network_resp_msg_v01  *resp_msg;

  qmi_error_e_type       errval = QMI_ERR_NONE;
  mmgsdi_session_id_type        session_id;
  mmgsdi_plmn_id_list_type      plmn_id_list;

  mmgsdi_eons_ignore_disp_cond_enum_type ignore_disp = MMGSDI_EONS_IGNORE_DISPLAY_COND_NONE;
  mmgsdi_session_get_operator_name_info_type *operator_name_info_ptr=NULL;
  boolean                is_plmn_undefined;
  uint8                  j;
  uint8                  plmn_name_short_encoding;
  uint32                 mcc,mnc;
  
  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);

    return NULL;
  }

  resp_msg = (nas_get_home_network_resp_msg_v01 *) 
  modem_mem_alloc( sizeof( nas_get_home_network_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if( resp_msg == NULL)
  {
    qmi_voice_mem_error();
    return NULL;
  }

  memset(resp_msg, 0, sizeof(nas_get_home_network_resp_msg_v01));

  if(cmmmgsdi_ptr()->sim_busy_status.is_sim_busy == TRUE)
  {
    QM_MSG_ERROR_1("Get Home network SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
  }

  {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
    if ( cm_ph_get_gw_subscription_source() == CM_CC_SUBSCRIPTION_SOURCE_NONE)
    {
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
    }

    if ( errval == QMI_ERR_NONE )
    {
      if ( !cmmmgsdi_read_imsi_hplmn(&home_plmn_id) )
      {
          errval = QMI_ERR_INTERNAL;
      }
      else
      {
        mmgsdi_plmn_id_type plmn;
        plmn_id_list.num_of_plmn_ids = 1;
        memscpy(&plmn.plmn_id_val, sizeof(plmn.plmn_id_val),
                &home_plmn_id.identity, sizeof(plmn.plmn_id_val) );
        plmn.csg_id = SYS_CSG_ID_INVALID;
        plmn.rat = MMGSDI_RAT_NONE;
        plmn_id_list.plmn_list_ptr = &plmn;

        if ( qm_efs_always_return_plmn() )
        {
          ignore_disp = MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND;
        }
        
        operator_name_info_ptr=(mmgsdi_session_get_operator_name_info_type*)modem_mem_alloc(sizeof(mmgsdi_session_get_operator_name_info_type), MODEM_MEM_CLIENT_QMI_MMODE);
        if( operator_name_info_ptr == NULL)
        {
           qmi_voice_mem_error();
           modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
           return NULL;
        }

        memset(operator_name_info_ptr, 0, sizeof(mmgsdi_session_get_operator_name_info_type));
        
        /*Allocate memory for PLMN List*/
        operator_name_info_ptr->plmn_info_ptr=(mmgsdi_plmn_info_static_type*)modem_mem_alloc((plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)), MODEM_MEM_CLIENT_QMI_MMODE);
        
        if( operator_name_info_ptr->plmn_info_ptr == NULL)
        {
           qmi_voice_mem_error();
           modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); 
           modem_mem_free((void *)operator_name_info_ptr,MODEM_MEM_CLIENT_QMI_MMODE);
           return NULL;
        }
        memset(operator_name_info_ptr->plmn_info_ptr, 0, (plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)));

        if( (cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id)!= CM_MMGSDI_SUCCESS) ||
                ( MMGSDI_SUCCESS != mmgsdi_session_get_operator_name_ext_sync( session_id,
                                                                              plmn_id_list,
                                                                              ignore_disp,
                                                                              operator_name_info_ptr) ))
        {
          errval = QMI_ERR_INTERNAL;
        }
        else
        {
          sys_plmn_get_mcc_mnc(
            home_plmn_id,
            &is_plmn_undefined,
            &resp_msg->nas_3gpp_mcs_include_digit.mnc_includes_pcs_digit,
            &mcc,
            &mnc
            );

          if(!is_plmn_undefined)
          {
            (void) hput16( (byte *) &resp_msg->home_network.mobile_country_code, (uint16) mcc );
            (void) hput16( (byte *) &resp_msg->home_network.mobile_network_code, (uint16) mnc );
          }
          
          resp_msg->nas_3gpp_mcs_include_digit_valid = TRUE;
          resp_msg->nas_3gpp_mcs_include_digit.is_3gpp_network = TRUE;
          
          {
            {
              QM_MSG_HIGH_2("get home network len %d, encoding %d", 
                  operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len, operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_encoding);
              for( j=0; j<operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len; j++ )
              {
                QM_MSG_HIGH_1("%d", operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data[j]);
              }
          
              if ( qm_efs_always_return_plmn() )
              {
                if ( !nasi_convert_mm_info_oper_name( operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data,
                                                     operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_encoding,
                                                     (char *) resp_msg->home_network.network_description,
                                                     (uint8 *)&plmn_name_short_encoding,
                                                     NAS_NETWORK_DESCRIPTION_MAX_V01,
                                                     (uint8)operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data_len ) )
          
                {
                  QM_MSG_ERROR("qmi_nasi_generate_get_home_network_resp: decoding failed, sending encoded name in response");
                  memscpy( resp_msg->home_network.network_description, operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data_len,
                           operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data, 
                           operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data_len );
                }
              }
              else
              {
                if ( !nasi_convert_mm_info_oper_name( operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data,
                                                     operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_encoding,
                                                     (char *) resp_msg->home_network.network_description,
                                                     (uint8 *)&plmn_name_short_encoding,
                                                     NAS_NETWORK_DESCRIPTION_MAX_V01,
                                                     (uint8)operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len ) )
          
                {
                  QM_MSG_ERROR("qmi_nasi_generate_get_home_network_resp: decoding failed, sending encoded name in response");
                  memscpy( resp_msg->home_network.network_description, operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len,
                         operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data, 
                         operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len );
                }
              }
          
              resp_msg->nas_3gpp_nw_name_source_valid = TRUE;
              resp_msg->nas_3gpp_nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( operator_name_info_ptr->plmn_info_ptr[0].plmn_name_source );
            }
          }
          
        }
      }
    }
 #endif // FEATURE_WCDMA || FEATURE_GSM
  }
  resp_msg->resp.error  = (qmi_error_type_v01)errval;
  resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t)cmd_buf_p->msg_id,
                                (void *) resp_msg,
                                (uint32_t) sizeof(nas_get_home_network_resp_msg_v01),
                                &response
                              );

  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  
  if(operator_name_info_ptr != NULL)
  {
    if(operator_name_info_ptr->plmn_info_ptr != NULL) 
    {
      modem_mem_free( (void *) operator_name_info_ptr->plmn_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
    }
  
    modem_mem_free( (void *) operator_name_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  return response;
} /* qmi_nasi_get_home_network() */
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
/*===========================================================================
  FUNCTION QMI_NASI_GET_PREFERRED_NETWORKS()

  DESCRIPTION
    Returns a list of preferred network providers.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_preferred_networks
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  boolean          retval;
  qmi_error_e_type errval = QMI_ERR_NONE;
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  mmgsdi_file_enum_type plmn_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_file_enum_type plmn_wact_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_file_enum_type oplmn_wact_filename = MMGSDI_NO_FILE_ENUM;
  #ifndef FEATURE_MMODE_DISABLE_UIM
  mmgsdi_access_type    file_access;
  uint16 read_data_len=0;
  #else
  mmgsdi_data_type mmgsdi_data;
  uint16           read_data_len=0;
  nas_get_preferred_networks_resp_msg_v01 *nas_get_pref_resp=NULL;
  #endif
  qmi_nas_mmgsdi_session_e_type session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_session_type_enum_type mmgsdi_session =  MMGSDI_GW_PROV_PRI_SESSION;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
  QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  /*-------------------------------------------------------------------------
    Operation not supported if device doesn't have WCDMA or GSM
    Operation works for multimode devices but will return only what
    is in the SIM ie GW
  -------------------------------------------------------------------------*/
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
  {
    QM_MSG_ERROR_1("Get Preferred network, SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
#ifdef FEATURE_DUAL_SIM
  if( bound_subs == QMI_NAS_SUBS_SECONDARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_SEC_SESSION;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if( bound_subs == QMI_NAS_SUBS_TERTIARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_TER_SESSION;
  }
#endif
#endif
  session = qmi_nas_map_mmgsdi_session_to_qmi(mmgsdi_session); 
  
  QM_MSG_HIGH_3("qmi_nasi_get_preferred_networks: mmgsdi_session:%d, session:%d, app_type:%d", mmgsdi_session, session, 
      qmi_nasi_global.mmgsdi->app_type[session]);
      
  if ( qmi_nasi_global.mmgsdi->operation_ready[session] == FALSE )
  {
    QM_MSG_HIGH_1("session:%d  is not ready", session);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  if ( qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_SIM)
  {
    plmn_filename       = MMGSDI_GSM_PLMN;
    plmn_wact_filename  = MMGSDI_GSM_PLMNWACT;
    oplmn_wact_filename = MMGSDI_GSM_OPLMNWACT;
  }
  else if ( qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_USIM)
  {
    plmn_wact_filename  = MMGSDI_USIM_PLMNWACT;
    oplmn_wact_filename = MMGSDI_USIM_OPLMNWACT;
  }
  else
  {
    QM_MSG_HIGH_1("app_type:%d  not supported", qmi_nasi_global.mmgsdi->app_type[session]);
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }
  #ifndef FEATURE_MMODE_DISABLE_UIM
  /* Queue the command buffer to send response later */
  qm_cbpq_add ( QM_CBPQ_QTYPE_GET_PREF, cmd_buf_p, ((qmi_nasi_client_state_type *)cl_sp)->clnt );
  #endif
  if ( !qmi_nasi_global.get_pref_nwks_req_pending )
  {
    #ifndef FEATURE_MMODE_DISABLE_UIM
    file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
    file_access.file.file_enum = plmn_wact_filename;

    if (qmi_nasi_global.mmgsdi_ef_info.plmn_wact == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND)
    {
      qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
      QM_MSG_HIGH("plmn_wact NOT_FOUND");
    }
    else
    #endif
    {
      QM_MSG_HIGH_1("Reading  plmn_wact_filename:%d", plmn_wact_filename);
      #ifndef FEATURE_MMODE_DISABLE_UIM
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_transparent( 
                                                              #ifndef FEATURE_MMODE_DISABLE_UIM
                                                              qmi_nasi_global.mmgsdi.session_id[session],
                                                              #else
                                                              qmi_nasi_global.mmgsdi->session_id[session],
                                                              #endif
                                                              file_access,
                                                              0,
                                                              sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_USER_PPLMN_LIST_MAX_LENGTH,
                                                              qmi_nas_mmgsdi_cmd_rsp_cb,
                                                              (uint32) cmd_buf_p) )
      {
        qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED;
      }
      #else
      mmgsdi_data.data_len = 0;
      mmgsdi_data.data_ptr = ( uint8 *) modem_mem_alloc( MMGSDI_MAX_DATA_BLOCK_LEN, MODEM_MEM_CLIENT_QMI_MMODE );
      if(mmgsdi_data.data_ptr!=NULL)
      {
        memset( mmgsdi_data.data_ptr, 0x00, MMGSDI_MAX_DATA_BLOCK_LEN );
      }
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_cache( 
                                                              #ifndef FEATURE_MMODE_DISABLE_UIM
                                                              qmi_nasi_global.mmgsdi.session_id[session],
                                                              #else
                                                              qmi_nasi_global.mmgsdi->session_id[session],
                                                              #endif
                                                              plmn_wact_filename,
                                                              mmgsdi_data))
      {
         qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED;
         read_data_len = (uint8) MIN( mmgsdi_data.data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_USER_PPLMN_LIST_MAX_LENGTH );
         qmi_nasi_global.pref_nw_scratch.plmn_wact_list_size = read_data_len / sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
         qmi_nasi_global.pref_nw_scratch.plmn_wact_list      = (qmi_nasi_mmgsdi_plmn_wact_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

          QM_MSG_HIGH_2("qmi_nasi_generate_get_preferred_nw_resp:PLMNWACT,  read_data_len%d,size:%d", read_data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type));

          if (qmi_nasi_global.pref_nw_scratch.plmn_wact_list == NULL)
          {
            errval = QMI_ERR_NO_MEMORY_V01;
            QM_MSG_MED("modem_mem_alloc is failed");
            goto send_result;
          }
          else
          {
            memscpy((void*)qmi_nasi_global.pref_nw_scratch.plmn_wact_list, read_data_len,
                    mmgsdi_data.data_ptr, read_data_len );
          }
      }
      #endif
      else
      {
        //mmgsdi_session_read_transparent failed
        errval = QMI_ERR_INTERNAL;
        goto send_result;
      }
    }
#ifndef FEATURE_MMODE_DISABLE_UIM
    file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
    file_access.file.file_enum = oplmn_wact_filename;

    if (qmi_nasi_global.mmgsdi_ef_info.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND)
    {
      qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
      QM_MSG_HIGH("oplmn_wact NOT_FOUND");
    }
    else
#endif
    {
      QM_MSG_HIGH_1("Reading  oplmn_wact_filename:%d", oplmn_wact_filename);
      #ifndef FEATURE_MMODE_DISABLE_UIM
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_transparent(
                                                              #ifndef FEATURE_MMODE_DISABLE_UIM
                                                              qmi_nasi_global.mmgsdi.session_id[session],
                                                              #else
                                                              qmi_nasi_global.mmgsdi->session_id[session],
                                                              #endif
                                                              file_access,
                                                              0,
                                                              sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_PLMN_LIST_MAX_LENGTH,
                                                              qmi_nas_mmgsdi_cmd_rsp_cb,
                                                              (uint32) cmd_buf_p) )
      {
        qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED;
      }
      #else
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_cache( 
                                                              #ifndef FEATURE_MMODE_DISABLE_UIM
                                                              qmi_nasi_global.mmgsdi.session_id[session],
                                                              #else
                                                              qmi_nasi_global.mmgsdi->session_id[session],
                                                              #endif
                                                              oplmn_wact_filename,
                                                              mmgsdi_data))
      {
        qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ;
        read_data_len = (uint8) MIN( mmgsdi_data.data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_PLMN_LIST_MAX_LENGTH );
        qmi_nasi_global.pref_nw_scratch.oplmn_wact_list_size = read_data_len / sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
        qmi_nasi_global.pref_nw_scratch.oplmn_wact_list = (qmi_nasi_mmgsdi_plmn_wact_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

        QM_MSG_MED_2("qmi_nasi_generate_get_preferred_nw_resp:OPLMNWACT,  read_data_len%d,size:%d", read_data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type));

        if (qmi_nasi_global.pref_nw_scratch.oplmn_wact_list == NULL)
        {
          errval = QMI_ERR_NO_MEMORY_V01;
          goto send_result;
        }
        else
        {
          memscpy( (void*)qmi_nasi_global.pref_nw_scratch.oplmn_wact_list, read_data_len,
          mmgsdi_data.data_ptr, mmgsdi_data.data_len );
        }
      }
      #endif
      else
      {
        //mmgsdi_session_read_transparent failed
        errval = QMI_ERR_INTERNAL;
        goto send_result;
      }
    }

    if (qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_SIM)
    {
      #ifndef FEATURE_MMODE_DISABLE_UIM
      file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
      file_access.file.file_enum = plmn_filename;

      if (qmi_nasi_global.mmgsdi_ef_info.plmn == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND)
      {
        qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
       QM_MSG_HIGH("plmn NOT_FOUND");
      }
      else
      #endif
      {
        QM_MSG_HIGH_1("Reading  plmn_filename:%d", plmn_filename);
        #ifndef FEATURE_MMODE_DISABLE_UIM
        if ( MMGSDI_SUCCESS == mmgsdi_session_read_transparent(
                                                                #ifndef FEATURE_MMODE_DISABLE_UIM
                                                                qmi_nasi_global.mmgsdi->session_id[session],
                                                                #else
                                                                qmi_nasi_global.mmgsdi->session_id[session],
                                                                #endif
                                                                file_access,
                                                                0,
                                                                sizeof(sys_plmn_id_s_type) * SYS_PLMN_LIST_MAX_LENGTH,
                                                                qmi_nas_mmgsdi_cmd_rsp_cb,
                                                                (uint32) cmd_buf_p) )
        {
          qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED;
        }
        #else
        if ( MMGSDI_SUCCESS == mmgsdi_session_read_cache( 
                                                              #ifndef FEATURE_MMODE_DISABLE_UIM
                                                              qmi_nasi_global.mmgsdi.session_id[session],
                                                              #else
                                                              qmi_nasi_global.mmgsdi->session_id[session],
                                                              #endif
                                                              plmn_filename,
                                                              mmgsdi_data))
        {
          qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ;

          read_data_len = (uint8) MIN( mmgsdi_data.data_len, sizeof(sys_plmn_id_s_type) * SYS_PLMN_LIST_MAX_LENGTH );
          qmi_nasi_global.pref_nw_scratch.plmn_list_size = read_data_len / sizeof(sys_plmn_id_s_type);
          qmi_nasi_global.pref_nw_scratch.plmn_list = (sys_plmn_id_s_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

          if (qmi_nasi_global.pref_nw_scratch.plmn_list == NULL)
          {
            errval = QMI_ERR_NO_MEMORY_V01;
            goto send_result;
          }
          else
          {
            memscpy((void*)qmi_nasi_global.pref_nw_scratch.plmn_list, read_data_len, 
                    mmgsdi_data.data_ptr, read_data_len );
          }
        }
        #endif
        else
        {
          //mmgsdi_session_read_transparent failed
          errval = QMI_ERR_INTERNAL;
          goto send_result;
        }
      }
    }
    #ifndef FEATURE_MMODE_DISABLE_UIM
    qmi_nasi_global.get_pref_nwks_req_pending = TRUE;
    QM_MSG_HIGH("Response pending for get preferred networks");
    qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_GET_PREF );
    #else

    nas_get_pref_resp = ( nas_get_preferred_networks_resp_msg_v01 * )modem_mem_alloc(sizeof(nas_get_preferred_networks_resp_msg_v01), MODEM_MEM_CLIENT_QMI);
    if( nas_get_pref_resp == NULL )
    {
      qmi_voice_mem_error();
      #ifndef FEATURE_MMODE_DISABLE_UIM
      while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_GET_PREF )) != NULL )
      {
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
      }
      #endif
    }
    else
    {
      qmi_nasi_global.get_pref_nwks_req_pending = FALSE;
      QM_MSG_HIGH("get_pref_nwks_req_pending is set to FALSE");
      qmi_nasi_populate_get_preferred_nw_resp( nas_get_pref_resp );
      nas_get_pref_resp->resp.error  = errval;
      nas_get_pref_resp->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
      #ifndef FEATURE_MMODE_DISABLE_UIM
      while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_GET_PREF )) != NULL )
      #endif
      {
        response = NULL;                                                                         // Important!  When multiple encode calls may be made.
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_RESPONSE,
                                                  (uint16_t)cmd_buf_p->msg_id,
                                                  (void *)nas_get_pref_resp,
                                                  (uint32_t)sizeof(nas_get_preferred_networks_resp_msg_v01),
                                                  &response
                                                ) )
        {
          if ( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
          {
            qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p) );
          }
        }
      }

      modem_mem_free((void *)nas_get_pref_resp, MODEM_MEM_CLIENT_QMI);
    }

    if (qmi_nasi_global.pref_nw_scratch.plmn_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    if (qmi_nasi_global.pref_nw_scratch.plmn_wact_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    if (qmi_nasi_global.pref_nw_scratch.oplmn_wact_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.oplmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }

    QM_MSG_HIGH_3("Resetting  pref_nw_scratch ptr_check pref_nw_scratch %d plmn_wact_list %d oplmn_wact_list %d",
          qmi_nasi_global.pref_nw_scratch.plmn_list == NULL, qmi_nasi_global.pref_nw_scratch.plmn_wact_list == NULL, qmi_nasi_global.pref_nw_scratch.oplmn_wact_list == NULL);
    memset(&qmi_nasi_global.pref_nw_scratch, 0, sizeof(qmi_nasi_global.pref_nw_scratch));
    #endif
  }
  else
  {
    QM_MSG_HIGH("Get preferred nwks already called with response pending.");
  }
  return QMI_SVC_RESPONSE_PENDING;
#else
  QM_MSG_HIGH("Unable to process GET_PREF_NWKS request: non-GSM non-WCDMA target");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
#else
  QM_MSG_HIGH("Unable to process GET_PREF_NWKS request: no MMGSDI support");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

send_result:
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  #ifndef FEATURE_MMODE_DISABLE_UIM
  (void) qm_cbpq_get( QM_CBPQ_QTYPE_GET_PREF );
  #endif
  if (qmi_nasi_global.pref_nw_scratch.plmn_list != NULL)
  {
    modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_list, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  if (qmi_nasi_global.pref_nw_scratch.plmn_wact_list != NULL)
  {
    modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  if (qmi_nasi_global.pref_nw_scratch.oplmn_wact_list != NULL)
  {
    modem_mem_free( qmi_nasi_global.pref_nw_scratch.oplmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  qmi_nasi_global.get_pref_nwks_req_pending = FALSE;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
  retval = qmi_svc_put_result_tlv(&response, QMI_RESULT_FAILURE, errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_get_preferred_networks() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_PREFERRED_NETWORKS()

  DESCRIPTION
    Sets the list of preferred network providers in the SIM/UIM to the list
    provided in the request.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_preferred_networks
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  qmi_error_e_type   errval;
  
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  nas_set_preferred_networks_req_msg_v01 *req_msg;

  mmgsdi_file_enum_type            plmn_wact_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_file_enum_type            plmn_filename = MMGSDI_NO_FILE_ENUM;
  qmi_nasi_mmgsdi_plmn_wact_type   preferred_networks_list[SYS_USER_PPLMN_LIST_MAX_LENGTH];
  sys_plmn_id_s_type               pref_plmn_list[SYS_USER_PPLMN_LIST_MAX_LENGTH];
  mmgsdi_write_data_type           plmn_data;

  uint32                            i;
  boolean                          mnc_includes_pcs_digit;
  mmgsdi_access_type               file_access;
  uint8                            file_num_recs;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
  qmi_nas_mmgsdi_session_e_type session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_session_type_enum_type mmgsdi_session =  MMGSDI_GW_PROV_PRI_SESSION;
  
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  response = NULL;
  errval = QMI_ERR_NONE;

  /*-------------------------------------------------------------------------
    Operation not supported if device doesn't have WCDMA or GSM
    Operation works for multimode devices but will return only wht
    is in the SIM ie GW
  -------------------------------------------------------------------------*/
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  req_msg = ( nas_set_preferred_networks_req_msg_v01 *) modem_mem_alloc( sizeof(nas_set_preferred_networks_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg  == NULL )
        {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
    ASSERT(req_msg);
          goto send_result;
        }

  memset (req_msg, 0x00, sizeof(nas_set_preferred_networks_req_msg_v01));

  // extract information from REQ message
  errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         sdu_in,
                                         (void *) req_msg,
                                         (uint32_t) sizeof(nas_set_preferred_networks_req_msg_v01)
                                       );
  if( errval != QMI_ERR_NONE )
    {
      goto send_result;
    }

  if(!req_msg->nas_3gpp_preferred_networks_valid)
  {
    errval = QMI_ERR_MISSING_ARG;
  }
  else
  {
    if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
    {
      QM_MSG_ERROR_1("Set Preferred network, SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      goto send_result;
    }

    bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
    
#ifdef FEATURE_DUAL_SIM
    if( bound_subs == QMI_NAS_SUBS_SECONDARY ) 
    {
      mmgsdi_session =  MMGSDI_GW_PROV_SEC_SESSION;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if( bound_subs == QMI_NAS_SUBS_TERTIARY ) 
    {
      mmgsdi_session =  MMGSDI_GW_PROV_TER_SESSION;
    }
#endif
#endif
    session = qmi_nas_map_mmgsdi_session_to_qmi(mmgsdi_session); 

    QM_MSG_HIGH_4("qmi_nasi_set_preferred_networks: mmgsdi_session:%d, session:%d app_type:%d, opr_session_ready %d", mmgsdi_session, session,
        qmi_nasi_global.mmgsdi->app_type[session], qmi_nasi_global.mmgsdi->operation_ready[session] );
    if ( qmi_nasi_global.mmgsdi->operation_ready[session] == FALSE )
    {
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      goto send_result;
    }

    if ( qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_SIM)
    {
      if (qmi_nasi_global.mmgsdi->cache[session].ef_plmnwact_valid == QMI_NAS_MMGSDI_VALID)
      {
        plmn_wact_filename = MMGSDI_GSM_PLMNWACT;
      }
      else if (qmi_nasi_global.mmgsdi->cache[session].ef_plmn_valid == QMI_NAS_MMGSDI_VALID)
      {
        plmn_filename = MMGSDI_GSM_PLMN;
      }
      else
      {
        QM_MSG_HIGH("SIM NOT_INITIALIZED");
        errval = QMI_ERR_SIM_NOT_INITIALIZED;
        goto send_result;
      }
    }
    else if ( qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_USIM)
    {
      if (qmi_nasi_global.mmgsdi->cache[session].ef_plmnwact_valid == QMI_NAS_MMGSDI_VALID)
      {
        plmn_wact_filename = MMGSDI_USIM_PLMNWACT;
      }
      else
      {
        QM_MSG_HIGH("USIM NOT_INITIALIZED");
        errval = QMI_ERR_SIM_NOT_INITIALIZED;
        goto send_result;
      }
    }
    else
    {
      QM_MSG_HIGH_1("app_type:%d  not supported", qmi_nasi_global.mmgsdi->app_type[session]);
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
      goto send_result;
    }

    QM_MSG_HIGH_2("plmn_wact_filename:%d, plmn_filename:%d", plmn_wact_filename, plmn_filename);

    if ( req_msg->nas_3gpp_mnc_includes_pcs_digit_valid 
         &&  req_msg->nas_3gpp_preferred_networks_len != req_msg->nas_3gpp_mnc_includes_pcs_digit_len )
    {
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    for(i=0; i<req_msg->nas_3gpp_preferred_networks_len; i++)
    {
      if ( req_msg->nas_3gpp_mnc_includes_pcs_digit_valid )
      {
        mnc_includes_pcs_digit = req_msg->nas_3gpp_mnc_includes_pcs_digit[i].mnc_includes_pcs_digit;
      }
      else
      {
        mnc_includes_pcs_digit = (req_msg->nas_3gpp_preferred_networks[i].mobile_country_code > 99) ? TRUE : FALSE;
      }

      if ( FALSE == sys_plmn_set_mcc_mnc(
                             mnc_includes_pcs_digit,
                             (uint32) req_msg->nas_3gpp_preferred_networks[i].mobile_country_code,
                             (uint32) req_msg->nas_3gpp_preferred_networks[i].mobile_network_code,
                             &(preferred_networks_list[i].plmn)) )
      {
        errval = QMI_ERR_INVALID_ARG;
        goto send_result;
      }
      else
      {
        memscpy ( &(pref_plmn_list[i]),
                  sizeof(sys_plmn_id_s_type),
                 &(preferred_networks_list[i].plmn),
                 sizeof(sys_plmn_id_s_type) );
      }

      preferred_networks_list[i].act[0] = 0;
      preferred_networks_list[i].act[1] = 0;

      if(req_msg->nas_3gpp_preferred_networks[i].radio_access_technology & 0x0080)
      {
        preferred_networks_list[i].act[1] |= 0x80; // 0000 0000 1000 0000 GSM
      }
      if(req_msg->nas_3gpp_preferred_networks[i].radio_access_technology & 0x0040)
      {
        preferred_networks_list[i].act[1] |= 0x40; // 0000 0000 0100 0000 GSM compact
      }
      #if defined(FEATURE_WCDMA)
      if(req_msg->nas_3gpp_preferred_networks[i].radio_access_technology & 0x8000)
      {
        preferred_networks_list[i].act[0] |= 0x80; // 1000 0000 0000 0000 UMTS
      }
      #endif
      if(req_msg->nas_3gpp_preferred_networks[i].radio_access_technology & 0x4000)
      {
        preferred_networks_list[i].act[0] |= 0x40; // 0100 0000 0000 0000 LTE
      }
    }

    if (plmn_wact_filename != MMGSDI_NO_FILE_ENUM)
    {
      plmn_data.data_len = req_msg->nas_3gpp_preferred_networks_len *
                             sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
      plmn_data.data_ptr = (uint8*)preferred_networks_list;

      if ( req_msg->clear_prev_preferred_networks_valid && (req_msg->clear_prev_preferred_networks == TRUE) &&
           (plmn_data.data_len < qmi_nasi_global.mmgsdi->cache[session].ef_plmnwact_size) )
      {
        file_num_recs = MIN(SYS_USER_PPLMN_LIST_MAX_LENGTH, (uint8)(qmi_nasi_global.mmgsdi->cache[session].ef_plmnwact_size/sizeof(qmi_nasi_mmgsdi_plmn_wact_type)));

        for( i = req_msg->nas_3gpp_preferred_networks_len; i < file_num_recs; i++ )
        {
          preferred_networks_list[i].plmn.identity[0] = 0xFF;
          preferred_networks_list[i].plmn.identity[1] = 0xFF;
          preferred_networks_list[i].plmn.identity[2] = 0xFF;

          preferred_networks_list[i].act[0] = 0x00;
          preferred_networks_list[i].act[1] = 0x00;
        }

        plmn_data.data_len = file_num_recs * sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
      }

      file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
      file_access.file.file_enum = plmn_wact_filename;

      if (MMGSDI_SUCCESS == mmgsdi_session_write_transparent(
                              qmi_nasi_global.mmgsdi->session_id[session],
                              file_access,
                              0,
                              plmn_data,
                              qmi_nas_mmgsdi_cmd_rsp_cb,
                              (uint32) cmd_buf_p))
      {
        return QMI_SVC_RESPONSE_PENDING;
      }
      else
      {
        QM_MSG_HIGH("mmgsdi_session_write_transparent failed");
        errval = QMI_ERR_INTERNAL;
      }
    }
    else if (plmn_filename != MMGSDI_NO_FILE_ENUM)
    {
      plmn_data.data_len = req_msg->nas_3gpp_preferred_networks_len *
                             sizeof(sys_plmn_id_s_type);
      plmn_data.data_ptr = (uint8*)pref_plmn_list;

      if ( req_msg->clear_prev_preferred_networks_valid && (req_msg->clear_prev_preferred_networks == TRUE) &&
           (plmn_data.data_len < qmi_nasi_global.mmgsdi->cache[session].ef_plmn_size) )
      {
        file_num_recs = (uint8)MIN(SYS_USER_PPLMN_LIST_MAX_LENGTH, (qmi_nasi_global.mmgsdi->cache[session].ef_plmn_size/sizeof(sys_plmn_id_s_type)));

        for( i = req_msg->nas_3gpp_preferred_networks_len; i < file_num_recs; i++ )
        {
          pref_plmn_list[i].identity[0] = 0xFF;
          pref_plmn_list[i].identity[1] = 0xFF;
          pref_plmn_list[i].identity[2] = 0xFF;
        }

        plmn_data.data_len = file_num_recs * sizeof(sys_plmn_id_s_type);
      }

      file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
      file_access.file.file_enum = plmn_filename;

      if (MMGSDI_SUCCESS == mmgsdi_session_write_transparent(
                              qmi_nasi_global.mmgsdi->session_id[session],
                              file_access,
                              0,
                              plmn_data,
                              qmi_nas_mmgsdi_cmd_rsp_cb,
                              (uint32) cmd_buf_p))
      {
        return QMI_SVC_RESPONSE_PENDING;
      }
      else
      {
        QM_MSG_HIGH("mmgsdi_session_write_transparent failed");
        errval = QMI_ERR_INTERNAL;
      }
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  QM_MSG_ERROR("Unable to change preferred networks settings");

#else
  QM_MSG_HIGH("Unable to process SET_PREF_NWKS request: non-GSM non-WCDMA target");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#else
  QM_MSG_HIGH("Unable to process SET_PREF_NWKS request: no MMGSDI support");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

send_result:
  if( cmd_buf_p != NULL )
  {
    nas_set_preferred_networks_resp_msg_v01 resp_msg;

    resp_msg.resp.error  = (qmi_error_type_v01)errval;
    resp_msg.resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) &resp_msg,
                                  (uint32_t) sizeof(nas_set_preferred_networks_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_set_preferred_networks() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_FORBIDDEN_NETWORKS()

  DESCRIPTION
    Returns a list of forbidden network providers.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_forbidden_networks
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  boolean            retval;
  qmi_error_e_type   errval;
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  uint32             filesize;
  mmgsdi_return_enum_type mmgsdi_status;
  mmgsdi_file_enum_type fplmn_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_access_type file_access;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
  qmi_nas_mmgsdi_session_e_type session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_session_type_enum_type mmgsdi_session =  MMGSDI_GW_PROV_PRI_SESSION;

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  response = NULL;
  errval = QMI_ERR_NONE;
  /*-------------------------------------------------------------------------
    Operation not supported if device doesn't have WCDMA or GSM
    Operation works for multimode devices but will return only wht
    is in the SIM ie GW
  -------------------------------------------------------------------------*/
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
#ifdef FEATURE_DUAL_SIM
  if( bound_subs == QMI_NAS_SUBS_SECONDARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_SEC_SESSION;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if( bound_subs == QMI_NAS_SUBS_TERTIARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_TER_SESSION;
  }
#endif
#endif
  session = qmi_nas_map_mmgsdi_session_to_qmi(mmgsdi_session); 

  QM_MSG_HIGH_5("qmi_nasi_get_forbidden_networks, mmgsdi_session:%d, session:%d,app_type:%d opr_ready %d sim_busy %d", mmgsdi_session, session,
      qmi_nasi_global.mmgsdi->app_type[session], qmi_nasi_global.mmgsdi->operation_ready[session],
      qmi_nasi_global.sim_busy_status.sim_busy);
  if ( qmi_nasi_global.mmgsdi->operation_ready[session] == FALSE )
  {
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
  {
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  /* Queue the command buffer to send response later */
  filesize = sizeof(sys_plmn_id_s_type) * SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH;

  file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
  file_access.file.file_enum = MMGSDI_NO_FILE_ENUM;

  if ( qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_SIM)
  {
    fplmn_filename = MMGSDI_GSM_FPLMN;
    filesize       = 0;
  }
  else if ( qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_USIM)
  {
    fplmn_filename = MMGSDI_USIM_FPLMN;
  }
  else
  {
    QM_MSG_HIGH_1("app_type:%d  not supported", qmi_nasi_global.mmgsdi->app_type[session]);
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }

  file_access.file.file_enum = fplmn_filename;

  mmgsdi_status = mmgsdi_session_read_transparent(
                                        #ifndef FEATURE_MMODE_DISABLE_UIM
                                        qmi_nasi_global.mmgsdi->session_id[session],
                                        #else
                                        qmi_nasi_global.mmgsdi->session_id[session],
                                        #endif
                                        file_access,
                                        0,
                                        filesize,
                                        qmi_nas_mmgsdi_cmd_rsp_cb,
                                        (uint32) cmd_buf_p);
  if (mmgsdi_status != MMGSDI_SUCCESS)
  {
    QM_MSG_HIGH_1("mmgsdi_status:%d", mmgsdi_status);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }
  return QMI_SVC_RESPONSE_PENDING;
#else
  QM_MSG_HIGH("Unable to process GET_FORB_NWKS request: non-GSM non-WCDMA target");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#else
  QM_MSG_HIGH("Unable to process GET_FORB_NWKS request: no MMGSDI support");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

send_result:
  retval = qmi_svc_put_result_tlv(&response,
                                  QMI_RESULT_FAILURE,
                                  errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_get_forbidden_networks() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_FORBIDDEN_NETWORKS()

  DESCRIPTION
    Sets the list of forbidden network providers in the SIM/UIM to the list
    provided in the request.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_forbidden_networks
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  boolean            retval;
  qmi_error_e_type   errval;
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  struct
  {
    uint16    length;
    struct
    {
      uint16  mcc;
      uint16  mnc;
    }plmn_info_list[SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH];
  } v_in_reqd;

  mmgsdi_access_type     file_access;
  mmgsdi_file_enum_type  fplmn_wact_filename = MMGSDI_NO_FILE_ENUM;
  sys_plmn_id_s_type     forbidden_networks_list[SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH];
  mmgsdi_write_data_type fplmn_data;
  boolean                got_v_in_reqd;
  uint8                  prm_type;
  uint16                 len;
  uint16                 expected_len;
  uint8                  i;
  void *                 value;
  boolean                mnc_includes_pcs_digit;
  uint16                 tlv_len = 0;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
  qmi_nas_mmgsdi_session_e_type session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_session_type_enum_type mmgsdi_session =  MMGSDI_GW_PROV_PRI_SESSION;

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  response = NULL;
  errval = QMI_ERR_NONE;

  /*-------------------------------------------------------------------------
    Operation not supported if device doesn't have WCDMA or GSM
    Operation works for multimode devices but will return only wht
    is in the SIM ie GW
  -------------------------------------------------------------------------*/
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
  file_access.file.file_enum = MMGSDI_NO_FILE_ENUM;

  memset(&v_in_reqd, 0, sizeof(v_in_reqd));
  got_v_in_reqd = FALSE;
  mnc_includes_pcs_digit = TRUE;

  while (*sdu_in)
  {
    if( !qmi_svc_get_tl(sdu_in, &prm_type, &len) )
    {
      continue;
    }

    /* special value 0 = variable length or don't care (unrecognzied TLV) */
    expected_len = 0;
    value = NULL;
    switch (prm_type)
    {
      case NASI_PARAM_TYPE_SET_FORB_NETWORKS:
        if (len <= sizeof(v_in_reqd))
        {
          value = &v_in_reqd;
          got_v_in_reqd = TRUE;
          tlv_len = len;
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG;
          goto send_result;
        }
        break;

      default:
        break;
    }

    if ((expected_len != 0) && (expected_len != len))
    {
      QM_MSG_ERROR_2("Invalid TLV len (%d) for type (%d)", len, prm_type);
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    if(len != dsm_pullup( sdu_in, value, len ))
    {
      QM_MSG_ERROR("Invalid length in TLV");
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }
  }

  if(!got_v_in_reqd)
  {
    errval = QMI_ERR_MISSING_ARG;
    goto send_result;
  }
  else
  {
    /* Validate length of input tlv to ensure it is consistent with
       num instances field specified in the tlv (2bytes + (n*4bytes)) */
    if ( tlv_len !=
             ( sizeof(v_in_reqd.length) +
               ( v_in_reqd.length * sizeof(v_in_reqd.plmn_info_list[0]) ) ) )
    {
      QM_MSG_HIGH_1("Num_forbidden_network_instances value(%d) different from number of networks sent in TLV!", v_in_reqd.length);
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    for(i=0; i<v_in_reqd.length; i++)
    {
      mnc_includes_pcs_digit = (v_in_reqd.plmn_info_list[i].mnc > 99) ? TRUE
                                                                     : FALSE;
      if ( FALSE == sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit,
                                   (uint32) v_in_reqd.plmn_info_list[i].mcc,
                                   (uint32) v_in_reqd.plmn_info_list[i].mnc,
                                   &(forbidden_networks_list[i])) )
      {
        errval = QMI_ERR_INVALID_ARG;
        goto send_result;
      }
    }
  }

  if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
  {
    QM_MSG_ERROR_1("Set Forbidden networks, SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
#ifdef FEATURE_DUAL_SIM
  if( bound_subs == QMI_NAS_SUBS_SECONDARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_SEC_SESSION;
  }
  #ifdef FEATURE_TRIPLE_SIM
  else if( bound_subs == QMI_NAS_SUBS_TERTIARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_TER_SESSION;
  }
#endif
#endif
  session = qmi_nas_map_mmgsdi_session_to_qmi(mmgsdi_session); 

  QM_MSG_HIGH_4("qmi_nasi_set_forbidden_networks: mmgsdi_session:%d, session:%d, app_type:%d, opr_ready_session %d", mmgsdi_session, session,
      qmi_nasi_global.mmgsdi->app_type[session], qmi_nasi_global.mmgsdi->operation_ready[session]);
  if ( qmi_nasi_global.mmgsdi->operation_ready[session] == FALSE )
  {
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  if ( qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_SIM)
  {
    fplmn_wact_filename = MMGSDI_GSM_FPLMN;
  }
  else if ( qmi_nasi_global.mmgsdi->app_type[session] == MMGSDI_APP_USIM)
  {
    fplmn_wact_filename = MMGSDI_USIM_FPLMN;
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }

  if ((errval == QMI_ERR_NONE) &&
      (fplmn_wact_filename != MMGSDI_NO_FILE_ENUM))
  {
    fplmn_data.data_len = v_in_reqd.length *
                           sizeof(sys_plmn_id_s_type);
    fplmn_data.data_ptr = (uint8*)forbidden_networks_list;
    file_access.file.file_enum = fplmn_wact_filename;
    QM_MSG_HIGH("mmgsdi_session_write_transparent");
    if (MMGSDI_SUCCESS == mmgsdi_session_write_transparent(
                            qmi_nasi_global.mmgsdi->session_id[session],
                            file_access,
                            0,
                            fplmn_data,
                            qmi_nas_mmgsdi_cmd_rsp_cb,
                            (uint32) cmd_buf_p))
    {
      return QMI_SVC_RESPONSE_PENDING;
    }
    else
    {
      QM_MSG_HIGH("mmgsdi_session_write_transparent failed");
      errval = QMI_ERR_INTERNAL;
    }
  }
  QM_MSG_ERROR("Unable to change Forbidden networks settings");

#else
  QM_MSG_HIGH("Unable to process SET_FORB_NWKS request: non-GSM non-WCDMA target");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#else
  QM_MSG_HIGH("Unable to process SET_FORB_NWKS request: no MMGSDI support");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

send_result:
  retval = qmi_svc_put_result_tlv(&response, QMI_RESULT_FAILURE, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_nasi_set_forbidden_networks() */
#ifndef FEATURE_MMODE_QMI_LTE_ONLY
/*===========================================================================
  FUNCTION QMI_NASI_SET_TECH_PREFERENCE()

  DESCRIPTION
    This writes the specified technology preference to the device.
    This setting is global to the device and is not unique to each control point.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in     : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_technology_preference
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  cm_mode_pref_e_type   cm_mode_pref = CM_MODE_PREF_NONE;
  cm_pref_term_e_type   cm_pref_term = CM_PREF_TERM_NONE;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  struct nas_002A_req_s req_msg;
  cm_cmd_user_pref_update_type  *user_pref_ptr;

  sys_modem_as_id_e_type  asubs_id = SYS_MODEM_AS_ID_1;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }
#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#endif
  if ( errval == QMI_ERR_NONE )
  {
    memset(&req_msg, 0x00, sizeof(req_msg));

    errval = qmi_nas_002A_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_002A_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    uint16 tech_pref = req_msg.t01.technology_pref & QMI_NAS_TECH_PREF_BIT_ALL;
    uint16 qmi_mode_pref = QMI_NAS_TECH_PREF_AUTOMATIC;

    if ( tech_pref == QMI_NAS_TECH_PREF_AUTOMATIC )
    {
      cm_mode_pref = CM_MODE_PREF_AUTOMATIC;
    }
    else
    {
      if ( tech_pref & QMI_NAS_TECH_PREF_BIT_3GPP2 )
      {
        if ( !TARGET_SUPPORTS_CDMA ) { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_DIGITAL; }
        if ( !TARGET_SUPPORTS_HDR  ) { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_HDR;     }

        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_DIGITAL ) { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_CDMA; }
        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_HDR )     { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_HDR;  }

        if ( qmi_mode_pref == 0x0000 )
        {
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
        }
      }
      else if ( tech_pref & QMI_NAS_TECH_PREF_BIT_3GPP )
      {
        if ( !TARGET_SUPPORTS_GSM )   { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_ANALOG;  }
        if ( !TARGET_SUPPORTS_WCDMA ) { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_DIGITAL; }
        if ( !TARGET_SUPPORTS_LTE )   { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_LTE;     }

        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_ANALOG  ) { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_GSM;  }
        #if defined(FEATURE_WCDMA)
        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_DIGITAL ) { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_UMTS; }
        #endif
        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_LTE     ) { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_LTE;  }

        if ( qmi_mode_pref == 0x0000 )
        {
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
        }
      }

      cm_mode_pref = qmi_nas_map_mode_pref_qmi_to_cm( qmi_mode_pref );

      if ( cm_mode_pref == CM_MODE_PREF_NONE )
      {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
      }
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( req_msg.t01.duration == QMI_NAS_TECH_PREF_DURATION_PERMANENT )
    {
      cm_pref_term = CM_PREF_TERM_PERMANENT; /* Permanent mode change */
    }
    else if ( req_msg.t01.duration == QMI_NAS_TECH_PREF_DURATION_POWER_CYCLE )
    {
      cm_pref_term = CM_PREF_TERM_PWR_CYCLE; /* Until power cycle */
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    boolean ret_val = FALSE;

    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
        user_pref_ptr = (cm_cmd_user_pref_update_type*)cm_mem_malloc(sizeof(cm_cmd_user_pref_update_type));
        cm_user_pref_init( user_pref_ptr);
        user_pref_ptr->plmn_ptr = NULL;
        user_pref_ptr->client_id = qmi_nasi_global.cm_clnt_id;
        user_pref_ptr->mode_pref = cm_mode_pref;
        user_pref_ptr->pref_term = cm_pref_term;
        user_pref_ptr->pref_duration = 0;
        ret_val = cm_user_pref_update_req( user_pref_ptr,
                                           qmi_nas_cmph_cmd_cb,
                                           (void *)cmd_buf_p
                                         );
    }
#ifdef FEATURE_DUAL_SIM
    else if ( asubs_id == SYS_MODEM_AS_ID_2 )
    {
      ret_val = cm_ph_cmd_sys_sel_pref_per_subs( qmi_nas_cmph_cmd_cb,
                                                 (void *)cmd_buf_p,
                                                 qmi_nasi_global.cm_clnt_id,
                                                 asubs_id,
                                                 cm_mode_pref,
                                                 cm_pref_term,
                                                 0,
                                                 CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                 CM_BAND_PREF_NO_CHANGE,
                                                 CM_PRL_PREF_NO_CHANGE,
                                                 CM_ROAM_PREF_NO_CHANGE,
                                                 CM_HYBR_PREF_NO_CHANGE,
                                                 CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                 CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                 NULL );
    }
#endif

    if ( ret_val )
    {
      QM_MSG_HIGH("Response pending for CM event");
      return QMI_SVC_RESPONSE_PENDING;
       // will react to CM_PH_CMD_SYS_SEL_PREF later
    }
    else
    {
     //Unable to change sys sel pref
      errval = QMI_ERR_NO_EFFECT;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_002A_rsp_s rsp_msg;

    memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_002A_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
} /* qmi_nasi_set_technology_preference() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_TECH_PREFERENCE ()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_technology_preference
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval   = QMI_ERR_NONE;
  struct nas_002B_rsp_s rsp_msg;
  nv_item_type          nv_item;

  qmi_cm_ph_info_s_type      *p_ph_info = &qmi_nasi_global.cm_ph_info;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }
#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    p_ph_info = &qmi_nasi_global.cm_ph_info2;
  }
#endif
  if ( errval == QMI_ERR_NONE )
  {
    memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

    if ( p_ph_info->mode_pref == CM_MODE_PREF_AUTOMATIC ||
         p_ph_info->mode_pref == CM_MODE_PREF_DIGITAL_ONLY )
    {
      rsp_msg.t01.active_technology_pref = QMI_NAS_TECH_PREF_AUTOMATIC;
    }
    else
    {
      uint16 qmi_mode_pref;

      qmi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( p_ph_info->mode_pref );

      if ( qmi_mode_pref != QMI_NAS_MODE_PREF_NONE )
      {
        #if defined(FEATURE_CDMA)
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_CDMA ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_DIGITAL | QMI_NAS_TECH_PREF_BIT_3GPP2; }
        #endif
        #if defined(FEATURE_HDR)
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_HDR  ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_HDR     | QMI_NAS_TECH_PREF_BIT_3GPP2; }
        #endif
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_GSM  ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_ANALOG  | QMI_NAS_TECH_PREF_BIT_3GPP;  }
        #if defined(FEATURE_WCDMA)
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_UMTS ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_DIGITAL | QMI_NAS_TECH_PREF_BIT_3GPP;  }
        #endif
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_LTE  ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_LTE     | QMI_NAS_TECH_PREF_BIT_3GPP;  }

        if ( (rsp_msg.t01.active_technology_pref & (QMI_NAS_TECH_PREF_BIT_3GPP|QMI_NAS_TECH_PREF_BIT_3GPP2)) == (QMI_NAS_TECH_PREF_BIT_3GPP|QMI_NAS_TECH_PREF_BIT_3GPP2) )
        {
          QM_MSG_ERROR_1("multimode not supported for get_technology_preference %d", p_ph_info->mode_pref);
          errval = QMI_ERR_INTERNAL;
        }
      }
      else
      {
        QM_MSG_ERROR_1("no mode pref bit set %d", p_ph_info->mode_pref);
        errval = QMI_ERR_INTERNAL;
      }
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    rsp_msg.t01_valid = TRUE;

    switch ( p_ph_info->pref_term )
    {
      case CM_PREF_TERM_PERMANENT     : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_PERMANENT;      break;
      case CM_PREF_TERM_PWR_CYCLE     : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_POWER_CYCLE;    break;
      case CM_PREF_TERM_1_CALL        : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_1_CALL;         break;
      case CM_PREF_TERM_1_CALL_OR_TIME: rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_1_CALL_OR_TIME; break;
      case CM_PREF_TERM_CM_1_CALL     : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_CM_1_CALL;      break;
      case CM_PREF_TERM_CM_1_CALL_PLUS: rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_CM_1_CALL_PLUS; break;
      case CM_PREF_TERM_CM_MO_SMS     : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_CM_MO_SMS;      break;
      default:
        errval            = QMI_ERR_INTERNAL;
        rsp_msg.t01_valid = FALSE;
        break;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( rsp_msg.t01.duration != QMI_NAS_TECH_PREF_DURATION_PERMANENT )
    {
      memset(&nv_item, 0, sizeof(nv_item));

      if ( qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item) == NV_DONE_S )
      {
        nv_item.pref_mode.nam = nv_item.curr_nam;
      }
      else
      {
        nv_item.pref_mode.nam = 0;
      }

      if ( qmi_mmode_get_nv_item(NV_PREF_MODE_I, &nv_item) == NV_DONE_S )
      {
        rsp_msg.t10_valid = TRUE;

        if ( nv_item.pref_mode.mode == NV_MODE_AUTOMATIC ||
             nv_item.pref_mode.mode == NV_MODE_DIGITAL_ONLY )
        {
          rsp_msg.t10.persistent_technology_pref = QMI_NAS_TECH_PREF_AUTOMATIC;
        }
        else
        {
          uint16 qmi_mode_pref;

          qmi_mode_pref = qmi_nas_map_mode_pref_nv_to_qmi( nv_item.pref_mode.mode );

          if ( qmi_mode_pref != QMI_NAS_MODE_PREF_NONE )
          {
            #if defined(FEATURE_CDMA)
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_CDMA ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_DIGITAL | QMI_NAS_TECH_PREF_BIT_3GPP2; }
            #endif
            #if defined(FEATURE_HDR)
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_HDR  ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_HDR     | QMI_NAS_TECH_PREF_BIT_3GPP2; }
            #endif
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_GSM  ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_ANALOG  | QMI_NAS_TECH_PREF_BIT_3GPP;  }
            #if defined(FEATURE_WCDMA)
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_UMTS ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_DIGITAL | QMI_NAS_TECH_PREF_BIT_3GPP;  }
            #endif
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_LTE  ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_LTE     | QMI_NAS_TECH_PREF_BIT_3GPP;  }

            if ( (rsp_msg.t10.persistent_technology_pref & (QMI_NAS_TECH_PREF_BIT_3GPP|QMI_NAS_TECH_PREF_BIT_3GPP2)) == (QMI_NAS_TECH_PREF_BIT_3GPP|QMI_NAS_TECH_PREF_BIT_3GPP2) )
            {
              QM_MSG_ERROR_1("multimode not supported for get_technology_preference nv %d", nv_item.pref_mode.mode);
              errval            = QMI_ERR_INTERNAL;
              rsp_msg.t10_valid = FALSE;
            }
          }
          else
          {
            QM_MSG_ERROR_1("no nv mode pref bit set %d", nv_item.pref_mode.mode);
            errval            = QMI_ERR_INTERNAL;
            rsp_msg.t10_valid = FALSE;
          }
        }
      }

      if ( rsp_msg.t01_valid && rsp_msg.t10_valid &&
           rsp_msg.t01.active_technology_pref == rsp_msg.t10.persistent_technology_pref )
      {
        QM_MSG_HIGH_2("same active %d persistent %d mode pref", rsp_msg.t01.active_technology_pref, rsp_msg.t10.persistent_technology_pref);
        rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_PERMANENT;
        rsp_msg.t10_valid    = FALSE;
      }
    }
  }

  if ( errval != QMI_ERR_NONE )
  {
    rsp_msg.t01_valid = FALSE;
    rsp_msg.t10_valid = FALSE;
  }

  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_002B_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
} /* qmi_nasi_get_technology_preference() */
#endif 
#endif
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
/*===========================================================================
  FUNCTION QMI_NASI_GET_ACCOLC ()

  DESCRIPTION
    Returns the Access Overload Class for C2K

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_accolc
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response = NULL;
  qmi_error_e_type   errval   = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  struct nas_002C_rsp_s  nas_002C_rsp;
  nv_stat_enum_type      nv_status;
  nv_item_type           nv_item;
  uint8                  curr_nam = 0; //default to first NAM
#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  if ( qmi_nasi_global.cm_ph_info.rtre_control == CM_RTRE_CONTROL_RUIM &&
       qmi_nasi_global.mmgsdi->operation_ready[MMGSDI_1X_PROV_PRI_SESSION] == FALSE )
  {
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
  }

  if (errval == QMI_ERR_NONE)
  {
    memset(&nas_002C_rsp, 0, sizeof(nas_002C_rsp));

    /*-------------------------------------------------------------------------
      Build the response
    -------------------------------------------------------------------------*/
    nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
    if ((nv_status != NV_NOTACTIVE_S) && (nv_item.curr_nam < NV_MAX_NAMS))
    {
      curr_nam = nv_item.curr_nam;
    }

    /* Read accolc from NV and write it to response struct */
    nv_item.accolc.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item(NV_ACCOLC_I, &nv_item);
    if ( nv_status == NV_DONE_S )
    {
      nas_002C_rsp.t01_valid  = TRUE;
      nas_002C_rsp.t01.accolc = nv_item.accolc.ACCOLCpClass[NV_CDMA_MIN_INDEX];
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Accolc NV item inactive");
      errval = QMI_ERR_NOT_PROVISIONED;
    }
    else
    {
      QM_MSG_ERROR("Could not read ACCOLC from NV for qmi_nasi_get_accolc");
      errval = QMI_ERR_INTERNAL;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_002C_rsp_write(&nas_002C_rsp, &response);
  }

#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;

#endif  /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_nasi_get_accolc() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_ACCOLC()

  DESCRIPTION

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in     : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_accolc
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response = NULL;
  qmi_error_e_type   errval = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  nv_stat_enum_type        nv_status;
  nv_item_type       nv_item;
  uint8                    current_accolc = 0;
  uint8                    curr_nam = 0; //default to the first NAM
  qmi_svc_spc_result_e_type check_spc_result;


  struct nas_002D_req_s nas_002D_req;
#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  memset(&nas_002D_req, 0, sizeof(nas_002D_req));

  errval = qmi_nas_002D_req_read(&nas_002D_req, sdu_in);

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_002D_req_check(&nas_002D_req);
  }

  if ( qmi_nasi_global.cm_ph_info.rtre_control != CM_RTRE_CONTROL_NV )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  if (errval == QMI_ERR_NONE)
  {
    check_spc_result = qmi_svc_check_spc((uint8 *)nas_002D_req.t01.spc, TRUE);

    if (check_spc_result == QMI_SVC_SPC_FAIL )
    {
      errval = QMI_ERR_AUTHENTICATION_FAILED;
    }

    if (check_spc_result == QMI_SVC_SPC_LOCKED )
    {
      errval = QMI_ERR_AUTHENTICATION_LOCK;
    }

    if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    /* Read current NAM */
    nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
    if((nv_status == NV_DONE_S) && (nv_item.curr_nam < NV_MAX_NAMS))
    {
      curr_nam = nv_item.curr_nam;
    }

    /* Read accolc from NV */
    nv_item.accolc.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item(NV_ACCOLC_I, &nv_item);
    if ( nv_status == NV_DONE_S )
    {
      current_accolc = nv_item.accolc.ACCOLCpClass[NV_CDMA_MIN_INDEX];
    }
    else
    {
      QM_MSG_ERROR("Could not read current ACCOLC from NV for qmi_nasi_set_accolc");
      errval = QMI_ERR_INTERNAL;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    if (nas_002D_req.t01.accolc == current_accolc)
    {
      errval = QMI_ERR_NO_EFFECT;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    /* Update ACCOLC as required */
    nv_item.accolc.nam = curr_nam;
    nv_item.accolc.ACCOLCpClass[NV_CDMA_MIN_INDEX] = nas_002D_req.t01.accolc;
    if ( NV_DONE_S != qmi_mmode_put_nv_item( NV_ACCOLC_I, &nv_item ) )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("Could not write ACCOLC to NV for qmi_nasi_set_accolc");
    }
  }

#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_set_accolc() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_SYSTEM_PREFERENCE ()

  DESCRIPTION
    Returns the System Preference for C2K

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_system_preference
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  nv_stat_enum_type     nv_status;
  uint8                 curr_nam;
  struct nas_002E_rsp_s rsp_msg;
  nv_item_type          nv_item;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( !TARGET_SUPPORTS_CDMA && !TARGET_SUPPORTS_HDR )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  if ( errval == QMI_ERR_NONE )
  {
    nv_status = qmi_mmode_get_nv_item( NV_CURR_NAM_I, &nv_item );

    if ( nv_status == NV_DONE_S && nv_item.curr_nam < NV_MAX_NAMS )
    {
      curr_nam = nv_item.curr_nam;
    }
    else
    {
      curr_nam = 0;
    }

    nv_item.prl_pref.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item( NV_PRL_PREF_I, &nv_item );

    if ( nv_status != NV_DONE_S )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("Could not read Sys Pref from NV for PRL pref");
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    rsp_msg.t01_valid = TRUE;

    switch ( nv_item.prl_pref.prl )
    {
      case CM_PRL_PREF_ANY:         rsp_msg.t01.sys_pref = QMI_NAS_SYS_PREF_AUTOMATIC; break;
      case CM_PRL_PREF_AVAIL_BC0_A: rsp_msg.t01.sys_pref = QMI_NAS_SYS_PREF_AUTO_A;    break;
      case CM_PRL_PREF_AVAIL_BC0_B: rsp_msg.t01.sys_pref = QMI_NAS_SYS_PREF_AUTO_B;    break;

      default:
        QM_MSG_HIGH_1("unexpected PRL PREF %d", nv_item.prl_pref.prl);
        rsp_msg.t01_valid = FALSE;
        errval            = QMI_ERR_INTERNAL;
        break;
    }
  }

  if ( errval != QMI_ERR_NONE )
  {
    rsp_msg.t01_valid = FALSE;
  }

  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_002E_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
} /* qmi_nasi_get_system_preference() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_DEVICE_CONFIG ()

  DESCRIPTION
    Returns the network device configuration

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_device_config
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type      *response  = NULL;
  qmi_error_e_type   errval     = QMI_ERR_NONE;
  nas_get_device_config_resp_msg_v01 *rsp_msg;


#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  nv_item_type       nv_item;
  nv_stat_enum_type       nv_status;
  uint8                   curr_nam = 0; //default to first NAM

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_device_config_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_device_config_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    return NULL;
  }
  memset(rsp_msg, 0, sizeof(nas_get_device_config_resp_msg_v01));

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  /*-------------------------------------------------------------------------
    Query all device config items
  -------------------------------------------------------------------------*/
  /* Read Slot Cycle Index from NV */
  memset(&nv_item, 0, sizeof(nv_item));
  nv_status = qmi_mmode_get_nv_item(NV_SLOT_CYCLE_INDEX_I, &nv_item);
  if (nv_status == NV_DONE_S)
  {
    rsp_msg->sci    = nv_item.slot_cycle_index;
    rsp_msg->sci_valid  = TRUE;
  }
  else if (nv_status == NV_NOTACTIVE_S)
  {
    QM_MSG_ERROR("Slot index NV item not active");
  }
  else
  {
    //Error reading slot index NV item
    errval = QMI_ERR_INTERNAL;
  }

  if (errval == QMI_ERR_NONE)
  {
    /* Read Station Class Mark from NV */
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_SCM_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->scm   = nv_item.scm;
      rsp_msg->scm_valid= TRUE;
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Station Class Mark NV item not active");
    }
    else
    {
      //Error reading Station Class Mark NV item
      errval = QMI_ERR_INTERNAL;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
    if (NV_DONE_S == nv_status)
    {
      curr_nam = nv_item.curr_nam;
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Current NAM NV item not active. Using default.");
    }
    else
    {
      QM_MSG_ERROR("Error reading NAM NV item");
    }
  }

  /* Read registration params from NV */
  if (errval == QMI_ERR_NONE)
  {
    /* Read registration param: Registered Home SID */
    nv_item.mob_term_home.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item(NV_MOB_TERM_HOME_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->registration_parameters.reg_home_sid = nv_item.mob_term_home.enabled[NV_CDMA_MIN_INDEX];
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Reg Home SID NV item not active");
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("Error reading Reg Home SID NV item");
    }
  }

  if (errval == QMI_ERR_NONE && nv_status == NV_DONE_S)
  {
    /* Read registration param: Registered Foreign SID */
    nv_status = qmi_mmode_get_nv_item(NV_MOB_TERM_FOR_SID_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->registration_parameters.reg_foreign_sid = nv_item.mob_term_for_sid.enabled[NV_CDMA_MIN_INDEX];
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Reg For SID NV item not active");
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("Error reading Reg For SID NV item");
    }
  }

  if (errval == QMI_ERR_NONE && nv_status == NV_DONE_S)
  {
    /* Read registration param: Registered Foreign NID */
    nv_status = qmi_mmode_get_nv_item(NV_MOB_TERM_FOR_NID_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      /* Set valid to TRUE because this is the last NV item to read
       * for registration parameters                                 */
      rsp_msg->registration_parameters_valid           = TRUE;
      rsp_msg->registration_parameters.reg_foreign_nid = nv_item.mob_term_for_nid.enabled[NV_CDMA_MIN_INDEX];
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Reg For NID NV item not active");
    }
    else
    {
      QM_MSG_ERROR("Error reading Reg For NID NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Read HDR Force Rev0 from NV */
  if (errval == QMI_ERR_NONE)
  {
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_HDRSCP_FORCE_REL0_CONFIG_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->force_rev0_valid      = TRUE;
      rsp_msg->force_rev0 = nv_item.hdrscp_force_rel0_config;
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("HDR Force Rev0 NV item not active");
    }
    else
    {
      QM_MSG_ERROR("Error reading HDR Force Rev0 NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Read HDR SCP Custom Config from NV */
  if (errval == (qmi_error_e_type)QMI_ERR_NONE)
  {
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_HDRSCP_SUBTYPE_CUSTOM_CONFIG_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->hdr_scp_config_valid            = TRUE;
      rsp_msg->hdr_scp_config.state            = (uint8) nv_item.hdrscp_subtype_custom_config.custom_config_is_active;
      rsp_msg->hdr_scp_config.protocol_mask    = (uint32) nv_item.hdrscp_subtype_custom_config.prot_subtype_mask;
      rsp_msg->hdr_scp_config.broadcast_mask   = (uint32) nv_item.hdrscp_subtype_custom_config.bcmcs_subtype_mask;
      rsp_msg->hdr_scp_config.application_mask = (uint32) nv_item.hdrscp_subtype_custom_config.app_subtype_mask;
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("HDR SCP Cust Config NV item not active");
    }
    else
    {
      QM_MSG_ERROR("Error reading HDR SCP Cust Config NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Read Roam Pref from NV */
  if (errval == QMI_ERR_NONE)
  {
    nv_item.roam_pref.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item(NV_ROAM_PREF_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->roam_pref_valid     = TRUE;
      switch (nv_item.roam_pref.roam)
      {
        case CM_ROAM_PREF_ANY:
          rsp_msg->roam_pref= NAS_ROAM_CONFIG_PREF_AUTO_V01;
          break;

        case CM_ROAM_PREF_HOME:
          rsp_msg->roam_pref = NAS_ROAM_CONFIG_PREF_HOME_ONLY_V01;
          break;

        case CM_ROAM_PREF_ROAM_ONLY:
          rsp_msg->roam_pref = NAS_ROAM_CONFIG_PREF_ROAM_ONLY_V01;
          break;

        case CM_ROAM_PREF_AFFIL:
          rsp_msg->roam_pref = NAS_ROAM_CONFIG_PREF_HOME_AND_AFFILIATE_V01;
          break;

        default:
          QM_MSG_HIGH_1("Invalid roam pref %d", nv_item.roam_pref.roam);
          errval = QMI_ERR_INTERNAL;
      }
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_ERROR("Roam Pref NV item not set");
    }
    else
    {
      QM_MSG_ERROR("Error reading Roam Pref NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Read HDR Force AT Config from NV */
  if (errval == QMI_ERR_NONE)
  {
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_HDRSCP_FORCE_AT_CONFIG_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->force_hdrscp_config_at_valid                  = TRUE;
      rsp_msg->force_hdrscp_config_at = nv_item.hdrscp_force_at_config; //QMI values same as NV values
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("NV_HDRSCP_FORCE_AT_CONFIG_I not active");
    }
    else
    {
      QM_MSG_ERROR("Error reading NV_HDRSCP_FORCE_AT_CONFIG_I NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;

#endif  /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = ( errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 ;

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t)cmd_buf_p->msg_id,
                                (void *) rsp_msg,
                                (uint32_t) sizeof( nas_get_device_config_resp_msg_v01 ),
                                &response
                              );
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_device_config() */


/*===========================================================================
  FUNCTION QMI_NASI_SET_DEVICE_CONFIG()

  DESCRIPTION
    Sets the network device configuration

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in     : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_device_config
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type           *response = NULL;
  qmi_error_e_type        errval    = QMI_ERR_NONE;
#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  nv_stat_enum_type       nv_status;
  nv_item_type            nv_item;
#endif

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  nas_set_device_config_req_msg_v01 *req_msg = NULL;
  uint8                    curr_nam  = 0; //default to first NAM
  uint8                    roam_pref = (uint8) CM_ROAM_PREF_MAX;
  qmi_svc_spc_result_e_type check_spc_result;

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  nas_set_device_config_resp_msg_v01  rsp_msg;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);


#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  if (errval == QMI_ERR_NONE)
  {
     req_msg = (nas_set_device_config_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_device_config_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( req_msg == NULL )
     {
       qmi_voice_mem_error();
       errval = QMI_ERR_NO_MEMORY;
       ASSERT(0); 
     }
  }  
  if (errval == QMI_ERR_NONE)
  {
    memset(req_msg, 0, sizeof(nas_set_device_config_req_msg_v01));
    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_device_config_req_msg_v01)
                                         );
  }
  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0030_req_check(req_msg);
  }

  /*-----------------------------------------------------------------------
    Check the supplied SPC is valid (only if given a TLV that requires an SPC)
  -----------------------------------------------------------------------*/
  if (errval == QMI_ERR_NONE)
  {
    if ( req_msg->force_hdr_rev0_valid|| req_msg->hdr_scp_config_valid)
    {
      if ( req_msg->spc_valid)
      {
        check_spc_result = qmi_svc_check_spc((uint8*)req_msg->spc, TRUE);

        if (check_spc_result == QMI_SVC_SPC_FAIL)
        {
          errval = QMI_ERR_AUTHENTICATION_FAILED;
        }
        else if (check_spc_result == QMI_SVC_SPC_LOCKED)
        {
          errval = QMI_ERR_AUTHENTICATION_LOCK;
        }
        else if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
        {
          errval = QMI_ERR_INTERNAL;
        }
      }
      else
      {
        errval = QMI_ERR_MISSING_ARG;
      }
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    if (req_msg->roam_pref_valid)
    {
      //set roam_pref to CM values
      switch (req_msg->roam_pref)
      {
        case NAS_ROAM_CONFIG_PREF_AUTO_V01:                          roam_pref = CM_ROAM_PREF_ANY;       break;
        case NAS_ROAM_CONFIG_PREF_HOME_ONLY_V01:                roam_pref = CM_ROAM_PREF_HOME;      break;
        case NAS_ROAM_CONFIG_PREF_ROAM_ONLY_V01:                roam_pref = CM_ROAM_PREF_ROAM_ONLY; break;
        case NAS_ROAM_CONFIG_PREF_HOME_AND_AFFILIATE_V01: roam_pref = CM_ROAM_PREF_AFFIL;     break;
        default:
          //should never occur
          QM_MSG_ERROR("Invalid roam pref, check function failed");
          errval = QMI_ERR_INTERNAL;
      }

      if (errval == QMI_ERR_NONE)
      {
        //read current NAM from NV
        nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
        if ((nv_status == NV_DONE_S) && (nv_item.curr_nam < NV_MAX_NAMS))
        {
          curr_nam = nv_item.curr_nam;
        }

        nv_item.roam_pref.nam  = curr_nam;
        nv_item.roam_pref.roam = roam_pref;
        if (NV_DONE_S != qmi_mmode_put_nv_item(NV_ROAM_PREF_I, &nv_item))
        {
          errval = QMI_ERR_INTERNAL;
          QM_MSG_ERROR("Could not write NV");
        }
      }
    }
  }

#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  if( cmd_buf_p != NULL )
  {
    rsp_msg.resp.error  = (qmi_error_type_v01) errval;
    rsp_msg.resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) &rsp_msg,
                                  (uint32_t) sizeof(nas_set_device_config_resp_msg_v01),
                                  &response
                                );
  }

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
#endif

  return response;
} /* qmi_nasi_set_device_config() */
#endif

/*===========================================================================
  FUNCTION QMI_NASI_GET_RF_BAND_INFO()

  DESCRIPTION
    Returns the current active band and channel information, along with
    the radio interface type.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_rf_band_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                 *response = NULL;
  qmi_error_e_type              errval = QMI_ERR_NONE;
  qmi_result_e_type             result;
  boolean                       retval;

  struct nas_0031_rsp_s                rsp_msg;

  int                           i = 0, stack_index = 0;
  cm_mm_ss_info_s_type *p_ss_info = NULL;

  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  uint8 asubs_max = sizeof(qmi_nasi_global.cm_msim_ss_info)/sizeof(qmi_nasi_global.cm_msim_ss_info[0]);
  #endif
  
  enum qmi_nas_subs_e bound_subs;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
  if( 
      (bound_subs > QMI_NAS_SUBS_NONE) && 
      (bound_subs < QMI_NAS_SUBS_MAX) 
    )
  {
    p_ss_info = &qmi_nasi_global.cm_ss_info[bound_subs];
  }

  if(!p_ss_info)
  {
    QM_MSG_ERROR("p_ss_info is NULL");
    errval = QMI_ERR_INTERNAL;
  }

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( errval == QMI_ERR_NONE )
  {
    if ( !qmi_nasi_global.rcvd_ss_info )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    for( stack_index = 0; stack_index < p_ss_info->number_of_stacks && stack_index < STACK_INDEX_MAX && i < NAS_0031_RSP_MAX_RADIO_IFS; stack_index++ )
    #endif
    {
      if ( qmi_nas_sys_mode_2_radio_if( p_ss_info,FALSE ) != QMI_NAS_RADIO_IF_NONE )
    {
        rsp_msg.t01.instances[i].radio_if       = qmi_nas_sys_mode_2_radio_if( p_ss_info, FALSE );
        rsp_msg.t01.instances[i].active_band    = qmi_nas_cm_bc_2_qmi_bc( p_ss_info->active_band);

        rsp_msg.t11.instances[i].radio_if       = qmi_nas_sys_mode_2_radio_if( p_ss_info, FALSE );
        rsp_msg.t11.instances[i].active_band    = qmi_nas_cm_bc_2_qmi_bc( p_ss_info->active_band);

      switch ( rsp_msg.t01.instances[i].radio_if )
      {
        #ifdef FEATURE_CDMA
        case QMI_NAS_RADIO_IF_CDMA20001X:
        case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
            rsp_msg.t01.instances[i].active_channel = p_ss_info->stack_info[stack_index].active_channel;
            rsp_msg.t11.instances[i].active_channel = p_ss_info->stack_info[stack_index].active_channel;
          break;
        #endif
        case QMI_NAS_RADIO_IF_GSM:
#ifdef FEATURE_CM_NEW_RR_CELL_INFO_INTERFACE
            rsp_msg.t01.instances[i].active_channel = p_ss_info->cell_info.arfcn;
            rsp_msg.t11.instances[i].active_channel = p_ss_info->cell_info.arfcn;
#else
          rsp_msg.t01.instances[i].active_channel = 0;
            rsp_msg.t11.instances[i].active_channel = 0;
#endif
          break;
        #if defined(FEATURE_WCDMA)
        case QMI_NAS_RADIO_IF_UMTS:
        #endif
        #if defined(FEATURE_TDSCDMA)
        case QMI_NAS_RADIO_IF_TDSCDMA:
        #endif
            rsp_msg.t01.instances[i].active_channel = p_ss_info->cell_info.uarfcn_dl;
            rsp_msg.t11.instances[i].active_channel = p_ss_info->cell_info.uarfcn_dl;
          break;

        case QMI_NAS_RADIO_IF_LTE:
            rsp_msg.t01.instances[i].active_channel = (uint16)p_ss_info->cell_info.earfcn_dl;
            rsp_msg.t11.instances[i].active_channel = p_ss_info->cell_info.earfcn_dl;
            
            if (i == 0)
            {
              rsp_msg.t13.ciot_lte_op_mode = qmi_nas_map_camped_lte_mode_cm_to_qmi(p_ss_info->ciot_lte_mode);
              rsp_msg.t13_valid = TRUE;
            }
          break;

        default:
          break;
      }
      i++;
    }
    }

    if ( i > 0 )
    {
      rsp_msg.t01.num_instances = i;
      rsp_msg.t11.num_instances = i;
      rsp_msg.t01_valid = TRUE;
      rsp_msg.t11_valid = TRUE;

      errval = qmi_nas_0031_rsp_write(&rsp_msg, &response);
    }
    else
    {
      errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_get_rf_band_info() */
#if defined(FEATURE_HDR)
/*===========================================================================
  FUNCTION QMI_NASI_GET_AN_AAA_STATUS()

  DESCRIPTION
    Returns the latest AN AAA status of 1xEV-DO.
    - AN : Access Network
    - AAA : Authentication, Authorization and Accounting

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_an_aaa_status
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type      *response = NULL;
  qmi_error_e_type   errval    = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

#ifdef FEATURE_HDR
  struct nas_0032_rsp_s   rsp_msg;
  int16              dss_errno=0;
  ds_sys_conf_3gpp2_an_auth_status_enum_type sys_status_type = DS_SYS_CONF_3GPP2_AN_AUTH_STATUS_NOT_AUTHENTICAED;
#endif /* FEATURE_HDR */

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

#ifdef FEATURE_HDR
  memset(&rsp_msg, 0, sizeof(rsp_msg));

  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  /* Get the last AN AAA status */
  if ( !ds_sys_conf_get( DS_SYS_TECH_3GPP2,
                         DS_SYS_CONF_3GPP2_AN_AUTH_STATUS,
                         &sys_status_type,
                         &dss_errno))
  {
    /* Translate aaa status info */
    switch (sys_status_type)
    {
      case DS_SYS_CONF_3GPP2_AN_AUTH_STATUS_NOT_AUTHENTICAED :    /* Not Authenticated */
        rsp_msg.t01.an_aaa_status = NAS_0032_AN_AAA_STATUS_NOT_AUTH;
        rsp_msg.t01_valid         = TRUE;
        errval = qmi_nas_0032_rsp_write(&rsp_msg, &response);
        break;

      case DS_SYS_CONF_3GPP2_AN_AUTH_STATUS_PASS:   /* Authenticated successfully */
        rsp_msg.t01.an_aaa_status = NAS_0032_AN_AAA_STATUS_SUCCESS;
        rsp_msg.t01_valid         = TRUE;
        errval = qmi_nas_0032_rsp_write(&rsp_msg, &response);
        break;

      case DS_SYS_CONF_3GPP2_AN_AUTH_STATUS_FAILED: /* Failed authentication */
        rsp_msg.t01.an_aaa_status = NAS_0032_AN_AAA_STATUS_FAILED;
    rsp_msg.t01_valid         = TRUE;
    errval = qmi_nas_0032_rsp_write(&rsp_msg, &response);
        break;

      default:
        QM_MSG_ERROR_1("qmi_nasi_get_an_aaa_status: received invalid aaa status = %d ", (int)sys_status_type);
        errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }
  else
  {
    errval = QMI_ERR_INFO_UNAVAILABLE;
    QM_MSG_ERROR_1("qmi_nasi_get_an_aaa_status: Cannot get configuration %d", dss_errno);
  }

#else /* FEATURE_HDR */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
#endif  /* FEATURE_HDR */

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_nasi_get_an_aaa_status() */
#endif
/*===========================================================================
  FUNCTION QMI_NAS_MAP_UE_USAGE_QMI_TO_CM()

  DESCRIPTION
    This functions maps QMI_NAS ue_usage preference enum to CM defined enum
        
  PARAMETERS
    ue_usage : QMI_NAS ue_usage enum type

  RETURN VALUE
    CM sys_ue_usage_setting_e_type ue_usage enum
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static sys_ue_usage_setting_e_type qmi_nas_map_ue_usage_qmi_to_cm( uint32 qmi_ue_usage )
{
  sys_ue_usage_setting_e_type cm_ue_usage = SYS_UE_USAGE_SETTING_NO_CHANGE;

  switch(qmi_ue_usage)
  {
    case NAS_USAGE_VOICE_CENTRIC_V01:
      cm_ue_usage = SYS_UE_USAGE_SETTING_VOICE_CENTRIC;
      break;
    case NAS_USAGE_DATA_CENTRIC_V01:
      cm_ue_usage = SYS_UE_USAGE_SETTING_DATA_CENTRIC;
      break;
    default:
      break;
  }

  return cm_ue_usage;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_LRRC_STATE_TO_QMI_EXT()

  DESCRIPTION
    This functions maps LTE RRC state to QMI_NAS enum 
        
  PARAMETERS
    rrc_state : lte_rrc_state_ext_e enum type

  RETURN VALUE
    QMI_NAS lte_rrc_state_ext_e_type_v01  enum
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static lte_rrc_state_ext_e_type_v01 qmi_nas_map_lrrc_state_to_qmi_ext( lte_rrc_state_ext_e rrc_state )
{
  lte_rrc_state_ext_e_type_v01 qmi_rrc_state = LTE_RRC_STATE_EXT_NULL_V01;

  switch(rrc_state)
  {
    case LTE_RRC_STATE_EXT_IDLE_CAMPED_ANYCELL:
      qmi_rrc_state = LTE_RRC_STATE_EXT_IDLE_CAMPED_ANYCELL_V01;
      break;
    case LTE_RRC_STATE_EXT_IDLE_CAMPED_NORMAL:
      qmi_rrc_state = LTE_RRC_STATE_EXT_IDLE_CAMPED_NORMAL_V01;
      break;
    case LTE_RRC_STATE_EXT_CONNECTING:
      qmi_rrc_state = LTE_RRC_STATE_EXT_CONNECTING_V01;
      break;
    case LTE_RRC_STATE_EXT_CONNECTED:
      qmi_rrc_state = LTE_RRC_STATE_EXT_CONNECTED_V01;
      break;
    case LTE_RRC_STATE_EXT_CLOSING:
      qmi_rrc_state = LTE_RRC_STATE_EXT_CLOSING_V01;
      break;
    default:
      qmi_rrc_state = LTE_RRC_STATE_EXT_NULL_V01;
      break;
  }

  QM_MSG_HIGH_2("rrc_state=%d masked to %d in qmi_nas_map_lrrc_state_to_qmi_ext()",rrc_state,qmi_rrc_state);
  return qmi_rrc_state;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_LTE_BW_QMI_BW()

  DESCRIPTION
    This functions maps LTE Bandwidth to QMI_NAS enum 
        
  PARAMETERS
    dl_bandwidth : LTE lte_bandwidth_e enum type

  RETURN VALUE
    QMI_NAS nas_lte_cphy_ca_bandwidth_enum_v01  enum
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static nas_lte_cphy_ca_bandwidth_enum_v01 qmi_nas_map_lte_bw_to_qmi_bw( lte_bandwidth_e dl_bandwidth )
{
  nas_lte_cphy_ca_bandwidth_enum_v01 qmi_bw = 0xFF;

  switch(dl_bandwidth)
  {
    case LTE_BW_NRB_6:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_6_V01;
      break;
    case LTE_BW_NRB_15:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_15_V01;
      break;
    case LTE_BW_NRB_25:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_25_V01;
      break;
    case LTE_BW_NRB_50:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_50_V01;
      break;
    case LTE_BW_NRB_75:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_75_V01;
      break;
    case LTE_BW_NRB_100:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_100_V01;
      break;

    default:
      QM_MSG_ERROR_1("Invalid dl_bandwidth passed in qmi_nas_map_lte_bw_to_qmi_bw() request %d", (int)dl_bandwidth);
      break;
  }

  return qmi_bw;
}

#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_LTE_CPHY_CA_IND()

  DESCRIPTION
    Generates and sends the LTE physical carrier aggregation(CA) status.

  PARAMETERS
    None

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nas_generate_lte_cphy_ca_ind(lte_cphy_ca_event_ind_s *cphy_ca)
{

  nas_lte_cphy_ca_ind_msg_v01        *ind_msg;
  dsm_item_type               *ind;

  int                          client=0;
  qmi_nasi_client_state_type  *cl_sp;
  enum qmi_nas_subs_e          bound_subs = QMI_NAS_SUBS_PRIMARY;

  ind_msg = (nas_lte_cphy_ca_ind_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_lte_cphy_ca_ind_msg_v01 ) );

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof( nas_lte_cphy_ca_ind_msg_v01 ) );

    QM_MSG_MED_6("qmi_nas_generate_lte_cphy_ca_ind() Scell PCI: %d FREQ: %d BANDWIDTH: %d,Pcell PCI: %d FREQ: %d BANDWIDTH: %d", (uint16_t)cphy_ca->scell_info.pci, (uint16_t)cphy_ca->scell_info.freq, (int)cphy_ca->scell_info.dl_bandwidth,
                         (uint16_t)cphy_ca->pcell_info.pci, (uint16_t)cphy_ca->pcell_info.freq, (int)cphy_ca->pcell_info.dl_bandwidth);

    QM_MSG_MED_3("qmi_nas_generate_lte_cphy_ca_ind() Scell BAND: %d STATUS: %d, Pcell BAND: %d", (int)cphy_ca->scell_info.sys_band, (int)cphy_ca->scell_info.scell_state,(int)cphy_ca->pcell_info.sys_band);

    //Old TLVs
    ind_msg->cphy_ca.pci = (uint16_t)cphy_ca->scell_info.pci;
    ind_msg->cphy_ca.freq = (uint16_t)cphy_ca->scell_info.freq;
    ind_msg->cphy_ca.scell_state = (nas_scell_state_enum_v01)cphy_ca->scell_info.scell_state;

    ind_msg->cphy_ca_dl_bandwidth_valid = TRUE;
    ind_msg->cphy_ca_dl_bandwidth = (nas_lte_cphy_ca_bandwidth_enum_v01)qmi_nas_map_lte_bw_to_qmi_bw(cphy_ca->scell_info.dl_bandwidth);

    //New TLVs
    ind_msg->pcell_info_valid = TRUE;
    ind_msg->pcell_info.pci = (uint16_t)cphy_ca->pcell_info.pci;
    ind_msg->pcell_info.freq = (uint16_t)cphy_ca->pcell_info.freq;
    ind_msg->pcell_info.cphy_ca_dl_bandwidth = (nas_lte_cphy_ca_bandwidth_enum_v01)qmi_nas_map_lte_bw_to_qmi_bw(cphy_ca->pcell_info.dl_bandwidth);
    ind_msg->pcell_info.band = (nas_active_band_enum_v01)qmi_nas_qmi_sys_lte_bc_2_lte_bc(cphy_ca->pcell_info.sys_band);

    ind_msg->scell_info_valid = TRUE;
    ind_msg->scell_info.pci = (uint16_t)cphy_ca->scell_info.pci;
    ind_msg->scell_info.freq = (uint16_t)cphy_ca->scell_info.freq;
    ind_msg->scell_info.cphy_ca_dl_bandwidth = (nas_lte_cphy_ca_bandwidth_enum_v01)qmi_nas_map_lte_bw_to_qmi_bw(cphy_ca->scell_info.dl_bandwidth);
    ind_msg->scell_info.band = (nas_active_band_enum_v01)qmi_nas_qmi_sys_lte_bc_2_lte_bc(cphy_ca->scell_info.sys_band);
    ind_msg->scell_info.scell_state = (nas_scell_state_enum_v01)cphy_ca->scell_info.scell_state;

    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {

      if ( cl_sp->report_status.report_lte_cphy_ca_status && cl_sp->report_status.bound_subs == bound_subs )
      {
        ind = NULL;

        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_INDICATION,
                                                  QMI_NAS_LTE_CPHY_CA_IND_V01,
                                                  (void *) ind_msg,
                                                  (uint32_t) sizeof( nas_lte_cphy_ca_ind_msg_v01 ),
                                                  &ind
                                                )
          )
        {
          qmi_nasi_send_ind( cl_sp, (uint16)QMI_NAS_LTE_CPHY_CA_IND_V01, ind );
        }
        else
        {
           QM_MSG_ERROR_1("failed to send LTE_CPHY_CA_IND ind, client %d", client);
        }
      }
      
      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( ind_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) ind_msg ); }
}
#endif

/*===========================================================================
  FUNCTION QMI_NASI_SET_SYS_SEL_PREF()

  DESCRIPTION
    Sets the different System Selection Preference of the device.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_sys_sel_pref(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type    *response = NULL;
  boolean           retval = FALSE;
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;

  nas_set_system_selection_preference_req_msg_v01  * req_msg;
  nas_set_system_selection_preference_resp_msg_v01 * rsp_msg;

  cm_cmd_user_pref_update_type  sys_pref_info;
  qmi_cm_ph_info_s_type   *p_ph_info     = &qmi_nasi_global.cm_ph_info;
  sys_plmn_id_s_type                plmn;
  boolean                         mnc_includes_pcs_digit = TRUE;
  uint32_t                          i;
  cm_rat_acq_order_pref_s_type rat_acq_order;
  sys_lte_band_mask_e_type       lte_band_pref_no_chg = SYS_LTE_BAND_MASK_CONST_NO_CHG;
  const sys_lte_band_mask_e_type lte_band_pref_any1 = SYS_LTE_BAND_MASK_CONST_ANY;
  const sys_lte_band_mask_e_type lte_m1_band_pref_any1 = SYS_LTE_M1_BAND_MASK_CONST_ANY;
  const sys_lte_band_mask_e_type lte_nb1_band_pref_any1 = SYS_LTE_NB1_BAND_MASK_CONST_ANY;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_set_sys_sel_pref processing started");
  
  req_msg = (nas_set_system_selection_preference_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_system_selection_preference_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_system_selection_preference_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_system_selection_preference_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_2("Not enough memory to allocate for QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE request. %p %p", req_msg, rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !cm_user_pref_init( &sys_pref_info ) )
    {
      QM_MSG_HIGH("Failed to initalize user pref structure");
      errval = QMI_ERR_MALFORMED_MSG_V01;
    }
    else
    {
      // QMI_NAS has different default value for pref_term than CM
      sys_pref_info.pref_term = CM_PREF_TERM_PERMANENT;
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_system_selection_preference_req_msg_v01) );

#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      sys_pref_info.asubs_id  = SYS_MODEM_AS_ID_2;
      p_ph_info = &qmi_nasi_global.cm_ph_info2;
    }
    else 
#endif
#ifdef FEATURE_TRIPLE_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      sys_pref_info.asubs_id  = SYS_MODEM_AS_ID_3;
      p_ph_info = &qmi_nasi_global.cm_ph_info3;
    }
    else
#endif
    {
      sys_pref_info.asubs_id = SYS_MODEM_AS_ID_1;
    }

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_system_selection_preference_req_msg_v01)
                                         );
  }

  // check for error in REQ message
  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_0033_req_check( req_msg );
  }

  QM_MSG_HIGH_1("set_sys_sel_pref errval %d", errval);
  
  if (errval == QMI_ERR_NONE_V01)
  {
    if ( req_msg->mode_pref_valid )
    {
      mode_pref_mask_type_v01 tmp_mp = req_msg->mode_pref;

      #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      if ( ! TARGET_SUPPORTS_CDMA  ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_CDMA2000_1X_V01;
      if ( ! TARGET_SUPPORTS_HDR   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_CDMA2000_HRPD_V01;
      if ( ! TARGET_SUPPORTS_GSM   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_GSM_V01;
      if ( ! TARGET_SUPPORTS_WCDMA ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_UMTS_V01;
      if ( ! TARGET_SUPPORTS_TDS   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_TDSCDMA_V01;
      #elif defined(FEATURE_MMODE_QMI_GPRS_LTE)
      if ( ! TARGET_SUPPORTS_GSM   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_GSM_V01;
      #endif
      if ( ! TARGET_SUPPORTS_LTE   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_LTE_V01;

      if ( tmp_mp == 0x0000 )
      {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
        QM_MSG_HIGH_1("set_sys_sel_pref target supp check fail %d", errval);
      }
    }
  }

  // fill in mode_pref, band_pref, prl_pref and roam_pref based on the REQ
  if (errval == QMI_ERR_NONE_V01)
  {

    #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
    // Handle emergency mode settings
    // Note: qmi_nas_0033_req_check will set all other TLVs to invalid if
    //       t10 is valid, and emergency mode is set to ON
    if ( req_msg->emergency_mode_valid )
    {
      if ( req_msg->emergency_mode == NAS_0033_EMERGENCY_MODE_ON )
      {
        sys_pref_info.mode_pref = CM_MODE_PREF_EMERGENCY;
        sys_pref_info.pref_term = CM_PREF_TERM_PWR_CYCLE;
      }
      else if ( p_ph_info->mode_pref == CM_MODE_PREF_EMERGENCY )
        {
        sys_pref_info.mode_pref = CM_MODE_PREF_PERSISTENT;
      }
    }
    #endif
    // Handle mode pref settings
    // When emergency mode is set to OFF, and t11 is valid
    // the value in t11 will take precedence over persistent
    // settings
    if ( req_msg->mode_pref_valid )
    {
      sys_pref_info.mode_pref = qmi_nas_map_mode_pref_qmi_to_cm( req_msg->mode_pref );

      if (sys_pref_info.mode_pref == CM_MODE_PREF_NONE)
      {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
        QM_MSG_HIGH_1("set_sys_sel_pref mode pref conversion failed %d", req_msg->mode_pref);
      }
    }
    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
    // handle Band preference
    if ( req_msg->band_pref_valid )
      sys_pref_info.band_pref = (cm_band_pref_e_type) req_msg->band_pref;
    #endif

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    // handle CDMA PRL preference
    if ( req_msg->prl_pref_valid )
      sys_pref_info.prl_pref  = (cm_prl_pref_e_type) req_msg->prl_pref;

    // handle Roam preference
    if ( req_msg->roam_pref_valid )
      sys_pref_info.roam_pref = (cm_roam_pref_e_type) req_msg->roam_pref;
#endif
    // handle LTE band preference
    if ( req_msg->lte_band_pref_valid )// set only the first 64 bits as we are using the legacy TLV
    {
      memset(&sys_pref_info.lte_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
      memscpy(&sys_pref_info.lte_band_pref, sizeof(uint64), &req_msg->lte_band_pref, sizeof(uint64));

	  if(!SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_band_pref_any1,&sys_pref_info.lte_band_pref ) ) 
		{
		   errval= QMI_ERR_BAND_NOT_SUPPORTED_V01;
		   QM_MSG_ERROR( "CM_PH_CMD_ERR_BAND_PREF_P: LTE Band Pref not valid");
		}
    }
    else if(req_msg->lte_band_pref_ext_valid)// set the whole 256 bitmask as we are using the new TLV
    {
      memset(&sys_pref_info.lte_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
      memscpy(&sys_pref_info.lte_band_pref, sizeof(sys_lte_band_mask_e_type), &req_msg->lte_band_pref_ext, sizeof(sys_lte_band_mask_e_type));

	  if(!SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_band_pref_any1,&sys_pref_info.lte_band_pref ) ) 
		{
		   errval= QMI_ERR_BAND_NOT_SUPPORTED_V01;
		   QM_MSG_ERROR( "CM_PH_CMD_ERR_BAND_PREF_P: LTE Band Pref_EXT not valid");
		}
    }

    if ( req_msg->net_sel_pref_valid && req_msg->srv_reg_restriction_valid )
    {
      switch ( req_msg->srv_reg_restriction )
      {
        case NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01:
          sys_pref_info.network_sel_mode_pref = (cm_network_sel_mode_pref_e_type) req_msg->net_sel_pref.net_sel_pref;
          break;

        case NAS_SRV_REG_RESTRICTION_LIMITED_V01:
          if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_AUTOMATIC_V01 )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV;
          }
          else if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_MANUAL_V01 )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV;
          }
          break;

        case NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01:
          if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_AUTOMATIC_V01 )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
          }
          else if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_MANUAL_V01 )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
          }
          break;

        default:
          QM_MSG_HIGH_1("Unexpected srv_reg_restriction %d", req_msg->srv_reg_restriction);
          break;
      }

      if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_MANUAL_V01 ||
           req_msg->rat_valid )
      {
        if ( req_msg->mnc_includes_pcs_digit_valid )
        {
          mnc_includes_pcs_digit = req_msg->mnc_includes_pcs_digit;
        }
        else
        {
          mnc_includes_pcs_digit = ( req_msg->net_sel_pref.mnc > 99 );
        }

        if ( sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit , req_msg->net_sel_pref.mcc, req_msg->net_sel_pref.mnc, &plmn ) )
        {
          sys_pref_info.plmn_ptr = &plmn;
        }
        else
        {
          errval = QMI_ERR_INVALID_ARG_V01;
        }

        if ( req_msg->rat_valid )
        {
          sys_pref_info.manual_rat = qmi_nas_radio_if_2_sys_radio_access_ciot(req_msg->rat, req_msg->man_ciot_lte_mode);
        }
      }
    }
    else if ( req_msg->net_sel_pref_valid )
    {
      sys_pref_info.network_sel_mode_pref = (cm_network_sel_mode_pref_e_type) req_msg->net_sel_pref.net_sel_pref;

      if ( sys_pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ||
           req_msg->rat_valid )
      {
        if ( req_msg->mnc_includes_pcs_digit_valid )
        {
          mnc_includes_pcs_digit = req_msg->mnc_includes_pcs_digit;
        }
        else
        {
          mnc_includes_pcs_digit = ( req_msg->net_sel_pref.mnc > 99 );
        }

        if ( sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit , req_msg->net_sel_pref.mcc, req_msg->net_sel_pref.mnc, &plmn ) )
        {
          sys_pref_info.plmn_ptr = &plmn;
        }
        else
        {
          errval = QMI_ERR_INVALID_ARG_V01;
        }

        if ( req_msg->rat_valid )
        {
          sys_pref_info.manual_rat = qmi_nas_radio_if_2_sys_radio_access_ciot(req_msg->rat, req_msg->man_ciot_lte_mode);
        }
      }
    }
    else if ( req_msg->srv_reg_restriction_valid )
    {
      switch ( req_msg->srv_reg_restriction )
      {
        case NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01:
          if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC        ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
          }
          else if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL             ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL;
          }
          break;

        case NAS_SRV_REG_RESTRICTION_LIMITED_V01:
          if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC        ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV;
          }
          else if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL             ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV;
        }
          break;

        case NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01:
          if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC        ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
          }
          else if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL             ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
          }
          break;

        default:
          QM_MSG_HIGH_1("Unexpected srv_reg_restriction %d", req_msg->srv_reg_restriction);
          break;
      }
    }

    if ( req_msg->change_duration_valid )
    {
      switch ( req_msg->change_duration )
      {
        case NAS_PERMANENT_V01:
          sys_pref_info.pref_term = CM_PREF_TERM_PERMANENT;
          break;

        case NAS_POWER_CYCLE_V01:
          sys_pref_info.pref_term = CM_PREF_TERM_PWR_CYCLE;
          break;

        default:
          break;
      }
    }

    if ( req_msg->srv_domain_pref_valid )
    {
      switch( req_msg->srv_domain_pref )
      {
        case QMI_SRV_DOMAIN_PREF_CS_ONLY_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
            break;

        case QMI_SRV_DOMAIN_PREF_PS_ONLY_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_ONLY;
            break;

        case QMI_SRV_DOMAIN_PREF_CS_PS_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_PS;
            break;

        case QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_ATTACH;
            break;

        case QMI_SRV_DOMAIN_PREF_PS_DETACH_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_DETACH;
            break;

        case QMI_SRV_DOMAIN_PREF_PS_DETACH_NO_PREF_CHANGE_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH;
            break;

    case QMI_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH;
            break;

          default:
            break;
      }
    }

    if ( req_msg->acq_order_valid )
    {
        rat_acq_order.type = CM_ACQ_ORDER_TYPE_RAT_PRI;
        rat_acq_order.acq_order.rat_acq_pri_order.num_rat = (uint16)req_msg->acq_order_len;
        for( i = 0 ; (i < MIN(req_msg->acq_order_len,QMI_NAS_ARR_SIZE(rat_acq_order.acq_order.rat_acq_pri_order.acq_order))) && errval == QMI_ERR_NONE_V01 ; i++ )
        {
          switch( req_msg->acq_order[i] )
          {
            #ifdef FEATURE_MMODE_3GPP2
            case NAS_RADIO_IF_CDMA_1X_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_CDMA;
              break;
            case NAS_RADIO_IF_CDMA_1XEVDO_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_HDR;
              break;
            #endif
            #ifdef FEATURE_GSM
            case NAS_RADIO_IF_GSM_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_GSM;
              break;
            #endif
            #ifdef FEATURE_WCDMA
            case NAS_RADIO_IF_UMTS_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_WCDMA;
              break;
            #endif
            case NAS_RADIO_IF_LTE_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_LTE;
              break;
            #ifdef FEATURE_TDSCDMA
            case NAS_RADIO_IF_TDSCDMA_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_TDS;
              break;
            #endif

            default:
              errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
              break;
          }
        }
        sys_pref_info.rat_acq_order_pref_ptr = &rat_acq_order;
      }
    else if ( req_msg->gw_acq_order_pref_valid )
    {
      rat_acq_order.type = CM_ACQ_ORDER_TYPE_GW;
      switch( req_msg->gw_acq_order_pref )
      {
        case NAS_GW_ACQ_ORDER_PREF_AUTOMATIC_V01:
            rat_acq_order.acq_order.gw_acq_order = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
            break;
        case NAS_GW_ACQ_ORDER_PREF_GSM_WCDMA_V01:
            rat_acq_order.acq_order.gw_acq_order = CM_GW_ACQ_ORDER_PREF_GSM_WCDMA;
            break;
        case NAS_GW_ACQ_ORDER_PREF_WCDMA_GSM_V01:
            rat_acq_order.acq_order.gw_acq_order = CM_GW_ACQ_ORDER_PREF_WCDMA_GSM;
            break;
          default:
            break;
    }

      sys_pref_info.rat_acq_order_pref_ptr = &rat_acq_order;
    }


    if ( req_msg->ciot_acq_order_valid )
    {
      rat_acq_order.type = CM_ACQ_ORDER_TYPE_RAT_PRI;
      rat_acq_order.acq_order.rat_acq_pri_order.num_rat =(uint16) req_msg->ciot_acq_order_len;
      for( i = 0 ; i < req_msg->ciot_acq_order_len && i < SYS_MAX_ACQ_PREF_RAT_LIST_NUM && errval == QMI_ERR_NONE_V01 ; i++ )
      {
        switch( req_msg->ciot_acq_order[i] )
        {
          #ifdef FEATURE_MMODE_3GPP2
          case NAS_RADIO_CDMA_1X_V01:
            rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_CDMA;
            break;
          case NAS_RADIO_CDMA_1XEVDO_V01:
            rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_HDR;
            break;
          #endif
          #ifdef FEATURE_GSM
          case NAS_RADIO_GSM_V01:
            rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_GSM;
            break;
          #endif
          #ifdef FEATURE_WCDMA
          case NAS_RADIO_UMTS_V01:
            rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_WCDMA;
            break;
          #endif
          case NAS_RADIO_LTE_V01:
            rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_LTE;
            break;
          #ifdef FEATURE_TDSCDMA
          case NAS_RADIO_TDSCDMA_V01:
            rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_TDS;
            break;
          #endif
          case NAS_RADIO_LTE_M1_V01:
            rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_LTE_M1;
            break;
  
          case NAS_RADIO_LTE_NB1_V01:
            rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_LTE_NB1;
            break;
  
          default:
            errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
            break;
        }
      }
      sys_pref_info.rat_acq_order_pref_ptr = &rat_acq_order;
     }

    #if defined(FEATURE_TDSCDMA)
    // handle TDS band preference
    if ( req_msg->tdscdma_band_pref_valid )
    {
      sys_pref_info.tds_band_pref = (cm_band_pref_e_type) req_msg->tdscdma_band_pref;
    }
    #endif

  // handle usage setting
  if ( req_msg->usage_setting_valid )
    sys_pref_info.ue_usage_setting = (sys_ue_usage_setting_e_type) qmi_nas_map_ue_usage_qmi_to_cm(req_msg->usage_setting);

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))

    if(qm_efs_csg_supported() && req_msg->csg_info_valid)
    {
      mnc_includes_pcs_digit = req_msg->csg_info.mnc_includes_pcs_digit;
      if ( sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit , req_msg->csg_info.mcc, req_msg->csg_info.mnc, &plmn ) )
      {
        sys_pref_info.plmn_ptr = &plmn;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
      sys_pref_info.csg_id = req_msg->csg_info.id;
      sys_pref_info.manual_rat = qmi_nas_radio_if_2_sys_radio_access( req_msg->csg_info.rat );
    }
#endif
#endif

    if(req_msg->ciot_lte_op_mode_pref_valid)
    {
      sys_pref_info.ciot_lte_pref.lte_op_mode_pref 
         = qmi_nas_map_ciot_lte_op_mode_pref_qmi_to_cm((uint16) req_msg->ciot_lte_op_mode_pref );

      if (sys_pref_info.ciot_lte_pref.lte_op_mode_pref == CM_MODE_PREF_NONE)
      {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      }
    }

    if ( req_msg->lte_m1_band_pref_valid )// set only the first 64 bits as we are using the legacy TLV
    {
      memset(&sys_pref_info.ciot_lte_pref.lte_m1_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
      memscpy(&sys_pref_info.ciot_lte_pref.lte_m1_band_pref, sizeof(uint64), &req_msg->lte_m1_band_pref, sizeof(uint64)); 

	  if(!SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_m1_band_pref_any1,&sys_pref_info.ciot_lte_pref.lte_m1_band_pref ) &&
      !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&sys_pref_info.ciot_lte_pref.lte_m1_band_pref,&lte_band_pref_no_chg)) 
	   	{
               errval= QMI_ERR_BAND_NOT_SUPPORTED_V01;
			   QM_MSG_ERROR( "CM_PH_CMD_ERR_BAND_PREF_P: M1 Band Pref not valid");
      	}

    } 
    else if(req_msg->lte_m1_band_pref_ext_valid)// set the whole 256 bitmask as we are using the new TLV
    {
      memset(&sys_pref_info.ciot_lte_pref.lte_m1_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
      memscpy(&sys_pref_info.ciot_lte_pref.lte_m1_band_pref, sizeof(sys_lte_band_mask_e_type), &req_msg->lte_m1_band_pref_ext, sizeof(sys_lte_band_mask_e_type));
	  
	  if(!SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_m1_band_pref_any1,&sys_pref_info.ciot_lte_pref.lte_m1_band_pref ) &&
		  !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&sys_pref_info.ciot_lte_pref.lte_m1_band_pref,&lte_band_pref_no_chg)) 
	    {
			  errval= QMI_ERR_BAND_NOT_SUPPORTED_V01;
			  QM_MSG_ERROR( "CM_PH_CMD_ERR_BAND_PREF_P: M1 Band Pref ext not valid");
		}
    }

    if ( req_msg->lte_nb1_band_pref_valid )// set only the first 64 bits as we are using the legacy TLV
    {
      memset(&sys_pref_info.ciot_lte_pref.lte_nb1_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
      memscpy(&sys_pref_info.ciot_lte_pref.lte_nb1_band_pref, sizeof(uint64), &req_msg->lte_nb1_band_pref, sizeof(uint64));
	  
	  if(!SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_nb1_band_pref_any1,&sys_pref_info.ciot_lte_pref.lte_nb1_band_pref ) &&
		  !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&sys_pref_info.ciot_lte_pref.lte_nb1_band_pref,&lte_band_pref_no_chg)) 
		{
			  errval= QMI_ERR_BAND_NOT_SUPPORTED_V01;
			  QM_MSG_ERROR( "CM_PH_CMD_ERR_BAND_PREF_P: NB1 Band Pref not valid");
		}
    }
    else if(req_msg->lte_nb1_band_pref_ext_valid)// set the whole 256 bitmask as we are using the new TLV
    {
      memset(&sys_pref_info.ciot_lte_pref.lte_nb1_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
      memscpy(&sys_pref_info.ciot_lte_pref.lte_nb1_band_pref, sizeof(sys_lte_band_mask_e_type), &req_msg->lte_nb1_band_pref_ext, sizeof(sys_lte_band_mask_e_type));
	  
	  if(!SYS_LTE_BAND_MASK_CHK_IF_SUBSET(&lte_nb1_band_pref_any1,&sys_pref_info.ciot_lte_pref.lte_nb1_band_pref ) &&
		  !SYS_LTE_BAND_MASK_CHK_IF_EQUAL(&sys_pref_info.ciot_lte_pref.lte_nb1_band_pref,&lte_band_pref_no_chg)) 
		{
			  errval= QMI_ERR_BAND_NOT_SUPPORTED_V01;
			  QM_MSG_ERROR( "CM_PH_CMD_ERR_BAND_PREF_P: NB1 Band Pref ext not valid");
		}
    }
  }

  // handle voice_domain_pref setting
  if(req_msg != NULL)
  {
    if ( req_msg->voice_domain_pref_valid )
    {
      sys_pref_info.voice_domain_pref = req_msg->voice_domain_pref;
    }
  }
  else
  {
    sys_pref_info.voice_domain_pref = SYS_VOICE_DOMAIN_PREF_NO_CHANGE;
  }

  // now call CM API
  if ( errval == QMI_ERR_NONE_V01 )
  {
    sys_pref_info.client_id = qmi_nasi_global.cm_clnt_id;

    retval = cm_user_pref_update_req( &sys_pref_info,
                                      qmi_nas_cmph_cmd_cb,
                                      (void *)cmd_buf_p );

    if ( !retval )
    {
      QM_MSG_HIGH_1("[QMINAS] cm_user_pref_update_req error: mode_pref %d", sys_pref_info.mode_pref);
      errval = QMI_ERR_INVALID_ARG_V01;
    }
  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_sys_sel_pref() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if ( rsp_msg == NULL )
  {
    QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE request. %p", rsp_msg);
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_set_system_selection_preference_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                         (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_system_selection_preference_resp_msg_v01),
                                  &response
                                       );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
} /* qmi_nasi_set_sys_sel_pref() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_SYS_SEL_PREF()

  DESCRIPTION
    Get the different System Selection Preference of the device.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_sys_sel_pref(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type           *response = NULL;
  qmi_error_type_v01      errval                 = QMI_ERR_NONE_V01;
  nas_get_system_selection_preference_resp_msg_v01   *rsp_msg;
  qmi_cm_ph_info_s_type      *p_ph_info = &qmi_nasi_global.cm_ph_info;
  boolean                 mnc_includes_pcs_digit = FALSE;
  sys_mcc_type            mcc = 0;
  sys_mnc_type            mnc = 0;
  boolean                 is_plmn_undefined = TRUE;
  uint32_t                     i;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_system_selection_preference_resp_msg_v01 *) 
      modem_mem_alloc( sizeof( nas_get_system_selection_preference_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {  
    memset( rsp_msg, 0, sizeof(nas_get_system_selection_preference_resp_msg_v01) );
  }

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    p_ph_info = &qmi_nasi_global.cm_ph_info2;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    p_ph_info = &qmi_nasi_global.cm_ph_info3;
  }
#endif
#endif
  if (errval == QMI_ERR_NONE_V01)
  {
    #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
    if ( p_ph_info->mode_pref == CM_MODE_PREF_EMERGENCY )
    {
      rsp_msg->emergency_mode = NASI_MODE_EMERGENCY_MODE_ON;

#ifdef FEATURE_DUAL_SIM
      if ( p_ph_info->asubs_id == SYS_MODEM_AS_ID_2 )
      {
        rsp_msg->mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref2 );
      }
      else
#endif
#ifdef FEATURE_TRIPLE_SIM
      if ( p_ph_info->asubs_id == SYS_MODEM_AS_ID_3 )
      {
        rsp_msg->mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref3 );
      }
      else
#endif
      {
        rsp_msg->mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref );
      }
    }
    else
    {
      rsp_msg->emergency_mode = NASI_MODE_EMERGENCY_MODE_OFF;
    #endif
      rsp_msg->mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( p_ph_info->mode_pref );
    #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
    }
    rsp_msg->emergency_mode_valid      = TRUE;
    #endif

    if (rsp_msg->mode_pref != 0)
    {
      rsp_msg->mode_pref_valid   = TRUE;
    }

    rsp_msg->ciot_lte_op_mode_pref 
         = qmi_nas_map_ciot_lte_op_mode_pref_cm_to_qmi( p_ph_info->ciot_lte_pref.lte_op_mode_pref);

    if (rsp_msg->ciot_lte_op_mode_pref != 0)
    {
      rsp_msg->ciot_lte_op_mode_pref_valid = TRUE;
    }
    
    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
    rsp_msg->band_pref = (uint64)p_ph_info->band_pref;
    rsp_msg->band_pref_valid     = TRUE;
    #endif

    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
    if ( TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR )
    {
      rsp_msg->prl_pref = (uint16)p_ph_info->prl_pref;
      rsp_msg->prl_pref_valid    = TRUE;
    }
    rsp_msg->roam_pref = (uint16)p_ph_info->roam_pref;
    rsp_msg->roam_pref_valid     = TRUE;
    #endif

    memscpy(&rsp_msg->band_pref_ext, sizeof(uint64), &p_ph_info->lte_band_pref, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
    memscpy(&rsp_msg->lte_band_pref_ext, sizeof(sys_lte_band_mask_e_type), &p_ph_info->lte_band_pref, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV
    
    rsp_msg->band_pref_ext_valid         = TRUE;
    rsp_msg->lte_band_pref_ext_valid          = TRUE;

    memscpy(&rsp_msg->lte_m1_band_pref, sizeof(uint64), &p_ph_info->ciot_lte_pref.lte_m1_band_pref, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
    memscpy(&rsp_msg->lte_m1_band_pref_ext, sizeof(sys_lte_band_mask_e_type), &p_ph_info->ciot_lte_pref.lte_m1_band_pref, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV
    
    rsp_msg->lte_m1_band_pref_valid         = TRUE;
    rsp_msg->lte_m1_band_pref_ext_valid          = TRUE;

    memscpy(&rsp_msg->lte_nb1_band_pref, sizeof(uint64), &p_ph_info->ciot_lte_pref.lte_nb1_band_pref, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
    memscpy(&rsp_msg->lte_nb1_band_pref_ext, sizeof(sys_lte_band_mask_e_type), &p_ph_info->ciot_lte_pref.lte_nb1_band_pref, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV
    
    rsp_msg->lte_nb1_band_pref_valid         = TRUE;
    rsp_msg->lte_nb1_band_pref_ext_valid          = TRUE;

    if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC ||
         p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
    {
      rsp_msg->net_sel_pref                   = (uint8)p_ph_info->network_sel_mode_pref;
      rsp_msg->net_sel_pref_valid           = TRUE;
      rsp_msg->srv_reg_restriction          = (uint8)NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;
      rsp_msg->srv_reg_restriction_valid  = TRUE;
    }
    else if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV )
    {
      rsp_msg->net_sel_pref             = (uint8)CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
      rsp_msg->net_sel_pref_valid    = TRUE;
      rsp_msg->srv_reg_restriction           = (uint8)NAS_SRV_REG_RESTRICTION_LIMITED_V01;
      rsp_msg->srv_reg_restriction_valid   = TRUE;
    }
    else if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV )
    {
      rsp_msg->net_sel_pref             = (uint8)CM_NETWORK_SEL_MODE_PREF_MANUAL;
      rsp_msg->net_sel_pref_valid     = TRUE;
      rsp_msg->srv_reg_restriction             = (uint8)NAS_SRV_REG_RESTRICTION_LIMITED_V01;
      rsp_msg->srv_reg_restriction_valid     = TRUE;
    }
    else if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY )
    {
      rsp_msg->net_sel_pref              = (uint8)CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
      rsp_msg->net_sel_pref_valid     = TRUE;
      rsp_msg->srv_reg_restriction            = (uint8)NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
      rsp_msg->srv_reg_restriction_valid    = TRUE;
    }
    else if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY )
    {
      rsp_msg->net_sel_pref                     = (uint8)CM_NETWORK_SEL_MODE_PREF_MANUAL;
      rsp_msg->net_sel_pref_valid             = TRUE;
      rsp_msg->srv_reg_restriction            = (uint8)NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
      rsp_msg->srv_reg_restriction_valid    = TRUE;
    }

    //service domain preference
    switch( p_ph_info->srv_domain_pref )
    {
      case CM_SRV_DOMAIN_PREF_CS_ONLY:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_CS_ONLY_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      case CM_SRV_DOMAIN_PREF_PS_ONLY:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_PS_ONLY_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      case CM_SRV_DOMAIN_PREF_CS_PS:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_CS_PS_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      case CM_SRV_DOMAIN_PREF_PS_ATTACH:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      case CM_SRV_DOMAIN_PREF_PS_DETACH:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_PS_DETACH_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      default:
        // don't include this TLV
        break;

    }

#ifndef FEATURE_MMODE_QMI_LTE_ONLY
    // GW acquisition order preference
    switch(p_ph_info->acq_order_pref)
    {
      case CM_GW_ACQ_ORDER_PREF_AUTOMATIC:
        rsp_msg->gw_acq_order_pref         = NAS_GW_ACQ_ORDER_PREF_AUTOMATIC_V01;
        rsp_msg->gw_acq_order_pref_valid = TRUE;
        break;

      case CM_GW_ACQ_ORDER_PREF_GSM_WCDMA:
        rsp_msg->gw_acq_order_pref          = NAS_GW_ACQ_ORDER_PREF_GSM_WCDMA_V01;
        rsp_msg->gw_acq_order_pref_valid = TRUE;
        break;

      case CM_GW_ACQ_ORDER_PREF_WCDMA_GSM:
        rsp_msg->gw_acq_order_pref = NAS_GW_ACQ_ORDER_PREF_WCDMA_GSM_V01;
        rsp_msg->gw_acq_order_pref_valid = TRUE;
        break;

      default :
        // don't include this TLV
        break;

    }
    #endif
    #if defined(FEATURE_TDSCDMA)
    // 0x1A - TDSCDMA band preference
    rsp_msg->tdscdma_band_pref              = (uint64)p_ph_info->tds_band_pref;
    rsp_msg->tdscdma_band_pref_valid      = TRUE;

    #endif
    // 0x1B - PLMN info - to be included when net_sel_mode_pref is manual
    if( rsp_msg->net_sel_pref_valid && rsp_msg->net_sel_pref == (uint8) CM_NETWORK_SEL_MODE_PREF_MANUAL )
    {
      sys_plmn_get_mcc_mnc( p_ph_info->plmn, &is_plmn_undefined, &mnc_includes_pcs_digit, &mcc, &mnc );
      if( !is_plmn_undefined )
      {
        rsp_msg->manual_net_sel_plmn.mcc = (uint16) mcc;
        rsp_msg->manual_net_sel_plmn.mnc = (uint16) mnc;
        rsp_msg->manual_net_sel_plmn.mnc_includes_pcs_digit = (uint8) mnc_includes_pcs_digit;
        rsp_msg->manual_net_sel_plmn_valid = TRUE;
      }
      else
      {
        QM_MSG_ERROR("Undefined PLMN value. Unable to obtain PLMN info");
      }

    }


    if( p_ph_info->acq_pri_order_pref.num_rat > NAS_ACQ_ORDER_LIST_MAX_V01 )
    {
      QM_MSG_HIGH_2("Received acquisition order num rat %d, max expected %d", p_ph_info->acq_pri_order_pref.num_rat, NAS_ACQ_ORDER_LIST_MAX_V01);
      rsp_msg->acq_order_len = NAS_ACQ_ORDER_LIST_MAX_V01;
    }
    else
    {
      rsp_msg->acq_order_len = p_ph_info->acq_pri_order_pref.num_rat ;
    }
    
    for( i = 0; i < MIN(rsp_msg->acq_order_len,QMI_NAS_ARR_SIZE(p_ph_info->acq_pri_order_pref.acq_order)) && errval == QMI_ERR_NONE_V01; i++ )
    {
      switch( p_ph_info->acq_pri_order_pref.acq_order[i] )
      {
        #ifdef FEATURE_MMODE_3GPP2
        case SYS_SYS_MODE_CDMA:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_CDMA_1X_V01;
          rsp_msg->ciot_acq_order[i] = NAS_RADIO_CDMA_1X_V01;
          break;
        case SYS_SYS_MODE_HDR:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_CDMA_1XEVDO_V01;
          rsp_msg->ciot_acq_order[i] = NAS_RADIO_CDMA_1XEVDO_V01;
          break;
        #endif
        #ifdef FEATURE_GSM
        case SYS_SYS_MODE_GSM:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_GSM_V01;
          rsp_msg->ciot_acq_order[i] = NAS_RADIO_GSM_V01;
          break;
        #endif
        #ifdef FEATURE_WCDMA
        case SYS_SYS_MODE_WCDMA:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_UMTS_V01;
          rsp_msg->ciot_acq_order[i] = NAS_RADIO_UMTS_V01;
          break;
        #endif
        #ifdef FEATURE_LTE
        case SYS_SYS_MODE_LTE:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_LTE_V01;
          rsp_msg->ciot_acq_order[i] = NAS_RADIO_LTE_V01;
          break;
        #endif
        #ifdef FEATURE_TDSCDMA
        case SYS_SYS_MODE_TDS:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_TDSCDMA_V01;
          rsp_msg->ciot_acq_order[i] = NAS_RADIO_TDSCDMA_V01;
          break;
        #endif

        #ifdef FEATURE_LTE
        case SYS_SYS_MODE_LTE_M1:
          rsp_msg->ciot_acq_order[i] = NAS_RADIO_LTE_M1_V01;
          break;

        case SYS_SYS_MODE_LTE_NB1:
          rsp_msg->ciot_acq_order[i] = NAS_RADIO_LTE_NB1_V01;
          break;
        #endif
        
        default:
          break;
      }
    }
    if ( errval == QMI_ERR_NONE_V01 )
    {
      rsp_msg->acq_order_valid = TRUE;
      rsp_msg->ciot_acq_order_valid = TRUE;
      rsp_msg->ciot_acq_order_len = p_ph_info->acq_pri_order_pref.num_rat ;
    }


#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))

    if ( qm_efs_csg_supported() )
    {
    if( p_ph_info->csg_id != SYS_CSG_ID_INVALID )
    {
      sys_plmn_get_mcc_mnc( p_ph_info->plmn, &is_plmn_undefined, &mnc_includes_pcs_digit, &mcc, &mnc );
      if( !is_plmn_undefined )
      {
        rsp_msg->csg_info_valid = TRUE;
        rsp_msg->csg_info.mcc = (uint16) mcc;
        rsp_msg->csg_info.mnc = (uint16) mnc;
        rsp_msg->csg_info.mnc_includes_pcs_digit = (uint8) mnc_includes_pcs_digit;
        rsp_msg->csg_info.id = p_ph_info->csg_id;
        rsp_msg->csg_info.rat = (nas_radio_if_enum_v01)qmi_nas_sys_radio_access_2_radio_if( p_ph_info->csg_rat );
      }
      else
      {
        QM_MSG_ERROR("Undefined PLMN value. Unable to obtain CSG PLMN info");
      }
    }
    }
#endif
#endif

    rsp_msg->usage_setting_valid = TRUE;
    QM_MSG_HIGH_2("cm_ph_info->ue_usage_setting %d, voice_domain_pref %d", p_ph_info->ue_usage_setting, p_ph_info->voice_domain_pref);

    switch(p_ph_info->ue_usage_setting)
    {
      case SYS_UE_USAGE_SETTING_VOICE_CENTRIC:
        rsp_msg->usage_setting = (uint32)NAS_USAGE_VOICE_CENTRIC_V01;
        break;
      case SYS_UE_USAGE_SETTING_DATA_CENTRIC:
        rsp_msg->usage_setting = (uint32)NAS_USAGE_DATA_CENTRIC_V01;
        break;
      default:
        rsp_msg->usage_setting = (uint32)NAS_USAGE_UNKNOWN_V01;
        break;      
    }

    rsp_msg->voice_domain_pref_valid = TRUE;
    //QM_MSG_HIGH_1("cm_ph_info->voice_domain_pref %d", p_ph_info->voice_domain_pref);
    rsp_msg->voice_domain_pref = (nas_voice_domain_pref_enum_type_v01)p_ph_info->voice_domain_pref;

  }

  if(rsp_msg != NULL)
  {
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)rsp_msg,
                                  (uint32_t) sizeof(nas_get_system_selection_preference_resp_msg_v01),
                                  &response
                                );
    modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
  }

  return response;
} /* qmi_nasi_get_sys_sel_pref() */

/*===========================================================================
  FUNCTION QMI_NASI_SYS_SEL_PREF_IND()

  DESCRIPTION
    Is called when any of the conditions set in reg_sys_sel_pref becomes true
    Sends an indication to the client

  PARAMETERS
    sp             : service provided state pointer (user data)
    clid           : clientID
    emergency_mode : Emergency mode
    mode_pref      : Mode preference
    band_pref      : Band preference
    prl_pref       : prl preference
    roam_pref      : roam preference

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_sys_sel_pref_ind(
  qmi_nasi_client_state_type *  cl_sp,
  #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
  uint8         emergency_mode,
  #endif
  uint16        mode_pref,
  uint64        band_pref,
  uint16        prl_pref,
  uint16        roam_pref,
  sys_lte_band_mask_e_type        lte_band_pref,
  uint64        tds_band_pref,
  uint8         net_sel_mode_pref,
  uint32        srv_domain_pref,
  uint32        gw_acq_order_pref,
  sys_plmn_id_s_type plmn,
  cm_acq_pri_order_pref_s_type acq_order,
  sys_ue_usage_setting_e_type ue_usage_setting,
  sys_csg_id_type csg_id,
  sys_radio_access_tech_e_type csg_rat,
  sys_voice_domain_pref_e_type  voice_domain_pref,
  cm_ciot_lte_op_mode_e_type    ciot_lte_op_mode,
  sys_lte_band_mask_e_type                        lte_m1_band_pref,
  sys_lte_band_mask_e_type                        lte_nb1_band_pref
)
{
  dsm_item_type               *ind = NULL;
  nas_system_selection_preference_ind_msg_v01      *ind_msg;
  boolean                     mnc_includes_pcs_digit = FALSE;
  sys_mcc_type                mcc = 0;
  sys_mnc_type                mnc = 0;
  boolean                     is_plmn_undefined = TRUE;
  uint32_t                        i;
  boolean                     include_acq_order = TRUE;

  if(cl_sp == NULL)
  {
    return;
  }

  ind_msg = (nas_system_selection_preference_ind_msg_v01  *) 
      modem_mem_alloc( sizeof(nas_system_selection_preference_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ind_msg == NULL )
  {
    qmi_voice_mem_error();
    return;
  }

  memset( ind_msg, 0, sizeof(nas_system_selection_preference_ind_msg_v01) );
 
  // TLV 0x20 - Usage setting
  ind_msg->voice_domain_pref_valid = TRUE;

  ind_msg->voice_domain_pref = (nas_voice_domain_pref_enum_type_v01)voice_domain_pref;

  // TLV 0x1F - Usage setting
  ind_msg->usage_setting_valid = TRUE;
    QM_MSG_HIGH_2("cm_ph_info->voice_domain_pref %d, ue_usage_setting %d", voice_domain_pref, ue_usage_setting);

  switch(ue_usage_setting)
  {
    case SYS_UE_USAGE_SETTING_VOICE_CENTRIC:
      ind_msg->usage_setting = (uint32)NAS_USAGE_VOICE_CENTRIC_V01;
      break;
    case SYS_UE_USAGE_SETTING_DATA_CENTRIC:
      ind_msg->usage_setting = (uint32)NAS_USAGE_DATA_CENTRIC_V01;
      break;
    default:
      ind_msg->usage_setting = (uint32)NAS_USAGE_UNKNOWN_V01;
      break;      
    }

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  if ( qm_efs_csg_supported() )
  {
  if( csg_id != SYS_CSG_ID_INVALID )
  {
    sys_plmn_get_mcc_mnc( plmn, &is_plmn_undefined, &mnc_includes_pcs_digit, &mcc, &mnc );
    QM_MSG_HIGH_3("SYS_SEL_PREF csg_id %d, csg_rat %d is_plmn_undefined %d", csg_id, csg_rat, is_plmn_undefined);
    if( !is_plmn_undefined )
    {
      ind_msg->csg_info_valid = TRUE;
      ind_msg->csg_info.mcc = (uint16) mcc;
      ind_msg->csg_info.mnc = (uint16) mnc;
      ind_msg->csg_info.mnc_includes_pcs_digit = (uint8) mnc_includes_pcs_digit;
      ind_msg->csg_info.id = csg_id;
      ind_msg->csg_info.rat = (nas_radio_if_enum_v01)qmi_nas_sys_radio_access_2_radio_if( csg_rat );
      
    }
  }
  }
#endif
#endif

  if( acq_order.num_rat > NAS_ACQ_ORDER_LIST_MAX_V01 )
  {
    ind_msg->acq_order_len = NAS_ACQ_ORDER_LIST_MAX_V01;
  }
  else
  {
    ind_msg->acq_order_len = acq_order.num_rat ;
  }

  for( i = 0; (i < MIN(ind_msg->acq_order_len,QMI_NAS_ARR_SIZE(acq_order.acq_order))) && include_acq_order; i++ )
  {
    switch( acq_order.acq_order[i] )
    {
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY
      #ifdef FEATURE_MMODE_3GPP2
      case SYS_SYS_MODE_CDMA:
        ind_msg->acq_order[i] = NAS_RADIO_IF_CDMA_1X_V01;
        ind_msg->ciot_acq_order[i] = NAS_RADIO_CDMA_1X_V01;
        break;
      case SYS_SYS_MODE_HDR:
        ind_msg->acq_order[i] = NAS_RADIO_IF_CDMA_1XEVDO_V01;
        ind_msg->ciot_acq_order[i] = NAS_RADIO_CDMA_1XEVDO_V01;
        break;
      #endif
      #ifdef FEATURE_GSM
      case SYS_SYS_MODE_GSM:
        ind_msg->acq_order[i] = NAS_RADIO_IF_GSM_V01;
        ind_msg->ciot_acq_order[i] = NAS_RADIO_GSM_V01;
        break;
      #endif
      #ifdef FEATURE_WCDMA
      case SYS_SYS_MODE_WCDMA:
        ind_msg->acq_order[i] = NAS_RADIO_IF_UMTS_V01;
        ind_msg->ciot_acq_order[i] = NAS_RADIO_UMTS_V01;
        break;
      #endif
      #ifdef FEATURE_TDSCDMA
      case SYS_SYS_MODE_TDS:
        ind_msg->acq_order[i] = NAS_RADIO_IF_TDSCDMA_V01;
        ind_msg->ciot_acq_order[i] = NAS_RADIO_TDSCDMA_V01;
        break;
      #endif
      #endif
        
      case SYS_SYS_MODE_LTE:
        ind_msg->acq_order[i] = NAS_RADIO_IF_LTE_V01;
        ind_msg->ciot_acq_order[i] = NAS_RADIO_LTE_V01;
        break;

      case SYS_SYS_MODE_LTE_M1:
        ind_msg->ciot_acq_order[i] = NAS_RADIO_LTE_M1_V01;
        break;

      case SYS_SYS_MODE_LTE_NB1:
        ind_msg->ciot_acq_order[i] = NAS_RADIO_LTE_NB1_V01;
        break;
        
      default:
        include_acq_order = FALSE;
        break;
    }
  }

  if( include_acq_order )
  {
    ind_msg->acq_order_valid = TRUE;
    ind_msg->ciot_acq_order_valid = TRUE;
    ind_msg->ciot_acq_order_len = acq_order.num_rat ;
  }

  // 0x1B - PLMN info - to be included when net_sel_mode_pref is manual
  if( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
  {
    sys_plmn_get_mcc_mnc( plmn, &is_plmn_undefined, &mnc_includes_pcs_digit, &mcc, &mnc );
    if( !is_plmn_undefined )
    {
      ind_msg->manual_net_sel_plmn.mcc = (uint16) mcc;
      ind_msg->manual_net_sel_plmn.mnc = (uint16) mnc;
      ind_msg->manual_net_sel_plmn.mnc_includes_pcs_digit = (uint8) mnc_includes_pcs_digit;
      ind_msg->manual_net_sel_plmn_valid = TRUE;
    }
  }
  #if defined(FEATURE_TDSCDMA)
  // 0x1A TDSCDMA band preference
  ind_msg->tdscdma_band_pref  = tds_band_pref;
  ind_msg->tdscdma_band_pref_valid          = TRUE;
  #endif
  
  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  // GW acquisition order preference
  switch( gw_acq_order_pref )
  {
    case CM_GW_ACQ_ORDER_PREF_AUTOMATIC:
      ind_msg->gw_acq_order_pref = NAS_GW_ACQ_ORDER_PREF_AUTOMATIC_V01;
      ind_msg->gw_acq_order_pref_valid = TRUE;
      break;

    case CM_GW_ACQ_ORDER_PREF_GSM_WCDMA:
      ind_msg->gw_acq_order_pref = NAS_GW_ACQ_ORDER_PREF_GSM_WCDMA_V01;
      ind_msg->gw_acq_order_pref_valid = TRUE;
      break;

    case CM_GW_ACQ_ORDER_PREF_WCDMA_GSM:
      ind_msg->gw_acq_order_pref = NAS_GW_ACQ_ORDER_PREF_WCDMA_GSM_V01;
      ind_msg->gw_acq_order_pref_valid = TRUE;
      break;

    default :
      // don't include this TLV
      break;

  }
  #endif

  //service domain preference
  switch( srv_domain_pref )
  {
    case CM_SRV_DOMAIN_PREF_CS_ONLY:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_CS_ONLY_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    case CM_SRV_DOMAIN_PREF_PS_ONLY:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_PS_ONLY_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    case CM_SRV_DOMAIN_PREF_CS_PS:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_CS_PS_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    case CM_SRV_DOMAIN_PREF_PS_ATTACH:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    case CM_SRV_DOMAIN_PREF_PS_DETACH:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_PS_DETACH_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    default:
      // don't include this TLV
      break;
  }

  if( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC || net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
  {
    ind_msg->net_sel_pref = net_sel_mode_pref;
    ind_msg->net_sel_pref_valid             = TRUE;
    ind_msg->srv_reg_restriction                        = (uint8)NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }
  else if ( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV )
  {
    ind_msg->net_sel_pref   = (uint8)CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
    ind_msg->net_sel_pref_valid               = TRUE;
    ind_msg->srv_reg_restriction = (uint8)NAS_SRV_REG_RESTRICTION_LIMITED_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }
  else if ( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV )
  {
    ind_msg->net_sel_pref   = (uint8)CM_NETWORK_SEL_MODE_PREF_MANUAL;
    ind_msg->net_sel_pref_valid               = TRUE;
    ind_msg->srv_reg_restriction = (uint8)NAS_SRV_REG_RESTRICTION_LIMITED_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }
  else if ( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY )
  {
    ind_msg->net_sel_pref   = (uint8)CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
    ind_msg->net_sel_pref_valid               = TRUE;
    ind_msg->srv_reg_restriction = (uint8)NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }
  else if ( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY )
  {
    ind_msg->net_sel_pref   = (uint8)CM_NETWORK_SEL_MODE_PREF_MANUAL;
    ind_msg->net_sel_pref_valid               = TRUE;
    ind_msg->srv_reg_restriction = (uint8)NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }

  memscpy(&ind_msg->lte_band_pref, sizeof(uint64), &lte_band_pref, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
  memscpy(&ind_msg->lte_band_pref_ext, sizeof(sys_lte_band_mask_e_type), &lte_band_pref, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV
  ind_msg->lte_band_pref_valid          = TRUE;
  ind_msg->lte_band_pref_ext_valid          = TRUE;

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) || defined(FEATURE_HDR)
  ind_msg->roam_pref                  = roam_pref;
  ind_msg->roam_pref_valid          = TRUE;

  ind_msg->prl_pref                  = prl_pref;
  ind_msg->prl_pref_valid          = TRUE;
  #endif

  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  ind_msg->band_pref            = band_pref;
  ind_msg->band_pref_valid    = TRUE;
  #endif

  ind_msg->mode_pref          = mode_pref;
  ind_msg->mode_pref_valid  = TRUE;
  #ifndef FEATURE_MMODE_DISABLE_EMERGENCY
  ind_msg->emergency_mode          = emergency_mode;
  ind_msg->emergency_mode_valid  = TRUE;
  #endif
  if ((ciot_lte_op_mode != CM_LTE_IOT_OP_MODE_PREF_NONE) &&
      (ciot_lte_op_mode != CM_LTE_IOT_OP_MODE_PREF_MAX)
     )
  {
    ind_msg->ciot_lte_op_mode_pref = qmi_nas_map_ciot_lte_op_mode_pref_cm_to_qmi(ciot_lte_op_mode);
    ind_msg->ciot_lte_op_mode_pref_valid = TRUE;
  }

  if (!SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&lte_m1_band_pref))
  {
    memscpy(&ind_msg->lte_m1_band_pref, sizeof(uint64), &lte_m1_band_pref, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
    memscpy(&ind_msg->lte_m1_band_pref_ext, sizeof(sys_lte_band_mask_e_type), &lte_m1_band_pref, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV
    ind_msg->lte_m1_band_pref_valid          = TRUE;
    ind_msg->lte_m1_band_pref_ext_valid          = TRUE;
  }

  if (!SYS_LTE_BAND_MASK_CHK_IF_EMPTY(&lte_nb1_band_pref))
  {
    memscpy(&ind_msg->lte_nb1_band_pref, sizeof(uint64), &lte_nb1_band_pref, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
    memscpy(&ind_msg->lte_nb1_band_pref_ext, sizeof(sys_lte_band_mask_e_type), &lte_nb1_band_pref, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV
    ind_msg->lte_nb1_band_pref_valid          = TRUE;
    ind_msg->lte_nb1_band_pref_ext_valid          = TRUE;
  }

  
  {
    ind = NULL;

    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                              QMI_IDL_INDICATION,
                                              QMI_NAS_SYSTEM_SELECTION_PREFERENCE_IND_MSG_V01,
                                              (void *) ind_msg,
                                              (uint32_t) sizeof( nas_system_selection_preference_ind_msg_v01 ),
                                              &ind
                                            )
      )
    {
      qmi_nasi_send_ind( cl_sp, (uint16)QMI_NAS_SYSTEM_SELECTION_PREFERENCE_IND_MSG_V01, ind );
    }
    else
    {
       QM_MSG_ERROR("failed to send SYSTEM_SELECTION_PREFERENCE_IND ind");
    }
  }

  if ( ind_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) ind_msg ); }

} /* qmi_nasi_sys_sel_pref_ind() */
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
/*===========================================================================
  FUNCTION QMI_NASI_CURRENT_NAM_IND()

  DESCRIPTION
    Is called when any of the conditions set in reg_current_nam becomes true
    Sends an indication to the client

  PARAMETERS
    sp           : service provided state pointer (user data)
    clid         : clientID
    current_nam_index   : current name Index

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_current_nam_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         current_nam_index
)
{
  dsm_item_type *  ind;

  struct
  {
    uint8   nam_index;
  } v_required_out;


  if(cl_sp == NULL)
  {
    return;
  }

  ind = NULL;

  v_required_out.nam_index = current_nam_index;
  if(FALSE == qmi_svc_put_param_tlv(&ind,
                                    QMI_TYPE_REQUIRED_PARAMETERS,
                                    sizeof (v_required_out),
                                    &v_required_out))
  {
    QM_MSG_HIGH("Unable to return the Current NAM!");
    dsm_free_packet(&ind);
    return;
  }

  qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_GET_NAM, ind );

} /* qmi_nasi_current_nam_ind() */
#endif
#ifndef REMOVE_QMI_NAS_SET_DDTM_PREFERENCE_V01
/*===========================================================================
  FUNCTION QMI_NASI_SET_DDTM_PREFERENCE()

  DESCRIPTION
    Sets the DDTM(Data Dedicated Transmission Model) preference for
    the device.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_ddtm_preference
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  boolean            retval;
  qmi_result_e_type  result;
  qmi_error_e_type   errval;
#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

#ifdef _WIN32
#pragma pack(push,1) // Save previous, and turn on 1 byte alignment
#endif

  PACK(struct)
  {
    uint8       ddtm_pref;
    uint16      ddtm_act;
    uint8       so_list_action;
    uint8       num_so_instances;
    uint16      so[SYS_DDTM_MAX_SO_LIST_SIZE];
  } v_required;

#ifdef _WIN32
#pragma pack(pop) // Revert alignment to what it was previously
#endif

  boolean                              got_required_tlv;
  uint8                                type;
  uint16                               len;
  uint16                               expected_len;
  void *                               value;

  cm_ddtm_pref_e_type                  ddtm_pref;
  sys_ddtm_act_mask_e_type             ddtm_act;
  cm_ddtm_so_list_act_e_type           so_list_act;
  uint16                               num_srv_opt;
  sys_srv_opt_type                     srv_opt_list[SYS_DDTM_MAX_SO_LIST_SIZE];
  uint16                               srv_opt_len = 0;
  uint16                               tlv_len = 0;

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);


  response = NULL;
  errval = QMI_ERR_NONE;

#if !defined (FEATURE_CDMA_800) && !defined (FEATURE_CDMA_1900)
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */
  memset(&v_required, 0, sizeof(v_required));
  got_required_tlv = FALSE;

  while (*sdu_in)
  {
    if( !qmi_svc_get_tl( sdu_in, &type, &len ) )
    {
      continue;
    }

    // special value 0 = variable length or don't care (unrecognzied TLV)
    expected_len = 0;
    value = NULL;
    switch (type)
    {
      case QMI_TYPE_REQUIRED_PARAMETERS:
        if (len <= sizeof(v_required))
        {
          got_required_tlv = TRUE;
          value = &v_required;
          tlv_len = len;
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG;
          goto send_result;
        }
        break;

      default:
        break;
    }

    if ((expected_len != 0) && (expected_len != len))
    {
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    /*-----------------------------------------------------------------------
      If type is unrecognized, value will be NULL, and dsm_pullup will
      free the unrecognized value, i.e. we skip past unrecognized TLVs
    -----------------------------------------------------------------------*/
    if(len != dsm_pullup( sdu_in, value, len ))
    {
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }
  }
  /*-------------------------------------------------------------------------
    If ALL optional TLVs are absent return error or else act depending on
    which tlvs are present
  -------------------------------------------------------------------------*/
  if(!(got_required_tlv))
  {
    errval = QMI_ERR_MISSING_ARG;
  }
  else
  {
    /* Validate length of input tlv to ensure it is consistent with
    num srv opt instances field specified in the tlv  */
    if ( tlv_len !=
             ( sizeof(v_required.ddtm_pref) +
               sizeof(v_required.ddtm_act) +
               sizeof(v_required.so_list_action) +
               sizeof(v_required.num_so_instances) +
               ( v_required.num_so_instances * sizeof(sys_srv_opt_type) ) ) )
    {
      QM_MSG_HIGH_2("Num_Service_opt_instances value(%d) different from number of Serice option sent in TLV: TLV_len(%d)!", v_required.num_so_instances, tlv_len);
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    if ((cm_ddtm_pref_e_type) v_required.ddtm_pref >= CM_DDTM_PREF_MAX)
    {
      errval = QMI_ERR_INVALID_ARG;
      goto send_result;
    }

    if ( (sys_ddtm_act_mask_e_type) v_required.ddtm_act == SYS_DDTM_ACT_MASK_EMPTY ||
         (sys_ddtm_act_mask_e_type) v_required.ddtm_act >= SYS_DDTM_ACT_MASK_MAX )
    {
      errval = QMI_ERR_INVALID_ARG;
      goto send_result;
    }

    if ((cm_ddtm_so_list_act_e_type) v_required.so_list_action >= CM_DDTM_SO_LIST_ACT_MAX)
    {
      errval = QMI_ERR_INVALID_ARG;
      goto send_result;
    }

    ddtm_pref = (cm_ddtm_pref_e_type) v_required.ddtm_pref;
    ddtm_act = (sys_ddtm_act_mask_e_type) v_required.ddtm_act;
    so_list_act = (cm_ddtm_so_list_act_e_type) v_required.so_list_action;
    num_srv_opt = v_required.num_so_instances;

    if(num_srv_opt > SYS_DDTM_MAX_SO_LIST_SIZE)
    {
      errval = QMI_ERR_ARG_TOO_LONG;
      goto send_result;
    }

    srv_opt_len = num_srv_opt * sizeof(sys_srv_opt_type);
    memscpy((sys_srv_opt_type *) srv_opt_list, srv_opt_len,
            (sys_srv_opt_type *) v_required.so, srv_opt_len);

    if (!cm_ph_cmd_ddtm_pref( qmi_nas_cmph_cmd_cb,
                              (void *)cmd_buf_p,
                              qmi_nasi_global.cm_clnt_id,
                              ddtm_pref,
                              ddtm_act,
                              so_list_act,
                              num_srv_opt,
                              srv_opt_list ))
    {
      QM_MSG_ERROR("Unable to change DDTM Preference");
    }
    return QMI_SVC_RESPONSE_PENDING;
  }
#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */
send_result:
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_set_ddtm_preference() */

/*===========================================================================
  FUNCTION QMI_NASI_DDTM_IND()

  DESCRIPTION
    Is called when any of the conditions set in reg_ddtm_events becomes true
    Sends an indication to the client

  PARAMETERS
    sp              : service provided state pointer (user data)
    clid            : clientID
    cur_ddtm_status : cuurent ddtm status
    ddtm_pref       : ddtm preference setting
    ddtm_act_mask   : bitmask representing combined DDTM action should take
    num_so_instances: number of service options that follow
    srv_option      : Serive option pages should be ignored when DDTM status ON

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_ddtm_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         cur_ddtm_status,
  uint8         ddtm_pref,
  uint16        ddtm_act_mask,
  uint8         num_so_instances,
  uint16*       srv_option
)
{
  dsm_item_type *  ind;

#ifdef _WIN32
#pragma pack(push,1) // Save previous, and turn on 1 byte alignment
#endif

  PACK(struct)
  {
    uint8       cur_ddtm_status;
    uint8       ddtm_pref;
    uint16      ddtm_act_mask;
    uint8       num_so_instances;
    uint16      srv_option[SYS_DDTM_MAX_SO_LIST_SIZE];
  } v_required_out;

#ifdef _WIN32
#pragma pack(pop) // Revert alignment to what it was previously
#endif

  uint16                        srv_opt_len = 0;
  uint16                        tlv_len = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(srv_option);
  memset(&v_required_out, 0, sizeof(v_required_out));

  ind = NULL;

  if(cl_sp == NULL)
  {
    return;
  }  

  if ( num_so_instances <= SYS_DDTM_MAX_SO_LIST_SIZE )
  {
    v_required_out.cur_ddtm_status = cur_ddtm_status;
    v_required_out.ddtm_pref = ddtm_pref;
    v_required_out.ddtm_act_mask = ddtm_act_mask;
    v_required_out.num_so_instances = num_so_instances;

    srv_opt_len = num_so_instances * sizeof(sys_srv_opt_type);
    memscpy ((void *)v_required_out.srv_option, srv_opt_len, srv_option, srv_opt_len);

    tlv_len = ( sizeof(v_required_out.cur_ddtm_status) +
                sizeof(v_required_out.ddtm_pref) +
                sizeof(v_required_out.ddtm_act_mask) +
                sizeof(v_required_out.num_so_instances) + srv_opt_len );

    if(FALSE == qmi_svc_put_param_tlv(&ind,
                                      QMI_TYPE_REQUIRED_PARAMETERS,
                                      tlv_len,
                                      &v_required_out))
    {
      QM_MSG_HIGH("Unable to generate DDTM indication!");
      dsm_free_packet(&ind);
      return;
    }

    qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_DDTM_IND, ind );
  }
  else
  {
    QM_MSG_ERROR_1("invalid SO instance %d", num_so_instances);
  }

} /* qmi_nasi_ddtm_ind() */
#endif
/*===========================================================================
  FUNCTION qmi_nas_bcd_to_ascii()

  DESCRIPTION
    BCD to ASCII

  RETURN VALUE
    Digits in ascii. 'D' considered as wildcard. 0x00 for error.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8 qmi_nas_bcd_to_ascii( uint8 ch )
{
  if ( ch == 0x0d )
    return 'D'; // wild card per TS 31.102 cl. 4.2.59

  if ( ch <= 0x09 )
    return ch+'0';

  return 0x00;
}

/*===========================================================================
  FUNCTION qmi_nas_get_opl_data()

  DESCRIPTION
    Read EF OPL data from cache and parse into data structure.

  RETURN VALUE
    TRUE for success, FALSE for failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_get_opl_data( nas_operator_plmn_list_type_v01 *p_dest, uint8 *p_src )
{
  // MCC - All 3 digits must be present
  // Refer ITU-T E212, Annex. A, section A.3.1
  if ( (p_dest->mcc[0]=qmi_nas_bcd_to_ascii( *p_src & 0x0f )) == 0x00 )
    return FALSE; // something wrong
  if ( (p_dest->mcc[1]=qmi_nas_bcd_to_ascii( (*p_src & 0xf0) >> 4 )) == 0x00 )
    return FALSE; // something wrong
  if ( (p_dest->mcc[2]=qmi_nas_bcd_to_ascii( *(p_src+1) & 0x0f )) == 0x00 )
    return FALSE; // something wrong

  // MNC
  if ( (p_dest->mnc[0]=qmi_nas_bcd_to_ascii( *(p_src+2) & 0x0f )) == 0x00 )
    return FALSE; // something wrong
  if ( (p_dest->mnc[1]=qmi_nas_bcd_to_ascii( (*(p_src+2) & 0xf0) >> 4 )) == 0x00 )
    return FALSE; // something wrong

  // Digit 3 in MNC is optional and when not present encoded as 0xF
  // For more details refer TS - 24.008, Table 10.5.3

  if ( ( p_dest->mnc[2]=qmi_nas_bcd_to_ascii( ( (*(p_src+1) & 0xf0) >> 4 ) ) ) == 0x00 )
  {
    if ( ( (*(p_src+1) & 0xf0) >> 4 ) == 0x0F )
    {
      p_dest->mnc[2] = 'F';
    }
    else
    {
      return FALSE; //something wrong. (non compliant 3rd digit for MNC)
    }
  }

  // lac1
  memscpy( (void*)&p_dest->lac1, sizeof(p_dest->lac1), p_src+3, sizeof(p_dest->lac1) );

  // lac2
  memscpy( (void*)&p_dest->lac2, sizeof(p_dest->lac2), p_src+5, sizeof(p_dest->lac2) );

  // pnn_rec_id
  memscpy( &p_dest->pnn_rec_id, sizeof(p_dest->pnn_rec_id), p_src+7, sizeof(p_dest->pnn_rec_id) );

  return TRUE;
}

/*===========================================================================
  FUNCTION qmi_nas_get_pnn_data()

  DESCRIPTION
    Read EF PNN data from cache and parse into data structure.

  RETURN VALUE
    TRUE for success, FALSE for failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_get_pnn_data( nas_plmn_network_name_type_v01 *p_dest, uint8 *p_src, mmgsdi_session_type_enum_type session )
{
  int long_len, short_len;
  uint32 ef_pnn_rec_size=0;
  
  if ( *p_src != 0x43 ) // full name network name IEI
  {
    QM_MSG_ERROR_1("full name IEI missing %d", *p_src);
    return FALSE;
  }

  if ( *(p_src+1) <= 0x01 ) // full name network name IEI len
  {
    QM_MSG_ERROR_1("full name len too short %d", *(p_src+1));
    return FALSE;
  }

  p_dest->coding_scheme        = (*(p_src+2) & 0x70) >> 4;
  p_dest->ci                   = (*(p_src+2) & 0x08) >> 3;
  p_dest->long_name_spare_bits =  *(p_src+2) & 0x07;
  p_dest->long_name_len        =  *(p_src+1)-1;

  long_len = MIN( p_dest->long_name_len, NAS_LONG_NAME_MAX_V01 );

  memscpy( p_dest->long_name, long_len, p_src+3, long_len );

  if ( ef_pnn_rec_size > (uint32) p_dest->long_name_len + 3/*headers*/ ) // we have more text
  {
    p_src += ( p_dest->long_name_len + 3/*headers*/ ); // p_src now points to short name IEI

    if ( *p_src != 0x45 ) // short name network name IEI
    {
      QM_MSG_ERROR_1("no short name IEI %d", *p_src);
    }
    else if ( *(p_src+1) <= 0x01 ) // short name network name IEI len
    {
      QM_MSG_ERROR_1("short name len too short %d", *(p_src+1));
    }
    else
    {
      p_dest->short_name_spare_bits =  *(p_src+2) & 0x07;
      p_dest->short_name_len        =  *(p_src+1)-1;

      short_len = MIN( p_dest->short_name_len, NAS_SHORT_NAME_MAX_V01 );

      memscpy( p_dest->short_name, short_len, p_src+3, short_len );
    }
  }

  p_dest->long_name_len = long_len;

  return TRUE;
}

/*===========================================================================
  FUNCTION qmi_nas_populate_spn_from_cache()

  DESCRIPTION
    Copy EF_SPN data from cache to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_spn_from_cache( nas_operator_name_data_ind_msg_v01 *p_msg, mmgsdi_session_type_enum_type session )
{
  uint8 *p_head, *p_tail;
  mmgsdi_file_enum_type spn_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_data_type mmgsdi_data;
  mmgsdi_session_id_type session_id=(mmgsdi_session_id_type)-1;
  uint8                          *ef_spn;

  #ifdef FEATURE_DUAL_SIM
  if ( p_msg && session <= MMGSDI_GW_PROV_SEC_SESSION )
  #else
  if ( p_msg && session <= MMGSDI_GW_PROV_PRI_SESSION )
  #endif
  {
    if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session)==MMGSDI_APP_SIM )
    {
      spn_filename=MMGSDI_GSM_SPN;
    }
    
    else if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session)==MMGSDI_APP_USIM )
    {
      spn_filename=MMGSDI_USIM_SPN;
    }
    mmgsdi_data.data_len = 0;
    mmgsdi_data.data_ptr = ( uint8 *) modem_mem_alloc( MMGSDI_MAX_DATA_BLOCK_LEN, MODEM_MEM_CLIENT_QMI_MMODE );
    if(mmgsdi_data.data_ptr!=NULL)
    {
      memset( mmgsdi_data.data_ptr, 0x00, MMGSDI_MAX_DATA_BLOCK_LEN );
    }
    

    if(cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id)== CM_MMGSDI_SUCCESS)
    {
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_cache( 
                                                              #ifndef FEATURE_MMODE_DISABLE_UIM
                                                                  qmi_nasi_global.mmgsdi.session_id[session],
                                                              #else
                                                                  session_id,
                                                              #endif
                                                                  spn_filename,
                                                                  mmgsdi_data))
      {
        ef_spn=( uint8 *) modem_mem_alloc( QMI_NAS_MMGSDI_LEN_EF_SPN, MODEM_MEM_CLIENT_QMI_MMODE );
        memscpy(ef_spn,
                     MIN(mmgsdi_data.data_len, QMI_NAS_MMGSDI_LEN_EF_SPN),
                     mmgsdi_data.data_ptr,
                     MIN(mmgsdi_data.data_len, QMI_NAS_MMGSDI_LEN_EF_SPN));

        if ( mmgsdi_data.data_len > 1 )
        {
          p_head = ef_spn+1;
          p_tail = memchr ( p_head, 0xff, mmgsdi_data.data_len-1 );

          p_msg->service_provider_name.display_cond = *ef_spn;
          p_msg->service_provider_name.spn_len      = (uint8) (p_tail ? p_tail-p_head : mmgsdi_data.data_len-1);

          if ( p_msg->service_provider_name.spn_len > 0 )
          {
            memscpy( p_msg->service_provider_name.spn, p_msg->service_provider_name.spn_len, p_head, p_msg->service_provider_name.spn_len );
            p_msg->service_provider_name_valid = TRUE;
          }
          else
          {
            QM_MSG_ERROR("zero length ef spn");
          }
        }
      }
    }
  }
  else
  {
    QM_MSG_ERROR_2("error populating spn %d %d", p_msg, session);
  }
}

/*===========================================================================
  FUNCTION qmi_nas_populate_opl_from_cache()

  DESCRIPTION
    Copy EF_OPL data from cache to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_opl_from_cache( nas_operator_name_data_ind_msg_v01 *p_msg, mmgsdi_session_type_enum_type session )
{
  uint16 i;
  uint8 *p_head;

  mmgsdi_file_enum_type opl_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_data_type mmgsdi_data;
  mmgsdi_session_id_type session_id=(mmgsdi_session_id_type)-1;
  uint8                          *ef_opl;
  uint32 ef_opl_num_recs=0;

  #ifdef FEATURE_DUAL_SIM
  if ( p_msg && session <= MMGSDI_GW_PROV_SEC_SESSION )
  #else
  if ( p_msg && session <= MMGSDI_GW_PROV_PRI_SESSION )
  #endif
  {
    if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session)==MMGSDI_APP_SIM )
    {
      opl_filename=MMGSDI_GSM_OPL;
    }
    
    else if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session)==MMGSDI_APP_USIM )
    {
      opl_filename=MMGSDI_USIM_OPL;
    }
    mmgsdi_data.data_len = 0;
    mmgsdi_data.data_ptr = ( uint8 *) modem_mem_alloc( MMGSDI_MAX_DATA_BLOCK_LEN, MODEM_MEM_CLIENT_QMI_MMODE );
    if(mmgsdi_data.data_ptr!=NULL)
    {
      memset( mmgsdi_data.data_ptr, 0x00, MMGSDI_MAX_DATA_BLOCK_LEN );
    }
    

    if(cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id)== CM_MMGSDI_SUCCESS)
    {
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_cache( 
                                                          #ifndef FEATURE_MMODE_DISABLE_UIM
                                                                  qmi_nasi_global.mmgsdi.session_id[session],
                                                          #else
                                                                  session_id,
                                                          #endif
                                                                  opl_filename,
                                                                  mmgsdi_data))
      {
        ef_opl=( uint8 *) modem_mem_alloc( QMI_NAS_MMGSDI_LEN_EF_OPL, MODEM_MEM_CLIENT_QMI_MMODE );
        memscpy(ef_opl,
                     MIN(mmgsdi_data.data_len, QMI_NAS_MMGSDI_LEN_EF_OPL),
                     mmgsdi_data.data_ptr,
                     MIN(mmgsdi_data.data_len, QMI_NAS_MMGSDI_LEN_EF_OPL));

        for (i=0; i<ef_opl_num_recs && i<NAS_0039_RSP_T11_DATA_MAX; i++)
        {
          p_head = ef_opl + i*QMI_NAS_MMGSDI_REC_SIZE_EF_OPL;

          if ( qmi_nas_get_opl_data( &p_msg->operator_plmn_list[i], p_head ) != TRUE )
          {
            QM_MSG_ERROR_1("ef opl record %d read fail", i);
            break;
          }
        }

        if ( (p_msg->operator_plmn_list_len = i) > 0 )
          p_msg->operator_plmn_list_valid = TRUE;
        else
          QM_MSG_ERROR("zero length ef opl");
      }
    }
  }
  else
  {
    QM_MSG_ERROR_2("error populating opl %d %d", p_msg, session);
  }
}

/*===========================================================================
  FUNCTION qmi_nas_populate_pnn_from_cache()

  DESCRIPTION
    Copy EF_PNN data from cache to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_pnn_from_cache( nas_operator_name_data_ind_msg_v01 *p_msg, mmgsdi_session_type_enum_type session )
{
  uint8 i;
  uint8 *p_head;
  mmgsdi_file_enum_type pnn_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_data_type mmgsdi_data;
  mmgsdi_session_id_type session_id=(mmgsdi_session_id_type)-1;
  uint8                          *ef_pnn;
  uint32    ef_pnn_num_recs=0;
  uint32    ef_pnn_rec_size=0;
  
  #ifdef FEATURE_DUAL_SIM
  if ( p_msg && session <= MMGSDI_GW_PROV_SEC_SESSION )
  #else
  if ( p_msg && session <= MMGSDI_GW_PROV_PRI_SESSION )
  #endif
  {
    if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session)==MMGSDI_APP_SIM )
    {
      pnn_filename=MMGSDI_GSM_PNN;
    }
 
    else if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session)==MMGSDI_APP_USIM )
    {
      pnn_filename=MMGSDI_USIM_PNN;
    }
     mmgsdi_data.data_len = 0;
     mmgsdi_data.data_ptr = ( uint8 *) modem_mem_alloc( MMGSDI_MAX_DATA_BLOCK_LEN, MODEM_MEM_CLIENT_QMI_MMODE );
     if(mmgsdi_data.data_ptr!=NULL)
     {
       memset( mmgsdi_data.data_ptr, 0x00, MMGSDI_MAX_DATA_BLOCK_LEN );
     }
     
  
     if(cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id)== CM_MMGSDI_SUCCESS)
     {
       if ( MMGSDI_SUCCESS == mmgsdi_session_read_cache( 
                                                         #ifndef FEATURE_MMODE_DISABLE_UIM
                                                                   qmi_nasi_global.mmgsdi.session_id[session],
                                                         #else
                                                                   session_id,
                                                         #endif
                                                                   pnn_filename,
                                                                   mmgsdi_data))
       {
         ef_pnn=( uint8 *) modem_mem_alloc( QMI_NAS_MMGSDI_LEN_EF_PNN, MODEM_MEM_CLIENT_QMI_MMODE );
         memscpy(ef_pnn,
                      MIN(mmgsdi_data.data_len, QMI_NAS_MMGSDI_LEN_EF_PNN),
                      mmgsdi_data.data_ptr,
                      MIN(mmgsdi_data.data_len, QMI_NAS_MMGSDI_LEN_EF_PNN));
  
         for (i=0; i<ef_pnn_num_recs && i<NAS_PLMN_NETWORK_NAME_LIST_MAX_V01; i++)
         {
           p_head = ef_pnn + i*ef_pnn_rec_size;

           if ( qmi_nas_get_pnn_data( &p_msg->plmn_network_name[i], p_head, session ) != TRUE )
           {
             QM_MSG_ERROR_1("ef pnn record %d read fail", i);
             break;
           }
         }
         if ( (p_msg->plmn_network_name_len = i) > 0 )
           p_msg->plmn_network_name_valid = TRUE;
       }
    }
  }
  else
  {
    QM_MSG_ERROR_2("error populating pnn %d %d", p_msg, session);
  }
}

/*===========================================================================
  FUNCTION qmi_nas_populate_ons_from_cache()

  DESCRIPTION
    Copy EF_ONS data from cache to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_ons_from_cache( nas_operator_name_data_ind_msg_v01 *p_msg, mmgsdi_session_type_enum_type session )
{
  uint8 *p_head, *p_tail;
  uint8 plmn_name_len = 0;
  mmgsdi_file_enum_type ons_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_data_type mmgsdi_data;
  mmgsdi_session_id_type session_id=(mmgsdi_session_id_type)-1;
  uint8                          *ef_ons = NULL;
  
  #ifdef FEATURE_DUAL_SIM
  if ( p_msg && session <= MMGSDI_GW_PROV_SEC_SESSION )
  #else
  if ( p_msg && session <= MMGSDI_GW_PROV_PRI_SESSION )
  #endif
  {
    
    if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session)==MMGSDI_APP_SIM )
    {
      ons_filename=MMGSDI_GSM_ONS;
    }
        
    else if(cm_mmgsdi_ssn_tbl_get_app_type_for_type(session)==MMGSDI_APP_USIM )
    {
      ons_filename=MMGSDI_USIM_OPL;
    }
    mmgsdi_data.data_len = 0;
    mmgsdi_data.data_ptr = ( uint8 *) modem_mem_alloc( MMGSDI_MAX_DATA_BLOCK_LEN, MODEM_MEM_CLIENT_QMI_MMODE );
    if(mmgsdi_data.data_ptr == NULL)
    {
        qmi_voice_mem_error();
        return;
    }
    memset( mmgsdi_data.data_ptr, 0x00, MMGSDI_MAX_DATA_BLOCK_LEN );
    if(cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id)== CM_MMGSDI_SUCCESS)
    {
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_cache( 
                                                          #ifndef FEATURE_MMODE_DISABLE_UIM
                                                                      qmi_nasi_global.mmgsdi.session_id[session],
                                                          #else
                                                                      session_id,
                                                          #endif
                                                                      ons_filename,
                                                                      mmgsdi_data))
      {
        ef_ons=( uint8 *) modem_mem_alloc( QMI_NAS_MMGSDI_LEN_EF_ONS, MODEM_MEM_CLIENT_QMI_MMODE );
        if(ef_ons == NULL)
        {
           qmi_voice_mem_error();
           modem_mem_free( mmgsdi_data.data_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
           return;
         }
          memscpy(ef_ons,
                         MIN(mmgsdi_data.data_len, QMI_NAS_MMGSDI_LEN_EF_ONS),
                         mmgsdi_data.data_ptr,
                         MIN(mmgsdi_data.data_len, QMI_NAS_MMGSDI_LEN_EF_ONS));

          p_head = ef_ons;
          p_tail = memchr ( p_head, 0xff, mmgsdi_data.data_len );

          plmn_name_len = (uint8) (p_tail ? p_tail-p_head : mmgsdi_data.data_len);

          if ( plmn_name_len > 0 )
          {
            memscpy (p_msg->plmn_name, plmn_name_len,  p_head,  plmn_name_len);
            p_msg->plmn_name_valid = TRUE;
          }
        }
      }
    }
  else
  {
    QM_MSG_ERROR_2("error populating ons %d %d", p_msg, session);
  }
}

/*===========================================================================
  FUNCTION qmi_nas_populate_nw_name_from_nitz()

  DESCRIPTION
    Copy network name data from NITZ to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_nw_name_from_nitz( nas_operator_name_data_ind_msg_v01 *p_msg, sys_mm_information_s_type *p_mm_info )
{
  if ( p_mm_info )
  {
    if ( p_mm_info->short_name_avail )
    {
      p_msg->nitz_information.coding_scheme         = (nas_coding_scheme_enum_v01)p_mm_info->short_name.coding_scheme;
      p_msg->nitz_information.ci                    = p_mm_info->short_name.add_country_initials;
      p_msg->nitz_information.short_name_spare_bits = p_mm_info->short_name.spare_bits;
      p_msg->nitz_information.short_name_len        = p_mm_info->short_name.length;
      memscpy(p_msg->nitz_information.short_name, p_msg->nitz_information.short_name_len, 
              p_mm_info->short_name.name, p_msg->nitz_information.short_name_len );
      p_msg->nitz_information_valid = TRUE;
    }

    if ( p_mm_info->full_name_avail )
    {
      p_msg->nitz_information.coding_scheme         = (nas_coding_scheme_enum_v01)p_mm_info->full_name.coding_scheme;
      p_msg->nitz_information.ci                    = p_mm_info->full_name.add_country_initials;
      p_msg->nitz_information.long_name_spare_bits  = p_mm_info->full_name.spare_bits;
      p_msg->nitz_information.long_name_len         = p_mm_info->full_name.length;
      memscpy(p_msg->nitz_information.long_name, p_msg->nitz_information.long_name_len,
              p_mm_info->full_name.name, p_msg->nitz_information.long_name_len );
      p_msg->nitz_information_valid = TRUE;
    }
  }
  else
  {
    QM_MSG_ERROR("error populating nitz null pointer");
  }
}
/*===========================================================================
  FUNCTION QMI_NASI_GET_PLMN_NAME()

  DESCRIPTION
    get the current nam of the device

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_plmn_name
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response = NULL;
  qmi_error_type_v01             errval = QMI_ERR_NONE_V01;
  nas_get_plmn_name_req_msg_v01 *req_msg;

  sys_plmn_id_s_type          plmn;
  qmi_nas_mmgsdi_session_e_type qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_plmn_id_list_type      plmn_id_list;
  mmgsdi_plmn_id_type plmn_id;
  mmgsdi_eons_ignore_disp_cond_enum_type ignore_disp = MMGSDI_EONS_IGNORE_DISPLAY_COND_NONE;
  mmgsdi_session_id_type        session_id;
  mmgsdi_plmn_info_static_type  * plmn_name_info_ptr;
  nas_get_plmn_name_resp_msg_v01 *rsp_msg;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  mmgsdi_session_get_operator_name_info_type *operator_name_info_ptr=NULL;
  size_t temp_len = 0;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

#if !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) && !defined(FEATURE_LTE)
  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

#else
  req_msg  = ( nas_get_plmn_name_req_msg_v01 *)modem_mem_alloc(sizeof(nas_get_plmn_name_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);
  rsp_msg  = ( nas_get_plmn_name_resp_msg_v01 *)modem_mem_alloc(sizeof(nas_get_plmn_name_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( req_msg == NULL || rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_get_plmn_name_req_msg_v01));
    memset(rsp_msg, 0, sizeof(nas_get_plmn_name_resp_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_GET_PLMN_NAME_REQ_MSG_V01,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_get_plmn_name_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0044_req_check(req_msg);
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !(req_msg->suppress_sim_error_valid && (req_msg->suppress_sim_error == TRUE)) )
    {
      if ( cm_ph_get_gw_subscription_source() == CM_CC_SUBSCRIPTION_SOURCE_NONE)
      {
        errval = QMI_ERR_SIM_NOT_INITIALIZED_V01;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    /*-------------------------------------------------------------------------
      check the provided PLMN
      -------------------------------------------------------------------------*/
    if ( !sys_plmn_set_mcc_mnc( (req_msg->mnc_includes_pcs_digit_valid ? req_msg->mnc_includes_pcs_digit : req_msg->plmn.mnc>99), (uint32)req_msg->plmn.mcc, (uint32)req_msg->plmn.mnc, &plmn) )
    {
      errval = QMI_ERR_INVALID_ARG_V01;
    }
    else
    {
      plmn_id_list.num_of_plmn_ids = 1;
      memscpy(&plmn_id.plmn_id_val, sizeof(plmn_id.plmn_id_val), 
              &plmn.identity, sizeof(plmn_id.plmn_id_val));
      plmn_id.csg_id = SYS_CSG_ID_INVALID;

      plmn_id.rat = (req_msg->rat_valid ? qmi_nas_rat_qmi_to_mmgsdi( req_msg->rat ) : MMGSDI_RAT_NONE);
      plmn_id_list.plmn_list_ptr = &plmn_id;
      if(cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id) == CM_MMGSDI_SUCCESS)
      {
        if( req_msg->use_static_table_only_valid && (req_msg->use_static_table_only == TRUE) )
        {
          plmn_name_info_ptr  = ( mmgsdi_plmn_info_static_type *)modem_mem_alloc(sizeof(mmgsdi_plmn_info_static_type), MODEM_MEM_CLIENT_QMI_MMODE);
          if(plmn_name_info_ptr == NULL)
          {
            qmi_voice_mem_error();
            modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
            modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); 
            return NULL;
          }  
          if( MMGSDI_SUCCESS != mmgsdi_get_se13_plmn_name_sync( session_id,
                                                             plmn_id,
                                                             plmn_name_info_ptr ) )
                                                            
          {
            errval = QMI_ERR_INTERNAL_V01;
            QM_MSG_HIGH(" MMGSDI se13 threw error");
          }
          else
          {
            QM_MSG_HIGH_4("Names found: short len=%d, long len=%d, Encoding: short = %d, long = %d", plmn_name_info_ptr->plmn_short_name.plmn_data_len, 
                plmn_name_info_ptr->plmn_long_name.plmn_data_len,plmn_name_info_ptr->plmn_short_name.plmn_encoding, 
                plmn_name_info_ptr->plmn_long_name.plmn_encoding);
            
            qm_util_print_bytes( plmn_name_info_ptr->plmn_short_name.plmn_data, 
                                 plmn_name_info_ptr->plmn_short_name.plmn_data_len );
            qm_util_print_bytes( plmn_name_info_ptr->plmn_long_name.plmn_data, 
                                 plmn_name_info_ptr->plmn_long_name.plmn_data_len );
            
            rsp_msg->eons_plmn_name_3gpp_valid = TRUE;

            rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
            rsp_msg->eons_plmn_name_3gpp.spn_len = 0;
            
            if( plmn_name_info_ptr->plmn_long_name.plmn_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = plmn_name_info_ptr->plmn_long_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = plmn_name_info_ptr->plmn_long_name.plmn_name_spare_bits;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( plmn_name_info_ptr->plmn_long_name.plmn_data,
                                                                                        plmn_name_info_ptr->plmn_long_name.plmn_data_len,
                                                                                        buff_ptr,
                                                                                        NASI_MAX_LEN_NETWORK_NAME/2 );
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len );
            }
            else if( nasi_convert_mm_info_oper_name( plmn_name_info_ptr->plmn_long_name.plmn_data,
                                                     plmn_name_info_ptr->plmn_long_name.plmn_encoding,
                                                       (char *) rsp_msg->eons_plmn_name_3gpp.plmn_long_name,
                                                       (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc,
                                                NASI_MAX_LEN_NETWORK_NAME,
                                                (uint8)(plmn_name_info_ptr->plmn_long_name.plmn_data_len)) )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = plmn_name_info_ptr->plmn_long_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = plmn_name_info_ptr->plmn_long_name.plmn_name_spare_bits;
              if( (rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                  (plmn_name_info_ptr->plmn_long_name.plmn_encoding== MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                )
              {
                rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, plmn_name_info_ptr->plmn_long_name.plmn_data_len);
              }
              else
              {
                rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01 ));
              }
            }
            
            if ( plmn_name_info_ptr->plmn_short_name.plmn_encoding== MMGSDI_EONS_ENC_UCS2_PACKED )
            {
                rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = plmn_name_info_ptr->plmn_short_name.plmn_name_ci;
                rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = plmn_name_info_ptr->plmn_short_name.plmn_name_spare_bits;
                rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
                rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( plmn_name_info_ptr->plmn_short_name.plmn_data,
                                                                                           plmn_name_info_ptr->plmn_short_name.plmn_data_len,
                                                                                           buff_ptr,
                                                                                           NASI_MAX_LEN_NETWORK_NAME/2 );
                memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len );
            }
            else if ( nasi_convert_mm_info_oper_name( plmn_name_info_ptr->plmn_short_name.plmn_data,
                                                 plmn_name_info_ptr->plmn_short_name.plmn_encoding,
                                                        (char *) rsp_msg->eons_plmn_name_3gpp.plmn_short_name,
                                                        (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc,
                                                 NASI_MAX_LEN_NETWORK_NAME,
                                                 (uint8)(plmn_name_info_ptr->plmn_short_name.plmn_data_len) ) )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = plmn_name_info_ptr->plmn_short_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = plmn_name_info_ptr->plmn_short_name.plmn_name_spare_bits;
              if( (rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                  (plmn_name_info_ptr->plmn_short_name.plmn_encoding== MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                )
              {
                rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, plmn_name_info_ptr->plmn_short_name.plmn_data_len);
              }
              else
              {
                rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01 ));
              }
            }
            
              if ( plmn_name_info_ptr->plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
                   plmn_name_info_ptr->plmn_additional_info.info_data_len != 0  )
              {
                if ( plmn_name_info_ptr->plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                {
                  rsp_msg->addl_info_valid = TRUE;
                  rsp_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                             plmn_name_info_ptr->plmn_additional_info.info_data,
                                             plmn_name_info_ptr->plmn_additional_info.info_data_len,
                                             buff_ptr,
                                             NAS_PLMN_NAME_MAX_V01/2 );
                  memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->addl_info_len*2 );
                }
                else if ( plmn_name_info_ptr->plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
                {
                  rsp_msg->addl_info_valid = TRUE;
                  rsp_msg->addl_info_len = plmn_name_info_ptr->plmn_additional_info.info_data_len/2;
                  memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)plmn_name_info_ptr->plmn_additional_info.info_data, plmn_name_info_ptr->plmn_additional_info.info_data_len);
                  convert_endianness16( (unsigned char*)rsp_msg->addl_info, plmn_name_info_ptr->plmn_additional_info.info_data_len);
                }
                else if ( plmn_name_info_ptr->plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
                {
                  if( !cm_util_gsm7_to_utf16( plmn_name_info_ptr->plmn_additional_info.info_data, 
                                              plmn_name_info_ptr->plmn_additional_info.info_data_len,
                                              FALSE,
                                              rsp_msg->addl_info,
                                              NAS_PLMN_NAME_MAX_V01,
                                              (size_t *)&rsp_msg->addl_info_len ) )
                  {
                    rsp_msg->addl_info_valid = TRUE;
                  }
                }
              }
          }
          modem_mem_free(plmn_name_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE);
        }
        else
        {
          if ( req_msg->send_all_information_valid && (req_msg->send_all_information == TRUE) )
          {
            ignore_disp = MMGSDI_EONS_IGNORE_SPN_RPLMN_DISPLAY_COND;
          }
          else if ( req_msg->always_send_plmn_name_valid && (req_msg->always_send_plmn_name == TRUE) )
          {
            ignore_disp = MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND;
          }
          
          operator_name_info_ptr=(mmgsdi_session_get_operator_name_info_type*)modem_mem_alloc(sizeof(mmgsdi_session_get_operator_name_info_type), MODEM_MEM_CLIENT_QMI_MMODE);
          
          if ( operator_name_info_ptr == NULL )
          {
            qmi_voice_mem_error();
            modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); 
            modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); 
            return NULL;
          }
          memset(operator_name_info_ptr, 0, sizeof(mmgsdi_session_get_operator_name_info_type));
          
          /*Allocate memory for PLMN List*/
          operator_name_info_ptr->plmn_info_ptr=(mmgsdi_plmn_info_static_type*)modem_mem_alloc((plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)), MODEM_MEM_CLIENT_QMI_MMODE);
          if ( operator_name_info_ptr->plmn_info_ptr == NULL )
          {
             qmi_voice_mem_error();
             modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); 
             modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); 
             modem_mem_free((void *)operator_name_info_ptr,MODEM_MEM_CLIENT_QMI_MMODE);
             return NULL;
          }
                    
          memset(operator_name_info_ptr->plmn_info_ptr, 0, (plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)));
          
          if(  MMGSDI_SUCCESS != mmgsdi_session_get_operator_name_ext_sync( session_id,
                                                                            plmn_id_list,
                                                                            ignore_disp,
                                                                            operator_name_info_ptr))
          {
            errval = QMI_ERR_INTERNAL_V01;
            QM_MSG_HIGH(" MMGSDI Operator name ext threw error");
          }
          else
          {
            
            QM_MSG_HIGH_6("Names found: SPN len=%d, short len=%d, long len=%d, Encoding: SPN = %d, short = %d, long = %d", 
                operator_name_info_ptr->spn.spn_data_len, operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len, 
                operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data_len,operator_name_info_ptr->spn.eons_encoding, 
                operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_encoding, 
                operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_encoding);
            
            
            qm_util_print_bytes( operator_name_info_ptr->spn.spn_data, operator_name_info_ptr->spn.spn_data_len);
            qm_util_print_bytes( operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data,
                                 operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len );
            qm_util_print_bytes( operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data,
                                 operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data_len );
            
            rsp_msg->eons_plmn_name_3gpp_valid = TRUE;
            rsp_msg->spn_ext_valid = TRUE;
            
            if( operator_name_info_ptr->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.spn_len = 2*qm_util_decode_ucs2_80_81_82_encoding( operator_name_info_ptr->spn.spn_data,
                                                                                              operator_name_info_ptr->spn.spn_data_len,
                                                                                              buff_ptr,
                                                                                              NAS_SPN_LEN_MAX_V01/2 );
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.spn, NAS_SPN_LEN_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.spn_len );
              
              //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
              temp_len = qm_util_decode_ucs2_80_81_82_encoding( operator_name_info_ptr->spn.spn_data,
                                                                operator_name_info_ptr->spn.spn_data_len,
                                                                buff_ptr,
                                                                NAS_SPN_EXT_LEN_MAX_V01/2 );
              memscpy((void*)rsp_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)buff_ptr, 2*temp_len);
            }
            else if ( operator_name_info_ptr->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
            {
              rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.spn_len = operator_name_info_ptr->spn.spn_data_len;
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.spn, NAS_SPN_LEN_MAX_V01, (void*)operator_name_info_ptr->spn.spn_data, operator_name_info_ptr->spn.spn_data_len );
              
              //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
              temp_len = operator_name_info_ptr->spn.spn_data_len/2;
              memscpy((void*)rsp_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)operator_name_info_ptr->spn.spn_data, 2*temp_len);
            }
            else
            {
              rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
              rsp_msg->eons_plmn_name_3gpp.spn_len = operator_name_info_ptr->spn.spn_data_len;
              memscpy(rsp_msg->eons_plmn_name_3gpp.spn, operator_name_info_ptr->spn.spn_data_len, 
                           operator_name_info_ptr->spn.spn_data, operator_name_info_ptr->spn.spn_data_len);
              
              qm_util_gsm7_to_utf16( operator_name_info_ptr->spn.spn_data,
                                     operator_name_info_ptr->spn.spn_data_len,
                                     FALSE,
                                     rsp_msg->spn_ext,
                                     NAS_SPN_EXT_LEN_MAX_V01,
                                     &temp_len);
              
            }
            
            QM_MSG_HIGH_5("eons_plmn_name_3gpp_valid=%d, spn_enc=%d, spn_len=%d, spn_ext_valid=%d, spn_ext_len=%d", 
                rsp_msg->eons_plmn_name_3gpp_valid = TRUE, rsp_msg->eons_plmn_name_3gpp.spn_enc, 
                rsp_msg->eons_plmn_name_3gpp.spn_len, rsp_msg->spn_ext_valid, temp_len);
            
            if( operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data,
                                                                                                           operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data_len,
                                                                                                           buff_ptr,
                                                                                                           NASI_MAX_LEN_NETWORK_NAME/2 );
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len );
            }
            else if( nasi_convert_mm_info_oper_name( operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data,
                                                     operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_encoding,
                                                     (char *) rsp_msg->eons_plmn_name_3gpp.plmn_long_name,
                                                     (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc,
                                                     NASI_MAX_LEN_NETWORK_NAME,
                                                     (uint8)operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data_len) )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
              if( (rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                  (operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                )
              {
                rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, operator_name_info_ptr->plmn_info_ptr[0].plmn_long_name.plmn_data_len);
              }
              else
              {
                rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01 ));
              }
            }
            
            if ( operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data,
                                                                                         operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len,
                                                                                         buff_ptr,
                                                                                         NASI_MAX_LEN_NETWORK_NAME/2 );
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len );
            }
            else if ( nasi_convert_mm_info_oper_name( operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data,
                                                      operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_encoding,
                                                      (char *) rsp_msg->eons_plmn_name_3gpp.plmn_short_name,
                                                      (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc,
                                                      NASI_MAX_LEN_NETWORK_NAME,
                                                      (uint8)operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len ) )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
              if( (rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                  (operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                )
              {
                rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, operator_name_info_ptr->plmn_info_ptr[0].plmn_short_name.plmn_data_len);
              }
              else
              {
                rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01 ));
              }
            }
            
            if (req_msg->send_all_information_valid && req_msg->send_all_information )
            {
              rsp_msg->eons_display_bit_info_valid = TRUE;
              rsp_msg->eons_display_bit_info.is_spn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( (mmgsdi_eons_rplmn_display_bit_enum_type) operator_name_info_ptr->spn_display_bit );
              rsp_msg->eons_display_bit_info.is_plmn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( operator_name_info_ptr->rplmn_display_bit );
            
              rsp_msg->is_home_network_valid = TRUE;
              rsp_msg->is_home_network = qmi_nas_map_home_status_mmgsdi_to_qmi( operator_name_info_ptr->roaming_status );
            }
            
            if ( operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
                 operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data_len != 0 )
            {
              if ( operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                rsp_msg->addl_info_valid = TRUE;
                rsp_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                           operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data,
                                           operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data_len,
                                           buff_ptr,
                                           NAS_PLMN_NAME_MAX_V01/2 );
                memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->addl_info_len*2 );
              }
              else if ( operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                rsp_msg->addl_info_valid = TRUE;
                rsp_msg->addl_info_len = operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data_len/2;
                memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data, operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data_len );
                convert_endianness16( (unsigned char*)rsp_msg->addl_info, operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data_len );
              }
              else if ( operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
              {
                if( !cm_util_gsm7_to_utf16( operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data, 
                                            operator_name_info_ptr->plmn_info_ptr[0].plmn_additional_info.info_data_len,
                                            FALSE,
                                            rsp_msg->addl_info,
                                            NAS_PLMN_NAME_MAX_V01,
                                            (size_t *)&rsp_msg->addl_info_len ) )
                {
                  rsp_msg->addl_info_valid = TRUE;
                }
              }
            }
            
            rsp_msg->nw_name_source_valid = TRUE;
            rsp_msg->nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( operator_name_info_ptr->plmn_info_ptr[0].plmn_name_source );
            
          }
          
          modem_mem_free( (void *) operator_name_info_ptr->plmn_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
          modem_mem_free( (void *) operator_name_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
        }
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }
#endif

  if(rsp_msg != NULL)
  {
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                QMI_IDL_RESPONSE,
                                                (uint16_t) QMI_NAS_GET_PLMN_NAME_RESP_MSG_V01,
                                                (void *) rsp_msg,
                                                (uint32_t) sizeof( nas_get_plmn_name_resp_msg_v01 ),
                                                &response
                                              );
  }
  else
  {
      /*Not enough memory to allocate for QMI_NAS_GET_PLMN_NAME response*/
    qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( rsp_msg  != NULL ){ modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_get_plmn_name */
/*===========================================================================
  FUNCTION qmi_nasi_get_operator_name_data()

  DESCRIPTION
    This message retrieves operator name data from multiple sources, including
    the card and NITZ 4 (Network Identity and Time Zone) information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_operator_name_data
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  nas_get_operator_name_data_resp_msg_v01 *rsp_msg;
  mmgsdi_session_type_enum_type session = MMGSDI_GW_PROV_PRI_SESSION;
  sys_mm_information_s_type    *p_mm_info = NULL;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  rsp_msg  = ( nas_get_operator_name_data_resp_msg_v01 *) 
                     QMI_NAS_MEM_ALLOC( sizeof(nas_get_operator_name_data_resp_msg_v01) );

  if(NULL == rsp_msg)
  {
    qmi_voice_mem_fatal();
    return NULL;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_operator_name_data_resp_msg_v01));

  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
  {
    session = MMGSDI_GW_PROV_PRI_SESSION;
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 && 
        qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE )
    {
      p_mm_info = &qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information;
    }
    else
    #endif
    {
      p_mm_info = &qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].mm_information;
    }
    
  }
#ifdef FEATURE_DUAL_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    session = MMGSDI_GW_PROV_SEC_SESSION;
    p_mm_info = &qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information;
  }
#endif
  else
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
    {
      errval = QMI_ERR_INTERNAL;
    }
    else if ( !TARGET_SUPPORTS_GSM && !TARGET_SUPPORTS_WCDMA && !TARGET_SUPPORTS_LTE )
    {
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    }
    else if (
             #ifndef FEATURE_MMODE_DISABLE_UIM
             (qmi_nas_mmgsdi_ef_ready ( session,
                                        QMI_NAS_MMGSDI_BITMAP_EF_SPN |
                                        QMI_NAS_MMGSDI_BITMAP_EF_OPL |
                                        QMI_NAS_MMGSDI_BITMAP_EF_PNN |
                                        QMI_NAS_MMGSDI_BITMAP_EF_ONS ) == FALSE )  &&
             #endif
              !p_mm_info->short_name_avail                                         &&
              !p_mm_info->full_name_avail
            )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {

    nas_operator_name_data_ind_msg_v01 * rsp_msg_t10  = (nas_operator_name_data_ind_msg_v01 * )&rsp_msg->service_provider_name_valid;
    #ifndef FEATURE_MMODE_DISABLE_UIM
    struct qmi_nas_mmgsdi_cache_s *p_cache = &qmi_nasi_global.mmgsdi->cache[session]; // shorthand

    if ( p_cache->ef_spn_valid == QMI_NAS_MMGSDI_VALID )
    {
      qmi_nas_populate_spn_from_cache( rsp_msg_t10, session );
    }

    if ( p_cache->ef_opl_valid == QMI_NAS_MMGSDI_VALID )
    {
      qmi_nas_populate_opl_from_cache(  rsp_msg_t10, session );
    }

    if ( p_cache->ef_pnn_valid == QMI_NAS_MMGSDI_VALID )
    {
      qmi_nas_populate_pnn_from_cache(  rsp_msg_t10, session );
    }

    if ( p_cache->ef_ons_valid == QMI_NAS_MMGSDI_VALID )
    {
      qmi_nas_populate_ons_from_cache(  rsp_msg_t10, session );
    }
    #endif
    qmi_nas_populate_nw_name_from_nitz( rsp_msg_t10, p_mm_info );

    if ( !rsp_msg->service_provider_name_valid && // EF exists but no valid contents
         !rsp_msg->operator_plmn_list_valid &&
         !rsp_msg->plmn_network_name_valid &&
         !rsp_msg->plmn_name_valid &&
         !rsp_msg->nitz_information_valid )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }

  if( cmd_buf_p != NULL )
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_operator_name_data_resp_msg_v01),
                                  &response
                                );
  }

  
  if ( rsp_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) rsp_msg ); }
  
  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_MODE_PREF()

  DESCRIPTION
    This messages retrieves the mode_pref from the NV

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_mode_pref(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_type_v01      errval   = QMI_ERR_NONE_V01;
  struct nas_0049_rsp_s rsp_msg;
  nv_item_type          nv_item;
  struct access_tech_s  access_tech;
  int                   i;
  nv_stat_enum_type     nv_status;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  memset( &rsp_msg, 0x00, sizeof(struct nas_0049_rsp_s) );

  for ( i=0; i<=1; i++ )
  {
    memset( &nv_item, 0x00, sizeof(nv_item_type) );

    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item_ext( NV_PREF_MODE_I, &nv_item, i );

    if ( nv_status == NV_DONE_S )
    {
      if ( qmi_nas_get_supported_technology_from_nv_pref_mode( nv_item.pref_mode.mode, &access_tech ) )
      {
        uint16  *p_mode_pref;
        boolean *p_is_valid;

        p_mode_pref = i == 0 ? &rsp_msg.t10.mode_pref_0 : &rsp_msg.t11.mode_pref_1;
        p_is_valid  = i == 0 ? &rsp_msg.t10_valid       : &rsp_msg.t11_valid;

        #ifdef FEATURE_MMODE_QMI_LTE_ONLY
        if ( access_tech.l ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_LTE_V01;           }
        #elif defined(FEATURE_MMODE_QMI_GPRS_LTE)
        if ( access_tech.g ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_GSM_V01;           }
        if ( access_tech.l ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_LTE_V01;           }
        #else
        #if defined(FEATURE_CDMA)
        if ( access_tech.c ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_CDMA2000_1X_V01;   }
        #endif
        #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
        if ( access_tech.h ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_CDMA2000_HRPD_V01; }
        #endif
        if ( access_tech.g ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_GSM_V01;           }
        #if defined(FEATURE_WCDMA)
        if ( access_tech.w ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_UMTS_V01;          }
        #endif
        if ( access_tech.l ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_LTE_V01;           }
        #if defined(FEATURE_TDSCDMA)
        if ( access_tech.t ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_TDSCDMA_V01;       }
        #endif
        #endif

        *p_is_valid = TRUE;
      }
      else
      {
        QM_MSG_ERROR_2("unsupported nv mode pref %d %d", nv_item.pref_mode.mode, i);
      }
    }
  }

  if ( !rsp_msg.t10_valid && !rsp_msg.t11_valid )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg.t02.result_code = errval == QMI_ERR_NONE_V01 ?  QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0049_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
}
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
/*===========================================================================
  FUNCTION qmi_nas_operator_name_data_ind()

  DESCRIPTION
    This message sends indication for operator name data from multiple sources,
    including the card and NITZ (Network Identity and Time Zone) information.

  PARAMETERS
    nitz_changed: flag to indicate NITZ information changed

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_operator_name_data_ind( mmgsdi_session_type_enum_type session, sys_mm_information_s_type *p_mm_info )
{
  nas_operator_name_data_ind_msg_v01 *ind_msg; // reuse message 0x39 as they have same data
  enum qmi_nas_subs_e   bound_subs = QMI_NAS_SUBS_PRIMARY;

  struct qmi_nas_mmgsdi_cache_s *p_cache;

  if ( session == MMGSDI_GW_PROV_PRI_SESSION 
    #ifdef FEATURE_DUAL_SIM
    || session == MMGSDI_GW_PROV_SEC_SESSION 
    #endif
    )
  {
    p_cache = &qmi_nasi_global.mmgsdi->cache[session]; // shorthand
    #ifdef FEATURE_DUAL_SIM
    bound_subs = session == MMGSDI_GW_PROV_PRI_SESSION ? QMI_NAS_SUBS_PRIMARY : QMI_NAS_SUBS_SECONDARY;
    #endif
  }
  else
  {
    return;
  }

  ind_msg  = ( nas_operator_name_data_ind_msg_v01 *) 
      QMI_NAS_MEM_ALLOC( sizeof(nas_operator_name_data_ind_msg_v01) );
  if(NULL == ind_msg)
  {
    qmi_voice_mem_fatal();    
    return;
  }  
  memset (ind_msg, 0x00, sizeof(nas_operator_name_data_ind_msg_v01));

  if ( p_cache->ef_spn_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_spn_changed )
  {
    qmi_nas_populate_spn_from_cache(ind_msg, session );
  }

  if ( p_cache->ef_opl_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_opl_changed )
  {
    qmi_nas_populate_opl_from_cache( ind_msg, session );
  }

  if ( p_cache->ef_pnn_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_pnn_changed )
  {
    qmi_nas_populate_pnn_from_cache( ind_msg, session );
  }

  if ( p_cache->ef_ons_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_ons_changed )
  {
    qmi_nas_populate_ons_from_cache( ind_msg, session );
  }

  if ( p_mm_info != NULL )
  {
    qmi_nas_populate_nw_name_from_nitz( ind_msg, p_mm_info );
  }

  // pack ind message

  if ( ind_msg->service_provider_name_valid ||
       ind_msg->operator_plmn_list_valid ||
       ind_msg->plmn_network_name_valid ||
       ind_msg->plmn_name_valid ||
       ind_msg->nitz_information_valid )
  {
    dsm_item_type       *response;
    qmi_nasi_client_state_type *cl_sp;

    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {

      if ( cl_sp->report_status.bound_subs == bound_subs &&
             cl_sp->report_status.report_operator_name_data)
      {
          response = NULL;

          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    QMI_NAS_OPERATOR_NAME_DATA_IND_MSG_V01,
                                                    (void *) ind_msg,
                                                    (uint32_t) sizeof( nas_operator_name_data_ind_msg_v01 ),
                                                    &response
                                                   )
            )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)QMI_NAS_OPERATOR_NAME_DATA_IND_MSG_V01, response );
          }
          else
          {
             QM_MSG_ERROR("failed to send SYSTEM_SELECTION_PREFERENCE_IND ind");
        }
      }
   
      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
  else
  {
    QM_MSG_HIGH("no real change");
  }
  
  if ( ind_msg  != NULL ) { QMI_NAS_MEM_FREE( (void *) ind_msg ); }
  
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_CSP_LMN_MODE_BIT()
===========================================================================*/
static dsm_item_type* qmi_nasi_get_csp_plmn_mode_bit
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  boolean               retval;
  qmi_result_e_type     result;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  struct nas_003B_rsp_s msg;
  qmi_nas_mmgsdi_session_e_type qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  memset (&msg, 0x00, sizeof(msg));

  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  }
  #ifdef FEATURE_DUAL_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_SEC_SESSION;
  }
  #endif
  #ifdef FEATURE_TRIPLE_SIM    
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_TER_SESSION;
  }
  #endif
  else
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    if(!qmi_nasi_get_csp_plmn_mode_val( qmi_session, &errval, &msg.t10.plmn_mode ))
    {
      if(qmi_nasi_global.mmgsdi->csp_req_buffer_valid)
      {
        errval = QMI_ERR_DEVICE_NOT_READY;
      }
      else
      {
        qmi_nasi_global.mmgsdi->csp_req_buffer_valid = TRUE;
        qmi_nasi_global.mmgsdi->csp_req_buffer = (qmi_mmode_qcsi_transaction_type*)cmd_buf_p;
        qmi_nasi_global.mmgsdi->csp_req_buffer_session = qmi_session;
        return QMI_SVC_RESPONSE_PENDING;
      }
    }
  }

  // pack response message

  if ( errval == QMI_ERR_NONE )
  {
    msg.t10_valid = TRUE;
    if ( !qmi_svc_put_param_tlv( &response, NAS_003B_RSP_T10, sizeof(msg.t10.plmn_mode), &(msg.t10.plmn_mode) ) )
    {
      QM_MSG_ERROR("error while packaging response");
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);

  if ((errval != QMI_ERR_NONE) && (response != NULL))
  {
    dsm_free_packet(&response);
  }
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_CSP_PLMN_MODE_VAL()

  DESCRIPTION
    Extract plmn mode from cached efs

  PARAMETERS
    qmi_session   : qmi subscription
    errval_p      : error type
    plmn_mode_p   : extracted plmn mode

  RETURN VALUE
    False if we need to queue the request(sim not ready), TRUE if 
    extraction was attempted, whether it succeeded or not

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

boolean qmi_nasi_get_csp_plmn_mode_val( qmi_nas_mmgsdi_session_e_type qmi_session, qmi_error_e_type* errval_p, uint8* plmn_mode_p )
{
  boolean found_val = FALSE;
  uint32                i;
  
    if ( qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
    {
    *errval_p = QMI_ERR_INTERNAL;
    }
    else if ( 
                #ifndef FEATURE_MMODE_QMI_LTE_ONLY
                 !TARGET_SUPPORTS_GSM && 
                 !TARGET_SUPPORTS_WCDMA &&
                 #endif
                 !TARGET_SUPPORTS_LTE 
               )
    {
    *errval_p = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    }
    else if ( qmi_nasi_global.mmgsdi->operation_ready[qmi_session] == FALSE )
    {
    *errval_p = QMI_ERR_SIM_NOT_INITIALIZED;
    }
    else if ( qmi_nasi_global.mmgsdi->cache[qmi_session].ef_csp_valid == QMI_NAS_MMGSDI_ERROR )
    {
    *errval_p = QMI_ERR_SIM_FILE_NOT_FOUND;
    }
    else if ( qmi_nas_mmgsdi_ef_ready( qmi_session, QMI_NAS_MMGSDI_BITMAP_EF_CSP ) == FALSE )
    {
    return FALSE;
  }

  if ( *errval_p == QMI_ERR_NONE )
  {
    struct qmi_nas_mmgsdi_cache_s *p_cache = &qmi_nasi_global.mmgsdi->cache[qmi_session]; // shorthand

    if ( p_cache->ef_csp_valid == QMI_NAS_MMGSDI_VALID )
    {
#define QMI_NAS_VALUE_ADDED_SERVICE_CODE  (0xC0)  // per CPHS Phase2 ver 4.2 cl. B.4.7.1
#define QMI_NAS_PLMN_MODE_BIT             (0x80)  // per CPHS Phase2 ver 4.2 cl. B.4.7.1
      for ( i=0; i<p_cache->ef_csp_size; i+=2 )
      {
        if ( p_cache->ef_csp[i] == QMI_NAS_VALUE_ADDED_SERVICE_CODE )
        {
          if ( p_cache->ef_csp[i+1] & QMI_NAS_PLMN_MODE_BIT )
            *plmn_mode_p = NAS_003B_RSP_T10_PLMN_MODE_DO_NOT_RESTRICT;
          else
            *plmn_mode_p = NAS_003B_RSP_T10_PLMN_MODE_RESTRICT;

          QM_MSG_HIGH_2("found VAS code with value %d in %dth byte", p_cache->ef_csp[i+1], i);
          found_val = TRUE;
          break;
        }
      }
    }
    else
    {
      QM_MSG_ERROR("ef csp not in valid state");
    }
  }

  if ( !found_val && *errval_p == QMI_ERR_NONE ) // EF exists but no valid contents
  {
    *errval_p = QMI_ERR_INTERNAL;
  }
  return TRUE;
}

/*===========================================================================
  FUNCTION QMI_NAS_CSP_POMN_MODE_BIT_IND()
===========================================================================*/
void qmi_nas_csp_plmn_mode_bit_ind( mmgsdi_session_type_enum_type session )
{
  struct nas_003B_rsp_s msg; // reuse message
  uint32                i;
  struct qmi_nas_mmgsdi_cache_s *p_cache;
  enum qmi_nas_subs_e            bound_subs = QMI_NAS_SUBS_PRIMARY;
  qmi_nas_mmgsdi_session_e_type qmi_session;

  if ( qmi_nas_mmgsdi_is_valid_3gpp_session(session) )
  {
    qmi_session = qmi_nas_map_mmgsdi_session_to_qmi(session);
    p_cache = &qmi_nasi_global.mmgsdi->cache[qmi_session]; // shorthand

    switch (session)
    {
      case MMGSDI_GW_PROV_PRI_SESSION:
        bound_subs = QMI_NAS_SUBS_PRIMARY;
        break;
#ifdef FEATURE_DUAL_SIM
      case MMGSDI_GW_PROV_SEC_SESSION:
        bound_subs = QMI_NAS_SUBS_SECONDARY;
        break;
#endif
#ifdef FEATURE_TRIPLE_SIM
      case MMGSDI_GW_PROV_TER_SESSION:
        bound_subs = QMI_NAS_SUBS_TERTIARY;
        break;
#endif
      default:
        break;
    }
  }
  else
  {
    return;
  }

  memset (&msg, 0x00, sizeof(msg));

  if ( p_cache->ef_csp_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_csp_changed )
  {
    for ( i=0; i<p_cache->ef_csp_size; i+=2 )
    {
      if ( p_cache->ef_csp[i] == QMI_NAS_VALUE_ADDED_SERVICE_CODE )
      {
        if ( p_cache->ef_csp[i+1] & QMI_NAS_PLMN_MODE_BIT )
          msg.t10.plmn_mode = NAS_003B_RSP_T10_PLMN_MODE_DO_NOT_RESTRICT;
        else
          msg.t10.plmn_mode = NAS_003B_RSP_T10_PLMN_MODE_RESTRICT;

        QM_MSG_HIGH_2("found VAS code with value %d in %dth byte", p_cache->ef_csp[i+1], i);
        msg.t10_valid = TRUE;
        break;
      }
    }
  }
  else
  {
    QM_MSG_ERROR("ef csp not in valid state");
  }

  // pack response message
  if ( msg.t10_valid )
  {
    dsm_item_type              *response;
    boolean                     success = TRUE;
    uint8                       client;
    qmi_nasi_client_state_type *cl_sp;

    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {

      if ( cl_sp->report_status.bound_subs == bound_subs &&
             cl_sp->report_status.report_csp_plmn_mode_bit )
        {
          response = NULL;
        success = TRUE;

          if ( msg.t10_valid ) // leave this check as it will be needed later when new TLVs get added
          {
            if ( !qmi_svc_put_param_tlv( &response, NAS_003B_RSP_T10, sizeof(msg.t10.plmn_mode), &msg.t10.plmn_mode ) )
            {
              QM_MSG_ERROR("error while packaging response");
              dsm_free_packet(&response);
              success = FALSE;
            }
          }

          if ( success )
          {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_CSP_PLMN_MODE_BIT_IND, response );
        }
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
  else // EF exists but no valid contents
  {
    QM_MSG_HIGH("no real change");
  }
}
#endif

/*===========================================================================
  FUNCTION QMI_NASI_RESET_CLIENT()

  DESCRIPTION
    Resets the state for the given client

  PARAMETERS
    cl_sp :  client state pointer

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_reset_client( void *cl_sp_in )
{
  qmi_nasi_client_state_type * cl_sp;

  cl_sp = (qmi_nasi_client_state_type *)cl_sp_in;

  qm_nas_clnt_reset_info( cl_sp );

  qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_NW_SCAN );

  /*-------------------------------------------------------------------------
    Free resources for client
    Remove any pending commmands for this client from the pending q's
    Clear pending msg transactions and partially bundled responses
  -------------------------------------------------------------------------*/
  qm_cbpq_del_client_items( QM_CBPQ_QTYPE_NW_SCAN, cl_sp->clnt );

} /* qmi_nasi_reset_client() */

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
/*===========================================================================
  FUNCTION NASI_CONVERT_MM_INFO_OPER_NAME()

  DESCRIPTION
      This function converts the operator name received from NAS
      mobility management message into suitable format for TE
      presentation.  The IRA character set is the assumed output format.
      Mimiced ATCOP local function etsicall_convert_mminfo_oper_name()

  PARAMETERS
    name_ptr    - Network Name from ss_info
    in_scheme   - Coding scheme to be converted from
    out_ptr     - Network name to be returned to client
    out_scheme  - Coding scheme converted to
    max_len     - Max length allowed to be converted
    encoded_len - Length of the network name to be converted

  RETURN VALUE
    TRUE:  Successful conversion
    FALSE: Otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean nasi_convert_mm_info_oper_name
(
  uint8                                      * name_ptr,
  mmgsdi_eons_encoding_enum_type   in_scheme,
  char                                       * out_ptr,
  uint8                          * out_scheme,
  uint8                                        max_len,
  uint8                                        encoded_len
)
{
  uint8 num_chars;
  uint8 tmp_buf[SYS_MAX_SHORT_NAME_CHARS] = { 0 };
  uint16 conv_success;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  QM_MSG_HIGH_3("nasi_convert_mm_info_oper_name with in_scheme = %d, max_len = %d, encoded_len = %d", in_scheme, max_len, encoded_len);

  if (!encoded_len || !max_len || !out_scheme)
  {
    QM_MSG_HIGH_3("nasi_convert_mm_info_oper_name: encoded_len %d max_len %d out_scheme %d", encoded_len, max_len, out_scheme);
    return FALSE;
  }

  /* Translate coding scheme */
  switch( in_scheme )
  {
    case MMGSDI_EONS_ENC_UCS2:
      memscpy( tmp_buf, encoded_len, name_ptr, encoded_len );
      convert_endianness16( tmp_buf, encoded_len );
        // CM sends UCS2 in big endian. dsatutil_convert_chset is expecting little endian

      /* Convert from OTA coding scheme, assuming IRA output */
      num_chars = MIN(encoded_len/2+1, max_len); /* UCS2 is 16 bits per char */
      conv_success = cm_util_utf16_to_gsm7((uint16 *) tmp_buf, num_chars, (uint8 *) out_ptr, max_len, NULL);
      if( conv_success == CHR_CVRT_SUCCESS )
      {
        *out_scheme = (uint8)NASI_PLMN_NAME_ENC_GSM_DEFAULT;
      }
      else
      {
        memscpy( out_ptr, MIN(encoded_len, max_len), tmp_buf, MIN(encoded_len, max_len) );
        *out_scheme = (uint8)NASI_PLMN_NAME_ENC_UCS2_16;
      }
      break;

    case MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED:
      encoded_len = MIN(encoded_len, max_len);
      (void) cm_util_gsm7_unpack_remove_suspected_padding( name_ptr, encoded_len,
                                                           (byte *) out_ptr, max_len, NULL);
      *out_scheme = (uint8)NASI_PLMN_NAME_ENC_GSM_DEFAULT;
            break;

    case MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED:
      encoded_len = MIN(encoded_len, max_len);
      memscpy( out_ptr, encoded_len, name_ptr, encoded_len );
      *out_scheme = (uint8)NASI_PLMN_NAME_ENC_GSM_DEFAULT;
            break;

          default:
      QM_MSG_ERROR("Detected unsupported encoding");
  return FALSE;
      }
    return TRUE;
} /* nasi_convert_mm_info_oper_name */

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
/*===========================================================================
  FUNCTION QMI_NASI_POPULATE_GET_PREFERRED_NW_RESP()

  DESCRIPTION
    Function to populate response for NASI_CMD_VAL_GET_PREFERRED_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_populate_get_preferred_nw_resp
(
   nas_get_preferred_networks_resp_msg_v01 *nas_get_pref_resp
)
{
  uint16             i;
  uint16             num_entries;
  qmi_nasi_mmgsdi_plmn_wact_type *plmn_iter;
  boolean            plmn_is_undefined = FALSE;
  boolean            mnc_includes_pcs_digit = FALSE;
  sys_mcc_type       mcc = 0;
  sys_mnc_type       mnc = 0;

  memset(nas_get_pref_resp, 0, sizeof(nas_get_preferred_networks_resp_msg_v01) );

  /* If at least one of PLMN_WACT and OPLMN_WACT has been read, we can send out the
   * response. The response for PLMN (without ACT) can be ignored. */
  if ( (qmi_nasi_global.pref_nw_scratch.plmn_wact  == QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ) ||
       (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ) )
  {
    if (qmi_nasi_global.pref_nw_scratch.plmn_wact == QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ)
    {
      nas_3gpp_preferred_networks_type_v01 *p_net_info;
      nas_mnc_pcs_digit_include_status_type_v01 *p_mnc_info;

      nas_get_pref_resp->nas_3gpp_preferred_networks_valid = TRUE;
      nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_valid = TRUE;
      nas_get_pref_resp->nas_3gpp_preferred_networks_len = 0;
      nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len = 0;
      num_entries = qmi_nasi_global.pref_nw_scratch.plmn_wact_list_size;
      for (i = 0;
           (i < num_entries) &&
             (nas_get_pref_resp->nas_3gpp_preferred_networks_len < SYS_USER_PPLMN_LIST_MAX_LENGTH) ;
           i++)
      {
        p_net_info = &nas_get_pref_resp->nas_3gpp_preferred_networks[nas_get_pref_resp->nas_3gpp_preferred_networks_len];
        p_mnc_info = &nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit[nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len];
        plmn_iter  = &qmi_nasi_global.pref_nw_scratch.plmn_wact_list[i];

        if(!sys_plmn_id_is_undefined(plmn_iter->plmn))
        {
          sys_plmn_get_mcc_mnc(plmn_iter->plmn, &plmn_is_undefined, &mnc_includes_pcs_digit, &mcc, &mnc);
          QM_MSG_HIGH_3("plmn(%d), mcc:%d, mnc%d", i, mcc, mnc);

          p_net_info->mobile_country_code     = (uint16) mcc;
          p_net_info->mobile_network_code     = (uint16) mnc;
          p_net_info->radio_access_technology = 0;
          #if defined(FEATURE_WCDMA)
          p_net_info->radio_access_technology |= (plmn_iter->act[0] & 0x80) << 8; // 1000 0000 0000 0000 UMTS
          #endif
          p_net_info->radio_access_technology |= (plmn_iter->act[0] & 0x40) << 8; // 0100 0000 0000 0000 LTE
          p_net_info->radio_access_technology |=  plmn_iter->act[1] & 0x80;       // 0000 0000 1000 0000 GSM
          p_net_info->radio_access_technology |=  plmn_iter->act[1] & 0x40;       // 0000 0000 0100 0000 GSM compact

          nas_get_pref_resp->nas_3gpp_preferred_networks_len++;

          p_mnc_info->mcc = (uint16_t)mcc;
          p_mnc_info->mnc =(uint16_t) mnc;
          p_mnc_info->mnc_includes_pcs_digit = (uint8_t) mnc_includes_pcs_digit;

          nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len++;
        }
      }
    }

    if (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ)
    {
      nas_3gpp_preferred_networks_type_v01 *p_net_info;
      nas_mnc_pcs_digit_include_status_type_v01 *p_mnc_info;

      nas_get_pref_resp->static_3gpp_preferred_networks_valid = TRUE;
      nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit_valid = TRUE;
      nas_get_pref_resp->static_3gpp_preferred_networks_len = 0;
      nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit_len = 0;
      num_entries = qmi_nasi_global.pref_nw_scratch.oplmn_wact_list_size;
      for (i = 0;
           (i < num_entries) &&
             (nas_get_pref_resp->static_3gpp_preferred_networks_len < SYS_PLMN_LIST_MAX_LENGTH) ;
           i++)
      {
        p_net_info = &nas_get_pref_resp->static_3gpp_preferred_networks[nas_get_pref_resp->static_3gpp_preferred_networks_len];
        p_mnc_info = &nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit[nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit_len];
        plmn_iter  = &qmi_nasi_global.pref_nw_scratch.oplmn_wact_list[i];

        if(!sys_plmn_id_is_undefined(plmn_iter->plmn))
        {
          sys_plmn_get_mcc_mnc(plmn_iter->plmn,
                               &plmn_is_undefined,
                               &mnc_includes_pcs_digit,
                               &mcc,
                               &mnc);
          QM_MSG_HIGH_3("plmn(%d), mcc:%d, mnc%d", i, mcc, mnc);

          p_net_info->mobile_country_code     = (uint16) mcc;
          p_net_info->mobile_network_code     = (uint16) mnc;
          p_net_info->radio_access_technology = 0;
          #if defined(FEATURE_WCDMA)
          p_net_info->radio_access_technology |= (plmn_iter->act[0] & 0x80) << 8; // 1000 0000 0000 0000 UMTS
          #endif
          p_net_info->radio_access_technology |= (plmn_iter->act[0] & 0x40) << 8; // 0100 0000 0000 0000 LTE
          p_net_info->radio_access_technology |=  plmn_iter->act[1] & 0x80;       // 0000 0000 1000 0000 GSM
          p_net_info->radio_access_technology |=  plmn_iter->act[1] & 0x40;       // 0000 0000 0100 0000 GSM compact

          nas_get_pref_resp->static_3gpp_preferred_networks_len++;

          p_mnc_info->mcc =(uint16_t) mcc;
          p_mnc_info->mnc = (uint16_t)mnc;
          p_mnc_info->mnc_includes_pcs_digit = (uint8_t) mnc_includes_pcs_digit;

          nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit_len++;
        }
      }
    }
  }
  /* If all other checks have failed, it means that only the PLMN file
   * (without ACT) was read successfully. We need to construct our response
   * accordingly. */
  else
  {
    nas_3gpp_preferred_networks_type_v01 *p_net_info;
    nas_mnc_pcs_digit_include_status_type_v01 *p_mnc_info;

    nas_get_pref_resp->nas_3gpp_preferred_networks_valid = TRUE;
    nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_valid = TRUE;
    nas_get_pref_resp->nas_3gpp_preferred_networks_len = 0;
    nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len = 0;
    num_entries = qmi_nasi_global.pref_nw_scratch.plmn_list_size;
    for (i = 0;
         (i < num_entries) &&
           (nas_get_pref_resp->nas_3gpp_preferred_networks_len < SYS_PLMN_LIST_MAX_LENGTH) ;
         i++)
    {
      p_net_info = &nas_get_pref_resp->nas_3gpp_preferred_networks[nas_get_pref_resp->nas_3gpp_preferred_networks_len];
      p_mnc_info = &nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit[nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len];

      if(!sys_plmn_id_is_undefined(
            qmi_nasi_global.pref_nw_scratch.plmn_list[i]))
      {
        sys_plmn_get_mcc_mnc(  qmi_nasi_global.pref_nw_scratch.plmn_list[i],
                              &plmn_is_undefined,
                              &mnc_includes_pcs_digit,
                              &mcc,
                              &mnc);
        QM_MSG_MED_3("plmn(%d), mcc:%d, mnc%d", i, mcc, mnc);

        p_net_info->mobile_country_code     = (uint16) mcc;
        p_net_info->mobile_network_code     = (uint16) mnc;
        p_net_info->radio_access_technology = 0;

        nas_get_pref_resp->nas_3gpp_preferred_networks_len++;

        p_mnc_info->mcc = (uint16_t)mcc;
        p_mnc_info->mnc = (uint16_t)mnc;
        p_mnc_info->mnc_includes_pcs_digit = (uint8_t) mnc_includes_pcs_digit;

        nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len++;
      }
    }
  }
}
#ifndef FEATURE_MMODE_DISABLE_UIM
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_PREFERRED_NW_RESP()

  DESCRIPTION
    Function to generate response for NASI_CMD_VAL_GET_PREFERRED_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_get_preferred_nw_resp
(
  mmgsdi_read_cnf_type       * cnf_data
)
{
  qmi_mmode_qcsi_transaction_type    *cmd_buf_p;
  dsm_item_type       *response;
  qmi_error_type_v01   errval = QMI_ERR_NONE_V01;
  uint16               read_data_len;
  mmgsdi_return_enum_type status;
  nas_get_preferred_networks_resp_msg_v01 *nas_get_pref_resp;

  if (cnf_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cnf_data in GET_PREF_NW callback");
    return;
  }
  status = cnf_data->response_header.mmgsdi_status;
  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *)cnf_data->response_header.client_data;
  if (!qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in GET_PREF_NW callback");
    return;
  }

  if (qmi_nasi_global.get_pref_nwks_req_pending == FALSE)
  {
    QM_MSG_MED("Received an unsolicited read confirmation for NASI_CMD_VAL_GET_PREFERRED_NETWORKS") ;
    return;
  }

  QM_MSG_MED_2("qmi_nasi_generate_get_preferred_nw_resp, file_enum %d, status:%d", cnf_data->access.file.file_enum, status);

  /* Update the scratchpad based on the confirmation. */
  switch (cnf_data->access.file.file_enum)
  {
    case MMGSDI_GSM_PLMN:
      if (qmi_nasi_global.pref_nw_scratch.plmn == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED)
      {
        if (status == MMGSDI_SUCCESS)
        {
          qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ;

          read_data_len = (uint8) MIN( cnf_data->read_data.data_len, sizeof(sys_plmn_id_s_type) * SYS_PLMN_LIST_MAX_LENGTH );
          qmi_nasi_global.pref_nw_scratch.plmn_list_size = read_data_len / sizeof(sys_plmn_id_s_type);
          qmi_nasi_global.pref_nw_scratch.plmn_list = (sys_plmn_id_s_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

          if (qmi_nasi_global.pref_nw_scratch.plmn_list == NULL)
          {
            errval = QMI_ERR_NO_MEMORY_V01;
          }
          else
          {
            memscpy((void*)qmi_nasi_global.pref_nw_scratch.plmn_list, read_data_len, 
                    cnf_data->read_data.data_ptr, read_data_len );
          }
        }
        else
        {
          qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
        }
      }
      else
      {
        return;
      }
      break;
    case MMGSDI_GSM_PLMNWACT:
    case MMGSDI_USIM_PLMNWACT:
      if (qmi_nasi_global.pref_nw_scratch.plmn_wact == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED)
      {
        if (status == MMGSDI_SUCCESS)
        {
          qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ;

          read_data_len = (uint8) MIN( cnf_data->read_data.data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_USER_PPLMN_LIST_MAX_LENGTH );
          qmi_nasi_global.pref_nw_scratch.plmn_wact_list_size = read_data_len / sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
          qmi_nasi_global.pref_nw_scratch.plmn_wact_list      = (qmi_nasi_mmgsdi_plmn_wact_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

          QM_MSG_MED_2("qmi_nasi_generate_get_preferred_nw_resp:PLMNWACT,  read_data_len%d,size:%d", read_data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type));

          if (qmi_nasi_global.pref_nw_scratch.plmn_wact_list == NULL)
          {
            errval = QMI_ERR_NO_MEMORY_V01;
          }
          else
          {
            memscpy((void*)qmi_nasi_global.pref_nw_scratch.plmn_wact_list, read_data_len,
                    cnf_data->read_data.data_ptr, read_data_len );
          }
        }
        else
        {
          qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
        }
      }
      else
      {
        return;
      }
      break;
    case MMGSDI_GSM_OPLMNWACT:
    case MMGSDI_USIM_OPLMNWACT:
      if (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED)
      {
        if (status == MMGSDI_SUCCESS)
        {
          qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ;

          read_data_len = (uint8) MIN( cnf_data->read_data.data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_PLMN_LIST_MAX_LENGTH );
          qmi_nasi_global.pref_nw_scratch.oplmn_wact_list_size = read_data_len / sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
          qmi_nasi_global.pref_nw_scratch.oplmn_wact_list = (qmi_nasi_mmgsdi_plmn_wact_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

          QM_MSG_MED_2("qmi_nasi_generate_get_preferred_nw_resp:OPLMNWACT,  read_data_len%d,size:%d", read_data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type));

          if (qmi_nasi_global.pref_nw_scratch.oplmn_wact_list == NULL)
          {
            errval = QMI_ERR_NO_MEMORY_V01;
          }
          else
          {
            memscpy( (void*)qmi_nasi_global.pref_nw_scratch.oplmn_wact_list, read_data_len,
                      cnf_data->read_data.data_ptr, cnf_data->read_data.data_len );
          }
        }
        else
        {
          qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
        }
      }
      else
      {
        return;
      }
      break;
    default:
      QM_MSG_MED_1("Received unsolicited read confirmation on file %d", cnf_data->access.file.file_enum);
      return;
  }

  if ( errval == QMI_ERR_NONE_V01 &&
       ( (qmi_nasi_global.pref_nw_scratch.plmn_wact  == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED) ||
         (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED) ||
         ( (qmi_nasi_global.pref_nw_scratch.plmn_wact  == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) &&
           (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) &&
           (qmi_nasi_global.pref_nw_scratch.plmn       == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED) ) ) )
  {
    QM_MSG_MED("Waiting for file read confirmation");
  }
  else
  {
    qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_GET_PREF );

    nas_get_pref_resp = ( nas_get_preferred_networks_resp_msg_v01 * )modem_mem_alloc(sizeof(nas_get_preferred_networks_resp_msg_v01), MODEM_MEM_CLIENT_QMI);
    if( nas_get_pref_resp == NULL )
    {
      qmi_voice_mem_error();

      while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_GET_PREF )) != NULL )
      {
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
      }
    }
    else
    {
      if ( errval == QMI_ERR_NONE_V01 )
      {
        if ( (qmi_nasi_global.pref_nw_scratch.plmn_wact  == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) &&
             (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) &&
             (qmi_nasi_global.pref_nw_scratch.plmn       == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) )
        {
          errval = QMI_ERR_SIM_FILE_NOT_FOUND_V01;
        }
        else
        {
          qmi_nasi_populate_get_preferred_nw_resp( nas_get_pref_resp );
        }
      }

      qmi_nasi_global.get_pref_nwks_req_pending = FALSE;
      QM_MSG_HIGH("get_pref_nwks_req_pending is set to FALSE");

      nas_get_pref_resp->resp.error  = errval;
      nas_get_pref_resp->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

      while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_GET_PREF )) != NULL )
      {
        response = NULL;                                                                         // Important!  When multiple encode calls may be made.
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_RESPONSE,
                                                  (uint16_t)cmd_buf_p->msg_id,
                                                  (void *)nas_get_pref_resp,
                                                  (uint32_t)sizeof(nas_get_preferred_networks_resp_msg_v01),
                                                  &response
                                                ) )
        {
          if ( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
          {
            qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
          }
        }
      }

      modem_mem_free((void *)nas_get_pref_resp, MODEM_MEM_CLIENT_QMI);
    }

    if (qmi_nasi_global.pref_nw_scratch.plmn_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    if (qmi_nasi_global.pref_nw_scratch.plmn_wact_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    if (qmi_nasi_global.pref_nw_scratch.oplmn_wact_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.oplmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }

    memset(&qmi_nasi_global.pref_nw_scratch, 0, sizeof(qmi_nasi_global.pref_nw_scratch));
  }
} /* qmi_nasi_generate_get_preferred_nw_resp */
#endif
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_FORBIDDEN_NW_RESP()

  DESCRIPTION
    Function to generate response for NASI_CMD_VAL_GET_FORBIDDEN_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_get_forbidden_nw_resp
(
  mmgsdi_read_cnf_type       * cnf_data
)
{
  qmi_mmode_qcsi_transaction_type    *cmd_buf_p;
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  qmi_result_e_type    result = QMI_RESULT_FAILURE;
  mmgsdi_return_enum_type status;
  uint16               read_data_len;
  sys_plmn_id_s_type   fplmn_list[SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH];
  int32                i;
  int32                num_entries;
  struct
  {
    uint16 num_of_networks;
    struct
    {
      uint16 mcc;
      uint16 mnc;
    }network_info[SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH];
  } v_out_networks_list;

  boolean              plmn_is_undefined = FALSE;
  boolean              mnc_includes_pcs_digit = FALSE;
  sys_mcc_type         mcc = 0;
  sys_mnc_type         mnc = 0;
  uint16               networks_list_size;

  if (cnf_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cnf_data in GET_FORB_NW callback");
    return;
  }
  status = cnf_data->response_header.mmgsdi_status;
  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *)cnf_data->response_header.client_data;
  if (!qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in GET_FORB_NW callback");
    return;
  }
  memset ( &v_out_networks_list, 0, sizeof(v_out_networks_list) );
  memset ( (void*)fplmn_list, 0, sizeof(sys_plmn_id_s_type)
                                   * SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH );

  switch (cnf_data->access.file.file_enum)
  {
    case MMGSDI_GSM_FPLMN:
    case MMGSDI_USIM_FPLMN:
      if (status != MMGSDI_SUCCESS)
      {
        errval = QMI_ERR_INTERNAL;
        goto send_result;
      }
      read_data_len = (uint16) MIN( cnf_data->read_data.data_len,
                                   sizeof(sys_plmn_id_s_type) *
                                     SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH );
      memscpy( (void*)fplmn_list, read_data_len,
              cnf_data->read_data.data_ptr,
              read_data_len );
      num_entries = cnf_data->read_data.data_len /
                      sizeof(sys_plmn_id_s_type);
      QM_MSG_HIGH_2("read_data_len: %d,  num_entries: %d", read_data_len, num_entries);
      for ( i = 0; i < num_entries; i++ )
      {
        if(!sys_plmn_id_is_undefined(fplmn_list[i]))
        {
         QM_MSG_HIGH_3("plmn[%d, %d, %d]", fplmn_list[i].identity[0], fplmn_list[i].identity[1],fplmn_list[i].identity[2]);
          sys_plmn_get_mcc_mnc(fplmn_list[i],
                               &plmn_is_undefined,
                               &mnc_includes_pcs_digit,
                               &mcc,
                               &mnc);
          v_out_networks_list.network_info\
            [v_out_networks_list.num_of_networks].mcc = (uint16) mcc;
          v_out_networks_list.network_info\
            [v_out_networks_list.num_of_networks].mnc = (uint16) mnc;
          v_out_networks_list.num_of_networks++;
          QM_MSG_HIGH_3("i: %d,  sizeof mcc %d, mnc: %d", i, mcc, mnc);
        }
      }
      QM_MSG_HIGH_3("data_len: %d,  num_entries: %d, num_of_networks: %d", cnf_data->read_data.data_len, num_entries, v_out_networks_list.num_of_networks);
      networks_list_size = sizeof(v_out_networks_list.network_info[0]) *
                             v_out_networks_list.num_of_networks +
                           sizeof(v_out_networks_list.num_of_networks);

      if(FALSE == qmi_svc_put_param_tlv(&response,
                                        NASI_PARAM_TYPE_GET_FORB_NETWORKS,
                                        networks_list_size,
                                        &v_out_networks_list))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
      break;
    default:
      return;
  }

send_result:
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  if ( (FALSE == qmi_svc_put_result_tlv(&response, result, errval)) ||
       (FALSE == qmi_nasi_send_response( cmd_buf_p, response)))
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
} /* qmi_nasi_generate_get_forbidden_nw_resp */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_SET_PREFERRED_NW_RESP()

  DESCRIPTION
    Function to generate response for NASI_CMD_VAL_SET_PREFERRED_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_set_preferred_nw_resp
(
  mmgsdi_write_cnf_type       * cnf_data
)
{
  qmi_mmode_qcsi_transaction_type  *cmd_buf_p;
  dsm_item_type     *response = NULL;
  qmi_error_e_type   errval = QMI_ERR_NONE;
  qmi_result_e_type  result = QMI_RESULT_FAILURE;
  mmgsdi_return_enum_type status;

  if (cnf_data == NULL)
  {
    return;
  }
  status = cnf_data->response_header.mmgsdi_status;
  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *)cnf_data->response_header.client_data;
  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_PREF_NW callback");
    return;
  }

  errval = (status == MMGSDI_SUCCESS)? QMI_ERR_NONE: QMI_ERR_INTERNAL;
  result = (status == MMGSDI_SUCCESS)?
             QMI_RESULT_SUCCESS:
             QMI_RESULT_FAILURE;

  if ( (FALSE == qmi_svc_put_result_tlv(&response, result, errval)) ||
       (FALSE == qmi_nasi_send_response( cmd_buf_p, response)))
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
}/* qmi_nasi_generate_set_preferred_nw_resp */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_SET_FORBIDDEN_NW_RESP()

  DESCRIPTION
    Function to generate response for NASI_CMD_VAL_SET_FORBIDDEN_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_set_forbidden_nw_resp
(
  mmgsdi_write_cnf_type       * cnf_data
)
{
  qmi_mmode_qcsi_transaction_type  *cmd_buf_p;
  dsm_item_type     *response = NULL;
  qmi_error_e_type   errval = QMI_ERR_NONE;
  qmi_result_e_type  result = QMI_RESULT_FAILURE;
  mmgsdi_return_enum_type status;

  if (cnf_data == NULL)
  {
    return;
  }
  status = cnf_data->response_header.mmgsdi_status;
  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *)cnf_data->response_header.client_data;
  if (!qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_FORB_NW callback");
    return;
  }

  errval = (status == MMGSDI_SUCCESS)? QMI_ERR_NONE: QMI_ERR_INTERNAL;
  result = (status == MMGSDI_SUCCESS)?
             QMI_RESULT_SUCCESS:
             QMI_RESULT_FAILURE;

  if ( (FALSE == qmi_svc_put_result_tlv(&response, result, errval)) ||
       (FALSE == qmi_nasi_send_response( cmd_buf_p, response)))
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
} /* qmi_nasi_generate_set_forbidden_nw_resp */

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
#endif
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
/*===========================================================================
  FUNCTION QMI_NASI_UPDATE_AKEY()

  DESCRIPTION
    This command updates AKEY. Modem will run authentication on the
  presented AKEY before updating AKEY. Authentication failure will
  result in error in response. On successful operation, the message
  will update NV_A_KEY_I NV item.

  *** This message is now deprecated ***

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_update_akey
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type      *response = NULL;
  qmi_error_e_type   errval    = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

  errval = QMI_ERR_NOT_SUPPORTED;

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_update_akey() */

/*===========================================================================
  FUNCTION QMI_NASI_DECODE_3GPP2_MCC()

  DESCRIPTION
    This message is used to encode 3GPP2 subscription related information; mcc.

  PARAMETERS
    decoded_mcc
    encoded_mcc

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_decode_3gpp2_mcc(uint32 *decoded_mcc, const uint32 encoded_mcc)
{
  uint32 d1, d2, d3, buf = encoded_mcc + 111;

  d3 = buf % 10;
  buf = ( d3 == 0 ) ? (buf-10)/10 : buf/10;

  d2 = buf % 10;
  buf = ( d2 == 0 ) ? (buf-10)/10 : buf/10;

  d1 = ( buf == 10 ) ? 0 : buf;

  *decoded_mcc = d1*100 + d2*10 + d3;
}

/*===========================================================================
  FUNCTION QMI_NASI_ENCODE_3GPP2_MCC()

  DESCRIPTION
    This message is used to encode 3GPP2 subscription related information; 3 digit encoding including mcc value

  PARAMETERS
    encoded_mcc
    decoded_mcc

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_encode_3gpp2_mcc( uint32 *encoded_mcc, const uint32 decoded_mcc)
{
  uint32 temp_decoded_mcc, digit[3];

  int i;
  temp_decoded_mcc = decoded_mcc;

  for (i = 2; i >= 0; i--)
  {
    digit[i] = temp_decoded_mcc % 10;

    if( digit[i] == 0)
    {
      digit[i] = 10;
    }
    temp_decoded_mcc /= 10;
  }
  *encoded_mcc =  (uint32)(100*digit[0] + 10*digit[1] + digit[2] - 111);
}

/*===========================================================================
  FUNCTION QMI_NASI_ENCODE_3GPP2_IMSI_11_12()

  DESCRIPTION
    This message is used to encode 3GPP2 subscription related information; mcc.

  PARAMETERS
    encoded_mcc
    decoded_mcc

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_encode_3gpp2_imsi_11_12( uint32 *encoded, const uint32 decoded)
{
  uint32  d1, d2;

  d1 = decoded /10;
  d2 = decoded %10;

  d1 = (d1 == 0)? 10 : d1;
  d2 = (d2 == 0)? 10 : d2;

  *encoded =  d1*10 + d2 - 11;
}

/*===========================================================================
  FUNCTION QMI_NASI_DECODE_3GPP2_IMSI_11_12()

  DESCRIPTION
    This message is used to encode 3GPP2 subscription related information; imsi_m/t_11_12.

  PARAMETERS
    decoded_mcc
    encoded_mcc

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_decode_3gpp2_imsi_11_12(uint32 *decoded_imsi_11_12, const uint32 encoded_imsi_11_12)
{
  uint32 d1, d2, temp_encoded;
  temp_encoded = encoded_imsi_11_12;

  temp_encoded += 11;
  d2 = temp_encoded % 10;
  if( d2 == 0)
  {
    temp_encoded =(temp_encoded - 10)/10;
  }
  else
  {
    temp_encoded /= 10;
  }

  if( temp_encoded == 10)
  {
    d1 =0;
  }
  else
  {
    d1 = temp_encoded;
  }
  *decoded_imsi_11_12 = d1*10 + d2;
}

/*===========================================================================
  FUNCTION QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO()

  DESCRIPTION
    This message is used to retrieve 3GPP2 subscription related information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_3gpp2_subscription_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type         *response = NULL;
  qmi_error_e_type      errval    = QMI_ERR_NONE;
  boolean               missed_value;
  nv_stat_enum_type     nv_status;
  int                   count;
  nv_item_type          nv_item;

  nas_get_3gpp2_subscription_info_req_msg_v01    *req_msg;
  nas_get_3gpp2_subscription_info_resp_msg_v01   *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_get_3gpp2_subscription_info_req_msg_v01  *) 
      modem_mem_alloc( sizeof(nas_get_3gpp2_subscription_info_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_3gpp2_subscription_info_resp_msg_v01 *) 
      modem_mem_alloc( sizeof(nas_get_3gpp2_subscription_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL || rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_3gpp2_subscription_info;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_3gpp2_subscription_info_resp_msg_v01));


  
  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    /*-------------------------------------------------------------------------
      Read the incoming message
    -------------------------------------------------------------------------*/

    memset (req_msg, 0x00, sizeof(nas_get_3gpp2_subscription_info_req_msg_v01));
    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_3gpp2_subscription_info_req_msg_v01)
                                         );
    /*-----------------------------------------------------------------------
      Check input
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE)
    {
      errval = qmi_nas_003E_req_check(req_msg);
    }

    /*-----------------------------------------------------------------------
      Check if we are supposed to get current NAM
    -----------------------------------------------------------------------*/
    if ( errval == QMI_ERR_NONE )
    {
      if (req_msg->nam_id == NAS_003E_REQ_CURR_NAM_MASK)
      {
        /* Read and temporarily cache the current NAM */
        nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
        if (nv_status == NV_NOTACTIVE_S)
        {
          QM_MSG_ERROR("Unable to get current NAM from NVM");
          errval = QMI_ERR_INTERNAL;
        }
        req_msg->nam_id = nv_item.curr_nam;
      }
    }

    /*-------------------------------------------------------------------------
      Get information to return. Begin with NAM name.
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_NAM_NAME_V01)))
    {
      nv_item.name_nam.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_NAME_NAM_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        memscpy(rsp_msg->nam_name, NV_MAX_LTRS, nv_item.name_nam.name, NV_MAX_LTRS);
        //figure out the length, assuming it is null-terminated
        for (count = 0; count < NV_MAX_LTRS; count++)
        {
          if (rsp_msg->nam_name[count] == 0)
          {
            break;
          }
        }

        rsp_msg->nam_name_len = count;
        rsp_msg->nam_name_valid= TRUE;
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        //QM_MSG_HIGH("NV_NAME_NAM_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        //QM_MSG_ERROR("Unable to read NV_NAME_NAM_I");
      }
    }

    /*-------------------------------------------------------------------------
      Get directory number
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_DIR_NUM_V01)))
    {
      nv_item.dir_number.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_DIR_NUMBER_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        memscpy(rsp_msg->dir_num, NV_DIR_NUMB_SIZ, nv_item.dir_number.dir_number, NV_DIR_NUMB_SIZ);
        //figure out the length, assuming it's null-terminated
        for (count = 0; count < NV_DIR_NUMB_SIZ; count++)
        {
          if (rsp_msg->dir_num[count] == 0)
          {
            break;
          }
        }

        rsp_msg->dir_num_len = count;
        rsp_msg->dir_num_valid= TRUE;
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        QM_MSG_HIGH("NV_DIR_NUMBER_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read NV_DIR_NUMBER_I");
      }
    }

    /*-------------------------------------------------------------------------
      Get home SID/NID
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_HOME_SID_IND_V01)))
    {
      nv_item.home_sid_nid.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_HOME_SID_NID_I, &nv_item);

      if (nv_status == NV_DONE_S)
      {
        rsp_msg->cdma_sys_id_len = NAS_MAX_3GPP2_HOME_SID_NID_NUM_V01;

        for (count = 0; count < NAS_MAX_3GPP2_HOME_SID_NID_NUM_V01; count++)
        {
          rsp_msg->cdma_sys_id[count].sid = nv_item.home_sid_nid.pair[count].sid;
          rsp_msg->cdma_sys_id[count].nid = nv_item.home_sid_nid.pair[count].nid;
        }
        rsp_msg->cdma_sys_id_valid = TRUE;
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        QM_MSG_HIGH("NV_HOME_SID_NID_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read NV_HOME_SID_NID_I");
      }
    }

    /*-------------------------------------------------------------------------
      Get MIN based IMSI
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_MIN_BASED_IMSI_V01)))
    {
      missed_value = FALSE;

      //mcc_m
      nv_item.imsi_mcc.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_IMSI_MCC_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        if( (uint16)nv_item.imsi_mcc.imsi_mcc != 0x03FF )
        {
          uint32 decoded_mcc;
          qmi_nasi_decode_3gpp2_mcc( &decoded_mcc, (uint32)nv_item.imsi_mcc.imsi_mcc );
          qmi_nas_binary_to_ascii(decoded_mcc, rsp_msg->min_based_info.mcc_m, NAS_003E_RSP_MCC_LEN);
        }
        else
        {
          rsp_msg->min_based_info.mcc_m[0] = '3';
          rsp_msg->min_based_info.mcc_m[1] = 'F';
          rsp_msg->min_based_info.mcc_m[2] = 'F';
        }
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        missed_value = TRUE;
        QM_MSG_HIGH("NV_IMSI_MCC_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        missed_value = TRUE;
        QM_MSG_ERROR("Unable to read NV_IMSI_MCC_I");
      }

      if (missed_value == FALSE)
      {
        //imsi_m_11_12
        nv_item.imsi_11_12.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_11_12_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          if( (uint8)nv_item.imsi_11_12.imsi_11_12 != 0x7F )
          {
            uint32 decoded;
            qmi_nasi_decode_3gpp2_imsi_11_12(&decoded, (uint32)nv_item.imsi_11_12.imsi_11_12);
            qmi_nas_binary_to_ascii(decoded, rsp_msg->min_based_info.imsi_m_11_12, NAS_003E_RSP_11_12_LEN);
          }
          else // Wild card  MNC value, no need to decode/encode
          {
            rsp_msg->min_based_info.imsi_m_11_12[0] = '7';
            rsp_msg->min_based_info.imsi_m_11_12[1] = 'F';
          }
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_11_12_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_11_12_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_m_s1
        nv_item.min1.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_MIN1_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          uint32  encoded_first, thousand, encoded_second;
          uint32  decoded_first, decoded_second, imsi_s1;
          imsi_s1 = (uint32)nv_item.min1.min1[NV_CDMA_MIN_INDEX];

          encoded_second = imsi_s1 & 0x3FF;
          imsi_s1 >>= 10;
          thousand = imsi_s1 & 0x0F;
          imsi_s1 >>= 4;
          encoded_first = imsi_s1;
          qmi_nasi_decode_3gpp2_mcc( &decoded_first, encoded_first) ;
          qmi_nasi_decode_3gpp2_mcc( &decoded_second, encoded_second) ;

          rsp_msg->min_based_info.imsi_m_s1[6] = (uint8)(decoded_second%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[5] = (uint8)((decoded_second/10)%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[4] = (uint8)(decoded_second/100 +'0');
          rsp_msg->min_based_info.imsi_m_s1[3] = (uint8)(thousand%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[2] = (uint8)(decoded_first%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[1] = (uint8)((decoded_first/10)%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[0] = (uint8)(decoded_first/100 +'0');
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_MIN1_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_MIN1_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_m_s2
        nv_item.min2.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_MIN2_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          uint32 decoded_m_s2;
          qmi_nasi_decode_3gpp2_mcc( &decoded_m_s2, (uint32)nv_item.min2.min2[NV_CDMA_MIN_INDEX] );
          qmi_nas_binary_to_ascii(decoded_m_s2, rsp_msg->min_based_info.imsi_m_s2, NASI_MIN2_LEN);
          rsp_msg->min_based_info_valid= TRUE;
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
            QM_MSG_HIGH("NV_IMSI_MIN2_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          QM_MSG_ERROR("Unable to read NV_IMSI_MIN2_I");
        }
      }
    }

    /*-------------------------------------------------------------------------
      Get true IMSI
      -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_TRUE_IMSI_V01)))
    {
      missed_value = FALSE;

      //mcc_t
      nv_item.imsi_t_mcc.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_MCC_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        // Wildcard  0x03ff
        if( (uint16)nv_item.imsi_t_mcc.imsi_mcc != 0x03FF )
        {
          uint32 decoded_mcc;
          qmi_nasi_decode_3gpp2_mcc( &decoded_mcc, (uint32)nv_item.imsi_t_mcc.imsi_mcc );
          qmi_nas_binary_to_ascii(decoded_mcc, rsp_msg->true_imsi.mcc_t, NAS_003E_RSP_MCC_LEN);
        }
        else
        {
          rsp_msg->true_imsi.mcc_t[0] = '3';
          rsp_msg->true_imsi.mcc_t[1] = 'F';
          rsp_msg->true_imsi.mcc_t[2] = 'F';
        }
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        missed_value = TRUE;
        QM_MSG_HIGH("NV_IMSI_T_MCC_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        missed_value = TRUE;
        QM_MSG_ERROR("Unable to read NV_IMSI_T_MCC_I");
      }

      if(missed_value == FALSE)
      {
        //imsi_t_11_12
        nv_item.imsi_t_11_12.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_11_12_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          if( (uint8)nv_item.imsi_t_11_12.imsi_11_12 != 0x7F )
          {
            uint32 decoded;
            qmi_nasi_decode_3gpp2_imsi_11_12(&decoded, (uint32)nv_item.imsi_t_11_12.imsi_11_12);
            qmi_nas_binary_to_ascii(decoded, rsp_msg->true_imsi.imsi_t_11_12, NAS_003E_RSP_11_12_LEN);
          }
          else
          {
            rsp_msg->true_imsi.imsi_t_11_12[0] = '7';
            rsp_msg->true_imsi.imsi_t_11_12[1] = 'F';
          }
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_T_11_12_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_T_11_12_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_t_s1
        nv_item.imsi_t_s1.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_S1_I, &nv_item);

        if (nv_status == NV_DONE_S)
        {
          uint32  encoded_first, thousand, encoded_second;
          uint32  decoded_first, decoded_second, imsi_s1;
          imsi_s1 = (uint32)nv_item.imsi_t_s1.min1[NV_CDMA_MIN_INDEX];

          encoded_second = imsi_s1 & 0x3FF;
          imsi_s1 >>= 10;
          thousand = imsi_s1 & 0x0F;
          imsi_s1 >>= 4;
          encoded_first = imsi_s1;
          qmi_nasi_decode_3gpp2_mcc( &decoded_first, encoded_first) ;
          qmi_nasi_decode_3gpp2_mcc( &decoded_second, encoded_second) ;

          rsp_msg->true_imsi.imsi_t_s1[6] = (uint8)(decoded_second%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[5] = (uint8)((decoded_second/10)%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[4] = (uint8)(decoded_second/100 +'0');
          rsp_msg->true_imsi.imsi_t_s1[3] = (uint8)(thousand%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[2] = (uint8)(decoded_first%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[1] = (uint8)((decoded_first/10)%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[0] = (uint8)(decoded_first/100 +'0');
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_T_S1_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_T_S1_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_m_s2
        nv_item.imsi_t_s2.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_S2_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          uint32 decoded_m_t2;
          qmi_nasi_decode_3gpp2_mcc( &decoded_m_t2, (uint32)nv_item.imsi_t_s2.min2[NV_CDMA_MIN_INDEX] );
          qmi_nas_binary_to_ascii(decoded_m_t2, rsp_msg->true_imsi.imsi_t_s2, NASI_MIN2_LEN);
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_T_S2_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_T_S2_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_t_addr_num
        nv_item.imsi_t_addr_num.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_ADDR_NUM_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          rsp_msg->true_imsi.imsi_t_addr_num = nv_item.imsi_t_addr_num.num;
          rsp_msg->true_imsi_valid= TRUE;
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          QM_MSG_HIGH("NV_IMSI_T_ADDR_NUM_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          QM_MSG_ERROR("Unable to read NV_IMSI_T_ADDR_NUM_I");
        }
      }
    }

    /*-------------------------------------------------------------------------
      Get CDMA channel
      -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_CDMA_CHANNEL_V01)))
    {
      missed_value = FALSE;
      //primary channel
      nv_item.name_nam.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_PCDMACH_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        rsp_msg->cdma_channel_info.pri_ch_a = nv_item.pcdmach.channel_a;
        rsp_msg->cdma_channel_info.pri_ch_b = nv_item.pcdmach.channel_b;
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        missed_value = TRUE;
        QM_MSG_HIGH("NV_PCDMACH_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        missed_value = TRUE;
        QM_MSG_ERROR("Unable to read NV_PCDMACH_I");
      }

      if(missed_value == FALSE)
      {
        //secondary channel
        nv_item.name_nam.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_SCDMACH_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          rsp_msg->cdma_channel_info.sec_ch_a = nv_item.scdmach.channel_a;
          rsp_msg->cdma_channel_info.sec_ch_b = nv_item.scdmach.channel_b;
          rsp_msg->cdma_channel_info_valid= TRUE;
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          QM_MSG_HIGH("NV_SCDMACH_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          QM_MSG_ERROR("Unable to read NV_SCDMACH_I");
        }
      }
    }

    /*-------------------------------------------------------------------------
      Get Mobile Directory Number (MDN)
    -------------------------------------------------------------------------*/

    if( errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_MDN_V01)))
    {
      nv_item.mob_dir_number.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_DIR_NUMBER_PCS_I, &nv_item);

      if (nv_status == NV_DONE_S)
      {
        rsp_msg->mdn_len = nv_item.mob_dir_number.n_digits;
        // copy just the specifed number of digits
        if( rsp_msg->mdn_len <= NASI_MDN_MAX_LEN )
        {
          rsp_msg->mdn_valid = TRUE;

          // Convert to ASCII from 3GPP2 format:
          //      - Spec: 3GPP2 C.S0005-D, Table 2.7.1.3.2.4-4
          //      - Byte padding: Unused bits (MSB) set to 0.
          for( count =0; count < rsp_msg->mdn_len ; count++ )
          {
            if ( nv_item.mob_dir_number.digitn[count] == 0x0B )
            {
              rsp_msg->mdn[count] = '*';
            }
            else if ( nv_item.mob_dir_number.digitn[count] == 0x0C )
            {
              rsp_msg->mdn[count] = '#';
            }
            else if ( nv_item.mob_dir_number.digitn[count] == 0x0A )
            {
              rsp_msg->mdn[count] = '0';
            }
            else
            {
              rsp_msg->mdn[count] =  nv_item.mob_dir_number.digitn[count] + '0';
            }
          }
        }
        else
        {
          QM_MSG_ERROR("Incorrect mdn_len");
          errval = QMI_ERR_INTERNAL;
        }
      }
    }

  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  if(errval != QMI_ERR_NONE)
  {
    memset (rsp_msg, 0x00, sizeof(nas_get_3gpp2_subscription_info_resp_msg_v01));
  }

  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t)cmd_buf_p->msg_id,
                                (void *) rsp_msg,
                                (uint32_t) sizeof(nas_get_3gpp2_subscription_info_resp_msg_v01),
                                &response
                              );
end_get_3gpp2_subscription_info:
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }


  return response;
} /*qmi_nasi_get_3gpp2_subscription_info()*/

/*===========================================================================
  FUNCTION QMI_NASI_SET_3GPP2_SUBSCRIPTION_INFO()

  DESCRIPTION
    This message is used to set 3GPP2 subscription related information.
    For any invalid value in a request message will cause service point to
    reject the message without updating any subscription information.
    In case of successful update of all requested information, QMI_ERR_NONE
    will be returned. In case all or subset of information failed to be
    written, QMI_ERR_INTERNAL will be returned.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_3gpp2_subscription_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                  response = NULL;
  qmi_error_type_v01               errval = QMI_ERR_NONE_V01;
  qmi_error_type_v01               error_spc = QMI_ERR_NONE_V01;
  nv_item_type                     nv_item;
  qmi_svc_spc_result_e_type        check_spc_result;

  nv_stat_enum_type                nv_status;

  uint8 count;

  nas_set_3gpp2_subscription_info_req_msg_v01   *req_msg;
  nas_set_3gpp2_subscription_info_resp_msg_v01  *resp_msg;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = ( nas_set_3gpp2_subscription_info_req_msg_v01 *)modem_mem_alloc(sizeof(nas_set_3gpp2_subscription_info_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);
  resp_msg = ( nas_set_3gpp2_subscription_info_resp_msg_v01 *)modem_mem_alloc(sizeof(nas_set_3gpp2_subscription_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    if( errval == QMI_ERR_NONE_V01)
    {
      memset(req_msg, 0, sizeof(nas_set_3gpp2_subscription_info_req_msg_v01));

      errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                             (uint16_t)cmd_buf_p->msg_id,
                                             sdu_in,
                                             (void *)req_msg,
                                             (uint32_t)sizeof(nas_set_3gpp2_subscription_info_req_msg_v01)
                                           );
    }

  
    if (errval == QMI_ERR_NONE_V01)
    {
      errval = qmi_nas_003F_req_check(req_msg);
    }

    if( errval == QMI_ERR_NONE_V01 && req_msg->spc_valid == TRUE )
    {
      check_spc_result = qmi_svc_check_spc((uint8*)req_msg->spc, TRUE );

      if (check_spc_result == QMI_SVC_SPC_FAIL)
      {
        error_spc = QMI_ERR_AUTHENTICATION_FAILED_V01;
      }
      else if (check_spc_result == QMI_SVC_SPC_LOCKED)
      {
        error_spc = QMI_ERR_AUTHENTICATION_LOCK_V01;
      }
      else if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
    {
        error_spc = QMI_ERR_INTERNAL_V01;
      }
    }

    /*-----------------------------------------------------------------------
      Check if we are supposed to get current NAM
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && req_msg->nam_id == NASI_CURR_NAM_MASK)
    {
      /* Read and temporarily cache the current NAM */
      nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
      if (nv_status == NV_NOTACTIVE_S)
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Unable to get current NAM from NVM");
      }
      req_msg->nam_id = nv_item.curr_nam;
    }

    /*-----------------------------------------------------------------------
      Update NV Items
    -----------------------------------------------------------------------*/

    /*-----------------------------------------------------------------------
      Directory number
    -----------------------------------------------------------------------*/

    if (errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->dir_num_valid)
    {
      //terminate directory number if it isn't max length
      if (req_msg->dir_num_len < NV_DIR_NUMB_SIZ)
      {
        req_msg->dir_num[req_msg->dir_num_len] = 0;
      }

      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.dir_number.nam = req_msg->nam_id;
      memscpy(nv_item.dir_number.dir_number, sizeof(req_msg->dir_num),
              req_msg->dir_num, sizeof(req_msg->dir_num));
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_DIR_NUMBER_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write directory number to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      Home SID/NID
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->cdma_sys_id_valid)
    {
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.sid_nid.nam = req_msg->nam_id;

      for (count = 0; count < req_msg->cdma_sys_id_len; count++)
      {
        nv_item.home_sid_nid.pair[count].sid = req_msg->cdma_sys_id[count].sid;
        nv_item.home_sid_nid.pair[count].nid = req_msg->cdma_sys_id[count].nid;
      }

      // Fill up the remaining values (upto NV_MAX_HOME_SID_NID) with default value
      for ( ; count < NV_MAX_HOME_SID_NID; count++)
      {
        nv_item.home_sid_nid.pair[count].sid = NASI_PRL_WILDCARD_SID;
        nv_item.home_sid_nid.pair[count].nid = NASI_PRL_WILDCARD_NID;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_HOME_SID_NID_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write home SID/NID to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      MIN based IMSI
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->min_based_info_valid)
    {
      /*-----------------------------------------------------------------------
        IMSI M MCC
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_mcc.nam = req_msg->nam_id;
      if( (req_msg->min_based_info.mcc_m[0]== '3') && (req_msg->min_based_info.mcc_m[1]=='F') && (req_msg->min_based_info.mcc_m[2]=='F') ) // wildcard handling
      {
        nv_item.imsi_mcc.imsi_mcc = 0x03FF;
      }
      else
      {
        uint32 encoded_mcc, mcc;
        uint8 buff[NASI_MCC_LEN+1];

        memscpy( buff, NASI_MCC_LEN, req_msg->min_based_info.mcc_m, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        mcc = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_mcc, mcc );
        nv_item.imsi_mcc.imsi_mcc = (uint16)encoded_mcc ;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_MCC_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MIN based IMSI MCC to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI M 11 12
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_11_12.nam = req_msg->nam_id;
      if( (req_msg->min_based_info.imsi_m_11_12[0]== '7') && (req_msg->min_based_info.imsi_m_11_12[1]=='F') ) // wildcard handling
      {
        nv_item.imsi_11_12.imsi_11_12 = 0x7F;
      }
      else
      {
        uint32 encoded, imsi_m_11_12;
        uint8 buff[NASI_11_12_LEN+1];

        memscpy ( buff, sizeof(buff), req_msg->min_based_info.imsi_m_11_12, NASI_11_12_LEN);
        buff[NASI_11_12_LEN] = '\0';
        imsi_m_11_12 = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_imsi_11_12( &encoded, imsi_m_11_12 );
        nv_item.imsi_11_12.imsi_11_12 = (uint8)encoded;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_11_12_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MIN based IMSI 11 12 to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI M S1  MIN =  imsi_s2( 3 digt) + imsi_s1 (7 digit)
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.min1.nam = req_msg->nam_id;
      {
        uint32 encoded, encoded_first, encoded_second, thousand, first, second;
        uint8 buff[NASI_MCC_LEN+1];

        memscpy ( buff, NASI_MCC_LEN, req_msg->min_based_info.imsi_m_s1, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        first = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_first, first );

        memscpy ( buff, NASI_MCC_LEN, req_msg->min_based_info.imsi_m_s1+4, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        second = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_second, second );

        thousand = (uint32)((req_msg->min_based_info.imsi_m_s1[3] == '0') ? 10 : (req_msg->min_based_info.imsi_m_s1[3] -'0'));

        encoded = encoded_first;
        encoded <<= 4;
        encoded |= thousand;
        encoded <<= 10;
        encoded |= encoded_second;

        nv_item.min1.min1[NV_CDMA_MIN_INDEX] = (uint32)encoded;
      }
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_MIN1_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MIN based IMSI MIN1 to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI M MIN2
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.min2.nam = req_msg->nam_id;

      {
        uint32 encoded, imsi_m_s2;
        uint8 buff[NASI_MIN2_LEN+1];

        memscpy ( buff, NASI_MIN2_LEN, req_msg->min_based_info.imsi_m_s2, NASI_MIN2_LEN);
        buff[NASI_MIN2_LEN] = '\0';
        imsi_m_s2 = atoi( (char *)buff );

        qmi_nasi_encode_3gpp2_mcc( &encoded, imsi_m_s2 );
        nv_item.min2.min2[NV_CDMA_MIN_INDEX] = (uint16)encoded ;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_MIN2_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MIN based IMSI MIN2 to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      True IMSI
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && req_msg->true_imsi_valid)
    {
      /*-----------------------------------------------------------------------
        IMSI T MCC
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_mcc.nam = req_msg->nam_id;
      if( (req_msg->true_imsi.mcc_t[0]== '3') && (req_msg->true_imsi.mcc_t[1]=='F') && (req_msg->true_imsi.mcc_t[2]=='F') ) // wildcard handling
      {
        nv_item.imsi_t_mcc.imsi_mcc = 0x3FF;
      }
      else
      {
        uint32 encoded_mcc, mcc;
        uint8 buff[NASI_MCC_LEN+1];

        memscpy ( buff, NASI_MCC_LEN, req_msg->true_imsi.mcc_t, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        mcc = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_mcc, mcc );
        nv_item.imsi_t_mcc.imsi_mcc = (uint16)encoded_mcc;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_MCC_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI MCC to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI T 11 12
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_11_12.nam = req_msg->nam_id;
      if( (req_msg->true_imsi.imsi_t_11_12[0]== '7') && (req_msg->true_imsi.imsi_t_11_12[1]=='F') ) // wildcard handling
      {
        nv_item.imsi_t_11_12.imsi_11_12 = 0x7F;
      }
      else
      {
        uint32 encoded, imsi_t_11_12;
        uint8 buff[NASI_11_12_LEN+1];

        memscpy ( buff, NASI_11_12_LEN, req_msg->true_imsi.imsi_t_11_12, NASI_11_12_LEN);
        buff[NASI_11_12_LEN] = '\0';
        imsi_t_11_12 = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_imsi_11_12( &encoded, imsi_t_11_12 );
        nv_item.imsi_t_11_12.imsi_11_12 = (uint16)encoded;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_11_12_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI 11 12 to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI T MIN1
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_s1.nam = req_msg->nam_id;

      {
        uint32 encoded, encoded_first, encoded_second, thousand, first, second;
        uint8 buff[NASI_MCC_LEN+1];

        memscpy ( buff, NASI_MCC_LEN, req_msg->true_imsi.imsi_t_s1, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        first = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_first, first );

        memscpy ( buff, NASI_MCC_LEN, req_msg->true_imsi.imsi_t_s1+4, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        second = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_second, second );
        thousand = (uint32)((req_msg->true_imsi.imsi_t_s1[3] == '0') ? 10 : (req_msg->true_imsi.imsi_t_s1[3] -'0'));

        encoded = encoded_first;
        encoded <<= 4;
        encoded |= thousand;
        encoded <<= 10;
        encoded |= encoded_second;

        nv_item.imsi_t_s1.min1[NV_CDMA_MIN_INDEX] = (uint32)encoded;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_S1_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI MIN1 to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI T MIN2
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_s2.nam = req_msg->nam_id;

      {
        uint32 encoded, imsi_t_s2;
        uint8 buff[NASI_MIN2_LEN+1];

        memscpy ( buff, NASI_MIN2_LEN, req_msg->true_imsi.imsi_t_s2, NASI_MIN2_LEN);
        buff[NASI_MIN2_LEN] = '\0';
        imsi_t_s2 = atoi( (char *)buff );

        qmi_nasi_encode_3gpp2_mcc( &encoded, imsi_t_s2 );
        nv_item.imsi_t_s2.min2[NV_CDMA_MIN_INDEX] = (uint16)encoded ;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_S2_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI MIN2 to NVM");
      }

      /*-----------------------------------------------------------------------
          Address Number
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_addr_num.nam = req_msg->nam_id;
      memscpy((void *) &nv_item.imsi_t_addr_num.num, sizeof(req_msg->true_imsi.imsi_t_addr_num),
              &req_msg->true_imsi.imsi_t_addr_num, sizeof(req_msg->true_imsi.imsi_t_addr_num));
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_ADDR_NUM_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI address number to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      CDMA Channel
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->cdma_channel_info_valid)
    {
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.pcdmach.nam = req_msg->nam_id;
      memscpy((void *) &nv_item.pcdmach.channel_a, sizeof(req_msg->cdma_channel_info.pri_ch_a),
              &req_msg->cdma_channel_info.pri_ch_a, sizeof(req_msg->cdma_channel_info.pri_ch_a));
      memscpy((void *) &nv_item.pcdmach.channel_b, sizeof(req_msg->cdma_channel_info.pri_ch_b),
              &req_msg->cdma_channel_info.pri_ch_b, sizeof(req_msg->cdma_channel_info.pri_ch_b));
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_PCDMACH_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write primary CDMA channels to NVM");
      }

      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.scdmach.nam = req_msg->nam_id;
      memscpy((void *) &nv_item.scdmach.channel_a, sizeof(req_msg->cdma_channel_info.sec_ch_a),
              &req_msg->cdma_channel_info.sec_ch_a, sizeof(req_msg->cdma_channel_info.sec_ch_a));
      memscpy((void *) &nv_item.scdmach.channel_b, sizeof(req_msg->cdma_channel_info.sec_ch_b),
              &req_msg->cdma_channel_info.sec_ch_b, sizeof(req_msg->cdma_channel_info.sec_ch_b));
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_SCDMACH_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write secondary CDMA channels to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      NAM Name
    -----------------------------------------------------------------------*/

    if( errval == QMI_ERR_NONE_V01 && req_msg->nam_name_valid)
    {
      memset(&nv_item, 0, sizeof(nv_item));

      nv_item.name_nam.nam = req_msg->nam_id;
      memscpy((void *) nv_item.name_nam.name, req_msg->nam_name_len,
              req_msg->nam_name, req_msg->nam_name_len);

      if ( NV_DONE_S != qmi_mmode_put_nv_item(NV_NAME_NAM_I, &nv_item) )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write NAM name to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      Mobile Directory Number (MDN)
    -----------------------------------------------------------------------*/
    if( errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->mdn_valid)
    {
      memset(&nv_item, 0, sizeof(nv_item));

      nv_item.mob_dir_number.nam = req_msg->nam_id;

      nv_item.mob_dir_number.n_digits = req_msg->mdn_len;

      // Convert from ASCII to 3GPP2 format:
      //      - Spec: 3GPP2 C.S0005-D, Table 2.7.1.3.2.4-4
      //      - Byte padding: Unused bits (MSB) set to 0.
      for ( count = 0; count < req_msg->mdn_len; count++ )
      {
       if ( req_msg->mdn[count] == '*' )
       {
         nv_item.mob_dir_number.digitn[count] = 0x0B ;
       }
       else if ( req_msg->mdn[count] == '#' )
       {
         nv_item.mob_dir_number.digitn[count] = 0x0C ;
       }
       else if ( req_msg->mdn[count] == '0' )
       {
         nv_item.mob_dir_number.digitn[count] = 0x0A ;
       }
       else
       {
         nv_item.mob_dir_number.digitn[count] =  req_msg->mdn[count] - '0';
       }
      }
      if ( NV_DONE_S != qmi_mmode_put_nv_item(NV_DIR_NUMBER_PCS_I, &nv_item) )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MDN to NV memory");
      }
    }
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_3gpp2_subscription_info_resp_msg_v01) );

    if(error_spc == QMI_ERR_NONE_V01)
    {
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    }
    else
    {
      resp_msg->resp.error  = error_spc;
      resp_msg->resp.result = (error_spc == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    }

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)resp_msg,
                                  (uint32_t)sizeof(nas_set_3gpp2_subscription_info_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    /*Not enough memory to allocate for QMI_NAS_SET_3GPP2_SUBSCRIPTION_INFO response*/
     qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_set_3gpp2_subscription_info() */

/*===========================================================================
  FUNCTION QMI_NAS_GET_MOB_CAI_REV()

  DESCRIPTION
    This message is used to retrieve Mobile CAI revision information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_mob_cai_rev
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  qmi_result_e_type     result;
  boolean               retval;
  nv_stat_enum_type     nv_status;
  nv_item_type          nv_item;

  struct nas_0040_rsp_s    rsp_msg;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    /*-------------------------------------------------------------------------
      Get mobile CAI revision
    -------------------------------------------------------------------------*/
    if ( errval == QMI_ERR_NONE)
    {
      memset(&nv_item, 0, sizeof(nv_item));
      nv_status = qmi_mmode_get_nv_item(NV_MOB_CAI_REV_I, &nv_item);

      if ( nv_status == NV_DONE_S)
      {
        rsp_msg.t10_valid   = TRUE;
        rsp_msg.t10.cai_rev = nv_item.mob_cai_rev;
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read NV_MOB_CAI_REV_I from NVM");
      }
    }

    /*-------------------------------------------------------------------------
      Construct response
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE)
    {
      errval = qmi_nas_0040_rsp_write(&rsp_msg, &response);
    }
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();
  return response;
} /*qmi_nasi_get_mob_cai_rev()*/

/*===========================================================================
  FUNCTION QMI_NAS_GET_RTRE_CONFIG()

  DESCRIPTION
    This message is used to retrieve RTRE (RunTime R-UIM Enable)
    Control information.  - Note: get contro not a config data

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_rtre_config
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  qmi_result_e_type     result;
  boolean               retval;

  struct nas_0041_rsp_s    rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&rsp_msg, 0, sizeof(rsp_msg));

  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    /*-------------------------------------------------------------------------
      Get RTRE config : Get RTRE_CONTROL from CM because qcril want to get rtre_control (24 Setp 10)
    -------------------------------------------------------------------------*/
      /* eventhough this GET_RTRE_CONFIG request would be happen after initialized, check for error */
      if( qmi_nasi_global.inited == INIT_STATE_INITIALIZED)
      {
        rsp_msg.t10_valid    = TRUE;
        switch(qmi_nasi_global.cm_ph_info.rtre_control)
        {
          case CM_RTRE_CONTROL_RUIM:
            rsp_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_RUIM_ONLY;
            break;
          case CM_RTRE_CONTROL_NV:
            rsp_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
            break;
          case CM_RTRE_CONTROL_SIM:
            rsp_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_GSM_ON_1X;
            break;
          default:
            // Error in Getting  rtre_control data
            errval = QMI_ERR_INTERNAL;
            QM_MSG_ERROR_1("qmi_nasi_get_rtre_config: wrong cm_ph_info.rtre_control data, %d", qmi_nasi_global.cm_ph_info.rtre_control);
            break;
        }

        rsp_msg.t11_valid    = TRUE;
        switch(qmi_nasi_global.cm_ph_info.rtre_config)
        {
          case CM_RTRE_CONFIG_RUIM_ONLY:
            rsp_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_RUIM_ONLY;
            break;
          case CM_RTRE_CONFIG_NV_ONLY:
            rsp_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
            break;
          case CM_RTRE_CONFIG_RUIM_OR_DROP_BACK:
            rsp_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_RUIM_IF_AVAIL;
            break;
          case CM_RTRE_CONFIG_SIM_ACCESS:
            rsp_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_GSM_ON_1X;
            break;
          default:
            // Error in Getting  rtre_pref data
            errval = QMI_ERR_INTERNAL;
            QM_MSG_ERROR_1("qmi_nasi_get_rtre_config: wrong cm_ph_info.rtre_config data, %d", qmi_nasi_global.cm_ph_info.rtre_config);
            break;
        }

      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read RTRE control from NVM");
      }

    if (errval == QMI_ERR_NONE)
    {
      errval = qmi_nas_0041_rsp_write(&rsp_msg, &response);
    }

  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();
  return response;
} /*qmi_nasi_get_rtre_config()*/

/*===========================================================================
  FUNCTION QMI_NASI_SET_RTRE_CONFIG()

  DESCRIPTION
    This message is used to set RTRE (RunTime R-UIM Enable) configuration
    information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_rtre_config
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{

  dsm_item_type *response = NULL;
  qmi_nasi_client_state_type *nas_client_sp;
  qmi_error_type_v01               errval = QMI_ERR_NONE_V01;
  qmi_svc_spc_result_e_type        check_spc_result;

  nas_set_rtre_config_req_v01   *nas_rtre_config_req;
  nas_set_rtre_config_resp_v01  *nas_rtre_config_resp;


  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  nas_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  nas_rtre_config_req  = ( nas_set_rtre_config_req_v01 *)modem_mem_alloc(sizeof(nas_set_rtre_config_req_v01), MODEM_MEM_CLIENT_QMI_MMODE);
  nas_rtre_config_resp = ( nas_set_rtre_config_resp_v01 *)modem_mem_alloc(sizeof(nas_set_rtre_config_resp_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( nas_rtre_config_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    if( errval == QMI_ERR_NONE_V01)
    {
      memset(nas_rtre_config_req, 0, sizeof(nas_set_rtre_config_req_v01));

      errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                             (uint16_t)cmd_buf_p->msg_id,
                                             sdu_in,
                                             (void *)nas_rtre_config_req,
                                             (uint32_t)sizeof(nas_set_rtre_config_req_v01)
                                           );
    }

    if (errval == QMI_ERR_NONE_V01)
    {
      errval = qmi_nas_0042_req_check(nas_rtre_config_req);
    }

    if( (errval == QMI_ERR_NONE_V01) && (nas_rtre_config_req->spc_valid == TRUE) )
    {
      check_spc_result = qmi_svc_check_spc((uint8*)nas_rtre_config_req->spc, TRUE );

      if (check_spc_result == QMI_SVC_SPC_FAIL)
      {
        errval = QMI_ERR_AUTHENTICATION_FAILED_V01;
      }
      else if (check_spc_result == QMI_SVC_SPC_LOCKED)
    {
        errval = QMI_ERR_AUTHENTICATION_LOCK_V01;
      }
      else if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
    {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }

    /*-----------------------------------------------------------------------
      Update RTRE config
    -----------------------------------------------------------------------*/
    if(errval == QMI_ERR_NONE_V01)
    {
      /* set rtre_set_status_pending: to indicate set_rtre_config request in service to prevent multiple requests
                                    TRUE - in the processing of previous request*/
      if( qmi_nasi_global.rtre_set_status_pending != TRUE )
      {
        if( qmi_nasi_global.cm_ph_info.rtre_config != (cm_rtre_config_e_type)nas_rtre_config_req->rtre_cfg_pref)
        {
          //0x04 - GSM on 1X (deprecated - converted to use 'Internal setting only' on QMI_NAS_SET_RTRE_CONFIG)
          if( nas_rtre_config_req->rtre_cfg_pref == (uint8)NAS_RTRE_CFG_GSM_ON_1X  )
          {
            nas_rtre_config_req->rtre_cfg_pref = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
          }

          if( cm_ph_cmd_change_rtre_config( qmi_nas_cmph_cmd_cb,
                                             (void *)cmd_buf_p,
                                             qmi_nasi_global.cm_clnt_id,
                                            (cm_rtre_config_e_type)nas_rtre_config_req->rtre_cfg_pref) )
          {
            errval = QMI_ERR_NONE_V01;
            qmi_nasi_global.rtre_set_status_pending = TRUE;
            qmi_nasi_global.p_rtre_set_status_cmd_buf = cmd_buf_p;
            QM_MSG_HIGH_1("qmi_nasi_set_rtre_config: nas_rtre_config_req.rtre_cfg_pref %d", nas_rtre_config_req->rtre_cfg_pref);
            response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
           }
           else
           {
            errval = QMI_ERR_INTERNAL_V01;
           }
         }
         else
         {
          errval = QMI_ERR_NO_EFFECT_V01;
         }
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
          QM_MSG_ERROR("Failed to write RTRE configuration to NVM due to previsous request in service");
      } /* qmi_nasi_global.rtre_set_status_pending != TRUE */
    }
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if(response == NULL)
  {
  if ( nas_rtre_config_resp != NULL )
  {
    memset(nas_rtre_config_resp, 0, sizeof(nas_set_rtre_config_resp_v01) );
    nas_rtre_config_resp->resp.error  = errval;
    nas_rtre_config_resp->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)nas_rtre_config_resp,
                                  (uint32_t)sizeof(nas_set_rtre_config_resp_v01),
                                  &response
                                );
  }
  else
  {
      qmi_voice_mem_error();
    }
  }

  if ( nas_rtre_config_req  != NULL ){ modem_mem_free((void *)nas_rtre_config_req,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( nas_rtre_config_resp != NULL ){ modem_mem_free((void *)nas_rtre_config_resp, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_set_rtre_config() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_RTRE_CONFIG_RESP()

  DESCRIPTION
    This message is used to set RTRE (RunTime R-UIM Enable) configuration response
    information.

  PARAMETERS
    result_status: TRUE - SUCCESS, FALSE - in case of Error

  RETURN VALUE
    none

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_rtre_config_resp
(
  boolean   result_status
)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type       errval;
  qmi_result_e_type      result;
  boolean                retval;
  qmi_mmode_qcsi_transaction_type            *cmd_buf_p;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = qmi_nasi_global.p_rtre_set_status_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_RTRE_CONFIG callback");
    return;
  }

  if( result_status == FALSE)
  {
    errval = QMI_ERR_INTERNAL;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
  }

}
#endif

/*===========================================================================
  FUNCTION QMI_NASI_GET_CELL_LOCATION_INFO()

  DESCRIPTION
    This message retrieves cell location related information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_cell_location_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type    *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

#ifdef FEATURE_LTE
  uint32_t              i, j;
#endif
  enum qm_subs_e subs_id;
  qmi_nasi_client_state_type *p_cs = (qmi_nasi_client_state_type*)cl_sp;


  nas_get_cell_location_info_resp_msg_v01 *rsp_msg;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  rsp_msg = (nas_get_cell_location_info_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_cell_location_info_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if ( rsp_msg != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_cell_location_info_resp_msg_v01) );

    subs_id = qm_nas_clnt_get_binding( p_cs );

  if ( qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
    {
        errval = QMI_ERR_INTERNAL_V01;
  }

    if ( errval == QMI_ERR_NONE_V01 )
    {
#ifdef FEATURE_MODEM_STATISTICS
      qm_mstats_populate_cell_loc_info( rsp_msg, subs_id );

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
      if ( qm_si_is_rat_active( subs_id, QM_RAT_1X ) )
      {
        cm_cdma_position_info_s_type info;
  
        if ( cm_get_cdma_position_info( &info ) )
        {
          rsp_msg->cdma_info.sid       = info.sid;
          rsp_msg->cdma_info.nid       = info.nid;
          rsp_msg->cdma_info.base_id   = info.base_id;
          rsp_msg->cdma_info.refpn     = info.refpn;
          rsp_msg->cdma_info.base_lat  = info.base_lat;
          rsp_msg->cdma_info.base_long = info.base_long;
  
          rsp_msg->cdma_info_valid = TRUE;
        }
        else
        {
          QM_MSG_ERROR("cm_get_cdma_position_info() failed");
        }
      }
      #endif
#endif
  
#ifdef FEATURE_LTE
      if( qm_si_is_rat_active( subs_id, QM_RAT_LTE ) )
      {
        cmapi_rat_meas_info_s_type *meas_info = NULL;
        uint16                     my_mcc;
        uint16                     my_mnc;
        sys_plmn_id_s_type         my_plmn;
        boolean                    mnc_includes_pcs_digit_3;
        sys_nas_information_s_type nas_info;

        memset( &nas_info, 0, sizeof(nas_info) );

        if (mm_per_stacks_get_nas_stats_info( &nas_info, (sys_modem_as_id_e_type)subs_id, SYS_MODEM_STACK_ID_1 )!= TRUE)
        {
          QM_MSG_ERROR("Can't get NAS statistics");
        }
        else
        {
          QM_MSG_HIGH_2("emm_state = %d, emm_connection_state = %d", nas_info.emm_state, nas_info.emm_connection_state);
          rsp_msg->emm_state = nas_info.emm_state;
          rsp_msg->emm_connection_state = nas_info.emm_connection_state;
          rsp_msg->emm_state_valid = TRUE;
          rsp_msg->emm_connection_state_valid = TRUE;
        }

        meas_info = (cmapi_rat_meas_info_s_type*)cm_mem_malloc(sizeof(cmapi_rat_meas_info_s_type));
  
        if( cmapi_get_rat_meas_info( CMAPI_SYS_MODE_LTE, meas_info ) == CMAPI_SUCCESS )
        {
          if( meas_info->is_service_available && (meas_info->sys_mode == CMAPI_SYS_MODE_LTE) &&
              meas_info->meas_info_u.lte_nbr_info.valid )
          {
            cmapi_lte_ngbr_ind_s* nbr_info = &meas_info->meas_info_u.lte_nbr_info;
  
            rsp_msg->lte_intra.ue_in_idle = nbr_info->idle;

            QM_MSG_HIGH_3("cmapi MCC = 0X%04X, MNC = 0X%04X, num_mnc_digits = %d", nbr_info->lte_serving_cell.mcc, nbr_info->lte_serving_cell.mnc, nbr_info->lte_serving_cell.num_mnc_digits);
    
            my_mcc = qm_util_bcd16_to_uint16( nbr_info->lte_serving_cell.mcc, NULL );
            my_mnc = qm_util_bcd16_to_uint16( nbr_info->lte_serving_cell.mnc, &mnc_includes_pcs_digit_3 );

            if ( my_mcc != QM_UTIL_INVALID_BCD16 && my_mnc != QM_UTIL_INVALID_BCD16 )
            {
              if ( sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit_3, (sys_mcc_type) my_mcc, (sys_mnc_type) my_mnc, &my_plmn ) )
            {
                memscpy((void *) &rsp_msg->lte_intra.plmn, sizeof( rsp_msg->lte_intra.plmn ),
                        (void *) &my_plmn.identity, sizeof( rsp_msg->lte_intra.plmn ) );
          }
            }

            rsp_msg->lte_intra.tac            = nbr_info->lte_serving_cell.tac;
            rsp_msg->lte_intra.global_cell_id = (uint32) nbr_info->lte_serving_cell.serving_cell_id;

            QM_MSG_HIGH_9("PLMN = 0x%02X_%02X_%02X, t13.TAC = %d = 0x%X, lte_serving_cell.tac = %d, global_cell_id = %d = 0x%08X, serving_cell_id = %d",
                          rsp_msg->lte_intra.plmn[0], rsp_msg->lte_intra.plmn[1], rsp_msg->lte_intra.plmn[2],
                          rsp_msg->lte_intra.tac, rsp_msg->lte_intra.tac, nbr_info->lte_serving_cell.tac,
                          rsp_msg->lte_intra.global_cell_id, rsp_msg->lte_intra.global_cell_id, nbr_info->lte_serving_cell.serving_cell_id);

            rsp_msg->lte_intra.earfcn = (uint16)nbr_info->lte_intra.earfcn;
            rsp_msg->lte_intra_earfcn = nbr_info->lte_intra.earfcn;
            rsp_msg->lte_intra.serving_cell_id = nbr_info->lte_intra.serving_cell_id;
            if( rsp_msg->lte_intra.ue_in_idle )
            {
              rsp_msg->lte_intra.cell_resel_priority = nbr_info->lte_intra.idle.cell_resel_priority;
              rsp_msg->lte_intra.s_non_intra_search = nbr_info->lte_intra.idle.s_non_intra_search;
              rsp_msg->lte_intra.thresh_serving_low = nbr_info->lte_intra.idle.thresh_serving_low;
              rsp_msg->lte_intra.s_intra_search = nbr_info->lte_intra.idle.s_intra_search;
            }
  
            if( nbr_info->lte_intra.num_lte_cells > NAS_MAX_LTE_NGBR_NUM_CELLS_V01 )
            {
              QM_MSG_ERROR_2("Received %d lte intra cells, max allowed %d", nbr_info->lte_intra.num_lte_cells, NAS_MAX_LTE_NGBR_NUM_CELLS_V01);
              rsp_msg->lte_intra.cells_len = NAS_MAX_LTE_NGBR_NUM_CELLS_V01;
            }
            else
            {
              rsp_msg->lte_intra.cells_len = nbr_info->lte_intra.num_lte_cells;
            }
  
            for( i = 0; i<rsp_msg->lte_intra.cells_len; i++ )
            {
              rsp_msg->lte_intra.cells[i].pci = nbr_info->lte_intra.cell[i].pci;
              rsp_msg->lte_intra.cells[i].rsrq = nbr_info->lte_intra.cell[i].rsrq;
              rsp_msg->lte_intra.cells[i].rsrp = nbr_info->lte_intra.cell[i].rsrp;
              rsp_msg->lte_intra.cells[i].rssi = nbr_info->lte_intra.cell[i].rssi;
              if( rsp_msg->lte_intra.ue_in_idle )
              {
                rsp_msg->lte_intra.cells[i].srxlev = nbr_info->lte_intra.cell[i].idle.srxlev;
              }
            }
  
            rsp_msg->lte_intra_valid = TRUE;
            rsp_msg->lte_intra_earfcn_valid = TRUE;
  
            rsp_msg->lte_inter.ue_in_idle = nbr_info->idle;
            if( nbr_info->lte_inter.num_freqs > NAS_MAX_LTE_NGBR_NUM_FREQS_V01 )
            {
              QM_MSG_ERROR_2("Received %d lte inter freqs, max allowed %d", nbr_info->lte_inter.num_freqs, NAS_MAX_LTE_NGBR_NUM_FREQS_V01);
              rsp_msg->lte_inter.freqs_len = NAS_MAX_LTE_NGBR_NUM_FREQS_V01;
            }
            else
            {
              rsp_msg->lte_inter.freqs_len = nbr_info->lte_inter.num_freqs;
            }
            rsp_msg->lte_inter_earfcn_len = rsp_msg->lte_inter.freqs_len;
  
            for( i=0; i<rsp_msg->lte_inter.freqs_len; i++ )
            {
              rsp_msg->lte_inter.freqs[i].earfcn = (uint16)nbr_info->lte_inter.freqs[i].earfcn;
              rsp_msg->lte_inter_earfcn[i] = nbr_info->lte_inter.freqs[i].earfcn;
              if( rsp_msg->lte_inter.ue_in_idle )
              {
                rsp_msg->lte_inter.freqs[i].threshX_low = nbr_info->lte_inter.freqs[i].idle.threshX_low;
                rsp_msg->lte_inter.freqs[i].threshX_high = nbr_info->lte_inter.freqs[i].idle.threshX_high;
                rsp_msg->lte_inter.freqs[i].cell_resel_priority = nbr_info->lte_inter.freqs[i].idle.cell_resel_priority;
              }
  
              if( nbr_info->lte_inter.freqs[i].num_lte_cells > NAS_MAX_LTE_NGBR_NUM_CELLS_V01 )
              {
                QM_MSG_ERROR_2("Received %d lte inter cells, max allowed %d", nbr_info->lte_inter.freqs[i].num_lte_cells, NAS_MAX_LTE_NGBR_NUM_CELLS_V01);
                rsp_msg->lte_inter.freqs[i].cells_len = NAS_MAX_LTE_NGBR_NUM_CELLS_V01;
              }
              else
              {
                rsp_msg->lte_inter.freqs[i].cells_len = nbr_info->lte_inter.freqs[i].num_lte_cells;
              }
  
              for( j=0; j<rsp_msg->lte_inter.freqs[i].cells_len; j++ )
              {
                rsp_msg->lte_inter.freqs[i].cells[j].pci = nbr_info->lte_inter.freqs[i].cells[j].pci;
                rsp_msg->lte_inter.freqs[i].cells[j].rsrq = nbr_info->lte_inter.freqs[i].cells[j].rsrq;
                rsp_msg->lte_inter.freqs[i].cells[j].rsrp = nbr_info->lte_inter.freqs[i].cells[j].rsrp;
                rsp_msg->lte_inter.freqs[i].cells[j].rssi = nbr_info->lte_inter.freqs[i].cells[j].rssi;
                if( rsp_msg->lte_inter.ue_in_idle )
                {
                  rsp_msg->lte_inter.freqs[i].cells[j].srxlev = nbr_info->lte_inter.freqs[i].cells[j].idle.srxlev;
                }
              }
            }
  
            rsp_msg->lte_inter_valid = TRUE;
            rsp_msg->lte_inter_earfcn_valid = TRUE;
  
            rsp_msg->lte_gsm.ue_in_idle = nbr_info->idle;
            if( nbr_info->gsm.num_freq_groups > NAS_MAX_LTE_NGBR_GSM_NUM_FREQS_V01 )
            {
              QM_MSG_ERROR_2("Received %d gsm freqs, max allowed %d", nbr_info->gsm.num_freq_groups, NAS_MAX_LTE_NGBR_GSM_NUM_FREQS_V01);
              rsp_msg->lte_gsm.freqs_len = NAS_MAX_LTE_NGBR_GSM_NUM_FREQS_V01;
            }
            else
            {
              rsp_msg->lte_gsm.freqs_len = nbr_info->gsm.num_freq_groups;
            }
  
            for( i=0; i<rsp_msg->lte_gsm.freqs_len; i++ )
            {
              QM_MSG_HIGH_2("freq %d of %d", i, rsp_msg->lte_gsm.freqs_len);
              if( rsp_msg->lte_gsm.ue_in_idle )
              {
                rsp_msg->lte_gsm.freqs[i].cell_resel_priority = nbr_info->gsm.freq_group[i].idle.cell_resel_priority;
                rsp_msg->lte_gsm.freqs[i].thresh_gsm_high = nbr_info->gsm.freq_group[i].idle.thresh_gsm_high;
                rsp_msg->lte_gsm.freqs[i].thresh_gsm_low = nbr_info->gsm.freq_group[i].idle.thresh_gsm_low;
                rsp_msg->lte_gsm.freqs[i].ncc_permitted = nbr_info->gsm.freq_group[i].idle.ncc_permitted;
              }
  
              if( nbr_info->gsm.freq_group[i].num_gsm_arfcn > NAS_MAX_LTE_NGBR_GSM_NUM_CELLS_V01 )
              {
                QM_MSG_ERROR_2("Received %d gsm cells, max allowed %d", nbr_info->gsm.freq_group[i].num_gsm_arfcn, NAS_MAX_LTE_NGBR_GSM_NUM_CELLS_V01);
                rsp_msg->lte_gsm.freqs[i].cells_len = NAS_MAX_LTE_NGBR_GSM_NUM_CELLS_V01;
              }
              else
              {
                rsp_msg->lte_gsm.freqs[i].cells_len = nbr_info->gsm.freq_group[i].num_gsm_arfcn;
              }
  
              for( j=0; j<rsp_msg->lte_gsm.freqs[i].cells_len; j++ )
              {
                rsp_msg->lte_gsm.freqs[i].cells[j].arfcn = nbr_info->gsm.freq_group[i].arfcn[j].arfcn;
                rsp_msg->lte_gsm.freqs[i].cells[j].band_1900 = nbr_info->gsm.freq_group[i].arfcn[j].band_1900;
                rsp_msg->lte_gsm.freqs[i].cells[j].cell_id_valid = nbr_info->gsm.freq_group[i].arfcn[j].cell_id_valid;
                rsp_msg->lte_gsm.freqs[i].cells[j].bsic_id = nbr_info->gsm.freq_group[i].arfcn[j].bsic_id;
                rsp_msg->lte_gsm.freqs[i].cells[j].rssi = nbr_info->gsm.freq_group[i].arfcn[j].rssi;
                if( rsp_msg->lte_gsm.ue_in_idle )
                {
                  rsp_msg->lte_gsm.freqs[i].cells[j].srxlev = nbr_info->gsm.freq_group[i].arfcn[j].idle.srxlev;
                }
              }
            }
  
            rsp_msg->lte_gsm_valid = TRUE;
            #ifdef FEATURE_WCDMA
            rsp_msg->lte_wcdma.ue_in_idle = nbr_info->idle;
            if( nbr_info->wcdma.num_wcdma_freqs > NAS_MAX_LTE_NGBR_WCDMA_NUM_FREQS_V01 )
            {
              QM_MSG_ERROR_2("Received %d wcdma freqs, max allowed %d", nbr_info->wcdma.num_wcdma_freqs, NAS_MAX_LTE_NGBR_WCDMA_NUM_FREQS_V01);
              rsp_msg->lte_wcdma.freqs_len = NAS_MAX_LTE_NGBR_WCDMA_NUM_FREQS_V01;
            }
            else
            {
              rsp_msg->lte_wcdma.freqs_len = nbr_info->wcdma.num_wcdma_freqs;
            }
  
            for( i=0; i<rsp_msg->lte_wcdma.freqs_len; i++ )
            {
              rsp_msg->lte_wcdma.freqs[i].uarfcn = nbr_info->wcdma.freq[i].uarfcn;
              if( rsp_msg->lte_wcdma.ue_in_idle )
              {
                rsp_msg->lte_wcdma.freqs[i].cell_resel_priority = nbr_info->wcdma.freq[i].idle.cell_resel_priority;
                rsp_msg->lte_wcdma.freqs[i].thresh_Xhigh = nbr_info->wcdma.freq[i].idle.thresh_Xhigh;
                rsp_msg->lte_wcdma.freqs[i].thresh_Xlow = nbr_info->wcdma.freq[i].idle.thresh_Xlow;
              }
  
              if( nbr_info->wcdma.freq[i].num_wcdma_cells > NAS_MAX_LTE_NGBR_WCDMA_NUM_CELLS_V01 )
              {
                QM_MSG_ERROR_2("Received %d wcdma cells, max allowed %d", nbr_info->wcdma.freq[i].num_wcdma_cells, NAS_MAX_LTE_NGBR_WCDMA_NUM_CELLS_V01);
                rsp_msg->lte_wcdma.freqs[i].cells_len = NAS_MAX_LTE_NGBR_WCDMA_NUM_CELLS_V01;
              }
              else
              {
                rsp_msg->lte_wcdma.freqs[i].cells_len = nbr_info->wcdma.freq[i].num_wcdma_cells;
              }
  
              for( j=0; j<rsp_msg->lte_wcdma.freqs[i].cells_len; j++ )
              {
                rsp_msg->lte_wcdma.freqs[i].cells[j].psc = nbr_info->wcdma.freq[i].cell[j].psc;
                rsp_msg->lte_wcdma.freqs[i].cells[j].cpich_rscp = nbr_info->wcdma.freq[i].cell[j].cpich_rscp;
                rsp_msg->lte_wcdma.freqs[i].cells[j].cpich_ecno = nbr_info->wcdma.freq[i].cell[j].cpich_ecno;
                if( rsp_msg->lte_wcdma.ue_in_idle )
                {
                  rsp_msg->lte_wcdma.freqs[i].cells[j].srxlev = nbr_info->wcdma.freq[i].cell[j].idle.srxlev;
                }
              }
            }
  
            rsp_msg->lte_wcdma_valid = TRUE;
            #endif

            if ( nbr_info->timing_advance <= NAS_0043_RSP_T1E_LTE_TIMING_ADVANCE_MAX )
            {
              rsp_msg->timing_advance_valid = TRUE;
              rsp_msg->timing_advance       = (int32_t) nbr_info->timing_advance;
            }
            else if ( nbr_info->timing_advance == CMAPI_TIMING_ADVANCE_INVALID )            // prevent possible Klocwork/compiler warnings
            {
              rsp_msg->timing_advance_valid = TRUE;
              rsp_msg->timing_advance       = (int32_t) CMAPI_TIMING_ADVANCE_INVALID;       // it's really not present, instead of invalid
            }
            else
            {
              QM_MSG_ERROR_1("nbr_info->timing_advance = 0x%08x, uint32 to large to represent in an int32.", nbr_info->timing_advance);
              rsp_msg->timing_advance_valid = FALSE;
            }

            if ( nbr_info->doppler_measurement <= 400 || nbr_info->doppler_measurement == 0xFFFF)
            {
              rsp_msg->doppler_measurement_valid = TRUE;
              rsp_msg->doppler_measurement       = (uint16_t) nbr_info->doppler_measurement;
            }
            else
            {
              QM_MSG_ERROR_1( "Recieved Invalid nbr_info->doppler_measurement = %d", nbr_info->doppler_measurement );
            }
          }
        }
        rsp_msg->lte_rrc_state_ext_valid = TRUE;
        rsp_msg->lte_rrc_state_ext = (lte_rrc_state_ext_e_type_v01)qmi_nas_map_lrrc_state_to_qmi_ext(lte_rrc_get_rrc_state_ext());
        QM_MSG_HIGH_1("lte_rrc_state_ext:%d", rsp_msg->lte_rrc_state_ext);
        cm_mem_free(meas_info);
      }
#endif // FEATURE_LTE
  
      if ( !rsp_msg->geran_info_valid && 
           #if defined(FEATURE_WCDMA)
           !rsp_msg->umts_info_valid && 
           #endif
           #if defined(FEATURE_CDMA)
           !rsp_msg->cdma_info_valid && 
           #endif
           !rsp_msg->lte_intra_valid )
      {
        errval = QMI_ERR_NO_NETWORK_FOUND_V01;
      }
    }
  
    if ( errval != QMI_ERR_NONE_V01 )
    {
      memset( rsp_msg, 0x00, sizeof(nas_get_cell_location_info_resp_msg_v01) );
    }
  
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_GET_CELL_LOCATION_INFO_RESP_MSG_V01,
                                  (void *)rsp_msg,
                                  (uint32_t)sizeof(nas_get_cell_location_info_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ){ modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_get_cell_location_info() */

#ifdef FEATURE_DUAL_SIM
/*===========================================================================
  FUNCTION QMI_NASI_BIND_SUBSCRIPTION()

  DESCRIPTION
    This message binds the current control point to a specific subscription

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_bind_subscription(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type    *response = NULL;
  qmi_error_e_type  errval = QMI_ERR_NONE;
  qmi_result_e_type result;
  boolean           retval;
  qmi_nasi_client_state_type *p_cs = (qmi_nasi_client_state_type*)cl_sp; // client state pointer

  struct nas_0045_req_s  req_msg;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  memset( &req_msg, 0, sizeof(req_msg));

  if ( errval == QMI_ERR_NONE && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0045_req_read ( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0045_req_check ( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    p_cs->report_status.bound_subs = (enum qmi_nas_subs_e)req_msg.t01.subscription_type;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
}

/*===========================================================================
   FUNCTION qmi_nas_map_standby_pref_cm_to_active_subs()

   DESCRIPTION
     Map standby_pref to active_subs based on the  cm ph info.

   PARAMETERS

   RETURN VALUE

   DEPENDENCIES
     None

   SIDE EFFECTS
     None
 ===========================================================================*/
void qmi_nas_map_standby_pref_cm_to_active_subs( 
  uint8* p_active_subs,
  qmi_cm_ph_info_s_type *p_ph_info
)
{
   uint8 cm_active_subs = *p_active_subs;

  switch(p_ph_info->standby_pref)
  {
    case SYS_MODEM_DS_PREF_NO_STANDBY_PREF:
      cm_active_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
      break;
      
    case SYS_MODEM_DS_PREF_SINGLE_STANDBY:
      if(p_ph_info->active_subs == SYS_MODEM_AS_ID_2)
      {
         cm_active_subs = SYS_MODEM_AS_ID_2_MASK;
      }
#ifdef FEATURE_TRIPLE_SIM
      else if(p_ph_info->active_subs == SYS_MODEM_AS_ID_3)
      {
         cm_active_subs = SYS_MODEM_AS_ID_3_MASK;
      }
#endif
      else  if(p_ph_info->active_subs == SYS_MODEM_AS_ID_1)
      {
        cm_active_subs = SYS_MODEM_AS_ID_1_MASK;
      }
      break;

    case SYS_MODEM_DS_PREF_DUAL_STANDBY:
    case SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY:
      cm_active_subs = SYS_MODEM_AS_ID_1_MASK | SYS_MODEM_AS_ID_2_MASK;
      break;

#ifdef FEATURE_TRIPLE_SIM
    case SYS_MODEM_DS_PREF_TRIPLE_STANDBY:
    case SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY:
      cm_active_subs = SYS_MODEM_AS_ID_1_MASK | SYS_MODEM_AS_ID_2_MASK | SYS_MODEM_AS_ID_3_MASK;
      break;
#endif
    default:
      break;
  }
  *p_active_subs = cm_active_subs;
  QM_MSG_HIGH_2("standby_pref:%d, active_subs:%d", p_ph_info->standby_pref, cm_active_subs);
}
/*===========================================================================
  FUNCTION QMI_NASI_SET_DUAL_STANDBY_PREF_NEW()

  DESCRIPTION
    This message configures dual standby preference

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_dual_standby_pref_new(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_set_dual_standby_pref_resp_msg_v01 *resp_msg;
  qmi_cm_ph_info_s_type                  *p_info            = NULL;
  nas_subs_type_enum_v01                 last_standby_pref;

#if defined(FEATURE_DUAL_SIM) || defined(FEATURE_TRIPLE_SIM)
  nas_set_dual_standby_pref_req_msg_v01  *req_msg;
  sys_modem_dual_standby_pref_e_type     standby_pref       = SYS_MODEM_DS_PREF_NO_CHANGE;
  sys_modem_as_id_e_type                 default_data_subs  = SYS_MODEM_AS_ID_NO_CHANGE;
  sys_modem_as_id_e_type                 priority_subs      = SYS_MODEM_AS_ID_NO_CHANGE;
  sys_modem_as_id_e_type                 default_voice_subs = SYS_MODEM_AS_ID_NO_CHANGE;
  uint8                                  active_subs        = SYS_MODEM_AS_ID_NO_CHANGE_MASK;
  uint8                                  current_active_subs = SYS_MODEM_AS_ID_NO_CHANGE_MASK;
  cm_dds_cause_e_type                    dds_cause          = DDS_CAUSE_PERMANENT;
#endif

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error: sp %d cmd_buf_p %d cl_sp %d sdu_in %d",
                   sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_dual_standby_pref_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_dual_standby_pref_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

#if defined(FEATURE_DUAL_SIM) || defined(FEATURE_TRIPLE_SIM)
  req_msg  = (nas_set_dual_standby_pref_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_dual_standby_pref_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_set_dual_standby_pref_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_dual_standby_pref_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_004B_req_check ( req_msg );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    switch ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs )
    {
#ifdef FEATURE_TRIPLE_SIM
      case QMI_NAS_SUBS_TERTIARY:
        p_info = &qmi_nasi_global.cm_ph_info3;
        break;
#endif
#ifdef FEATURE_DUAL_SIM
      case QMI_NAS_SUBS_SECONDARY:
        p_info = &qmi_nasi_global.cm_ph_info2;
        break;
#endif
      case QMI_NAS_SUBS_PRIMARY:
        p_info = &qmi_nasi_global.cm_ph_info;
        break;
      default:
        QM_MSG_ERROR_1("bound_subs not valid %d", ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs);
        errval = QMI_ERR_INTERNAL_V01;
        break;
    }
  }


  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( req_msg->standby_pref_valid ) { standby_pref             = (sys_modem_dual_standby_pref_e_type)req_msg->standby_pref; }
    if ( req_msg->priority_subs_valid ) { priority_subs           = (sys_modem_as_id_e_type)req_msg->priority_subs;            }
    if ( req_msg->default_data_subs_valid ) { default_data_subs   = (sys_modem_as_id_e_type)req_msg->default_data_subs;        }
    if ( req_msg->default_voice_subs_valid ) { default_voice_subs = (sys_modem_as_id_e_type)req_msg->default_voice_subs;       }
    if ( req_msg->dds_duration_valid ) { dds_cause                = (cm_dds_cause_e_type)req_msg->dds_duration;                }

    if ( req_msg->active_subs_mask_valid ) 
    {
      if ( req_msg->active_subs_mask == 0 )
      {
        standby_pref = SYS_MODEM_DS_PREF_NO_STANDBY_PREF;
        active_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
      }
#ifdef FEATURE_TRIPLE_SIM
      else if ( req_msg->active_subs_mask == 
               (QMI_NAS_ACTIVE_SUB_PRIMARY_V01|QMI_NAS_ACTIVE_SUB_SECONDARY_V01|QMI_NAS_ACTIVE_SUB_TERTIARY_V01) )
      {
        standby_pref = SYS_MODEM_DS_PREF_TRIPLE_STANDBY;
        active_subs = (uint8)req_msg->active_subs_mask;
      }
#endif
      else if ( req_msg->active_subs_mask == (QMI_NAS_ACTIVE_SUB_PRIMARY_V01|QMI_NAS_ACTIVE_SUB_SECONDARY_V01) )
      {
        standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
        active_subs = (uint8)req_msg->active_subs_mask;
      }
#ifdef FEATURE_TRIPLE_SIM
      else if ( req_msg->active_subs_mask == (QMI_NAS_ACTIVE_SUB_PRIMARY_V01|QMI_NAS_ACTIVE_SUB_TERTIARY_V01) )
      {
        standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
        active_subs = (uint8)req_msg->active_subs_mask;
      }
      else if ( req_msg->active_subs_mask == (QMI_NAS_ACTIVE_SUB_SECONDARY_V01|QMI_NAS_ACTIVE_SUB_TERTIARY_V01) )
      {
        standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
        active_subs = (uint8)req_msg->active_subs_mask;
      }
      else if ( req_msg->active_subs_mask == QMI_NAS_ACTIVE_SUB_TERTIARY_V01 )
      {
        standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
        active_subs = SYS_MODEM_AS_ID_3_MASK;
      }
#endif
      else if ( req_msg->active_subs_mask & QMI_NAS_ACTIVE_SUB_SECONDARY_V01 )
      {
        standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
        active_subs = SYS_MODEM_AS_ID_2_MASK;
      }
      else
      {
        standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
        active_subs = SYS_MODEM_AS_ID_1_MASK;
      }
    }

    if(p_info != NULL && errval == QMI_ERR_NONE_V01)
    {
      qmi_nas_map_standby_pref_cm_to_qmi((uint32*)&last_standby_pref, p_info->standby_pref );
      qmi_nas_map_standby_pref_cm_to_active_subs(&current_active_subs, p_info );

      if ( ( !req_msg->standby_pref_valid || req_msg->standby_pref == last_standby_pref) &&
           ( !req_msg->priority_subs_valid || req_msg->priority_subs == (nas_subs_type_enum_v01)p_info->priority_subs )  &&
           ( !req_msg->default_data_subs_valid || req_msg->default_data_subs == (nas_subs_type_enum_v01)p_info->default_data_subs) &&
           ( !req_msg->default_voice_subs_valid || req_msg->default_voice_subs == (nas_subs_type_enum_v01)p_info->default_voice_subs) &&
           ( !req_msg->active_subs_mask_valid || active_subs == current_active_subs)
         )
      {
        QM_MSG_ERROR("Duplicate dual standby request. Rejecting");
        errval = QMI_ERR_NO_EFFECT_V01;
      }
    }

    QM_MSG_HIGH_3("Active subs mask %d, standby %d, active subs %d", req_msg->active_subs_mask, standby_pref, active_subs);
    if ( errval == QMI_ERR_NONE_V01 )
    {
      if ( !cm_ph_cmd_dual_standby_pref_1( qmi_nas_cmph_cmd_cb,
                                         (void *)cmd_buf_p,
                                         qmi_nasi_global.cm_clnt_id,
                                         standby_pref,
                                         active_subs,
                                         default_voice_subs,
                                         default_data_subs,
                                       priority_subs ,
                                       dds_cause) )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("cm_ph_cmd_dual_standby_pref() failed");
      }
    }
  }
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( resp_msg != NULL )
    {
      memset(resp_msg, 0, sizeof(nas_set_dual_standby_pref_resp_msg_v01) );
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)cmd_buf_p->msg_id,
                                    (void *)resp_msg,
                                    (uint32_t)sizeof(nas_set_dual_standby_pref_resp_msg_v01),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }
  }
#if defined(FEATURE_DUAL_SIM) || defined(FEATURE_TRIPLE_SIM)
  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
#endif
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}
#endif

/*===========================================================================
  FUNCTION QMI_NASI_GET_SYS_INFO()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_sys_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  cm_mm_ss_info_s_type *p_ss_info = NULL;
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  uint8 asubs_max = sizeof(qmi_nasi_global.cm_msim_ss_info)/sizeof(qmi_nasi_global.cm_msim_ss_info[0]);
  sys_modem_as_id_e_type    asubs_id = SYS_MODEM_AS_ID_1;
  #endif
  enum qmi_nas_subs_e bound_subs;
  qmi_cm_ph_info_s_type        *p_ph_info = &qmi_nasi_global.cm_ph_info;

  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_sys_info_resp_msg_v01 * nas_get_sys_info_resp;

  nas_get_sys_info_resp = (nas_get_sys_info_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_sys_info_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr 0x%x 0x%x 0x%x 0x%x", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }
  else
  {
    bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
    if( 
        (bound_subs > QMI_NAS_SUBS_NONE) && 
        (bound_subs < QMI_NAS_SUBS_MAX) 
      )
    {
      p_ss_info = &qmi_nasi_global.cm_ss_info[bound_subs];
    }
  }

  if(!p_ss_info)
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !qmi_nasi_global.rcvd_ss_info )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
  }

#ifdef FEATURE_DUAL_SIM
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
      p_ph_info = &qmi_nasi_global.cm_ph_info2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY)
    {
      asubs_id = SYS_MODEM_AS_ID_3;
      p_ph_info = &qmi_nasi_global.cm_ph_info3;
    }
#endif // FEATURE_TRIPLE_SIM
  }
#endif

  if ( nas_get_sys_info_resp != NULL && cmd_buf_p != NULL )
  {
    memset( nas_get_sys_info_resp, 0x00, sizeof( nas_get_sys_info_resp_msg_v01 ) );

    if( errval == QMI_ERR_NONE_V01 )
  {
      errval =  qmi_nas_generate_sys_info_msg( p_ss_info, p_ph_info, nas_get_sys_info_resp); 
  }

    nas_get_sys_info_resp->resp.error  = errval;
    nas_get_sys_info_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) nas_get_sys_info_resp,
                                  (uint32_t) sizeof( nas_get_sys_info_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_get_sys_info_resp != NULL ) { modem_mem_free( (void *) nas_get_sys_info_resp, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_sys_info */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_SYS_INFO_MSG ()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    qmi_nas_sys_info_type message from a given CM SS and PH info. To be used
    in QMI_NAS_GET_SYS_INFO

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    cm_ph_info_s_type    CM PH info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_error_type_v01 qmi_nas_generate_sys_info_msg(
    cm_mm_ss_info_s_type   *p_ss_info,
    qmi_cm_ph_info_s_type      *p_ph_info,
  nas_get_sys_info_resp_msg_v01 * nas_get_sys_info_resp
)
{
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  memset( nas_get_sys_info_resp, 0x00, sizeof(nas_get_sys_info_resp_msg_v01) );

  /////////////////////////////////////////////////////////
  // CDMA
  /////////////////////////////////////////////////////////
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
  if ( TARGET_SUPPORTS_CDMA && asubs_id == SYS_MODEM_AS_ID_1)
  {

    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_CDMA)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    // TLV 0x10
    if(stack_index != STACK_INDEX_MAX)
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->cdma_srv_status_info.srv_status = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, STACK_INDEX_0, SYS_SYS_MODE_CDMA);
#else
        nas_get_sys_info_resp->cdma_srv_status_info.srv_status = (nas_service_status_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_status ;
#endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    else
    {
      nas_get_sys_info_resp->cdma_srv_status_info.srv_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    nas_get_sys_info_resp->cdma_srv_status_info.is_pref_data_path = ( p_ss_info->stack_info[STACK_INDEX_0].cur_idle_digital_mode == SYS_SYS_MODE_CDMA );  // ? TRUE : FALSE;
    nas_get_sys_info_resp->cdma_srv_status_info_valid             = TRUE;

    if ( nas_get_sys_info_resp->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      // TLV 0x15
      nas_get_sys_info_resp->cdma_sys_info_valid                                          = TRUE;

      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.srv_domain_valid               = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.srv_domain                     = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_domain;

      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.srv_capability_valid           = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.srv_capability                 = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_capability;

      if ( p_ss_info->stack_info[STACK_INDEX_0].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.roam_status_valid              = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.common_sys_info.roam_status                    = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].roam_status;
      }

      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.is_sys_forbidden_valid         = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.is_sys_forbidden               = p_ss_info->stack_info[STACK_INDEX_0].is_sys_forbidden;

      nas_get_sys_info_resp->cdma_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match_valid  = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match        = p_ss_info->stack_info[STACK_INDEX_0].is_sys_prl_match ;

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use != CM_SS_P_REV_IN_USE_NONE )
      {
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.p_rev_in_use_valid    = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.p_rev_in_use          = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use;
      }

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.bs_p_rev != CM_SS_BS_P_REV_NONE )
      {
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_p_rev_valid        = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_p_rev              = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.bs_p_rev;
      }

      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.ccs_supported_valid     = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.ccs_supported           = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.ccs_supported;

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id_valid     = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id.sid       = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.sid;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id.nid       = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.nid;
      }

      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_info_valid           = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_info.base_id         = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_id;
      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_info.base_lat        = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_lat;
      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_info.base_long       = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_long;

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.packet_zone != 0x00)
      {
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.packet_zone_valid     = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.packet_zone           = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.packet_zone;
      }

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc == 0 && p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12 == 0 )
        {
          nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.network_id_valid    = FALSE;
        }
        else
        {
          nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.network_id_valid    = TRUE;
          convert_cdma_mcc_2_ascii_mcc( nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.network_id.mcc, p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc );        // TODO apply decoding
          convert_cdma_mnc_2_ascii_mnc( nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.network_id.mnc, p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12 ); // TODO apply decoding
        }

        if(p_ss_info->current_mcc < 1000)
        {
          nas_get_sys_info_resp->cdma_mcc_resolved_via_sid_lookup                         = p_ss_info->current_mcc;
          nas_get_sys_info_resp->cdma_mcc_resolved_via_sid_lookup_valid                   = TRUE;
        }
      }

    // TLV 0x1A additional CDMA sys info
      nas_get_sys_info_resp->cdma_sys_info2_valid                                         = TRUE;

      nas_get_sys_info_resp->cdma_sys_info2.geo_sys_idx                                   = p_ss_info->stack_info[STACK_INDEX_0].geo_sys_idx;
      nas_get_sys_info_resp->cdma_sys_info2.reg_prd                                       = p_ss_info->stack_info[STACK_INDEX_0].rat_mode_info.cdma_mode_info.cdma_reg_prd;

    // TLV 0x2B CDMA Reg Zone
      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.reg_zone != CM_SS_REG_ZONE_NONE )
      {
        nas_get_sys_info_resp->cdma_reg_zone_valid                                        = TRUE;
        nas_get_sys_info_resp->cdma_reg_zone                                              = ( NAS_004D_CDMA_REG_ZONE_MASK & p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.reg_zone );
    }

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA &&
           ( p_ss_info->stack_info[STACK_INDEX_0].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[STACK_INDEX_0].srv_domain  == SYS_SRV_DOMAIN_CS_PS))
      {
        nas_get_sys_info_resp->cdma_voice_status_valid = TRUE;
        nas_get_sys_info_resp->cdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        nas_get_sys_info_resp->cdma_sms_status_valid = TRUE;
        nas_get_sys_info_resp->cdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  } // end CDMA
#endif
  /////////////////////////////////////////////////////////
  // HDR
  /////////////////////////////////////////////////////////
#if defined(FEATURE_HDR)
  if( TARGET_SUPPORTS_HDR && asubs_id == SYS_MODEM_AS_ID_1)
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_HDR)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x11
    if( stack_index != STACK_INDEX_MAX )
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->hdr_srv_status_info.srv_status                                 = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_HDR );
#else
      nas_get_sys_info_resp->hdr_srv_status_info.srv_status                               = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
     #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    else
    {
      nas_get_sys_info_resp->hdr_srv_status_info.srv_status                               = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->hdr_srv_status_info.is_pref_data_path                        = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_HDR );
    }
    nas_get_sys_info_resp->hdr_srv_status_info_valid                                      = TRUE;

    //TLV 0x16
    if ( nas_get_sys_info_resp->hdr_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->hdr_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01  &&
         stack_index != STACK_INDEX_MAX)
    {
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.srv_domain_valid                = TRUE;
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.srv_domain                      = SYS_SRV_DOMAIN_PS_ONLY_V01;

      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.srv_capability_valid            = TRUE;
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.srv_capability                  = SYS_SRV_DOMAIN_PS_ONLY_V01;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.roam_status_valid               = TRUE;
        nas_get_sys_info_resp->hdr_sys_info.common_sys_info.roam_status                   = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.is_sys_forbidden_valid          = TRUE;
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.is_sys_forbidden                = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      nas_get_sys_info_resp->hdr_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match_valid   = TRUE;
      nas_get_sys_info_resp->hdr_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match         = p_ss_info->stack_info[stack_index].is_sys_prl_match ;

      if( p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_personality != SYS_PERSONALITY_NONE )
      {
        nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.hdr_personality_valid   = TRUE;
        nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.hdr_personality         = (nas_hdr_personality_enum_type_v01)p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_personality;
      }

      if( p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_active_prot != SYS_ACTIVE_PROT_NONE )
      {
        nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.hdr_active_prot_valid   = TRUE;
        nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.hdr_active_prot         = (nas_hdr_active_prot_enum_type_v01)p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_active_prot;
      }

      if ( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_IS856 )
        {
          nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.is856_sys_id_valid    = TRUE;
          memscpy( &nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.is856_sys_id, 
                   NAS_IS_856_MAX_LEN,
                 p_ss_info->stack_info[stack_index].sys_id.id.is856, NAS_IS_856_MAX_LEN );
        }
      nas_get_sys_info_resp->hdr_sys_info_valid                                           = TRUE;

    // TLV 0x1B additional HDR sys info
      nas_get_sys_info_resp->hdr_sys_info2_valid                                          = TRUE;
      nas_get_sys_info_resp->hdr_sys_info2.geo_sys_idx                                  = p_ss_info->stack_info[stack_index].geo_sys_idx;

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->hdr_voice_status_valid = TRUE;
        nas_get_sys_info_resp->hdr_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        nas_get_sys_info_resp->hdr_sms_status_valid = TRUE;
        nas_get_sys_info_resp->hdr_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

      nas_get_sys_info_resp->hdr_subnet_mask_len_valid = TRUE;
      nas_get_sys_info_resp->hdr_subnet_mask_len = p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.subnet_mask_len;
    }
  } // end HDR
#endif
  /////////////////////////////////////////////////////////
  // GSM
  /////////////////////////////////////////////////////////
#if defined(FEATURE_GSM) 

  if( TARGET_SUPPORTS_GSM )
  {
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM)
    {
      stack_index = STACK_INDEX_0;
    }
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM)
    {
      stack_index = STACK_INDEX_1;
    }
    #endif 
    else   
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x12
    if( stack_index != STACK_INDEX_MAX )
    #endif
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
      nas_get_sys_info_resp->gsm_srv_status_info.srv_status                               = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, SYS_SYS_MODE_GSM);
#else
        nas_get_sys_info_resp->gsm_srv_status_info.srv_status                             = (nas_service_status_enum_type_v01)p_ss_info->srv_status;
      #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else
    {
      nas_get_sys_info_resp->gsm_srv_status_info.srv_status                             = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
    if( stack_index != STACK_INDEX_MAX )
    #endif
    {
      nas_get_sys_info_resp->gsm_srv_status_info.true_srv_status                        =  (nas_true_service_status_enum_type_v01)p_ss_info->true_srv_status;
      nas_get_sys_info_resp->gsm_srv_status_info.is_pref_data_path                      = ( p_ss_info->cur_idle_digital_mode == SYS_SYS_MODE_GSM );
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else
    {
      nas_get_sys_info_resp->gsm_srv_status_info.true_srv_status                        =  SYS_SRV_STATUS_NO_SRV_V01;
    }
    #endif
      nas_get_sys_info_resp->gsm_srv_status_info_valid                                    = TRUE;


    //TLV 0x17
    if ( nas_get_sys_info_resp->gsm_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->gsm_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01)
    {
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.srv_domain_valid                = TRUE;
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.srv_capability_valid            = TRUE;
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.is_sys_forbidden_valid          = TRUE;

      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.srv_domain                      =  (nas_service_domain_enum_type_v01)p_ss_info->srv_domain;
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.srv_capability                  =  (nas_service_domain_enum_type_v01)p_ss_info->srv_capability;
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.is_sys_forbidden              =  p_ss_info->plmn_forbidden;

      if ( p_ss_info->roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        nas_get_sys_info_resp->gsm_sys_info.common_sys_info.roam_status                   =  (nas_roam_status_enum_type_v01)p_ss_info->roam_status;
        nas_get_sys_info_resp->gsm_sys_info.common_sys_info.roam_status_valid               = TRUE;
      }

      nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.lac                =  qmi_nas_get_lac( p_ss_info );

      if ( nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.lac != QMI_NAS_INVALID_LAC )
      {
        nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.lac_valid          = TRUE;
      }

      nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.cell_id_valid    = TRUE;
      nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.cell_id          = p_ss_info->cell_info.cell_id;

      if( p_ss_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->sys_id.id.plmn ))
      {
        nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->sys_id.id.plmn );
      }

      if( p_ss_info->reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->reg_reject_info.reject_srv_domain;
        nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->reg_reject_info.reject_cause;
      }

      nas_get_sys_info_resp->gsm_sys_info.gsm_specific_sys_info.egprs_supp_valid          = TRUE;
      nas_get_sys_info_resp->gsm_sys_info.gsm_specific_sys_info.dtm_supp_valid            = TRUE;


      nas_get_sys_info_resp->gsm_sys_info.gsm_specific_sys_info.egprs_supp              = p_ss_info->cell_srv_ind.egprs_supp;
      nas_get_sys_info_resp->gsm_sys_info.gsm_specific_sys_info.dtm_supp                = p_ss_info->cell_srv_ind.dtm_supp;

      nas_get_sys_info_resp->gsm_sys_info_valid                                           = TRUE;

      #if !defined(FEATURE_MMODE_QMI_GPRS_LTE)
      nas_get_sys_info_resp->gsm_sys_info2_valid                                          = TRUE;
      nas_get_sys_info_resp->gsm_sys_info2.geo_sys_idx                                  = p_ss_info->geo_sys_idx;
      nas_get_sys_info_resp->gsm_sys_info2.cell_broadcast_cap                           = (nas_cell_broadcast_cap_enum_type_v01)p_ss_info->cell_bc_info.cell_bc_capability;

    // TLV 0x1F GSM Cell Access info
      nas_get_sys_info_resp->gsm_sys_info3_valid                                          = TRUE;
      if ( p_ss_info->cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        nas_get_sys_info_resp->gsm_sys_info3.cs_bar_status                              = (nas_cell_access_status_e_type_v01) p_ss_info->cell_access_info.cs_bar_status;
      }
      else
      {
          nas_get_sys_info_resp->gsm_sys_info3.cs_bar_status                              = NAS_CELL_ACCESS_UNKNOWN_V01;
        }

      if ( p_ss_info->cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        nas_get_sys_info_resp->gsm_sys_info3.ps_bar_status                              = (nas_cell_access_status_e_type_v01) p_ss_info->cell_access_info.ps_bar_status;
        }
        else
        {
          nas_get_sys_info_resp->gsm_sys_info3.ps_bar_status                              = NAS_CELL_ACCESS_UNKNOWN_V01;
      }
      #endif

    // TLV 0x22 GSM Cipher Domain info
      nas_get_sys_info_resp->gsm_cipher_domain_valid                                      = TRUE;
      nas_get_sys_info_resp->gsm_cipher_domain                                            = (nas_service_domain_enum_type_v01)p_ss_info->cipher_domain;

    // TLV 0x2C GSM RAC
      if( p_ss_info->rac_or_mme_code != 0xFF )
        {
          nas_get_sys_info_resp->gsm_rac_valid       = TRUE;
        nas_get_sys_info_resp->gsm_rac                                                    =  p_ss_info->rac_or_mme_code ;
    }

    // TLV 0x33 GSM Possible Registration Domain
      if (  p_ss_info->available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        nas_get_sys_info_resp->gsm_reg_domain_valid                                       = TRUE;
        nas_get_sys_info_resp->gsm_reg_domain                                             = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->available_plmn_type );
    }

      if ( p_ss_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->gsm_voice_status_valid = TRUE;
        nas_get_sys_info_resp->gsm_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );
        nas_get_sys_info_resp->gsm_sms_status_valid = TRUE;
        nas_get_sys_info_resp->gsm_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }// NO_SRV/NO_PWR_SAVE
  }//End GSM
#endif
  /////////////////////////////////////////////////////////
  // WCDMA
  /////////////////////////////////////////////////////////
#if defined(FEATURE_WCDMA)
  if( TARGET_SUPPORTS_WCDMA )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA)
    {
      stack_index = STACK_INDEX_0;
    }
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_WCDMA)
    { 
      stack_index = STACK_INDEX_1;
    }
    #endif
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x13
    if( stack_index != STACK_INDEX_MAX )
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->wcdma_srv_status_info.srv_status                             = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, stack_index, SYS_SYS_MODE_WCDMA);
#else
      nas_get_sys_info_resp->wcdma_srv_status_info.srv_status                           = (nas_service_status_enum_type_v01)p_ss_info->srv_status;
     #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    else
    {
      nas_get_sys_info_resp->wcdma_srv_status_info.srv_status                           = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->wcdma_srv_status_info.true_srv_status                      = (nas_true_service_status_enum_type_v01)p_ss_info->true_srv_status;
      nas_get_sys_info_resp->wcdma_srv_status_info.is_pref_data_path                    = ( p_ss_info->cur_idle_digital_mode == SYS_SYS_MODE_WCDMA ) ;
    }
    else
    {
      nas_get_sys_info_resp->wcdma_srv_status_info.true_srv_status                      = SYS_SRV_STATUS_NO_SRV_V01;
    }
      nas_get_sys_info_resp->wcdma_srv_status_info_valid                                  = TRUE;

    if ( nas_get_sys_info_resp->wcdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->wcdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      //TLV 0x18
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.srv_domain_valid              = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.srv_capability_valid          = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.is_sys_forbidden_valid        = TRUE;

      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.srv_domain                  = (nas_service_domain_enum_type_v01)p_ss_info->srv_domain;
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.srv_capability              = (nas_service_domain_enum_type_v01)p_ss_info->srv_capability;
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.is_sys_forbidden            = p_ss_info->plmn_forbidden;

      if ( p_ss_info->roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.roam_status                 = (nas_roam_status_enum_type_v01)p_ss_info->roam_status;
        nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.roam_status_valid             = TRUE;
      }

      nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.lac              = qmi_nas_get_lac( p_ss_info, stack_index );

      if ( nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.lac != QMI_NAS_INVALID_LAC )
      {
        nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.lac_valid        = TRUE;
      }

      nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.cell_id_valid  = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.cell_id        = p_ss_info->cell_info.cell_id;

      if( p_ss_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->sys_id.id.plmn ))
      {
        nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->sys_id.id.plmn);
      }

      nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.hs_call_status_valid  = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.hs_ind_valid          = TRUE;

      nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.hs_call_status      = (nas_hs_support_enum_type_v01)p_ss_info->cell_srv_ind.hs_call_status;
      nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.hs_ind              = (nas_hs_support_enum_type_v01)p_ss_info->cell_srv_ind.hs_ind;

      if( p_ss_info->cell_info.psc != 0xFFFF )
        {
          nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.psc_valid         = TRUE;
        nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.psc               = p_ss_info->cell_info.psc;
      }

      if( p_ss_info->reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->reg_reject_info.reject_srv_domain;
        nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->reg_reject_info.reject_cause;
      }

      nas_get_sys_info_resp->wcdma_sys_info_valid                                         = TRUE;

    // TLV 0x1D additional UMTS sys info
      nas_get_sys_info_resp->wcdma_sys_info2_valid                                        = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info2.geo_sys_idx                                  = p_ss_info->geo_sys_idx;
      nas_get_sys_info_resp->wcdma_sys_info2.cell_broadcast_cap                           = (nas_cell_broadcast_cap_enum_type_v01) p_ss_info->cell_bc_info.cell_bc_capability;

    // TLV 0x20 WCDMA Cell Access info
      nas_get_sys_info_resp->wcdma_sys_info3_valid                                        = TRUE;

      if ( p_ss_info->cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        nas_get_sys_info_resp->wcdma_sys_info3.cs_bar_status                            = (nas_cell_access_status_e_type_v01) p_ss_info->cell_access_info.cs_bar_status;
        }
        else
        {
          nas_get_sys_info_resp->wcdma_sys_info3.cs_bar_status                            = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
      if ( p_ss_info->cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        nas_get_sys_info_resp->wcdma_sys_info3.ps_bar_status                            = (nas_cell_access_status_e_type_v01) p_ss_info->cell_access_info.ps_bar_status;
        }
        else
        {
          nas_get_sys_info_resp->wcdma_sys_info3.ps_bar_status                            = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

    // TLV 0x23 WCDMA Cipher Domain info
      nas_get_sys_info_resp->wcdma_cipher_domain_valid                                    = TRUE;
      nas_get_sys_info_resp->wcdma_cipher_domain                                          = (nas_service_domain_enum_type_v01)p_ss_info->cipher_domain;

    // TLV 0x28 WCDMA E-UTRA Status info
      nas_get_sys_info_resp->wcdma_eutra_status_valid                                     = TRUE;
      nas_get_sys_info_resp->wcdma_eutra_status                                           = (nas_eutra_cell_status_enum_type_v01) qmi_nas_eutra_status_cm_2_qmi( p_ss_info->eutra_detect_status );

    // TLV 0x2D WCDMA RAC
      if( p_ss_info->rac_or_mme_code != 0xFF )
        {
          nas_get_sys_info_resp->wcdma_rac_valid                                            = TRUE;
        nas_get_sys_info_resp->wcdma_rac                                                  = p_ss_info->rac_or_mme_code;
    }

    // TLV 0x32 WCDMA Possible Registration Domain
      if ( p_ss_info->available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        nas_get_sys_info_resp->wcdma_reg_domain_valid                                     = TRUE;
        nas_get_sys_info_resp->wcdma_reg_domain                                           = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->available_plmn_type);
    }

      if ( p_ss_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->wcdma_voice_status_valid = TRUE;
        nas_get_sys_info_resp->wcdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        nas_get_sys_info_resp->wcdma_sms_status_valid = TRUE;
        nas_get_sys_info_resp->wcdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  if ( qm_efs_csg_supported() )
  {
        if( p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID )
      {
        nas_get_sys_info_resp->wcdma_csg_info_valid = TRUE;
          nas_get_sys_info_resp->wcdma_csg_info.id = p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id;
          nas_get_sys_info_resp->wcdma_csg_info.name_len = MIN(p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length, NAS_CSG_NAME_MAX_V01);
        memscpy( nas_get_sys_info_resp->wcdma_csg_info.name, 
                 nas_get_sys_info_resp->wcdma_csg_info.name_len,
                   p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.name, 
                 nas_get_sys_info_resp->wcdma_csg_info.name_len);
          QM_MSG_HIGH_2("CM SS Evt csg_id %d, name_len %d", p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id, p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length);
      }
      }
#endif
#endif
    }
  } // end WCDMA
#endif
  /////////////////////////////////////////////////////////
  // LTE
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_LTE )
  {
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE)
  {
      stack_index = STACK_INDEX_0;
    }
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) &&   (defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) )
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE)
    { 
      stack_index = STACK_INDEX_1;
    }
    #endif
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    if( stack_index != STACK_INDEX_MAX )
    #endif
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->lte_srv_status_info.srv_status                                 = qmi_nas_get_srv_status_from_cmss_event(p_ss_info,SYS_SYS_MODE_LTE);
#else
      nas_get_sys_info_resp->lte_srv_status_info.srv_status                               = (nas_service_status_enum_type_v01)p_ss_info->srv_status;
      #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else
    {
      nas_get_sys_info_resp->lte_srv_status_info.srv_status                               = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    if( stack_index != STACK_INDEX_MAX )
    #endif
    {
      nas_get_sys_info_resp->lte_srv_status_info.true_srv_status                          = (nas_true_service_status_enum_type_v01)p_ss_info->true_srv_status;
      #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      nas_get_sys_info_resp->lte_srv_status_info.is_pref_data_path                        = ( p_ss_info->cur_idle_digital_mode == SYS_SYS_MODE_LTE ) ;      
      #else
      nas_get_sys_info_resp->lte_srv_status_info.is_pref_data_path                        = TRUE;
      #endif
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else
    {
      nas_get_sys_info_resp->lte_srv_status_info.true_srv_status                          = SYS_SRV_STATUS_NO_SRV_V01;
    }
    #endif
    nas_get_sys_info_resp->lte_srv_status_info_valid                                    = TRUE;

    //TLV 0x19
    if ( nas_get_sys_info_resp->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.srv_domain_valid                = TRUE;
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.srv_capability_valid            = TRUE;
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.is_sys_forbidden_valid          = TRUE;

      nas_get_sys_info_resp->lte_sys_info.common_sys_info.srv_domain                    = (nas_service_domain_enum_type_v01)p_ss_info->srv_domain;
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.srv_capability                = (nas_service_domain_enum_type_v01)p_ss_info->srv_capability;
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.is_sys_forbidden              = p_ss_info->plmn_forbidden;

      if ( p_ss_info->roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        nas_get_sys_info_resp->lte_sys_info.common_sys_info.roam_status                   = (nas_roam_status_enum_type_v01)p_ss_info->roam_status;
        nas_get_sys_info_resp->lte_sys_info.common_sys_info.roam_status_valid               = TRUE;
      }

      nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.lac_valid            = FALSE;                // invalid under LTE
      nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.lac                  = QMI_NAS_INVALID_LAC;

      nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.cell_id_valid    = TRUE;
      nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.cell_id          = p_ss_info->cell_info.cell_id;

      if( p_ss_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->sys_id.id.plmn ))
      {
        nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->sys_id.id.plmn);
      }

      if( p_ss_info->reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->reg_reject_info.reject_srv_domain;
        nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->reg_reject_info.reject_cause;
      }

      // LTE specific params
      nas_get_sys_info_resp->lte_sys_info.lte_specific_sys_info.tac                     = p_ss_info->tac;

      if ( IS_TAC_VALID(nas_get_sys_info_resp->lte_sys_info.lte_specific_sys_info.tac) )
      {
      nas_get_sys_info_resp->lte_sys_info.lte_specific_sys_info.tac_valid                 = TRUE;
      }
      else
      {
        nas_get_sys_info_resp->lte_sys_info.lte_specific_sys_info.tac                     = 0;
      }

      nas_get_sys_info_resp->lte_sys_info_valid                                           = TRUE;

      #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    // TLV 0x1E additional LTE sys info
      nas_get_sys_info_resp->lte_sys_info2_valid                                          = TRUE;
      nas_get_sys_info_resp->lte_sys_info2.geo_sys_idx                                    = p_ss_info->geo_sys_idx;
      #endif

    // TLV 0x21 voice support on LTE
    // Valid only when LTE is on main stack
      if ( p_ss_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS )
    {
        nas_get_sys_info_resp->voice_support_on_lte_valid                                 = TRUE;
        //nas_get_sys_info_resp->voice_support_on_lte                                       = p_ss_info->voice_support_on_lte;
    }
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
#ifdef FEATURE_LTE_EMBMS
      // TLV 0x26 eMBMS coverage information // embms supported // now deprecated
      nas_get_sys_info_resp->lte_embms_coverage_valid                                     = TRUE;
      if(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status != SYS_EMBMS_COVERAGE_STATUS_AVAILABLE)
      {
        nas_get_sys_info_resp->lte_embms_coverage                                           = FALSE;
      }
      else
      {
        nas_get_sys_info_resp->lte_embms_coverage                                           = TRUE;
      }

      // TLV 0x46 LTE eMBMS Coverage Info Extended
      nas_get_sys_info_resp->embms_coverage_status_valid = TRUE;
      switch(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status)
      {
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_AVAILABLE:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_AVAILABLE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_E911:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_EMERGENCY_V01; break;
      default:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_UNKNOWN_V01; break;
      }

      // TLV 0x34 eMBMS coverage information // trace id
      nas_get_sys_info_resp->lte_embms_coverage_trace_id_valid                            = TRUE;
      nas_get_sys_info_resp->lte_embms_coverage_trace_id                                  = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.trace_id;
#endif
#endif
      //TLV 0x29 lte_ims_voice_avail
      if ( p_ss_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
          nas_get_sys_info_resp->lte_ims_voice_avail_valid                                = TRUE;
          nas_get_sys_info_resp->lte_ims_voice_avail                                      = p_ss_info->lte_ims_voice_avail;
      }

      //TLV 0x2A LTE Voice status
      // Valid only when LTE is on main stack
      if ( p_ss_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->lte_voice_status_valid                                     = TRUE;
        nas_get_sys_info_resp->lte_voice_status                                           = qmi_nas_map_lte_voice_status_cm_to_qmi(p_ss_info);

        nas_get_sys_info_resp->lte_sms_status_valid= TRUE;
        nas_get_sys_info_resp->lte_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

      // TLV 0x39 LTE Emergency Bearer Support
      // Assumption: CM will be passing this value for LTE on MAIN stack as well as GW_HYB stack
      nas_get_sys_info_resp->lte_is_eb_supported_valid = TRUE;
      nas_get_sys_info_resp->lte_is_eb_supported = qmi_nas_map_lte_eb_status_cm_to_qmi(p_ss_info->lte_ims_emerg_avail);

      // TLV 0x3E LTE Emergency Access Barred
      nas_get_sys_info_resp->emergency_access_barred_valid = TRUE;
      nas_get_sys_info_resp->emergency_access_barred = qmi_nas_map_lte_eab_status_cm_to_qmi(p_ss_info->cell_info.emerg_access_status);

    // TLV 0x31 LTE Possible Registration Domain
      if ( p_ss_info->available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        nas_get_sys_info_resp->lte_reg_domain_valid                                       = TRUE;
        nas_get_sys_info_resp->lte_reg_domain                                             = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->available_plmn_type);
      }

      nas_get_sys_info_resp->lte_cell_status_valid                                        = TRUE;

      if ( p_ss_info->cell_info.lte_cell_access_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->cell_info.lte_cell_access_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        nas_get_sys_info_resp->lte_cell_status                                          = (nas_cell_access_status_e_type_v01) p_ss_info->cell_info.lte_cell_access_status;
      }
      else
      {
        nas_get_sys_info_resp->lte_cell_status                                          = NAS_CELL_ACCESS_UNKNOWN_V01;
      }
  
      #ifdef FEATURE_FEMTO_CSG
      #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      if ( qm_efs_csg_supported() )
      {
        if( p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID )
        {
            nas_get_sys_info_resp->lte_csg_info_valid = TRUE;
              nas_get_sys_info_resp->lte_csg_info.id = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id;
              nas_get_sys_info_resp->lte_csg_info.name_len = MIN(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length, NAS_CSG_NAME_MAX_V01);
            memscpy(nas_get_sys_info_resp->lte_csg_info.name, 
                    nas_get_sys_info_resp->lte_csg_info.name_len,
                      p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.name, sizeof(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.name));
              QM_MSG_HIGH_2("CM SS Evt csg_id %d, name_len %d", p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id, p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length);
        }
      }
      #endif
      #endif


      if(p_ss_info->srv_status == SYS_SRV_STATUS_SRV)
      {
        nas_get_sys_info_resp->nas_supp_ciot_optimizations_valid = TRUE;
        
        nas_get_sys_info_resp->nas_supp_ciot_optimizations.cp_ciot_supported
          = p_ss_info->neg_ciot_cap.cp_ciot_supported;
  
        nas_get_sys_info_resp->nas_supp_ciot_optimizations.up_ciot_supported
          = p_ss_info->neg_ciot_cap.up_ciot_supported;
  
      }
    
      nas_get_sys_info_resp->nas_camped_ciot_lte_op_mode_valid  = TRUE;
      nas_get_sys_info_resp->nas_camped_ciot_lte_op_mode        =
          qmi_nas_map_camped_lte_mode_cm_to_qmi(p_ss_info->ciot_lte_mode);


      if(p_ss_info->cp_sms_service_status != SYS_CP_SMS_STATUS_NONE &&
         p_ss_info ->sys_mode == SYS_SYS_MODE_LTE &&
         p_ss_info ->ciot_lte_mode == SYS_SYS_MODE_LTE_NB1 &&
         p_ss_info->srv_status == SYS_SRV_STATUS_SRV
         )
      {
        nas_get_sys_info_resp->cp_sms_service_status_valid = TRUE;
        nas_get_sys_info_resp->cp_sms_service_status = qmi_nas_map_cp_sms_status_cm_to_qmi(p_ss_info->cp_sms_service_status);
      }
    }
  }// end LTE

  /////////////////////////////////////////////////////////
  // TDSCDMA
  /////////////////////////////////////////////////////////
#if defined(FEATURE_TDSCDMA)
  if ( TARGET_SUPPORTS_TDS )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_TDS)
    {
      stack_index = STACK_INDEX_0;
    }
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_TDS)
    { 
      stack_index = STACK_INDEX_1;
    }
    #endif
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    
    //TLV 0x24
    
    if( stack_index != STACK_INDEX_MAX )
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status                             = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, stack_index, SYS_SYS_MODE_TDS);
#else
      nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status                           = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
      #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    else
    {
      nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status                           = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->tdscdma_srv_status_info.true_srv_status                      = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      nas_get_sys_info_resp->tdscdma_srv_status_info.is_pref_data_path                    = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_TDS );
    }
    else
    {
      nas_get_sys_info_resp->tdscdma_srv_status_info.true_srv_status                      = SYS_SRV_STATUS_NO_SRV_V01;
    }
    nas_get_sys_info_resp->tdscdma_srv_status_info_valid                                  = TRUE;

    //TLV 0x25
    if ( nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01 &&
         nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.srv_domain_valid            = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.srv_capability_valid        = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.is_sys_forbidden_valid      = TRUE;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.roam_status_valid           = TRUE;
        nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.roam_status                 = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.hs_call_status_valid = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.hs_ind_valid         = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cell_broadcast_cap_valid  = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status_valid = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status_valid = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cipher_domain_valid = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info_valid                                         = TRUE;

      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status     = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
      }
      else
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status     = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status     = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
      }
      else
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status     = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.srv_domain                  = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.srv_capability              = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.is_sys_forbidden            = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      if ( p_ss_info->stack_info[stack_index].cell_info.lac_id != QMI_NAS_INVALID_LAC )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.lac_valid      = TRUE;
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.lac            = p_ss_info->stack_info[stack_index].cell_info.lac_id;
      }
        
      nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.cell_id_valid  = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.cell_id        = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if ( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      if ( p_ss_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn_avail )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn);
      }
      else if ( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }

      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.hs_call_status       = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_call_status;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.hs_ind               = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_ind;

      if ( p_ss_info->stack_info[stack_index].cell_info.psc != 0xFFFF )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cell_parameter_id_valid = TRUE;
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cell_parameter_id       = p_ss_info->stack_info[stack_index].cell_info.psc;
      }
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cell_broadcast_cap        = (nas_cell_broadcast_cap_enum_type_v01) p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;


      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cipher_domain       = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

    // TLV 0x30 TDSCDMA Possible Registration Domain
      if ( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        nas_get_sys_info_resp->tdscdma_reg_domain_valid                                   = TRUE;
        nas_get_sys_info_resp->tdscdma_reg_domain                                         = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type);
      }
  
      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->tdscdma_voice_status_valid = TRUE;
        nas_get_sys_info_resp->tdscdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        nas_get_sys_info_resp->tdscdma_sms_status_valid = TRUE;
        nas_get_sys_info_resp->tdscdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  } // end TDSCDMA
#endif
  // TLV 0x27 SIM reject information
  if ( TARGET_SUPPORTS_LTE
        #ifndef FEATURE_MMODE_QMI_LTE_ONLY
        || TARGET_SUPPORTS_WCDMA ||TARGET_SUPPORTS_GSM || TARGET_SUPPORTS_TDS
        #endif
      )
  {
    nas_get_sys_info_resp->sim_rej_info_valid                                             = TRUE;
    if(p_ss_info->sim_state == SYS_SIM_STATE_NOT_AVAILABLE )
    {
      nas_get_sys_info_resp->sim_rej_info = (nas_sim_rej_info_enum_type_v01)qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_PRIMARY];
    }
    else
    {
      nas_get_sys_info_resp->sim_rej_info = (nas_sim_rej_info_enum_type_v01)p_ss_info->sim_state;
    }
  }

  // srv_reg_restriction Indication - Global, always returned
  nas_get_sys_info_resp->srv_reg_restriction_valid                                        = TRUE;
  if ( p_ss_info->available_plmn_type == SYS_REG_DOMAIN_NOT_APPLICABLE )
  {
    nas_get_sys_info_resp->srv_reg_restriction                                            = NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;
  }
  else
  {
    nas_get_sys_info_resp->srv_reg_restriction                                            = NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
  }

  return errval;
}

/*===========================================================================
  FUNCTION qmi_nas_map_lte_voice_status_cm_to_qmi()

  DESCRIPTION
    Maps CM lte_voice_status to QMI_NAS enum type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_lte_voice_status_enum_type_v01  qmi_nas_map_lte_voice_status_cm_to_qmi( cm_mm_ss_info_s_type *p_ss_info )
{
  nas_lte_voice_status_enum_type_v01 retval = NAS_LTE_VOICE_STATUS_NO_VOICE_V01;

  switch( p_ss_info->voice_domain )
  {
    case SYS_CM_DOMAIN_SEL_DOMAIN_NO_VOICE : retval = NAS_LTE_VOICE_STATUS_NO_VOICE_V01;   break;
    case SYS_CM_DOMAIN_SEL_DOMAIN_IMS      : retval = NAS_LTE_VOICE_STATUS_IMS_V01;        break;
    case SYS_CM_DOMAIN_SEL_DOMAIN_1X       : retval = NAS_LTE_VOICE_STATUS_1X_V01;         break;
    case SYS_CM_DOMAIN_SEL_DOMAIN_3GPP     : retval = NAS_LTE_VOICE_STATUS_3GPP_V01;       break;

    default:
      QM_MSG_ERROR_1("sys_cm_domain_sel_domain_e_type type %d not supported", (int) p_ss_info->voice_domain);
      retval = NAS_LTE_VOICE_STATUS_NO_VOICE_V01;
      break;
  }

  return retval;
}

/*===========================================================================
  FUNCTION qmi_nas_map_available_plmn_type_cm_to_qmi()

  DESCRIPTION
    Maps CM lte_voice_status to QMI_NAS enum type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_possible_reg_domain_enum_type_v01 qmi_nas_map_available_plmn_type_cm_to_qmi( sys_reg_domain_e_type available_plmn_type )
{
  nas_possible_reg_domain_enum_type_v01 retval = NAS_POSSIBLE_REG_DOMAIN_NA_V01;

  switch( available_plmn_type )
  {
    case SYS_REG_DOMAIN_NOT_APPLICABLE  : retval = NAS_POSSIBLE_REG_DOMAIN_NA_V01;              break;
    case SYS_REG_DOMAIN_CS_SERVICE_ONLY : retval = NAS_POSSIBLE_REG_DOMAIN_CS_ONLY_V01;         break;
    case SYS_REG_DOMAIN_PS_SERVICE_ONLY : retval = NAS_POSSIBLE_REG_DOMAIN_PS_ONLY_V01;         break;
    case SYS_REG_DOMAIN_CS_PS_SERVICE   : retval = NAS_POSSIBLE_REG_DOMAIN_CS_PS_V01;           break;
    case SYS_REG_DOMAIN_CAMPED_ONLY     : retval = NAS_POSSIBLE_REG_DOMAIN_LIMITED_SERVICE_V01; break;

    default:
      retval = NAS_POSSIBLE_REG_DOMAIN_NA_V01;
      break;
  }

  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_LTE_EB_STATUS_CM_TO_QMI()

  DESCRIPTION
    Maps CM lte_ims_emerg_avail to QMI_NAS enum type

  RETURN VALUE
    QMI_NAS enum type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_tri_state_boolean_type_v01 qmi_nas_map_lte_eb_status_cm_to_qmi( sys_ims_lte_emerg_supp_e_type lte_ims_emerg_avail )
{
  nas_tri_state_boolean_type_v01 retval = NAS_TRI_UNKNOWN_V01;

//  QM_MSG_LOW_1("sys_ims_lte_emerg_supp_e_type type %d", lte_ims_emerg_avail);

  switch(lte_ims_emerg_avail)
    {
      case SYS_IMS_LTE_EMERG_SUPP_NOT_AVAILABLE: retval = NAS_TRI_FALSE_V01;  break;
      case SYS_IMS_LTE_EMERG_SUPP_AVAILABLE    : retval = NAS_TRI_TRUE_V01;   break;

      default:
        break;
    }

  return retval;
}

/*===========================================================================
  FUNCTION qmi_nas_map_lte_eab_status_cm_to_qmi()

  DESCRIPTION
    Maps CM sys_lte_emerg_access_status_e_type emerg_bar_status to QMI IDL enum type
    nas_tri_state_boolean_type_v01 to indicate network SIB2 Access barring for making emergency calls.

  RETURN VALUE
    QMI IDL enum type nas_tri_state_boolean_type_v01

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_tri_state_boolean_type_v01 qmi_nas_map_lte_eab_status_cm_to_qmi( sys_lte_emerg_access_status_e_type cm_eab_status )
{
  nas_tri_state_boolean_type_v01 retval = NAS_TRI_UNKNOWN_V01;

//  QM_MSG_HIGH_1("sys_lte_emerg_access_status_e_type type %d", cm_eab_status); 

  switch(cm_eab_status)
  {
    case SYS_LTE_EMERG_ACCESS_BARRED     : retval = NAS_TRI_TRUE_V01;    break;
    case SYS_LTE_EMERG_ACCESS_ALLOWED    : retval = NAS_TRI_FALSE_V01;   break;

    default:
      break;
  }

  return retval;
}


/*===========================================================================
  FUNCTION qmi_nas_map_camped_lte_mode_cm_to_qmi()

  DESCRIPTION
    Maps CM sys_sys_mode_e_type  to QMI IDL enum type
    nas_camped_ciot_lte_op_mode_enum_type_v01 to indicate camped ciot LTE mode

  RETURN VALUE
    QMI IDL enum type nas_camped_ciot_lte_op_mode_enum_type_v01

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_camped_ciot_lte_op_mode_enum_type_v01 qmi_nas_map_camped_lte_mode_cm_to_qmi
( 
  sys_sys_mode_e_type  ciot_lte_mode
)
{
  nas_camped_ciot_lte_op_mode_enum_type_v01 retval = NAS_CIOT_SYS_MODE_NO_SRV_V01;

  

  switch(ciot_lte_mode)
  {
    case SYS_SYS_MODE_LTE_M1     : retval = NAS_CIOT_SYS_MODE_LTE_M1_V01;    break;
    case SYS_SYS_MODE_LTE_NB1    : retval = NAS_CIOT_SYS_MODE_LTE_NB1_V01;   break;

    default:
      break;
  }

  QM_MSG_HIGH_2("ciot_lte_mode CM %d QMI %d", ciot_lte_mode, retval); 
  return retval;
}

/*===========================================================================
  FUNCTION qmi_nas_map_cp_sms_status_cm_to_qmi()

  DESCRIPTION
    Maps CM sys_cp_sms_service_status_e_type  to QMI IDL enum type
    nas_cp_sms_service_status_e_type_v01 to indicate cp sms service status

  RETURN VALUE
    QMI IDL enum type nas_cp_sms_service_status_e_type_v01

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_cp_sms_service_status_e_type_v01 qmi_nas_map_cp_sms_status_cm_to_qmi
( 
  sys_cp_sms_service_status_e_type  cp_sms_service_status
)
{
  nas_cp_sms_service_status_e_type_v01 retval = NAS_CP_SMS_SERVICE_STATUS_NOT_AVAILABLE_V01;

  

  switch(cp_sms_service_status)
  {
    case SYS_CP_SMS_STATUS_AVAILABLE                      : retval = NAS_CP_SMS_SERVICE_STATUS_AVAILABLE_V01;    break;
    case SYS_CP_SMS_STATUS_NOT_AVAILABLE                  : retval = NAS_CP_SMS_SERVICE_STATUS_NOT_AVAILABLE_V01;   break;
    case SYS_CP_SMS_STATUS_SERVICE_NOT_AVAILABLE_IN_PLMN  : retval = NAS_CP_SMS_SERVICE_STATUS_NOT_AVAILABLE_V01;   break;
    case SYS_CP_SMS_STATUS_SERVICE_TEMP_FAILURE           : retval = NAS_CP_SMS_SERVICE_STATUS_TEMP_FAILURE_V01;   break;
    case SYS_CP_SMS_STATUS_SERVICE_FAIL_DUE_TO_NW_FAILURE : retval = NAS_CP_SMS_SERVICE_STATUS_TEMP_FAILURE_V01;   break;
    case SYS_CP_SMS_STATUS_SERVICE_FAIL_DUE_TO_CONGESTION : retval = NAS_CP_SMS_SERVICE_STATUS_TEMP_FAILURE_V01;   break;



    default:
      break;
  }

  QM_MSG_HIGH_2("cp_sms_service_status CM %d QMI %d", cp_sms_service_status, retval); 
  return retval;
}


/*===========================================================================
  FUNCTION QMI_NAS_GEN_SYS_INFO_IND()

  DESCRIPTION
    Generate and send sys info IND message

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_sys_info_ind(
  cm_mm_ss_info_s_type       * p_ss_info,
  qmi_cm_ph_info_s_type          * p_ph_info,
  boolean                      evt_reg_reject
)
{
  dsm_item_type              * indication = NULL;
  sys_modem_as_id_e_type       asubs_id = SYS_MODEM_AS_ID_1;
  qmi_nasi_client_state_type *cl_sp;

  nas_sys_info_ind_msg_v01   * new_ind;
  nas_sys_info_ind_msg_v01   * old_ind;

  qmi_cm_ph_info_s_type          * p_new_ph_info = p_ph_info;
  qmi_cm_ph_info_s_type          * p_old_ph_info = &qmi_nasi_global.cm_ph_info;

  boolean                      send_indication;
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  uint8 asubs_max = sizeof(qmi_nasi_global.cm_msim_ss_info)/sizeof(qmi_nasi_global.cm_msim_ss_info[0]);
  if( (p_ss_info->asubs_id > SYS_MODEM_AS_ID_NONE) && (p_ss_info->asubs_id < asubs_max) )
  {
    asubs_id = p_ss_info->asubs_id;
  }
  #endif
  /* Reset jamming status global of all RATs, if service has changed and not OOS*/
    if(((p_ss_info->sys_mode == SYS_SYS_MODE_LTE && 
        qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].ciot_lte_mode  != p_ss_info->ciot_lte_mode) || 
      (qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].sys_mode != p_ss_info->sys_mode))
        && (p_ss_info->srv_status == SYS_SRV_STATUS_SRV || p_ss_info->srv_status == SYS_SRV_STATUS_LIMITED
      || p_ss_info->srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL) )
     {
         qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_M1].jammer_status = JAMMING_STATUS_NOT_FOUND;
         qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_NB1].jammer_status = JAMMING_STATUS_UNKNOWN;
         qmi_nasi_global.jamming_status_info[IOT_RAT_GSM].jammer_status = JAMMING_STATUS_NOT_FOUND;
         
         qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_M1].soft_jammer_flag = FALSE;
         qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_NB1].soft_jammer_flag = FALSE;
         qmi_nasi_global.jamming_status_info[IOT_RAT_GSM].soft_jammer_flag = FALSE;
    }

  new_ind = (nas_sys_info_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_sys_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  old_ind = (nas_sys_info_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_sys_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( new_ind != NULL && old_ind != NULL )
  {
    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {
      send_indication = FALSE;

      // Check to see if the client exists, AND it wants to receive updates, AND that
          // if it is a registration rejection event, that the client doesn't wish to suppress sys info notification
      if ( cl_sp->report_status.report_sys_info &&
            !( evt_reg_reject && cl_sp->report_status.network_reject.suppress_sys_info_on_reject ) &&
             (cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)asubs_id))
    {
      if ( cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
      {
        asubs_id      = SYS_MODEM_AS_ID_1;
        p_new_ph_info = p_ph_info;
        p_old_ph_info = &qmi_nasi_global.cm_ph_info;
      }
#ifdef FEATURE_DUAL_SIM
      else if( cl_sp->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
      {
        asubs_id      = SYS_MODEM_AS_ID_2;
        p_new_ph_info = &qmi_nasi_global.cm_ph_info2;
        p_old_ph_info = &qmi_nasi_global.cm_ph_info2;
      }
#endif
#ifdef FEATURE_TRIPLE_SIM
      else if( cl_sp->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
      {
        asubs_id      = SYS_MODEM_AS_ID_3;
        p_new_ph_info = &qmi_nasi_global.cm_ph_info3;
        p_old_ph_info = &qmi_nasi_global.cm_ph_info3;
      }
#endif
        memset( new_ind, 0x00, sizeof( nas_sys_info_ind_msg_v01 ) );
        memset( old_ind, 0x00, sizeof( nas_sys_info_ind_msg_v01 ) );

        qmi_nas_populate_sys_info_ind( p_ss_info,                   p_new_ph_info, new_ind);
        qmi_nas_populate_sys_info_ind( &qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY], p_old_ph_info, old_ind);

      if ( !qmi_nasi_global.rcvd_ss_info )
      {
          send_indication = TRUE;
      }
        else if ( memcmp( old_ind, new_ind, sizeof( nas_sys_info_ind_msg_v01) ) ||
                  new_ind->sys_info_no_change_valid                             )
      {
          #if defined(FEATURE_MMODE_QMI_LTE_ONLY)
          if ( 
               new_ind->lte_srv_status_info_valid  || new_ind->lte_sys_info_valid                     ||
               new_ind->lte_sys_info2_valid        || new_ind->voice_support_on_lte_valid             ||
               new_ind->sys_info_no_change_valid   || new_ind->lte_embms_coverage_valid               ||
               new_ind->sim_rej_info_valid              || 
               new_ind->lte_ims_voice_avail_valid  || new_ind->lte_voice_status_valid                 ||
               new_ind->srv_reg_restriction_valid  || new_ind->lte_reg_domain_valid       || 
               new_ind->lte_embms_coverage_trace_id_valid    || new_ind->embms_coverage_status_valid  ||
               new_ind->edrx_supported_valid)
          #elif defined(FEATURE_MMODE_QMI_GPRS_LTE)
          if ( new_ind->gsm_srv_status_info_valid  || new_ind->lte_srv_status_info_valid              || 
               new_ind->gsm_sys_info_valid         || new_ind->lte_sys_info_valid                     ||
               new_ind->gsm_sys_info2_valid        || new_ind->lte_sys_info2_valid                    || 
               new_ind->gsm_sys_info3_valid        ||new_ind->voice_support_on_lte_valid              ||
               new_ind->gsm_cipher_domain_valid    || new_ind->sys_info_no_change_valid               || 
               new_ind->lte_embms_coverage_valid   ||new_ind->sim_rej_info_valid                      || 
               new_ind->lte_ims_voice_avail_valid  || new_ind->lte_voice_status_valid                 ||
               new_ind->gsm_rac_valid              || new_ind->srv_reg_restriction_valid              || 
               new_ind->lte_reg_domain_valid       || new_ind->gsm_reg_domain_valid                   || 
               new_ind->lte_embms_coverage_trace_id_valid      ||new_ind->embms_coverage_status_valid ||
               new_ind->edrx_supported_valid       || new_ind->nas_supp_ciot_optimizations_valid      ||
               new_ind->nas_camped_ciot_lte_op_mode_valid      || new_ind->cp_sms_service_status_valid)
          #else
          if ( 
               #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)
               new_ind->cdma_srv_status_info_valid || 
               new_ind->cdma_sys_info_valid        ||
               new_ind->cdma_sys_info2_valid       ||
               new_ind->cdma_reg_zone_valid        ||
               new_ind->cdma_mcc_resolved_via_sid_lookup_valid ||
               #endif
               #if defined(FEATURE_HDR)
               new_ind->hdr_srv_status_info_valid  ||
               new_ind->hdr_sys_info_valid         ||
               new_ind->hdr_sys_info2_valid        ||
               #endif
               new_ind->gsm_srv_status_info_valid  ||
               #if defined(FEATURE_WCDMA)
               new_ind->wcdma_srv_status_info_valid||
               new_ind->wcdma_sys_info_valid       ||
               new_ind->wcdma_sys_info3_valid      ||
               new_ind->wcdma_cipher_domain_valid  ||
               new_ind->wcdma_eutra_status_valid   ||
               new_ind->wcdma_rac_valid            ||
               new_ind->wcdma_reg_domain_valid     ||
               new_ind->wcdma_csg_info_valid       ||
               #endif
               #if defined(FEATURE_TDSCDMA)
               new_ind->tdscdma_srv_status_info_valid||
               new_ind->tdscdma_sys_info_valid     ||
               new_ind->tdscdma_reg_domain_valid   ||
               #endif
               new_ind->lte_srv_status_info_valid  ||
               new_ind->gsm_sys_info_valid         ||
               new_ind->lte_sys_info_valid         ||
               new_ind->gsm_sys_info2_valid        ||
               new_ind->lte_sys_info2_valid        || new_ind->gsm_sys_info3_valid                    ||
               new_ind->voice_support_on_lte_valid||
               new_ind->gsm_cipher_domain_valid    ||
               new_ind->sys_info_no_change_valid   || new_ind->lte_embms_coverage_valid               ||
               new_ind->sim_rej_info_valid         || 
               new_ind->lte_ims_voice_avail_valid  || new_ind->lte_voice_status_valid                 ||
               new_ind->gsm_rac_valid              ||
               new_ind->srv_reg_restriction_valid  ||
               new_ind->lte_reg_domain_valid       || 
               new_ind->gsm_reg_domain_valid       || new_ind->lte_embms_coverage_trace_id_valid      ||
               new_ind->embms_coverage_status_valid            ||
               new_ind->edrx_supported_valid       || new_ind->nas_supp_ciot_optimizations_valid      ||
               new_ind->nas_camped_ciot_lte_op_mode_valid || new_ind->cp_sms_service_status_valid)
          #endif
        {
          if( !cl_sp->report_status.limit_sys_info_reporting_mask ||
                qmi_nas_check_sys_info_chg_against_rpt_limits( new_ind, old_ind, cl_sp->report_status.limit_sys_info_reporting_mask) )
          {
              send_indication = TRUE;
            }
          }
          else
          {
            QM_MSG_HIGH_1("qmi_nas_gen_sys_info_ind() information changed but nothing to send %p", cl_sp->clnt);
          }
        }

        if ( send_indication )
        {
          indication = NULL;                                                                         // Important!  When multiple encode calls may be made.
          if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_SYS_INFO_IND_MSG_V01, // message_id = 0x004E = ( (qmi_mmode_qcsi_transaction_type *) cmd_buf_p )->cmd_type,
                                             (void *) new_ind,
                                             (uint32_t) sizeof( nas_sys_info_ind_msg_v01 ),
                                             &indication ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_SYS_INFO_IND, indication );
      }
      else
      {
            QM_MSG_HIGH_1("qmi_nas_gen_sys_info_ind() idl_message_encode failed, no indication sent %p.", cl_sp->clnt);
          }
      }
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
    qmi_nasi_global.rcvd_ss_info = TRUE;
  }

    if ( p_ss_info->sim_state != SYS_SIM_STATE_NOT_AVAILABLE )
    {
    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
      if ( p_ss_info->sys_mode == SYS_SYS_MODE_GSM ||
           #ifdef FEATURE_WCDMA
           p_ss_info->sys_mode == SYS_SYS_MODE_WCDMA ||
           #endif
           p_ss_info->sys_mode == SYS_SYS_MODE_LTE
           #ifdef FEATURE_TDSCDMA
           || p_ss_info->sys_mode == SYS_SYS_MODE_TDS
           #endif
           )
    #else
       if ( p_ss_info->sys_mode == SYS_SYS_MODE_LTE )
    #endif
  {
        qmi_nasi_global.sim_state_before_not_avail[asubs_id] = p_ss_info->sim_state;
  }
  }
    }
  else
  {
    qmi_voice_mem_error();
  } // endif (both mallocs OK)

  if ( new_ind != NULL ) { modem_mem_free( (void *) new_ind, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( old_ind != NULL ) { modem_mem_free( (void *) old_ind, MODEM_MEM_CLIENT_QMI_MMODE ); }
}


/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_SYS_INFO_IND()

  DESCRIPTION
    <QMI NAS internal use only>
    Helper function to generate qmi_nas_sys_info_type message from a given CM SS and PH info.
    To be used in QMI_NAS_SYS_INFO_IND.

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    cm_ph_info_s_type    CM PH info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_sys_info_ind(
    cm_mm_ss_info_s_type *p_ss_info,
    qmi_cm_ph_info_s_type *p_ph_info,
    nas_sys_info_ind_msg_v01 * ind_msg
  )
{
  memset( ind_msg, 0x00, sizeof(nas_sys_info_ind_msg_v01) );
  
  /////////////////////////////////////////////////////////
  // CDMA
  /////////////////////////////////////////////////////////
  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
  if ( TARGET_SUPPORTS_CDMA && asubs_id == SYS_MODEM_AS_ID_1 )
  {
  
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks>1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_CDMA)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    // TLV 0x10

    if( stack_index != STACK_INDEX_MAX )
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->cdma_srv_status_info.srv_status                                   = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, STACK_INDEX_0, SYS_SYS_MODE_CDMA );
#else
       ind_msg->cdma_srv_status_info.srv_status                                   = (nas_service_status_enum_type_v01)p_ss_info->srv_status;
#endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    else
    {
      ind_msg->cdma_srv_status_info.srv_status                                  = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }


    ind_msg->cdma_srv_status_info.is_pref_data_path                            = ( p_ss_info->stack_info[STACK_INDEX_0].cur_idle_digital_mode == SYS_SYS_MODE_CDMA );
    ind_msg->cdma_srv_status_info_valid                                        = TRUE;

    // TLV 0x15
    if ( ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      ind_msg->cdma_sys_info_valid                                             = TRUE;

      ind_msg->cdma_sys_info.common_sys_info.srv_domain_valid                  = TRUE;
      ind_msg->cdma_sys_info.common_sys_info.srv_domain                        = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_domain;

      ind_msg->cdma_sys_info.common_sys_info.srv_capability_valid              = TRUE;
      ind_msg->cdma_sys_info.common_sys_info.srv_capability                    = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_capability;

      if ( p_ss_info->stack_info[STACK_INDEX_0].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      ind_msg->cdma_sys_info.common_sys_info.roam_status_valid                 = TRUE;
        ind_msg->cdma_sys_info.common_sys_info.roam_status                     = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].roam_status;
      }

      ind_msg->cdma_sys_info.common_sys_info.is_sys_forbidden_valid            = TRUE;
      ind_msg->cdma_sys_info.common_sys_info.is_sys_forbidden                  = p_ss_info->stack_info[STACK_INDEX_0].is_sys_forbidden;

      ind_msg->cdma_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match_valid     = TRUE;
      ind_msg->cdma_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match           = p_ss_info->stack_info[STACK_INDEX_0].is_sys_prl_match ;

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use != CM_SS_P_REV_IN_USE_NONE )
      {
        ind_msg->cdma_sys_info.cdma_specific_sys_info.p_rev_in_use_valid       = TRUE;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.p_rev_in_use             = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use;
      }

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.bs_p_rev != CM_SS_BS_P_REV_NONE )
      {
        ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_p_rev_valid           = TRUE;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_p_rev                 = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.bs_p_rev;
      }

      ind_msg->cdma_sys_info.cdma_specific_sys_info.ccs_supported_valid        = TRUE;
      ind_msg->cdma_sys_info.cdma_specific_sys_info.ccs_supported              = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.ccs_supported;

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        ind_msg->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id_valid        = TRUE;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id.sid          = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.sid;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id.nid          = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.nid;
      }

      ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_info_valid              = TRUE;
      ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_info.base_id            = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_id;
      ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_info.base_lat           = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_lat;
      ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_info.base_long          = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_long;

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.packet_zone != 0x00)
      {
        ind_msg->cdma_sys_info.cdma_specific_sys_info.packet_zone_valid        = TRUE;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.packet_zone              = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.packet_zone;
      }

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc == 0 && p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12 == 0 )
        {
          ind_msg->cdma_sys_info.cdma_specific_sys_info.network_id_valid       = FALSE;
        }
        else
        {
          ind_msg->cdma_sys_info.cdma_specific_sys_info.network_id_valid       = TRUE;
          convert_cdma_mcc_2_ascii_mcc( (char *) ind_msg->cdma_sys_info.cdma_specific_sys_info.network_id.mcc, p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc );        // TODO apply decoding
          convert_cdma_mnc_2_ascii_mnc( (char *) ind_msg->cdma_sys_info.cdma_specific_sys_info.network_id.mnc, p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12 ); // TODO apply decoding
        }

        if(p_ss_info->current_mcc < 1000)
        {
          ind_msg->cdma_mcc_resolved_via_sid_lookup                            = p_ss_info->current_mcc;
          ind_msg->cdma_mcc_resolved_via_sid_lookup_valid                      = TRUE;
        }
      }
    }

    // TLV 0x1A additional CDMA sys info
    if ( ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      ind_msg->cdma_sys_info2_valid                                            = TRUE;

      ind_msg->cdma_sys_info2.geo_sys_idx                                      = p_ss_info->stack_info[STACK_INDEX_0].geo_sys_idx;
      ind_msg->cdma_sys_info2.reg_prd                                          = p_ss_info->stack_info[STACK_INDEX_0].rat_mode_info.cdma_mode_info.cdma_reg_prd;
    }

    // TLV 0x2C CDMA Reg Zone
    if ( ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.reg_zone != CM_SS_REG_ZONE_NONE )
      {
        ind_msg->cdma_reg_zone_valid                                           = TRUE;
        ind_msg->cdma_reg_zone                                                 = ( NAS_004D_CDMA_REG_ZONE_MASK & p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.reg_zone );
      }
    }

    if ( ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA &&
           ( p_ss_info->stack_info[STACK_INDEX_0].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[STACK_INDEX_0].srv_domain  == SYS_SRV_DOMAIN_CS_PS))         
      {
        ind_msg->cdma_voice_status_valid = TRUE;
        ind_msg->cdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->cdma_sms_status_valid = TRUE;
        ind_msg->cdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  } // end CDMA
  #endif
  /////////////////////////////////////////////////////////
  // HDR
  /////////////////////////////////////////////////////////
  #if defined(FEATURE_HDR)
  if( TARGET_SUPPORTS_HDR && asubs_id == SYS_MODEM_AS_ID_1)
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_HDR)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks>1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x11
    if( stack_index != STACK_INDEX_MAX )
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->hdr_srv_status_info.srv_status                                    = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_HDR );
#else
      ind_msg->hdr_srv_status_info.srv_status                                  = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
      #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    else
    {
      ind_msg->hdr_srv_status_info.srv_status                                  = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->hdr_srv_status_info.is_pref_data_path                             = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_HDR );
    }

    ind_msg->hdr_srv_status_info_valid                                         = TRUE;

    //TLV 0x16
    if ( ind_msg->hdr_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->hdr_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      ind_msg->hdr_sys_info.common_sys_info.srv_domain_valid                   = TRUE;
      ind_msg->hdr_sys_info.common_sys_info.srv_domain                         = SYS_SRV_DOMAIN_PS_ONLY_V01;

      ind_msg->hdr_sys_info.common_sys_info.srv_capability_valid               = TRUE;
      ind_msg->hdr_sys_info.common_sys_info.srv_capability                     = SYS_SRV_DOMAIN_PS_ONLY_V01;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      ind_msg->hdr_sys_info.common_sys_info.roam_status_valid                  = TRUE;
        ind_msg->hdr_sys_info.common_sys_info.roam_status                      = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      ind_msg->hdr_sys_info.common_sys_info.is_sys_forbidden_valid             = TRUE;
      ind_msg->hdr_sys_info.common_sys_info.is_sys_forbidden                   = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      ind_msg->hdr_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match_valid      = TRUE;
      ind_msg->hdr_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match            = p_ss_info->stack_info[stack_index].is_sys_prl_match ;

      if( p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_personality != SYS_PERSONALITY_NONE )
      {
        ind_msg->hdr_sys_info.hdr_specific_sys_info.hdr_personality_valid      = TRUE;
        ind_msg->hdr_sys_info.hdr_specific_sys_info.hdr_personality            = (nas_hdr_personality_enum_type_v01)p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_personality;
      }

      if( p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_active_prot != SYS_ACTIVE_PROT_NONE )
      {
        ind_msg->hdr_sys_info.hdr_specific_sys_info.hdr_active_prot_valid      = TRUE;
        ind_msg->hdr_sys_info.hdr_specific_sys_info.hdr_active_prot            = (nas_hdr_active_prot_enum_type_v01)p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_active_prot;
      }

      if ( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_IS856 )
        {
          ind_msg->hdr_sys_info.hdr_specific_sys_info.is856_sys_id_valid       = TRUE;
          memscpy(&ind_msg->hdr_sys_info.hdr_specific_sys_info.is856_sys_id, 
                  NAS_IS_856_MAX_LEN_V01,
                p_ss_info->stack_info[stack_index].sys_id.id.is856, NAS_IS_856_MAX_LEN_V01 );

        }

      ind_msg->hdr_sys_info_valid                                              = TRUE;

    // TLV 0x1B additional HDR sys info
      ind_msg->hdr_sys_info2_valid                                             = TRUE;
      ind_msg->hdr_sys_info2.geo_sys_idx                                       = p_ss_info->stack_info[stack_index].geo_sys_idx;

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS ) 
      {
        ind_msg->hdr_voice_status_valid = TRUE;
        ind_msg->hdr_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->hdr_sms_status_valid = TRUE;
        ind_msg->hdr_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

      ind_msg->hdr_subnet_mask_len_valid = TRUE;
      ind_msg->hdr_subnet_mask_len = p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.subnet_mask_len;
    }
  } // end HDR
  #endif

  /////////////////////////////////////////////////////////
  // GSM
  /////////////////////////////////////////////////////////
  #if defined(FEATURE_GSM) 
  if( TARGET_SUPPORTS_GSM )
  {
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM)
    {
      stack_index = STACK_INDEX_0;
    }
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM)
    {
      stack_index = STACK_INDEX_1;
    }
    #endif
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x12
    if( stack_index != STACK_INDEX_MAX )
    #endif
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->gsm_srv_status_info.srv_status                      = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, SYS_SYS_MODE_GSM );
#else
    ind_msg->gsm_srv_status_info.srv_status                      = (nas_service_status_enum_type_v01)p_ss_info->srv_status;
#endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else
    {
      ind_msg->gsm_srv_status_info.srv_status                      = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
    if( stack_index != STACK_INDEX_MAX )
    #endif
    {
      ind_msg->gsm_srv_status_info.true_srv_status                 = (nas_true_service_status_enum_type_v01)p_ss_info->true_srv_status;
      ind_msg->gsm_srv_status_info.is_pref_data_path               = ( p_ss_info->cur_idle_digital_mode == SYS_SYS_MODE_GSM );
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else
    {
      ind_msg->gsm_srv_status_info.true_srv_status                 = SYS_SRV_STATUS_NO_SRV_V01;
    }
    #endif
    ind_msg->gsm_srv_status_info_valid                           = TRUE;

    //TLV 0x17
    if ( ind_msg->gsm_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->gsm_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      ind_msg->gsm_sys_info.common_sys_info.srv_domain_valid       = TRUE;
      ind_msg->gsm_sys_info.common_sys_info.srv_domain             = (nas_service_domain_enum_type_v01)p_ss_info->srv_domain;

      ind_msg->gsm_sys_info.common_sys_info.srv_capability_valid   = TRUE;
      ind_msg->gsm_sys_info.common_sys_info.srv_capability         = (nas_service_domain_enum_type_v01)p_ss_info->srv_capability;

      if ( p_ss_info->roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      ind_msg->gsm_sys_info.common_sys_info.roam_status_valid      = TRUE;
        ind_msg->gsm_sys_info.common_sys_info.roam_status            =  (nas_roam_status_enum_type_v01)p_ss_info->roam_status;
      }

      ind_msg->gsm_sys_info.common_sys_info.is_sys_forbidden_valid = TRUE;
      ind_msg->gsm_sys_info.common_sys_info.is_sys_forbidden       =  p_ss_info->plmn_forbidden;

      ind_msg->gsm_sys_info.threegpp_specific_sys_info.lac         = p_ss_info->sys_id.id.plmn_lac.lac;

      if ( ind_msg->gsm_sys_info.threegpp_specific_sys_info.lac != QMI_NAS_INVALID_LAC )
      {
        ind_msg->gsm_sys_info.threegpp_specific_sys_info.lac_valid = TRUE;
      }

      ind_msg->gsm_sys_info.threegpp_specific_sys_info.cell_id_valid    = TRUE;
      ind_msg->gsm_sys_info.threegpp_specific_sys_info.cell_id          = p_ss_info->cell_info.cell_id;

      if( p_ss_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->sys_id.id.plmn ))
      {
        ind_msg->gsm_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->gsm_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->gsm_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->sys_id.id.plmn );
      }

      if(p_ss_info->reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          ind_msg->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        ind_msg->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->reg_reject_info.reject_srv_domain;
        ind_msg->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->reg_reject_info.reject_cause;
      }

      ind_msg->gsm_sys_info.gsm_specific_sys_info.egprs_supp_valid = TRUE;
      ind_msg->gsm_sys_info.gsm_specific_sys_info.egprs_supp       = p_ss_info->cell_srv_ind.egprs_supp;

      ind_msg->gsm_sys_info.gsm_specific_sys_info.dtm_supp_valid   = TRUE;
      ind_msg->gsm_sys_info.gsm_specific_sys_info.dtm_supp         = p_ss_info->cell_srv_ind.dtm_supp;

      ind_msg->gsm_sys_info_valid                                  = TRUE;

     #if !defined(FEATURE_MMODE_QMI_GPRS_LTE)
    // TLV 0x1C additional GSM sys info
      ind_msg->gsm_sys_info2_valid                                 = TRUE;
      ind_msg->gsm_sys_info2.geo_sys_idx                         = p_ss_info->geo_sys_idx; // currently there is no gw_geo_sys_idx;
      ind_msg->gsm_sys_info2.cell_broadcast_cap                = (uint32) p_ss_info->cell_bc_info.cell_bc_capability;

    // TLV 0x1F GSM Cell Access info
      ind_msg->gsm_sys_info3_valid                                 = TRUE;
      if ( p_ss_info->cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        ind_msg->gsm_sys_info3.cs_bar_status                     = (uint32) p_ss_info->cell_access_info.cs_bar_status;
        }
        else
        {
          ind_msg->gsm_sys_info3.cs_bar_status                     = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
      
      if ( p_ss_info->cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        ind_msg->gsm_sys_info3.ps_bar_status                     = (uint32) p_ss_info->cell_access_info.ps_bar_status;
        }
        else
        {
          ind_msg->gsm_sys_info3.ps_bar_status                     = NAS_CELL_ACCESS_UNKNOWN_V01;
      }
      #endif

    // TLV 0x22 GSM Cipher Domain info
      ind_msg->gsm_cipher_domain_valid                             = TRUE;
      ind_msg->gsm_cipher_domain                                   = (nas_service_domain_enum_type_v01)p_ss_info->cipher_domain;

    // TLV 0x2D GSM RAC
      if( p_ss_info->rac_or_mme_code != 0xFF )
        {
          ind_msg->gsm_rac_valid                                     = TRUE;
        ind_msg->gsm_rac                                           = p_ss_info->rac_or_mme_code;
    }

    // TLV 0x34 GSM Possible Registration Domain
      if( p_ss_info->available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        ind_msg->gsm_reg_domain_valid                              = TRUE;
        ind_msg->gsm_reg_domain                                    = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->available_plmn_type );
    }

      if ( p_ss_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        ind_msg->gsm_voice_status_valid = TRUE;
        ind_msg->gsm_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->gsm_sms_status_valid = TRUE;
        ind_msg->gsm_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  }
  #endif

#if defined(FEATURE_WCDMA)
  /////////////////////////////////////////////////////////
  // WCDMA
  /////////////////////////////////////////////////////////
  if( TARGET_SUPPORTS_WCDMA )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA)
    {
      stack_index = STACK_INDEX_0;
    }
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_WCDMA)
    {
      stack_index = STACK_INDEX_1;
    }
    #endif
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
  
    //TLV 0x13
    
    if( stack_index != STACK_INDEX_MAX )
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
      ind_msg->wcdma_srv_status_info.srv_status                      = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_WCDMA );
#else
      ind_msg->wcdma_srv_status_info.srv_status                      = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
      #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    else
    {
      ind_msg->wcdma_srv_status_info.srv_status                      = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->wcdma_srv_status_info.true_srv_status                 = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      ind_msg->wcdma_srv_status_info.is_pref_data_path               = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_WCDMA );
    }
    else
    {
      ind_msg->wcdma_srv_status_info.true_srv_status                 = SYS_SRV_STATUS_NO_SRV_V01;
    }
      ind_msg->wcdma_srv_status_info_valid                           = TRUE;

    //TLV 0x18
    if ( ind_msg->wcdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01 &&
         ind_msg->wcdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX)
    {
      ind_msg->wcdma_sys_info.common_sys_info.srv_domain_valid       = TRUE;
      ind_msg->wcdma_sys_info.common_sys_info.srv_domain             = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;

      ind_msg->wcdma_sys_info.common_sys_info.srv_capability_valid   = TRUE;
      ind_msg->wcdma_sys_info.common_sys_info.srv_capability         = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      ind_msg->wcdma_sys_info.common_sys_info.roam_status_valid      = TRUE;
        ind_msg->wcdma_sys_info.common_sys_info.roam_status            = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      ind_msg->wcdma_sys_info.common_sys_info.is_sys_forbidden_valid = TRUE;
      ind_msg->wcdma_sys_info.common_sys_info.is_sys_forbidden       = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      ind_msg->wcdma_sys_info.threegpp_specific_sys_info.lac         = p_ss_info->stack_info[stack_index].sys_id.id.plmn_lac.lac;
      if ( ind_msg->wcdma_sys_info.threegpp_specific_sys_info.lac != QMI_NAS_INVALID_LAC )
      {
        ind_msg->wcdma_sys_info.threegpp_specific_sys_info.lac_valid = TRUE;
      }

      ind_msg->wcdma_sys_info.threegpp_specific_sys_info.cell_id_valid     = TRUE;
      ind_msg->wcdma_sys_info.threegpp_specific_sys_info.cell_id           = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        ind_msg->wcdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->wcdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->wcdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }

      ind_msg->wcdma_sys_info.wcdma_specific_sys_info.hs_call_status_valid     = TRUE;
      ind_msg->wcdma_sys_info.wcdma_specific_sys_info.hs_call_status           = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_call_status;

      ind_msg->wcdma_sys_info.wcdma_specific_sys_info.hs_ind_valid             = TRUE;
      ind_msg->wcdma_sys_info.wcdma_specific_sys_info.hs_ind                   = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_ind;

      if( p_ss_info->stack_info[stack_index].cell_info.psc != 0xFFFF )
        {
          ind_msg->wcdma_sys_info.wcdma_specific_sys_info.psc_valid            = TRUE;
        ind_msg->wcdma_sys_info.wcdma_specific_sys_info.psc                  = p_ss_info->stack_info[stack_index].cell_info.psc;
      }

      if( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          ind_msg->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        ind_msg->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        ind_msg->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      ind_msg->wcdma_sys_info_valid                 = TRUE;

    // TLV 0x1D additional UMTS sys info
      ind_msg->wcdma_sys_info2_valid                = TRUE;
      ind_msg->wcdma_sys_info2.geo_sys_idx        = p_ss_info->stack_info[stack_index].geo_sys_idx;
      ind_msg->wcdma_sys_info2.cell_broadcast_cap = (uint32) p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;

      ind_msg->wcdma_sys_info3_valid                = TRUE;
      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        ind_msg->wcdma_sys_info3.cs_bar_status    = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
      }
      else
      {
          ind_msg->wcdma_sys_info3.cs_bar_status    = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
      
      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        ind_msg->wcdma_sys_info3.ps_bar_status    = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
        }
        else
        {
          ind_msg->wcdma_sys_info3.ps_bar_status    = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

      ind_msg->wcdma_cipher_domain_valid            = TRUE;
      ind_msg->wcdma_cipher_domain                  = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

      ind_msg->wcdma_eutra_status_valid             = TRUE;
      ind_msg->wcdma_eutra_status                   = (nas_eutra_cell_status_enum_type_v01)qmi_nas_eutra_status_cm_2_qmi( p_ss_info->eutra_detect_status );

      if( p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.rac_or_mme_code != 0xFF )
        {
          ind_msg->wcdma_rac_valid                    = TRUE;
        ind_msg->wcdma_rac                          = p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.rac_or_mme_code;
    }

      if( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        ind_msg->wcdma_reg_domain_valid             = TRUE;
        ind_msg->wcdma_reg_domain                   = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type );
    }

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        ind_msg->wcdma_voice_status_valid = TRUE;
        ind_msg->wcdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->wcdma_sms_status_valid = TRUE;
        ind_msg->wcdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  if ( qm_efs_csg_supported() )
  {
        if( p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID )
      {
        ind_msg->wcdma_csg_info_valid = TRUE;
          ind_msg->wcdma_csg_info.id = p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id;
          ind_msg->wcdma_csg_info.name_len = MIN(p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length, NAS_CSG_NAME_MAX_V01);
        memscpy(ind_msg->wcdma_csg_info.name, ind_msg->wcdma_csg_info.name_len,
                  p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.name, ind_msg->wcdma_csg_info.name_len );
          QM_MSG_HIGH_2("CM SS Evt csg_id %d, name_len %d", p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id, p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length);
    }
      }
#endif
#endif
    }
  } // end WCDMA
  #endif
  /////////////////////////////////////////////////////////
  // LTE
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_LTE )
  {
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    if(p_ss_info->is_operational && p_ss_info->sys_mode == SYS_SYS_MODE_LTE)
    {
      stack_index = STACK_INDEX_0;
    }
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && ((defined(FEATURE_CDMA) || defined(FEATURE_HDR)))
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE)
  {
      stack_index = STACK_INDEX_1;
    }
    #endif
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x14
    
    if( stack_index != STACK_INDEX_MAX )
    #endif
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->lte_srv_status_info.srv_status          = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, SYS_SYS_MODE_LTE );
#else // FEATURE_MMODE_REPORT_POWERSAVE
      ind_msg->lte_srv_status_info.srv_status        = (nas_service_status_enum_type_v01)p_ss_info->srv_status;
      #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else
    {
      ind_msg->lte_srv_status_info.srv_status        = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    if(stack_index != STACK_INDEX_MAX)
    #endif
    {
      ind_msg->lte_srv_status_info.true_srv_status   = (nas_true_service_status_enum_type_v01)p_ss_info->true_srv_status;
      #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      ind_msg->lte_srv_status_info.is_pref_data_path = ( p_ss_info->cur_idle_digital_mode == SYS_SYS_MODE_LTE );
      #else
       ind_msg->lte_srv_status_info.is_pref_data_path = TRUE;
      #endif
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else
    {
      ind_msg->lte_srv_status_info.true_srv_status   = SYS_SRV_STATUS_NO_SRV_V01;
    }
    #endif
      ind_msg->lte_srv_status_info_valid             = TRUE;

    //TLV 0x19
    if ( ind_msg->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      ind_msg->lte_sys_info.common_sys_info.srv_domain_valid             = TRUE;
      ind_msg->lte_sys_info.common_sys_info.srv_capability_valid         = TRUE;
      ind_msg->lte_sys_info.common_sys_info.is_sys_forbidden_valid       = TRUE;

      ind_msg->lte_sys_info.common_sys_info.srv_domain                 = (nas_service_domain_enum_type_v01)p_ss_info->srv_domain;
      ind_msg->lte_sys_info.common_sys_info.srv_capability             = (nas_service_domain_enum_type_v01)p_ss_info->srv_capability;
      ind_msg->lte_sys_info.common_sys_info.is_sys_forbidden           = p_ss_info->plmn_forbidden;

      if ( p_ss_info->roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        ind_msg->lte_sys_info.common_sys_info.roam_status_valid            = TRUE;
        ind_msg->lte_sys_info.common_sys_info.roam_status                = (nas_roam_status_enum_type_v01)p_ss_info->roam_status;
      }

      ind_msg->lte_sys_info.threegpp_specific_sys_info.lac_valid         = FALSE;
      ind_msg->lte_sys_info.threegpp_specific_sys_info.lac               = QMI_NAS_INVALID_LAC;

      ind_msg->lte_sys_info.threegpp_specific_sys_info.cell_id_valid = TRUE;
      ind_msg->lte_sys_info.threegpp_specific_sys_info.cell_id       = p_ss_info->cell_info.cell_id;

      if( p_ss_info->sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->sys_id.id.plmn ))
      {
        ind_msg->lte_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->lte_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->lte_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->sys_id.id.plmn);
      }

      if( p_ss_info->reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          ind_msg->lte_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        ind_msg->lte_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->reg_reject_info.reject_srv_domain;
        ind_msg->lte_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->reg_reject_info.reject_cause;
      }

      // LTE specific params
      ind_msg->lte_sys_info.lte_specific_sys_info.tac       =      p_ss_info->tac;
      if ( IS_TAC_VALID( ind_msg->lte_sys_info.lte_specific_sys_info.tac ) )
      {
      ind_msg->lte_sys_info.lte_specific_sys_info.tac_valid = TRUE;
      }
      else
      {
        ind_msg->lte_sys_info.lte_specific_sys_info.tac = 0;
      }

      ind_msg->lte_sys_info_valid                       = TRUE;

     #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    // TLV 0x1E additional LTE sys info
      ind_msg->lte_sys_info2_valid                      = TRUE;

      ind_msg->lte_sys_info2.geo_sys_idx              = p_ss_info->stack_info[stack_index].geo_sys_idx;
      #endif

    // TLV 0x21 voice support on LTE
      if ( p_ss_info->srv_domain ==  SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS)
    {
      ind_msg->voice_support_on_lte_valid              = TRUE;
      //ind_msg->voice_support_on_lte                    = p_ss_info->voice_support_on_lte;
    }

#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
#ifdef FEATURE_LTE_EMBMS
      // TLV 0x27 voice support on LTE (now deprecated)
      ind_msg->lte_embms_coverage_valid                = TRUE;
      if(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status != SYS_EMBMS_COVERAGE_STATUS_AVAILABLE)
      {
        ind_msg->lte_embms_coverage                                           = FALSE;
      }
      else
      {
        ind_msg->lte_embms_coverage                                           = TRUE;
      }

      // TLV 0x47 LTE eMBMS Coverage Info Extended
      ind_msg->embms_coverage_status_valid = TRUE;
      switch(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status)
      {
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_AVAILABLE:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_AVAILABLE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_E911:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_EMERGENCY_V01; break;
      default:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_UNKNOWN_V01; break;
      }

      // TLV 0x35 eMBMS coverage information // trace id
      ind_msg->lte_embms_coverage_trace_id_valid       = TRUE;
      ind_msg->lte_embms_coverage_trace_id             = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.trace_id;
#endif
#endif

      // TLV 0x2A voice support on LTE
      if ( p_ss_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS)
      {
        ind_msg->lte_ims_voice_avail_valid             = TRUE;
        ind_msg->lte_ims_voice_avail                   = p_ss_info->lte_ims_voice_avail;
      }

      ind_msg->lte_sms_status_valid = FALSE;
      ind_msg->lte_voice_status_valid = FALSE;

      /* In CT there is only one possible domain that is IMS. To determine supprot of voice, client should directly list to
              QMI-IMS indication about IMS reg status for voice & SMS*/

      #if 0
      // TLV 0x2B voice support on LTE
      if ( p_ss_info->srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        ind_msg->lte_voice_status_valid                = TRUE;
        ind_msg->lte_voice_status                      = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_lte_voice_status_cm_to_qmi( p_ss_info );

        
        ind_msg->lte_sms_status_valid = FALSE;
        ind_msg->lte_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
        
      }
      #endif

      // TLV 0x3A LTE Emergency Bearer Support
      // Assumption: CM will be passing this value for LTE on MAIN stack as well as GW_HYB stack
      ind_msg->lte_is_eb_supported_valid = TRUE;
      ind_msg->lte_is_eb_supported = qmi_nas_map_lte_eb_status_cm_to_qmi(p_ss_info->lte_ims_emerg_avail);

      // TLV 0x3F LTE Emergency Access Barred
      /* CM MASK checking is not required.
         Checking mask may cause issue( i.e. not sending this TLV) in case of if either PLMN, 
         TAC (in LTE) or LAC (other sys_modes) is out of sync in NAS when RRC reports EAB status.
      */
        ind_msg->emergency_access_barred_valid = TRUE;
      ind_msg->emergency_access_barred = qmi_nas_map_lte_eab_status_cm_to_qmi(p_ss_info->cell_info.emerg_access_status);

    // TLV 0x32 LTE Possible Registration Domain
     if( p_ss_info->available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        ind_msg->lte_reg_domain_valid                  = TRUE;
       ind_msg->lte_reg_domain                        = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->available_plmn_type );
    }

      ind_msg->lte_cell_status_valid                   = TRUE;

     if ( p_ss_info->cell_info.lte_cell_access_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
          p_ss_info->cell_info.lte_cell_access_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
       ind_msg->lte_cell_status                     = (nas_cell_access_status_e_type_v01) p_ss_info->cell_info.lte_cell_access_status;
        }
        else
        {
          ind_msg->lte_cell_status                     = NAS_CELL_ACCESS_UNKNOWN_V01;
        }

    #ifdef FEATURE_FEMTO_CSG
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    if ( qm_efs_csg_supported() )
    {
      if ( ind_msg->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
           ind_msg->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
      {
           if( p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID )
        {
          ind_msg->lte_csg_info_valid = TRUE;
             ind_msg->lte_csg_info.id = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id;
             ind_msg->lte_csg_info.name_len = MIN(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length, NAS_CSG_NAME_MAX_V01);
          memscpy(ind_msg->lte_csg_info.name, ind_msg->lte_csg_info.name_len,
                            p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.name, ind_msg->lte_csg_info.name_len);
             QM_MSG_HIGH_2("CM SS Evt csg_id %d, name_len %d", p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id, p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length);
        }
      }
    }
    #endif
    #endif


     if (p_ss_info->srv_status == SYS_SRV_STATUS_SRV)
     {
       ind_msg->nas_supp_ciot_optimizations_valid = TRUE;
       
       ind_msg->nas_supp_ciot_optimizations.cp_ciot_supported
          = p_ss_info->neg_ciot_cap.cp_ciot_supported;
  
       ind_msg->nas_supp_ciot_optimizations.up_ciot_supported
         = p_ss_info->neg_ciot_cap.up_ciot_supported;
     }
  
     ind_msg->nas_camped_ciot_lte_op_mode_valid  = TRUE;
     ind_msg->nas_camped_ciot_lte_op_mode        =
          qmi_nas_map_camped_lte_mode_cm_to_qmi(p_ss_info->ciot_lte_mode);

     if(p_ss_info->cp_sms_service_status != SYS_CP_SMS_STATUS_NONE &&
        p_ss_info ->sys_mode == SYS_SYS_MODE_LTE &&
        p_ss_info ->ciot_lte_mode == SYS_SYS_MODE_LTE_NB1 &&
        p_ss_info->srv_status == SYS_SRV_STATUS_SRV
        )
     {
     ind_msg->cp_sms_service_status_valid = TRUE;
     ind_msg->cp_sms_service_status = qmi_nas_map_cp_sms_status_cm_to_qmi(p_ss_info->cp_sms_service_status);
     }
   }
  }// end LTE

  // TLV 0x24 PLMN no change
  // This TLV is not RAT specific
  if( (p_ss_info->changed_fields & CM_SS_EVT_NO_CHANGE_MASK) 
       #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && ((defined(FEATURE_CDMA) || defined(FEATURE_HDR)))
       ||  (p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_NO_CHANGE_MASK) 
       #endif
    )
  {
    ind_msg->sys_info_no_change_valid                  = TRUE;
    ind_msg->sys_info_no_change                        = TRUE;
  }

  //EDRX Notification if the current camped  cell supports
  if (p_ph_info->edrx_enabled)
  {
    ind_msg->edrx_supported_valid = TRUE;
    ind_msg->edrx_supported = p_ph_info->edrx_enabled;
    QM_MSG_MED("edrx enabled");
  }
  /////////////////////////////////////////////////////////
  // TDSCDMA
  /////////////////////////////////////////////////////////
  #if defined(FEATURE_TDSCDMA)
  if ( TARGET_SUPPORTS_TDS )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_TDS)
    {
      stack_index = STACK_INDEX_0;
    }
    #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_TDS)
    { 
      stack_index = STACK_INDEX_1;
    }
    #endif
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    
    //TLV 0x25
    if( stack_index != STACK_INDEX_MAX )
    {
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->tdscdma_srv_status_info.srv_status        = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_TDS );
#else
      ind_msg->tdscdma_srv_status_info.srv_status        = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
      #endif // FEATURE_MMODE_REPORT_POWERSAVE
    }
    else
    {
      ind_msg->tdscdma_srv_status_info.srv_status        = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }

    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->tdscdma_srv_status_info.true_srv_status   = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      ind_msg->tdscdma_srv_status_info.is_pref_data_path = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_TDS );
    }
    else
    {
      ind_msg->tdscdma_srv_status_info.true_srv_status   = SYS_SRV_STATUS_NO_SRV_V01;
    }

    ind_msg->tdscdma_srv_status_info_valid             = TRUE;

    //TLV 0x26
    if ( ind_msg->tdscdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->tdscdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01  &&
         stack_index != STACK_INDEX_MAX)
    {
      ind_msg->tdscdma_sys_info.common_sys_info.srv_domain_valid           = TRUE;
      ind_msg->tdscdma_sys_info.common_sys_info.srv_capability_valid       = TRUE;
      ind_msg->tdscdma_sys_info.common_sys_info.is_sys_forbidden_valid     = TRUE;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        ind_msg->tdscdma_sys_info.common_sys_info.roam_status                = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      ind_msg->tdscdma_sys_info.common_sys_info.roam_status_valid          = TRUE;
      }

      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.hs_call_status_valid = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.hs_ind_valid         = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cell_broadcast_cap_valid  = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status_valid  = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status_valid  = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cipher_domain_valid  = TRUE;
      ind_msg->tdscdma_sys_info_valid                                          = TRUE;

      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status      = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
      }
      else
      {
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status      = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status_valid  = TRUE;

      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status      = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
        }
        else
        {
          ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status      = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
      
      ind_msg->tdscdma_sys_info.common_sys_info.srv_domain                 = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;
      ind_msg->tdscdma_sys_info.common_sys_info.srv_capability             = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;
      ind_msg->tdscdma_sys_info.common_sys_info.is_sys_forbidden           = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      if ( p_ss_info->stack_info[stack_index].cell_info.lac_id != QMI_NAS_INVALID_LAC )
      {
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.lac_valid     = TRUE;
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.lac           = p_ss_info->stack_info[stack_index].cell_info.lac_id;
      }

      ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.cell_id_valid = TRUE;
      ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.cell_id       = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if ( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
      {
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      if ( p_ss_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn_avail )
      {
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn);
      }
      else if ( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.hs_call_status       = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_call_status;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.hs_ind               = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_ind;

      if ( p_ss_info->stack_info[stack_index].cell_info.psc != 0xFFFF )
  {
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cell_parameter_id_valid = TRUE;
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cell_parameter_id       = p_ss_info->stack_info[stack_index].cell_info.psc;
      }

      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cell_broadcast_cap        = (uint32) p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;

      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cipher_domain        = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

    // TLV 0x31 TDSCDMA Possible Registration Domain
      if( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        ind_msg->tdscdma_reg_domain_valid = TRUE;
        ind_msg->tdscdma_reg_domain       = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type );
      }

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        ind_msg->tdscdma_voice_status_valid = TRUE;
        ind_msg->tdscdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->tdscdma_sms_status_valid = TRUE;
        ind_msg->tdscdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  }//End TDS
  #endif

  // TLV 0x28 SIM reject information
  if ( TARGET_SUPPORTS_LTE 
        #ifndef FEATURE_MMODE_QMI_LTE_ONLY
        || TARGET_SUPPORTS_WCDMA || TARGET_SUPPORTS_GSM || TARGET_SUPPORTS_TDS 
       #endif
    )
  {
    ind_msg->sim_rej_info_valid      = TRUE;
    if ( p_ss_info->sim_state == SYS_SIM_STATE_NOT_AVAILABLE )
        {
      ind_msg->sim_rej_info      = (nas_sim_rej_info_enum_type_v01)qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_PRIMARY];
        }
        else
        {
      ind_msg->sim_rej_info      = (nas_sim_rej_info_enum_type_v01)p_ss_info->sim_state;
        }
    }

  // Camp Only Indication - Global, always returned

  ind_msg->srv_reg_restriction_valid = TRUE;

  if( p_ss_info->available_plmn_type == SYS_REG_DOMAIN_NOT_APPLICABLE )
  {
    ind_msg->srv_reg_restriction     = NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;
  }
  else
  {
    ind_msg->srv_reg_restriction     = NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
    }
  }

/*===========================================================================
  FUNCTION QMI_NAS_GET_SIG_INFO()

  DESCRIPTION
    Returns the current signal strength information for all available
    RATs

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_sig_info(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
  enum qm_subs_e     sub_id = QM_SUBS_MIN;

  nas_get_sig_info_resp_msg_v01 *rsp_msg = NULL;

  sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_1;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg = (nas_get_sig_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_sig_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    qmi_voice_mem_error();
  }
  else
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_sig_info_resp_msg_v01) );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
  
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif
    sub_id = qm_util_map_cm_asubs_to_qm_subs(asubs_id);
    errval = qm_meas_populate_get_sig_info_resp(rsp_msg, sub_id);
    }

  if ( (errval != QMI_ERR_NO_MEMORY_V01) && (cmd_buf_p != NULL) )
  {
  // update result TLV
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01);
    rsp_msg->resp.error  = errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_sig_info_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  rsp_msg = NULL;

  return response;
} /* qmi_nasi_get_sig_info */

#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES

/*===========================================================================
  FUNCTION QMI_NASI_CONFIG_SIG_INFO()

  DESCRIPTION
    To set thresholds for reporting sig info indication msg

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None
    (This message is DS/DS agnostic)

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_config_sig_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_type_v01                 errval         = QMI_ERR_NONE_V01;
  dsm_item_type                    * response = NULL;
  nas_config_sig_info_req_msg_v01  * req_msg;
  nas_config_sig_info_resp_msg_v01 * rsp_msg;
  qmi_nasi_client_state_type     *nasi_client_sp = (qmi_nasi_client_state_type *)cl_sp;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p,  cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  req_msg = (nas_config_sig_info_req_msg_v01  *) modem_mem_alloc( sizeof(nas_config_sig_info_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_config_sig_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_config_sig_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
    {
    memset( req_msg, 0x00, sizeof(nas_config_sig_info_req_msg_v01) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)   req_msg,
                                           (uint32_t) sizeof(nas_config_sig_info_req_msg_v01)
                                         );
      }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0050_req_check( req_msg );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    qm_nas_clnt_process_config_sig_info( nasi_client_sp, req_msg );
  } // End copy all thresholds

#ifdef FEATURE_LTE
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( req_msg->lte_sig_rpt_config_valid )
    {
      if ( ! cmapi_set_lte_signal_reporting_config( ( cmapi_lte_signal_reporting_rate_e )req_msg->lte_sig_rpt_config.rpt_rate,
                                                    ( cmapi_lte_signal_averaging_period_e )req_msg->lte_sig_rpt_config.avg_period ) )
      {
        QM_MSG_HIGH("cmapi_set_lte_signal_reporting_config failed");
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }
#endif // FEATURE_LTE

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !qmi_nasi_global.is_set_cm_ph_cmd_signal_strength_delta )
    {
      if (!cm_ph_cmd_signal_strength_delta_lte( qmi_nas_cmph_cmd_cb,
                                                (void *)cmd_buf_p,
                                                qmi_nasi_global.cm_clnt_id,
                                                NASI_MIN_SIG_INFO_DELTA, //rssi
                                                NASI_MIN_SIG_INFO_DELTA, //ecio
                                                NASI_MIN_SIG_INFO_DELTA, //io
                                                NASI_MIN_SIG_INFO_DELTA, //sinr
                                                NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //pathloss
                                                NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //cqi
                                                NASI_MIN_SIG_INFO_DELTA, //rsrp
                                                NASI_MIN_SIG_INFO_DELTA)) //rsrq
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
      else
      {
        qmi_nasi_global.is_pending_config_sig_info = TRUE;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.is_pending_config_sig_info )
  {
    response = (dsm_item_type*) QMI_SVC_RESPONSE_PENDING;
    QM_MSG_HIGH("qmi_nasi_config_sig_info() returning QMI_SVC_RESPONSE_PENDING");
    }
  else if ( rsp_msg == NULL )
    {
    qmi_voice_mem_error();
    }
  else if ( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_config_sig_info_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_config_sig_info_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_config_sig_info() */
#endif
#ifndef REMOVE_QMI_NAS_GET_ERR_RATE_V01
/*===========================================================================
  FUNCTION QMI_NAS_GET_ERR_RATE()

  DESCRIPTION
    Returns the error rate information for all available
    RATs

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_err_rate(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
  enum qm_subs_e     sub_id = QM_SUBS_MIN;

  sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_1;

  nas_get_err_rate_resp_msg_v01 * rsp_msg = NULL;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg = (nas_get_err_rate_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_err_rate_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    qmi_voice_mem_error();
  }
  else
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_err_rate_resp_msg_v01) );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif
    sub_id = qm_util_map_cm_asubs_to_qm_subs(asubs_id);
    errval = qm_meas_populate_get_err_rate_resp(rsp_msg, sub_id);

    }

  if ( errval != QMI_ERR_NO_MEMORY_V01 && (cmd_buf_p != NULL) )
    {
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01);
    rsp_msg->resp.error  = errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)   rsp_msg,
                                  (uint32_t) sizeof(nas_get_err_rate_resp_msg_v01),
                                  &response
                                );
      }      

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  rsp_msg = NULL;

  return response;
} /* qmi_nasi_get_err_rate */
#endif

#ifndef REMOVE_QMI_NAS_UPDATE_AKEY_EXT_V01
/*===========================================================================
  FUNCTION QMI_NASI_UPDATE_AKEY_EXT()

  DESCRIPTION
    This command updates AKEY. Prior to performing any operation on the AKEY
    the modem will verify the SPC.  Modem will run authentication on the
    presented AKEY before updating AKEY. Authentication failure will result
    in error in response. On successful operation, the message will update
    NV_A_KEY_I NV item.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_update_akey_ext
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type      *response = NULL;
  qmi_error_e_type   errval    = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  qmi_svc_spc_result_e_type check_spc_result;
  struct nas_005B_req_s     req_msg;
#endif

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    memset(&req_msg, 0, sizeof(req_msg));

    /*-------------------------------------------------------------------------
      Read the incoming message
      -------------------------------------------------------------------------*/

    errval = qmi_nas_005B_req_read(&req_msg, sdu_in);

    /*-------------------------------------------------------------------------
      If request is valid, run authentication using AKEY
      -------------------------------------------------------------------------*/
    if ( errval == QMI_ERR_NONE )
    {
      errval = qmi_nas_005B_req_check(&req_msg);
    }

    if( errval == QMI_ERR_NONE )
    {
      check_spc_result = qmi_svc_check_spc((uint8*)req_msg.t01.spc, TRUE);

      if (check_spc_result == QMI_SVC_SPC_FAIL)
      {
        errval = QMI_ERR_AUTHENTICATION_FAILED;
      }
      else if (check_spc_result == QMI_SVC_SPC_LOCKED)
      {
        errval = QMI_ERR_AUTHENTICATION_LOCK;
      }
      else if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
      {
        errval = QMI_ERR_INTERNAL;
      }
    }

    if ( errval == QMI_ERR_NONE )
    {
      if(auth_validate_a_key(req_msg.t01.akey))
      {
        if (!auth_send_update_a_key_cmd(req_msg.t01.akey, NAS_005B_REQ_AKEY_EXT_ASCII_MAX_SIZE,0))
        {
          QM_MSG_ERROR("AKEY write command could not be given to modem");
          errval = QMI_ERR_INTERNAL;
        }
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG;
      }
    }
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
#endif // defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_update_akey() */
#endif
#if 0
/*===========================================================================
  FUNCTION get_mode_pref()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    qmi_nas_sys_info_type message from a given CM SS and PH info. To be used
    in QMI_NAS_GET_SYS_INFO

  PARAMETERS
    cm_ph_info_s_type    CM PH info
    access_tech_s        ptr to return value

  RETURN VALUE
    boolean              TRUE / FALSE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean get_mode_pref( qmi_cm_ph_info_s_type *p_ph_info, struct access_tech_s *p )
{
  boolean ret_val = TRUE;

  switch ( p_ph_info->mode_pref )
  {
    case CM_MODE_PREF_DIGITAL_ONLY:              p->c=1; p->h=1; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_AUTOMATIC:                 p->c=1; p->h=1; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_CDMA_ONLY:                 p->c=1; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_HDR_ONLY:                  p->c=0; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_AMPS_ONLY:            p->c=1; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_GPS_ONLY:                  p->c=0; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_GSM_ONLY:                  p->c=0; p->h=0; p->g=1; p->w=0; p->l=0; break;
    case CM_MODE_PREF_WCDMA_ONLY:                p->c=0; p->h=0; p->g=0; p->w=1; p->l=0; break;
    case CM_MODE_PREF_ANY_BUT_HDR:               p->c=1; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_GSM_WCDMA_ONLY:            p->c=0; p->h=0; p->g=1; p->w=1; p->l=0; break;
    case CM_MODE_PREF_DIGITAL_LESS_HDR_ONLY:     p->c=1; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_CDMA_HDR_ONLY:             p->c=1; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_AMPS_HDR_ONLY:        p->c=1; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_WLAN_ONLY:                 p->c=0; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_WLAN:                 p->c=1; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_HDR_WLAN:                  p->c=0; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_HDR_WLAN:             p->c=1; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_GSM_WLAN:                  p->c=0; p->h=0; p->g=1; p->w=0; p->l=0; break;
    case CM_MODE_PREF_WCDMA_WLAN:                p->c=0; p->h=0; p->g=0; p->w=1; p->l=0; break;
    case CM_MODE_PREF_GW_WLAN:                   p->c=0; p->h=0; p->g=1; p->w=1; p->l=0; break;
    case CM_MODE_PREF_CDMA_AMPS_HDR_WLAN_ONLY:   p->c=1; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_AMPS_WLAN_ONLY:       p->c=1; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_ANY_BUT_HDR_WLAN:          p->c=1; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_LTE_ONLY:                  p->c=0; p->h=0; p->g=0; p->w=0; p->l=1; break;
    case CM_MODE_PREF_GWL:                       p->c=0; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_HDR_LTE_ONLY:              p->c=0; p->h=1; p->g=0; p->w=0; p->l=1; break;
    case CM_MODE_PREF_CDMA_HDR_LTE_ONLY:         p->c=1; p->h=1; p->g=0; p->w=0; p->l=1; break;
    case CM_MODE_PREF_CDMA_HDR_GW:               p->c=1; p->h=1; p->g=1; p->w=1; p->l=0; break;
    case CM_MODE_PREF_CDMA_GW:                   p->c=1; p->h=0; p->g=1; p->w=1; p->l=0; break;
    case CM_MODE_PREF_ANY_BUT_WLAN:              p->c=1; p->h=1; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_GWL_WLAN:                  p->c=0; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_CDMA_LTE_ONLY:             p->c=1; p->h=0; p->g=0; p->w=0; p->l=1; break;
    case CM_MODE_PREF_ANY_BUT_HDR_LTE:           p->c=1; p->h=0; p->g=1; p->w=1; p->l=0; break;
    // TODO: clarify case CM_MODE_PREF_EMERGENCY:

    default:
      QM_MSG_ERROR_1("unknown mode_pref %d", p_ph_info->mode_pref);
      ret_val = FALSE;
  }

  return ret_val;
}
#endif

#if defined (FEATURE_CDMA)

/*===========================================================================
  FUNCTION convert_cdma_mcc_2_ascii_mcc()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    mcc for CDMA.

  PARAMETERS
    p_mcc : ptr to return value (i.e ASCII )


  RETURN VALUE
   none

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void convert_cdma_mcc_2_ascii_mcc( char *p_mcc, word mcc )
{
  unsigned int d1, d2, d3, buf = mcc + 111;

  if ( mcc == 0x3FF ) // wildcard
  {
    *(p_mcc+0) = '3';
    *(p_mcc+1) = 0xFF;
    *(p_mcc+2) = 0xFF;
  }
  else
  {
    d3 = buf % 10;
    buf = ( d3 == 0 ) ? (buf-10)/10 : buf/10;

    d2 = buf % 10;
    buf = ( d2 == 0 ) ? (buf-10)/10 : buf/10;

    d1 = ( buf == 10 ) ? 0 : buf;

    if ( d1<10 && d2<10 && d3<10 )
    {
      *(p_mcc+0) = '0' + d1;
      *(p_mcc+1) = '0' + d2;
      *(p_mcc+2) = '0' + d3;
    }
    else
    {
      QM_MSG_ERROR_3("invalid digits %d %d %d", d1, d2, d3);
      *(p_mcc+0) = 0xFF;
      *(p_mcc+1) = 0xFF;
      *(p_mcc+2) = 0xFF;
    }
  }
}

/*===========================================================================
  FUNCTION convert_cdma_mnc_2_ascii_mnc()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    mnc for CDMA.

  PARAMETERS
    p_mnc : ptr to return value (i.e ASCII )


  RETURN VALUE
   none

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void convert_cdma_mnc_2_ascii_mnc( char *p_mnc, byte imsi_11_12)
{
  unsigned int d1, d2, buf = imsi_11_12 + 11;

  if ( imsi_11_12 == 0x7F ) // wildcard
  {
    *(p_mnc+0) = '7';
    *(p_mnc+1) = 0xFF;
    *(p_mnc+2) = 0xFF;
  }
  else
  {
    d2 = buf % 10;
    buf = ( d2 == 0 ) ? (buf-10)/10 : buf/10;

    d1 = ( buf == 10 ) ? 0 : buf;

    if ( d1<10 && d2<10 )
    {
     *(p_mnc+0) = '0' + d1;
      *(p_mnc+1) = '0' + d2;
      *(p_mnc+2) = 0xFF;
    }
    else
    {
      QM_MSG_ERROR_2("invalid digits %d %d", d1, d2);
      *(p_mnc+0) = 0xFF;
      *(p_mnc+1) = 0xFF;
      *(p_mnc+2) = 0xFF;
    }
  }
}
#endif

/*===========================================================================
  FUNCTION convert_3gpp_plmn_2_ascii_mcc_mnc()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    3 digit ASCII MCC and MNC values from a givem 3GPP PLMN.

  PARAMETERS
   *p_mcc : ptr to mcc to be returned
   *p_mnc : ptr to mnc to be returned
   *p_plmn: ptr to the input PLMN values

  RETURN VALUE
   none

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void convert_3gpp_plmn_2_ascii_mcc_mnc( char *p_mcc, char *p_mnc, sys_plmn_id_s_type p_plmn)
{
  boolean      plmn_is_undefined;
  boolean      mnc_includes_pcs_digit;
  sys_mcc_type mcc;
  sys_mcc_type mnc;

  sys_plmn_get_mcc_mnc2(p_plmn, &plmn_is_undefined, &mnc_includes_pcs_digit, &mcc, &mnc);

  if( !plmn_is_undefined )
  {
    // MCC
    p_mcc[2] = (char)(mcc%10 + '0');
    p_mcc[1] = (char)((mcc/10)%10 + '0');
    p_mcc[0] = (char)((mcc/100)%10 + '0');


    if( mnc == SYS_WILDCARD_MNC)
    {
      p_mnc[2] = 0xFF;
      p_mnc[1] = 0xFF;
      p_mnc[0] = 0xFF;
    }
    else
    {
      // MNC
      if( mnc_includes_pcs_digit )
      {
        p_mnc[2] = (char)(mnc%10 + '0');
        p_mnc[1] = (char)((mnc/10)%10 + '0');
        p_mnc[0] = (char)((mnc/100)%10 + '0');
      }
      else
      {
        p_mnc[2] = 0xFF;
        p_mnc[1] = (char)mnc%10 + '0';
        p_mnc[0] =(char) (mnc/10)%10 + '0';
      }
    }
  }
  else
  {
    // Undefined PLMN. Send all 'F' values
    p_mcc[0] = 0xFF;
    p_mcc[1] = 0xFF;
    p_mcc[2] = 0xFF;

    p_mnc[0] = 0xFF;
    p_mnc[1] = 0xFF;
    p_mnc[2] = 0xFF;

    QM_MSG_ERROR("PLMN undefined");
  }
}

#ifdef FEATURE_QMI_NAS_HDR
//===========================================================================
// FUNCTION: qmi_nasi_get_hdr_subtype
//
// DESCRIPTION:
//
// PARAMETERS:
//    sp        : service provided state pointer
//    cmd_buf_p : ptr to cmd buffer
//    cl_sp     : client state pointer
//    sdu_in    : incoming request
//
// RETURN:
//  ptr to response
//===========================================================================
//
static dsm_item_type*  qmi_nasi_get_hdr_subtype
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
   dsm_item_type *response = NULL;
   qmi_error_e_type errval   = QMI_ERR_NONE;
   struct nas_0056_req_s req_msg;
   struct nas_0056_rsp_s rsp_msg;

   uint16 subtype = 0;

   // check for null inputs
   if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in ) {
      QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
      errval = QMI_ERR_INTERNAL;
   }
   else if ( !TARGET_SUPPORTS_HDR ) {
      QM_MSG_ERROR_1("unsupported target %d", qmi_nasi_global.cm_ph_info.mode_capability);
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
   }
   else {
      memset(&req_msg, 0, sizeof(req_msg));

      //====================================================================
      // Read input parameters
      //====================================================================
      errval = qmi_nas_0056_req_read(&req_msg, sdu_in);

      //====================================================================
      // validate input paramteres
      //====================================================================
      if (errval == QMI_ERR_NONE) {
         errval = qmi_nas_0056_req_check(&req_msg);
      }

      //====================================================================
      // Call HDR function to get color code
      //====================================================================
      if (errval == QMI_ERR_NONE) {
#ifndef FEATURE_HDR
         errval = QMI_ERR_NOT_SUPPORTED;
#else
         subtype = hdrcp_scp_get_current_subtype(
                      (hdrhai_protocol_name_enum_type)req_msg.t01.protocol);
#endif
      }
   }

   // Create response message
   memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

   /*
     Note: To preservce backwards compatibility, in case of invalid HDR protocol value
     we will still include the TLV 0x10, with value 0xFFFF hardcoded.
   */
   rsp_msg.t02.result_code =
      (errval == QMI_ERR_NONE || errval == QMI_ERR_INVALID_ARG) ?  QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
   rsp_msg.t02.error_code  = (errval == QMI_ERR_NONE || errval == QMI_ERR_INVALID_ARG) ? QMI_ERR_NONE : errval ;
   rsp_msg.t02_valid = TRUE;

   rsp_msg.t10.subtype = ( errval == QMI_ERR_INVALID_ARG)? 0xFFFF : subtype;
   rsp_msg.t10_valid = (errval == QMI_ERR_NONE || errval == QMI_ERR_INVALID_ARG) ? TRUE : FALSE;

   if ( qmi_nas_0056_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE ) {
     response = NULL;
   }

   return response;
}

//===========================================================================
// FUNCTION: qmi_nasi_get_hdr_color_code
//
// DESCRIPTION:
//
// PARAMETERS:
//    sp        : service provided state pointer
//    cmd_buf_p : ptr to cmd buffer
//    cl_sp     : client state pointer
//    sdu_in    : incoming request
//
// RETURN:
//  ptr to response
//===========================================================================
//
static dsm_item_type*  qmi_nasi_get_hdr_color_code
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response   = NULL;
  qmi_error_e_type      errval     = QMI_ERR_NONE;
  struct nas_0057_rsp_s rsp_msg;

#ifdef FEATURE_HDR
  uint8                 color_code = 0;
  hdrerrno_enum_type err = E_SUCCESS;
#endif

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }
  else if ( !TARGET_SUPPORTS_HDR ) {
     QM_MSG_ERROR_1("unsupported target %d", qmi_nasi_global.cm_ph_info.mode_capability);
     errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
  else {
#ifndef FEATURE_HDR
        errval = QMI_ERR_NOT_SUPPORTED;
#else
     // Call HDR function to get color code
     err = hdrcp_ovhd_get_color_code(&color_code, HDRHAI_EXTERNAL_MODULE);
     if ( err != E_SUCCESS )
     {
        errval = QMI_ERR_INTERNAL;
     }
     else
     {
       rsp_msg.t10.color_code = color_code;
       rsp_msg.t10_valid       = (errval == QMI_ERR_NONE) ? TRUE : FALSE;
     }
#endif
  }

  // Create response message
  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE) ?  QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0057_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
}
#endif // FEATURE_QMI_NAS_HDR


#ifndef REMOVE_QMI_NAS_GET_CURRENT_ACQ_SYS_MODE_V01
//===========================================================================
// FUNCTION: qmi_nasi_get_cm_acq_mode
//
// DESCRIPTION:
//
// PARAMETERS:
//    sp        : service provided state pointer
//    cmd_buf_p : ptr to cmd buffer
//    cl_sp     : client state pointer
//    sdu_in    : incoming request
//
// RETURN:
//  ptr to response
//===========================================================================
//
static dsm_item_type* qmi_nasi_get_cm_acq_mode
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
   dsm_item_type        *response = NULL;
   qmi_error_e_type      errval   = QMI_ERR_NONE;
   nas_get_current_acq_sys_mode_resp_msg_v01 rsp_msg;

  memset (&rsp_msg, 0x00, sizeof(nas_get_current_acq_sys_mode_resp_msg_v01));


  QM_MSG_HIGH("Received request for GET_CM_ACQ_MODE. Message no longer supported");
  errval = QMI_ERR_NOT_SUPPORTED;

   // Set return status TLV
   rsp_msg.resp.result = (errval == QMI_ERR_NONE) ?  QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
   rsp_msg.resp.error  = (qmi_error_type_v01)errval;
   if(cmd_buf_p != NULL)
   {
     qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                   QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) &rsp_msg,
                                  (uint32_t) sizeof(nas_get_current_acq_sys_mode_resp_msg_v01),
                                  &response
                                );
   }

   return response;
}
#endif

#ifdef FEATURE_QMI_NAS_HDR
#if defined(FEATURE_HDR)
//===========================================================================
// FUNCTION: qmi_nas_cmd_handler
//
// DESCRIPTION:
//   Generic handler function for QMI NAS event handlers
//
// RETURN:
//   None
//===========================================================================
//
void qmi_nas_cmd_handler( qmi_mmode_cmd_enum_type cmd, void *payload )
{
   qmi_nasi_client_state_type *cl_sp;


   if (!payload) {
      QM_MSG_ERROR("NULL cmd param");
      return;
   }

   // Send indication to each QMI instance
  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {
     // Process indication according to payload type
     switch (*((enum qmi_nas_cmd_handler_type*)payload)) {
        case QMI_NAS_CMD_HDR: {
           qmi_nas_hdr_process_evt_payload(cl_sp, payload);
           break;
        }
        default: {
           QM_MSG_HIGH_1("Unhandled QMI NAS cmd type %d", *((uint32*)(payload)));
        }
     } // end_switch

     cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  } 
}

//===========================================================================
// FUNCTION: qmi_nas_hdr_process_evt_payload
//
// DESCRIPTION:
//   Process HDR event payload (called once per QMI CLID instance)
//
// RETURN:
//   None
//===========================================================================
//
void qmi_nas_hdr_process_evt_payload( qmi_nasi_client_state_type *cl_sp,
                                      const void *payload)
{
   uint16 id;
   dsm_item_type* dsm_ptr = NULL;
   qmi_error_e_type err_val = QMI_ERR_NONE;
   hdrmc_cb_params_rsp_union_type *parms;


   if (!payload) {
      QM_MSG_ERROR("NULL cmd param");
      return;
   }

   parms = &((struct qmi_nas_cmd_hdr_payload*)(payload))->parms;

   switch (parms->cb_type) {
      case HDRMC_CB_EVENT_UATI_UPDATE: {
         struct nas_0055_ind_s msg;

         if (! REGISTERED(cl_sp, uati) ) {
            return;
         } // not registered

         id = NASI_CMD_VAL_HDR_UATI_UPDATE_IND;
         memset( &msg, 0x00, sizeof(msg) );

         // copy UATI array to our struct
         memscpy(&msg.t01.uati, NAS_UATI_LENGTH,
                       &parms->uati_update.full_uati, NAS_UATI_LENGTH);
         msg.t01_valid = TRUE;
         err_val = qmi_nas_0055_ind_write( &msg, &dsm_ptr );

         break;
      }
      case HDRMC_CB_EVENT_SESSION_CLOSE: {
         struct nas_0054_ind_s msg;

         if (! REGISTERED(cl_sp, session_close) ) {
            return;
         } // not registered

         id = NASI_CMD_VAL_HDR_SESSION_CLOSE_IND;
         memset( &msg, 0x00, sizeof(msg) );

         // copy close_reason to our indication struct
         msg.t01.close_reason = parms->session_close.close_reason;
         msg.t01_valid = TRUE;
         err_val = qmi_nas_0054_ind_write( &msg, &dsm_ptr );

         break;
      }
      default:
         QM_MSG_ERROR_1("Unsupported HDR event", parms->cb_type);
         return;
   }

   if (err_val != QMI_ERR_NONE ) {
      QM_MSG_ERROR("Failed QMI_NAS data translation");
      return;
   }

   // Send indication to this QIM/CLID instance
   qmi_nasi_send_ind( cl_sp, id, dsm_ptr);

}
#endif // FEATURE_HDR
#endif // FEATURE_QMI_NAS_HDR

/*===========================================================================
  FUNCTION QMI_NASI_SET_RX_DIVERSITY()

  DESCRIPTION
    Message to set Rx diversity

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_rx_diversity
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void           *cl_sp,
  dsm_item_type **sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  struct nas_0059_req_s req_msg;
  struct nas_0059_rsp_s rsp_msg;

  memset( &req_msg, 0x00, sizeof(req_msg) );
  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0059_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0059_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    cmapi_err_e_type                   err;

    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    cmapi_sys_mode_e_type              sys_mode = CMAPI_SYS_MODE_CDMA;
    #else
    cmapi_sys_mode_e_type              sys_mode = CMAPI_SYS_MODE_LTE;
    #endif

    switch ( req_msg.t01.radio_if )
    {
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY
      #if defined(FEATURE_MMODE_3GPP2)
      case QMI_NAS_RADIO_IF_CDMA20001X:     sys_mode = CMAPI_SYS_MODE_CDMA;  break;
      case QMI_NAS_RADIO_IF_CDMA20001XEVDO: sys_mode = CMAPI_SYS_MODE_HDR;   break;
      #endif
      case QMI_NAS_RADIO_IF_GSM:            sys_mode = CMAPI_SYS_MODE_GSM;   break;
      #ifdef FEATURE_WCDMA
      case QMI_NAS_RADIO_IF_UMTS:           sys_mode = CMAPI_SYS_MODE_WCDMA; break;
      #endif
      #endif
      case QMI_NAS_RADIO_IF_LTE:            sys_mode = CMAPI_SYS_MODE_LTE;   break;
      default:
        // should not come here as qmi_nas_0059_req_check() won't let us
        // adding default just to keep compiler quiet
        break;
    }

    err = cmapi_change_rx_diversity( sys_mode, (cmapi_rx_diversity_bit_mask_e_type)(req_msg.t01.rx_chain_bitmask) );

    if ( err != CMAPI_SUCCESS )
    {
      switch ( err )
      {
        case CMAPI_NO_SERVICE:       errval = QMI_ERR_NO_RADIO;              break;
        case CMAPI_INVALID_SYS_MODE: errval = QMI_ERR_OP_DEVICE_UNSUPPORTED; break;
        case CMAPI_INVALID_PARAM:    errval = QMI_ERR_INVALID_OPERATION;     break;

        default:
          QM_MSG_ERROR_1("cmapi err %d", err);
          errval = QMI_ERR_INTERNAL;
          break;
      }
    }
  }

  // update result TLV
  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0059_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_TX_RX_INFO()

  DESCRIPTION
    Message to retrieve detailed Tx/Rx information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_tx_rx_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void           *cl_sp,
  dsm_item_type **sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  nas_get_tx_rx_info_req_msg_v01 req_msg;
  nas_get_tx_rx_info_resp_msg_v01 *rsp_msg;
  uint8 i;

  rsp_msg = (nas_get_tx_rx_info_resp_msg_v01 *) 
      modem_mem_alloc( sizeof(nas_get_tx_rx_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    return NULL;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_tx_rx_info_resp_msg_v01));

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
   // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) &req_msg,
                                           (uint32_t) sizeof(nas_get_tx_rx_info_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005A_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    cmapi_err_e_type         err;
    cmapi_sys_mode_e_type    sys_mode = CMAPI_SYS_MODE_CDMA;
    cmapi_signal_info_s_type signal_info;

    /*Initialize*/
    memset( &signal_info, 0x00, sizeof(signal_info) );

    switch ( req_msg.radio_if )
    {
      #ifndef FEATURE_MMODE_QMI_LTE_ONLY
      #if defined(FEATURE_MMODE_3GPP2)
      case QMI_NAS_RADIO_IF_CDMA20001X:     sys_mode = CMAPI_SYS_MODE_CDMA;  break;
      case QMI_NAS_RADIO_IF_CDMA20001XEVDO: sys_mode = CMAPI_SYS_MODE_HDR;   break;
      #endif
      case QMI_NAS_RADIO_IF_GSM:            sys_mode = CMAPI_SYS_MODE_GSM;   break;
      #if defined(FEATURE_WCDMA)
      case QMI_NAS_RADIO_IF_UMTS:           sys_mode = CMAPI_SYS_MODE_WCDMA; break;
      #endif
      #if defined(FEATURE_TDSCDMA)
      case QMI_NAS_RADIO_IF_TDSCDMA:        sys_mode = CMAPI_SYS_MODE_TDS;   break;
      #endif
      #endif
      case QMI_NAS_RADIO_IF_LTE:            sys_mode = CMAPI_SYS_MODE_LTE;   break;
      
      default:
        // should not come here as qmi_nas_005A_req_check() won't let us
        // adding default just to keep compiler quiet
        break;
    }

    QM_MSG_HIGH_1("Calling cmapi_get_signal_info with sys_mode:%d", sys_mode);
    err = cmapi_get_signal_info( sys_mode, &signal_info );

    if ( err == CMAPI_SUCCESS )
    {
      cmapi_rx_chain_info_s_type *p_sig_info;

      QM_MSG_HIGH_1("cmapi_get_signal_info rx_diversity_indicator:%d", signal_info.rx_power.rx_diversity_indicator);
      if ( signal_info.rx_power.rx_diversity_indicator & CMAPI_BM_RX_CHAIN_0 )
      {
        p_sig_info = &signal_info.rx_power.rx_pwr_chain[CMAPI_RX_CHAIN_0];

        rsp_msg->rx_chain_0.is_radio_tuned = p_sig_info->is_radio_tuned ? 1 : 0;
        rsp_msg->rx_chain_0.rx_pwr         = p_sig_info->rx_pwr;
        rsp_msg->rx_chain_0.ecio           = p_sig_info->ecio;
        #if defined(FEATURE_WCDMA)
        rsp_msg->rx_chain_0.rscp           = p_sig_info->rscp;
        #endif
        rsp_msg->rx_chain_0.rsrp           = p_sig_info->rsrp;
        rsp_msg->rx_chain_0.phase          = p_sig_info->phase;

        rsp_msg->rx_chain_0_valid = TRUE;
      }

      if ( signal_info.rx_power.rx_diversity_indicator & CMAPI_BM_RX_CHAIN_1 )
      {
        p_sig_info = &signal_info.rx_power.rx_pwr_chain[CMAPI_RX_CHAIN_1];

        rsp_msg->rx_chain_1.is_radio_tuned = p_sig_info->is_radio_tuned ? 1 : 0;
        rsp_msg->rx_chain_1.rx_pwr         = p_sig_info->rx_pwr;
        rsp_msg->rx_chain_1.ecio           = p_sig_info->ecio;
        #if defined(FEATURE_WCDMA)
        rsp_msg->rx_chain_1.rscp           = p_sig_info->rscp;
        #endif
        rsp_msg->rx_chain_1.rsrp           = p_sig_info->rsrp;
        rsp_msg->rx_chain_1.phase          = p_sig_info->phase;

        rsp_msg->rx_chain_1_valid = TRUE;
      }

      rsp_msg->tx.is_in_traffic = signal_info.tx_power.is_in_traffic ? 1 : 0;
      rsp_msg->tx.tx_pwr        = signal_info.tx_power.tx_pwr;
      rsp_msg->tx_valid = TRUE;
      if(sys_mode == CMAPI_SYS_MODE_LTE)
      {
        if(
            (signal_info.modulation.lte_modulation.downlink.num_layer > 0) &&
            (signal_info.modulation.lte_modulation.downlink.num_layer <= NAS_LTE_MAX_NUM_LAYER)
          )
        {
          rsp_msg->downlink_mod_valid = TRUE;
          rsp_msg->downlink_mod_len = signal_info.modulation.lte_modulation.downlink.num_layer;
          for(i = 0; i < rsp_msg->downlink_mod_len; i++)
          {
            rsp_msg->downlink_mod[i] = (nas_lte_modulation_enum_type_v01)signal_info.modulation.lte_modulation.downlink.modulation[i];
          }
        }
  
        if(
            (signal_info.modulation.lte_modulation.uplink.num_layer > 0) &&
            (signal_info.modulation.lte_modulation.uplink.num_layer <= NAS_LTE_MAX_NUM_LAYER)
          )
        {
          rsp_msg->uplink_mod_valid = TRUE;
          rsp_msg->uplink_mod_len = signal_info.modulation.lte_modulation.uplink.num_layer;
          for(i = 0; i < rsp_msg->uplink_mod_len; i++)
          {
            rsp_msg->uplink_mod[i] = (nas_lte_modulation_enum_type_v01)signal_info.modulation.lte_modulation.uplink.modulation[i];
          }
        }
      }

      if ( signal_info.rx_power.rx_diversity_indicator & CMAPI_BM_RX_CHAIN_2 )
      {
        p_sig_info = &signal_info.rx_power.rx_pwr_chain[CMAPI_RX_CHAIN_2];

        rsp_msg->rx_chain_2.is_radio_tuned = p_sig_info->is_radio_tuned ? 1 : 0;
        rsp_msg->rx_chain_2.rx_pwr         = p_sig_info->rx_pwr;
        rsp_msg->rx_chain_2.ecio           = p_sig_info->ecio;
        #if defined(FEATURE_WCDMA)
        rsp_msg->rx_chain_2.rscp           = p_sig_info->rscp;
        #endif
        rsp_msg->rx_chain_2.rsrp           = p_sig_info->rsrp;
        rsp_msg->rx_chain_2.phase          = p_sig_info->phase;

        rsp_msg->rx_chain_2_valid = TRUE;
      }

      if ( signal_info.rx_power.rx_diversity_indicator & CMAPI_BM_RX_CHAIN_3 )
      {
        p_sig_info = &signal_info.rx_power.rx_pwr_chain[CMAPI_RX_CHAIN_3];

        rsp_msg->rx_chain_3.is_radio_tuned = p_sig_info->is_radio_tuned ? 1 : 0;
        rsp_msg->rx_chain_3.rx_pwr         = p_sig_info->rx_pwr;
        rsp_msg->rx_chain_3.ecio           = p_sig_info->ecio;
        #if defined(FEATURE_WCDMA)
        rsp_msg->rx_chain_3.rscp           = p_sig_info->rscp;
        #endif
        rsp_msg->rx_chain_3.rsrp           = p_sig_info->rsrp;
        rsp_msg->rx_chain_3.phase          = p_sig_info->phase;

        rsp_msg->rx_chain_3_valid= TRUE;
      }
    }
    else
    {
      QM_MSG_HIGH_1("cmapi_get_signal_info failed with err %d", err);
      switch ( err )
      {
        case CMAPI_NO_SERVICE:       errval = QMI_ERR_NO_RADIO;              break;
        case CMAPI_INVALID_SYS_MODE: errval = QMI_ERR_OP_DEVICE_UNSUPPORTED; break;

        default:
          QM_MSG_ERROR_1("cmapi err %d", err);
          errval = QMI_ERR_INTERNAL;
          break;
      }
    }
  }

  if(errval != QMI_ERR_NONE)
  {
    memset (rsp_msg, 0x00, sizeof(nas_get_tx_rx_info_resp_msg_v01));
  }

  if( cmd_buf_p != NULL)
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_tx_rx_info_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}
#ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
/*===========================================================================
  FUNCTION QMI_NAS_GEN_MANAGED_ROAMING_IND()

  DESCRIPTION
    Generate a managed roaming indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    cm_ph_info_s_type    CM PH info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_managed_roaming_ind( cm_mm_ss_info_s_type *p_ss_info, qmi_cm_ph_info_s_type *p_ph_info, enum qmi_nas_subs_e bound_subs )
{
  boolean                     send_ind = FALSE;
  nv_item_type                nv_item;
  struct nas_0046_ind_s       ind_msg;

  dsm_item_type              *ind;
//  int                         client;
  qmi_nasi_client_state_type *cl_sp;

  memset( &ind_msg, 0x00, sizeof(ind_msg) );

  if( TARGET_SUPPORTS_LTE || TARGET_SUPPORTS_GSM || TARGET_SUPPORTS_WCDMA )
  {
    // Check SS event values
     if( (p_ss_info->changed_fields & CM_SS_EVT_TRUE_SRV_STATUS_MASK) &&
           ( (p_ss_info->sys_mode == SYS_SYS_MODE_GSM) ||
             #ifdef FEATURE_WCDMA
             (p_ss_info->sys_mode == SYS_SYS_MODE_WCDMA) ||
             #endif
             (p_ss_info->sys_mode == SYS_SYS_MODE_LTE) ) &&
           p_ss_info->true_srv_status == SYS_SRV_STATUS_LIMITED &&
           p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        send_ind = TRUE;
        ind_msg.t10.radio_if = qmi_nas_sys_mode_2_radio_if( p_ss_info, FALSE );
        ind_msg.t10_valid = TRUE;
      }
     #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
      else if( p_ss_info->number_of_stacks > 1 &&
               (p_ss_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_TRUE_SRV_STATUS_MASK) &&
             ( (p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM) ||
             (p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_WCDMA) ||
             (p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE) ) &&
           p_ss_info->stack_info[STACK_INDEX_1].true_srv_status == SYS_SRV_STATUS_LIMITED &&
           p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        send_ind = TRUE;
        ind_msg.t10.radio_if = qmi_nas_sys_mode_2_radio_if( p_ss_info, STACK_INDEX_1, FALSE );
        ind_msg.t10_valid = TRUE;
      }
      #endif

    // Read and check NV only if SS event indicates managed roaming
    // !GPRS && (MGRF || ENS)
    if( send_ind == TRUE )
    {
      if( qmi_mmode_get_nv_item_ext(NV_GPRS_ANITE_GCF_I, &nv_item, (bound_subs ? 1 : 0)) != NV_DONE_S )
      {
        return;
      }
      else if( nv_item.gprs_anite_gcf == TRUE )
      {
        return;
      }

      if( (qmi_mmode_get_nv_item_ext(NV_MGRF_SUPPORTED_I, &nv_item, (bound_subs ? 1 : 0)) != NV_DONE_S) ||
          (nv_item.mgrf_supported == FALSE) )
      {
        if( qmi_mmode_get_nv_item_ext(NV_ENS_ENABLED_I, &nv_item, (bound_subs ? 1 : 0)) != NV_DONE_S )
        {
          return;
        }
        else if( nv_item.ens_enabled == FALSE )
        {
          return;
        }
      }
    }

    // Send indication to clients as all checks have passed
    if( send_ind == TRUE )
    {
      cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
      while ( cl_sp != NULL )
      {

        if ( cl_sp->report_status.report_managed_roaming && cl_sp->report_status.bound_subs == bound_subs )
        {
          ind = NULL;

          if ( qmi_nas_0046_ind_write ( &ind_msg, &ind ) == QMI_ERR_NONE )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_MANAGED_ROAMING_IND, ind );
          }
        }

        cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
      }
    }
  }
}
#endif
#ifdef FEATURE_DUAL_SIM
/*===========================================================================
  FUNCTION QMI_NASI_GET_DUAL_STANDBY_PREF()

  DESCRIPTION
    Get the Dual Standby Preference of the device.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_dual_standby_pref
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type           *response = NULL;
  qmi_error_type_v01       errval = QMI_ERR_NONE_V01;

  nas_get_dual_standby_pref_resp_msg_v01   *rsp_msg = NULL;

#ifdef FEATURE_DUAL_SIM
  qmi_cm_ph_info_s_type      *p_ph_info = &qmi_nasi_global.cm_ph_info;
#endif

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg = (nas_get_dual_standby_pref_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_dual_standby_pref_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    qmi_voice_mem_error();
  }
  else
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_dual_standby_pref_resp_msg_v01) );
  }


#ifdef FEATURE_DUAL_SIM
  if(errval == QMI_ERR_NONE_V01)
  {
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    if( !qmi_nasi_global.rcvd_ph_info2 )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
    else
    {
      p_ph_info = &qmi_nasi_global.cm_ph_info2;
    }
  }
#ifdef FEATURE_TRIPLE_SIM    
   else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY)
   {
     if( !qmi_nasi_global.rcvd_ph_info3 )
     {
       errval = QMI_ERR_INFO_UNAVAILABLE_V01;
     }
     else
     {
       p_ph_info = &qmi_nasi_global.cm_ph_info3;
     }
   }
#endif
  else if( ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
  {
    if( !qmi_nasi_global.rcvd_ph_info )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
    else
    {
      p_ph_info = &qmi_nasi_global.cm_ph_info;
    }
  }
  else
  {
    QM_MSG_ERROR_1("invalid binding %d", ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs);
    errval = QMI_ERR_INTERNAL_V01;
  }
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_3("get_dual_standby_pref subs %d standby_pref %d active_subs %d", ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs, p_ph_info->standby_pref, p_ph_info->active_subs);

    qmi_nas_map_standby_pref_cm_to_qmi((uint32*)&rsp_msg->standby_pref, p_ph_info->standby_pref );
    rsp_msg->standby_pref_valid = TRUE;

    rsp_msg->priority_subs       = (nas_subs_type_enum_v01)p_ph_info->priority_subs;
    rsp_msg->priority_subs_valid = TRUE;

    rsp_msg->active_subs = (nas_subs_type_enum_v01)p_ph_info->active_subs;
    rsp_msg->active_subs_valid = TRUE;

    rsp_msg->default_data_subs       = (nas_subs_type_enum_v01)p_ph_info->default_data_subs;
    rsp_msg->default_data_subs_valid = TRUE;

    rsp_msg->default_voice_subs       = (nas_subs_type_enum_v01)p_ph_info->default_voice_subs;
    rsp_msg->default_voice_subs_valid = TRUE;

    rsp_msg->active_subs_mask_valid = TRUE;
    if ( p_ph_info->standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF )
    {
      rsp_msg->active_subs_mask = 0;
    }
    else if ( p_ph_info->standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY )
    {
#ifdef FEATURE_TRIPLE_SIM
      if ( p_ph_info->active_subs == SYS_MODEM_AS_ID_3 )
      {
        rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
      }
      else 
#endif
      if ( p_ph_info->active_subs == SYS_MODEM_AS_ID_2 )
      {
        rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
      }
      else
      {
        rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      }
    }
    else if ( p_ph_info->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY ||
              p_ph_info->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY)
    {
      rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      rsp_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( p_ph_info->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY ||
              p_ph_info->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY )
    {
      rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      rsp_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
      rsp_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
    }
#endif
    else
    {
      rsp_msg->active_subs_mask_valid = FALSE;
    }
  }

#else /* FEATURE_DUAL_SIM */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* FEATURE_DUAL_SIM */

  if ( (errval != QMI_ERR_NO_MEMORY_V01) && (rsp_msg != NULL) && (cmd_buf_p != NULL) )
  {
  // update result TLV
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01);
    rsp_msg->resp.error  = errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_dual_standby_pref_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_dual_standby_pref() */
#endif
/*===========================================================================
  FUNCTION QMI_NASI_DETACH_LTE()

  DESCRIPTION
    Message to detach lte

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_detach_lte
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  cm_plmn_blocking_info_s_type plmn_detach;
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;

  plmn_detach.request_pref = CM_PLMN_BLOCKING_PREF_LTE_DETACH_ONLY;

  /* Ignoring callback from command for now */
  if( !cm_ph_cmd_detach_and_plmn_blocking( qmi_nas_cmph_cmd_cb, (void *)cmd_buf_p, qmi_nasi_global.cm_clnt_id, plmn_detach ) )
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_005D_rsp_s        rsp_msg;

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_005D_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
}


/*===========================================================================
  FUNCTION QMI_NASI_BLOCK_LTE_PLMN()

  DESCRIPTION
    Message to set Rx diversity

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_block_lte_plmn
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  cm_plmn_blocking_info_s_type plmn_block;
  struct nas_005E_req_s        req_msg;
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;
  dword                        t3402_value;

  memset(&req_msg, 0, sizeof(req_msg));
  memset(&plmn_block, 0, sizeof(plmn_block));
  plmn_block.cause = SYS_BLOCK_PLMN_CAUSE_NONE;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005E_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005E_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    plmn_block.request_pref = CM_PLMN_BLOCKING_PREF_LTE_DETACH_PLMN_BLOCKING;
    if( !sys_plmn_set_mcc_mnc( req_msg.t01.mnc_includes_pcs_digit, req_msg.t01.mcc, req_msg.t01.mnc, &plmn_block.plmn ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      if( req_msg.t10_valid )
      {
        plmn_block.blocking_interval = req_msg.t10.blocking_interval_abs;
      }
      else if( req_msg.t11_valid )
      {
        if( efs_get("/nv/item_files/modem/nas/t3402", &t3402_value, sizeof(dword) ) == sizeof(dword) )
        {
          // mult and copy
          plmn_block.blocking_interval = (uint32)(t3402_value * req_msg.t11.blocking_interval_mult);
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
        }
      }
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    /* Ignoring callback from command for now */
    if( !cm_ph_cmd_detach_and_plmn_blocking( qmi_nas_cmph_cmd_cb, (void *)cmd_buf_p, qmi_nasi_global.cm_clnt_id, plmn_block ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_005E_rsp_s        rsp_msg;

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_005E_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
}


/*===========================================================================
  FUNCTION QMI_NASI_UNBLOCK_LTE_PLMN()

  DESCRIPTION
    Message to set Rx diversity

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_unblock_lte_plmn
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  cm_plmn_blocking_info_s_type plmn_unblock;
  struct nas_005F_req_s        req_msg;
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;

  memset(&req_msg, 0, sizeof(req_msg));
  memset(&plmn_unblock, 0, sizeof(plmn_unblock));
  plmn_unblock.cause = SYS_BLOCK_PLMN_CAUSE_NONE;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005F_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005F_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    plmn_unblock.request_pref = CM_PLMN_BLOCKING_PREF_PLMN_UNBLOCKING_ONLY;
    if( !sys_plmn_set_mcc_mnc( req_msg.t01.mnc_includes_pcs_digit, req_msg.t01.mcc, req_msg.t01.mnc, &plmn_unblock.plmn ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    /* Ignoring callback from command for now */
    if( !cm_ph_cmd_detach_and_plmn_blocking( qmi_nas_cmph_cmd_cb, (void *)cmd_buf_p, qmi_nasi_global.cm_clnt_id, plmn_unblock ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_005F_rsp_s        rsp_msg;

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_005F_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
}


/*===========================================================================
  FUNCTION QMI_NASI_RESET_LTE_PLMN_BLOCKING()

  DESCRIPTION
    Message to set Rx diversity

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_reset_lte_plmn_blocking
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  cm_plmn_blocking_info_s_type plmn_reset;
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;

  plmn_reset.request_pref = CM_PLMN_BLOCKING_PREF_PLMN_RESET;

  /* Ignoring callback from command for now */
  if( !cm_ph_cmd_detach_and_plmn_blocking( qmi_nas_cmph_cmd_cb, (void *)cmd_buf_p, qmi_nasi_global.cm_clnt_id, plmn_reset ) )
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_0060_rsp_s        rsp_msg;

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_0060_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nas_is_different_from_last_sent_name()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to determine if newly available
    network name differens from last sent PLMN Name.
    
  PARAMETERS
    eons: pointer to eons information to compare to.

  RETURN VALUE
   boolean : TRUE if name information differs
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_is_different_from_last_sent_name( 
  mmgsdi_session_get_operator_name_info_type *op_name_info,
  boolean ign_disp
)
{
  struct current_plmn_name_s *name_cache =  &qmi_nasi_global.current_plmn_name_cache;
  boolean display_spn=FALSE;
  boolean display_operator_info=FALSE;
  
  if( ign_disp )
  {
    name_cache = &qmi_nasi_global.current_plmn_name_cache_ignore;
  }

  if(op_name_info->roaming_status != MMGSDI_EONS_NW_INFO_NOT_AVAILABLE &&
     op_name_info->rplmn_display_bit != MMGSDI_EONS_RPLMN_DISPLAY_BIT_NOT_AVAILABLE &&
     op_name_info->spn_display_bit != MMGSDI_EONS_SPN_DISPLAY_BIT_NOT_AVAILABLE)
  {
    display_spn=display_spn_param[op_name_info->roaming_status-1][op_name_info->rplmn_display_bit-1][op_name_info->spn_display_bit-1];
    display_operator_info=display_operator_info_param[op_name_info->roaming_status-1][op_name_info->rplmn_display_bit-1][op_name_info->spn_display_bit-1];
  }
  if ( ign_disp || display_spn )
  {
    if ( name_cache->srv_prov_name.eons_encoding != op_name_info->spn.eons_encoding ||
         name_cache->srv_prov_name.spn_data_len != op_name_info->spn.spn_data_len ||
       memcmp( &name_cache->srv_prov_name.spn_data, 
                 &op_name_info->spn.spn_data, 
                 sizeof(op_name_info->spn.spn_data) ) )
    {
      return TRUE;
    }
  }

  if ( ign_disp || display_operator_info )
  {
    if ( name_cache->plmn_long_name.plmn_name_spare_bits != op_name_info->plmn_info_ptr->plmn_long_name.plmn_name_spare_bits ||
         name_cache->plmn_long_name.plmn_name_ci != op_name_info->plmn_info_ptr->plmn_long_name.plmn_name_ci ||
         name_cache->plmn_long_name.plmn_encoding != op_name_info->plmn_info_ptr->plmn_long_name.plmn_encoding ||
         name_cache->plmn_long_name.plmn_data_len != op_name_info->plmn_info_ptr->plmn_long_name.plmn_data_len ||
         memcmp( &name_cache->plmn_long_name.plmn_data, 
                 &op_name_info->plmn_info_ptr->plmn_long_name.plmn_data, 
                 sizeof(op_name_info->plmn_info_ptr->plmn_long_name.plmn_data) ) )
    {
      return TRUE;
    }

    if ( name_cache->plmn_short_name.plmn_name_spare_bits != op_name_info->plmn_info_ptr->plmn_short_name.plmn_name_spare_bits ||
         name_cache->plmn_short_name.plmn_name_ci != op_name_info->plmn_info_ptr->plmn_short_name.plmn_name_ci ||
         name_cache->plmn_short_name.plmn_encoding != op_name_info->plmn_info_ptr->plmn_short_name.plmn_encoding ||
         name_cache->plmn_short_name.plmn_data_len != op_name_info->plmn_info_ptr->plmn_short_name.plmn_data_len ||
         memcmp( &name_cache->plmn_short_name.plmn_data, 
                 &op_name_info->plmn_info_ptr->plmn_short_name.plmn_data, 
                 sizeof(op_name_info->plmn_info_ptr->plmn_short_name.plmn_data) ) )
    {
      return TRUE;
    }
  }
  
  return FALSE;
}

/*===========================================================================
  FUNCTION QMI_NAS_GEN_CURRENT_PLMN_NAME_IND()

  DESCRIPTION
    Generate a current plmn name indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_current_plmn_name_ind(
  cm_mm_ss_info_s_type *p_ss_info,
  mmgsdi_session_type_enum_type session
)
{
  nas_current_plmn_name_ind_msg_v01 *ind_msg;
  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  nas_current_plmn_name_ind_msg_v01 *ind_msg_sec_stack;  // SGLTE only
  #endif

  dsm_item_type              *ind;
  #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  dsm_item_type              *ind_sec;
  #endif
  qmi_nasi_client_state_type *cl_sp;
  boolean                     send_main = FALSE, send_sec = FALSE;

  ind_msg = (nas_current_plmn_name_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_current_plmn_name_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  ind_msg_sec_stack = (nas_current_plmn_name_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_current_plmn_name_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  #endif
  QM_MSG_HIGH_1("Generating current_plmn_name indication srv = %d",p_ss_info->srv_status);
  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof( nas_current_plmn_name_ind_msg_v01 ) );

    if ( p_ss_info->srv_status == SYS_SRV_STATUS_SRV )
    {
      send_main = qmi_nas_populate_current_plmn_name_ind( ind_msg, p_ss_info, FALSE, session );
      QM_MSG_HIGH_1("Generating current_plmn_name indication, send_main %d",send_main);
    }
    else
    {
      QM_MSG_HIGH("Generating current_plmn_name indication aborted");
      qmi_nasi_global.current_plmn_name_cache.current_plmn_valid = FALSE;
    }
  }
  else
  {
    qmi_voice_mem_error();
  }
  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  if ( ind_msg_sec_stack != NULL )
  {
    memset( ind_msg_sec_stack, 0x00, sizeof( nas_current_plmn_name_ind_msg_v01 ) );

    #if !defined(FEATURE_MMODE_QMI_GPRS_LTE) && ((defined(FEATURE_CDMA) || defined(FEATURE_HDR)))
    if ( p_ss_info->number_of_stacks > 1 &&
         p_ss_info->stack_info[STACK_INDEX_1].srv_status == SYS_SRV_STATUS_SRV )
    {
      QM_MSG_HIGH("Generating current_plmn_name indication for second stack info");
      send_sec = qmi_nas_populate_current_plmn_name_ind( ind_msg_sec_stack, p_ss_info, STACK_INDEX_1, FALSE, session );
    }
    else
    #endif
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    {
      qmi_nasi_global.current_plmn_name_cache_sec_stack.current_plmn_valid = FALSE;
    }
#endif
  }
  else
  {
    qmi_voice_mem_error();
  }
  #endif

  if ( send_main || send_sec )
  {
    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {
      QM_MSG_HIGH_3(" clnt %p, ignore %d, send_main %d", cl_sp->clnt, cl_sp->report_status.ignore_plmn_display_cond_in_ind,send_main);
      QM_MSG_HIGH_2(" report_current_plmn_name %d, sub %d", cl_sp->report_status.report_current_plmn_name, cl_sp->report_status.bound_subs );

      if ( cl_sp->report_status.report_current_plmn_name &&
           (cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY ) &&
           !(cl_sp->report_status.ignore_plmn_display_cond_in_ind || qm_efs_always_return_plmn()) )
      {
        if ( send_main )
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_CURRENT_PLMN_NAME_IND_V01,
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_current_plmn_name_ind_msg_v01),
                                                    &ind
                                                  ) )
          {
            QM_MSG_HIGH("send NASI_CMD_VAL_CURRENT_PLMN_NAME_IND");
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_CURRENT_PLMN_NAME_IND, ind );
          }
          else
          {
            QM_MSG_ERROR_1("problem writing indication main stack %p", cl_sp->clnt);
          }
        }
        #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
        if ( send_sec )
        {
          ind_sec = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_CURRENT_PLMN_NAME_IND_V01,
                                                    (void *) ind_msg_sec_stack,
                                                    (uint32_t)sizeof(nas_current_plmn_name_ind_msg_v01),
                                                    &ind_sec
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_CURRENT_PLMN_NAME_IND, ind_sec );
          }
          else
          {
            QM_MSG_ERROR_1("problem writing indication sec stack %p", cl_sp->clnt);
          }
        }
        #endif
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }

  // reset for ignoring display condition
  send_main = send_sec = FALSE;

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof( nas_current_plmn_name_ind_msg_v01 ) );

    if ( p_ss_info->srv_status == SYS_SRV_STATUS_SRV )
    {
      send_main = qmi_nas_populate_current_plmn_name_ind( ind_msg, p_ss_info, TRUE, session );
      QM_MSG_HIGH_1("Generating current_plmn_name indication, ignoring disp condition, send_main %d",send_main);
    }
    else
    {
      QM_MSG_HIGH("Generating current_plmn_name indication, ignoring disp condition - aborted");
      qmi_nasi_global.current_plmn_name_cache.current_plmn_valid = FALSE;
    }
  }
  else
  {
    /*Not enough memory to allocate QMI_NAS_CURRENT_PLMN_NAME_IND buffer for main stack*/
     qmi_voice_mem_error();
      }

  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  if ( ind_msg_sec_stack != NULL )
  {
    memset( ind_msg_sec_stack, 0x00, sizeof( nas_current_plmn_name_ind_msg_v01 ) );

    #if !defined(FEATURE_MMODE_QMI_GPRS_LTE)  && (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
    if ( p_ss_info->number_of_stacks > 1 &&
         p_ss_info->stack_info[STACK_INDEX_1].srv_status == SYS_SRV_STATUS_SRV )
    {
      //QM_MSG_HIGH("Generating current_plmn_name indication for second stack info, ignoring disp conditon");
      send_sec = qmi_nas_populate_current_plmn_name_ind( ind_msg_sec_stack, p_ss_info, STACK_INDEX_1, TRUE, session );
    }
    else
    #endif
    {
      #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
      qmi_nasi_global.current_plmn_name_cache_sec_stack.current_plmn_valid = FALSE;
      #endif
    }
  }
  else
  {
    /*Not enough memory to allocate QMI_NAS_CURRENT_PLMN_NAME_IND buffer for sec stack*/
     qmi_voice_mem_error();
  }
  #endif

  if ( send_main || send_sec )
  {
    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {

      if ( cl_sp->report_status.report_current_plmn_name &&
           (cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY) &&
           (cl_sp->report_status.ignore_plmn_display_cond_in_ind || qm_efs_always_return_plmn()) )
      {
        if ( send_main )
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_CURRENT_PLMN_NAME_IND_V01,
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_current_plmn_name_ind_msg_v01),
                                                    &ind
                                                  ) )
          {
            QM_MSG_HIGH("NASI_CMD_VAL_CURRENT_PLMN_NAME_IND");
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_CURRENT_PLMN_NAME_IND, ind );
          }
          else
          {
            QM_MSG_ERROR_1("problem writing indication main stack %p", cl_sp->clnt);
          }
        }
        #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
        if ( send_sec )
        {
          ind_sec = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_CURRENT_PLMN_NAME_IND_V01,
                                                    (void *) ind_msg_sec_stack,
                                                    (uint32_t)sizeof(nas_current_plmn_name_ind_msg_v01),
                                                    &ind_sec
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_CURRENT_PLMN_NAME_IND, ind_sec );
          }
          else
          {
            QM_MSG_ERROR_1("problem writing indication sec stack %p", cl_sp->clnt);
          }
        }
        #endif
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  if ( ind_msg_sec_stack != NULL ) { modem_mem_free( (void *) ind_msg_sec_stack, MODEM_MEM_CLIENT_QMI_MMODE ); }
  #endif
}

/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_CURRENT_PLMN_NAME_IND()

  DESCRIPTION
    Populates a current plmn name indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_populate_current_plmn_name_ind(
  nas_current_plmn_name_ind_msg_v01 *ind_msg,
  cm_mm_ss_info_s_type         *p_ss_info,
  boolean                            ign_disp,
  mmgsdi_session_type_enum_type      session
)
{
  sys_plmn_id_s_type          plmn;
  sys_mcc_type                mcc;
  sys_mnc_type                mnc;
  boolean                     plmn_undefined, plmn_includes_pcs_digit_ptr;
  mmgsdi_rat_enum_type        rat            = qmi_nas_rat_cm_mode_to_mmgsdi(p_ss_info->sys_mode);
  sys_sys_id_s_type           sys_id         = p_ss_info->sys_id;
  sys_mm_information_s_type   *mm_information =&(p_ss_info->mm_information);
  sys_lac_type                lac            = p_ss_info->sys_mode == SYS_SYS_MODE_LTE ? p_ss_info->tac : qmi_nas_get_lac( p_ss_info );
  struct current_plmn_name_s *cache          = ign_disp ? &qmi_nasi_global.current_plmn_name_cache_ignore : &qmi_nasi_global.current_plmn_name_cache;
  #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  sys_csg_id_type             csg_id         = qm_util_retrieve_csg_id(p_ss_info, stack_idx);
  #else
  sys_csg_id_type             csg_id         = SYS_CSG_ID_INVALID;
  #endif
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  uint32 i = 0;
  size_t temp_len = 0;
  uint8 tmp_buf[NAS_ALT_LANG_NAME_LEN_MAX_V01*2] = { 0 };
  mmgsdi_session_get_operator_name_info_type *operator_name_info_ptr=NULL;
  mmgsdi_plmn_id_list_type      plmn_id_list;
  mmgsdi_session_id_type session_id=(mmgsdi_session_id_type)-1;
  mmgsdi_eons_ignore_disp_cond_enum_type ignore_disp = MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND;
  //mmgsdi_eons_per_stack_evt_info_type *plmn_name;
  boolean display_operator_info=FALSE;
  boolean display_spn=FALSE;
  mmgsdi_return_enum_type mmgsdi_status;
  cm_mmgsdi_error_e_type cmmmgsdi_status;
  
  #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  // LTE on Nikel
  if( stack_idx == STACK_INDEX_1 )
  {
    cache = ign_disp ? &qmi_nasi_global.current_plmn_name_cache_sec_stack_ignore : &qmi_nasi_global.current_plmn_name_cache_sec_stack;
  }
  #endif

  plmn = mm_information->plmn_avail ? mm_information->plmn : sys_id.id.plmn;

  QM_MSG_HIGH_3("Retrieving name for %d %d %d", plmn.identity[0], plmn.identity[1], plmn.identity[2]);

  #ifndef FEATURE_MMODE_DISABLE_UIM
  if( (eons = qmi_nas_nw_name_find( session, plmn, lac, rat, csg_id )) != NULL )
  {
    mmgsdi_eons_per_stack_evt_info_type *plmn_name = &eons->first_stack_info;
    enum qmi_nas_stack_e eons_info_stack = qmi_nas_nw_name_info_stack( eons, plmn, lac, rat, csg_id );
    //QM_MSG_HIGH_3("Using stack %d, stack validity %d, %d", eons_info_stack, eons->first_stack_info.is_valid, eons->sec_stack_info.is_valid);
    if ( eons_info_stack == QMI_NAS_STACK_MAIN )
    {
      plmn_name = &eons->first_stack_info;
    }
    #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    else if ( eons_info_stack == QMI_NAS_STACK_GW_HYB )
    {
      plmn_name = &eons->sec_stack_info;
    }
    else
    {
      QM_MSG_ERROR("EONS information provided did not match requested info");
      return FALSE;
    }
    #endif
    QM_MSG_LOW_7("SPN len=%d, short len=%d, long len=%d, Encoding: SPN = %d, short = %d, long = %d, Add names: %d", 
    eons->spn.eons_data.data_len, plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len, plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len,
    eons->spn.eons_encoding, plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding, plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding,
    plmn_name->operator_info.num_plmn_additional_names);
  
    qm_util_print_bytes( eons->spn.eons_data.data_ptr, eons->spn.eons_data.data_len );
    qm_util_print_bytes( plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, 
                         plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len );
    qm_util_print_bytes( plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_ptr, 
                         plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len );
    
    // Check if newly in service, or compare previous sent message
    if ( cache->current_plmn_valid == FALSE ||
         memcmp( &cache->plmn, &plmn, sizeof(plmn) ) ||
         qmi_nas_is_different_from_last_sent_name( eons, plmn_name, ign_disp ) )
    {
      memscpy( &cache->plmn, sizeof(plmn), &plmn, sizeof(plmn));
      memscpy( &cache->srv_prov_name, sizeof(eons->spn), &eons->spn, sizeof(eons->spn));
      memscpy( &cache->plmn_short_name, sizeof(plmn_name->operator_info.plmn_short_name), &plmn_name->operator_info.plmn_short_name, sizeof(plmn_name->operator_info.plmn_short_name));
      memscpy( &cache->plmn_long_name, sizeof(plmn_name->operator_info.plmn_long_name), &plmn_name->operator_info.plmn_long_name, sizeof(plmn_name->operator_info.plmn_long_name));
      cache->current_plmn_valid = TRUE;

      ind_msg->plmn_id_valid = TRUE;
      sys_plmn_get_mcc_mnc( plmn, &plmn_undefined, &plmn_includes_pcs_digit_ptr, &mcc, &mnc );
      ind_msg->plmn_id.mcc = (uint16) mcc;
      ind_msg->plmn_id.mnc = (uint16) mnc;
      ind_msg->plmn_id.mnc_includes_pcs_digit = plmn_includes_pcs_digit_ptr;

      ind_msg->spn_valid = TRUE;
      ind_msg->spn_ext_valid = TRUE;
      if ( ign_disp || eons->display_spn )
      {
        if( eons->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          ind_msg->spn.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
          ind_msg->spn.spn_len = 2*qm_util_decode_ucs2_80_81_82_encoding( eons->spn.eons_data.data_ptr,
                                                                          eons->spn.eons_data.data_len,
                                                                          buff_ptr,
                                                                          NAS_SPN_LEN_MAX_V01/2 );
          memscpy( (void*)ind_msg->spn.spn, NAS_SPN_LEN_MAX_V01, (void*)buff_ptr, ind_msg->spn.spn_len );
          
          //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
          temp_len = qm_util_decode_ucs2_80_81_82_encoding( eons->spn.eons_data.data_ptr,
                                                            eons->spn.eons_data.data_len,
                                                            buff_ptr,
                                                            NAS_SPN_EXT_LEN_MAX_V01/2 );
          memscpy((void*)ind_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)buff_ptr, 2*temp_len);
        }
        else if ( eons->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
        {
          ind_msg->spn.spn_enc = NAS_CODING_SCHEME_UCS2_V01; 
          ind_msg->spn.spn_len = eons->spn.eons_data.data_len;
          memscpy( (void*)ind_msg->spn.spn, NAS_SPN_LEN_MAX_V01, (void*)eons->spn.eons_data.data_ptr, eons->spn.eons_data.data_len);
          
          //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
          temp_len = eons->spn.eons_data.data_len/2;
          memscpy( (void*)ind_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)eons->spn.eons_data.data_ptr, 2*temp_len);
        }
        else
        {
          ind_msg->spn.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
          ind_msg->spn.spn_len = eons->spn.eons_data.data_len;
          memscpy( ind_msg->spn.spn, eons->spn.eons_data.data_len, eons->spn.eons_data.data_ptr, eons->spn.eons_data.data_len);
          
          qm_util_gsm7_to_utf16( eons->spn.eons_data.data_ptr, 
                                 eons->spn.eons_data.data_len,
                                 FALSE,
                                 ind_msg->spn_ext,
                                 NAS_SPN_EXT_LEN_MAX_V01,
                                 &temp_len);
        }
        QM_MSG_HIGH_5("spn_valid=%d, spn_enc=%d, spn_len=%d, spn_ext_valid=%d, spn_ext_len=%d", 
            ind_msg->spn_valid, ind_msg->spn.spn_enc, ind_msg->spn.spn_len, ind_msg->spn_ext_valid, temp_len);   
      }
      else
      {
        ind_msg->spn.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
        ind_msg->spn.spn_len = 0;
      }

      if ( ign_disp || plmn_name->display_operator_info )
      {
        if ( plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          ind_msg->short_name_valid = TRUE;
          ind_msg->short_name.plmn_name_ci    = plmn_name->operator_info.plmn_short_name.plmn_name_ci;
          ind_msg->short_name.plmn_spare_bits = plmn_name->operator_info.plmn_short_name.plmn_name_spare_bits;
          ind_msg->short_name.plmn_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
          ind_msg->short_name.plmn_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                         plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len,
                                                                                         buff_ptr,
                                                                                         NAS_PLMN_NAME_MAX_V01/2 );
          memscpy( (void*)ind_msg->short_name.plmn_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->short_name.plmn_name_len );
        }
        else if( nasi_convert_mm_info_oper_name( 
                 plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_ptr,
                 plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding,
                 (char *)ind_msg->short_name.plmn_name,
                 (uint8 *)&ind_msg->short_name.plmn_name_enc,
                 NASI_MAX_LEN_NETWORK_NAME,
                 (uint8)plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len) )
        {
          ind_msg->short_name_valid = TRUE;
          ind_msg->short_name.plmn_name_ci    = plmn_name->operator_info.plmn_short_name.plmn_name_ci;
          ind_msg->short_name.plmn_spare_bits = plmn_name->operator_info.plmn_short_name.plmn_name_spare_bits;
          if( (ind_msg->short_name.plmn_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
              (plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
            )
          {
            ind_msg->short_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len);
          }
          else
          {
            ind_msg->short_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)ind_msg->short_name.plmn_name, NAS_PLMN_NAME_MAX_V01 ));
          }
        }

        if ( plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          ind_msg->long_name_valid = TRUE;
          ind_msg->long_name.plmn_name_ci    = plmn_name->operator_info.plmn_long_name.plmn_name_ci;
          ind_msg->long_name.plmn_spare_bits = plmn_name->operator_info.plmn_long_name.plmn_name_spare_bits;
          ind_msg->long_name.plmn_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
          ind_msg->long_name.plmn_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                        plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len,
                                                                                        buff_ptr,
                                                                                        NAS_PLMN_NAME_MAX_V01/2 );
          memscpy( (void*)ind_msg->long_name.plmn_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->long_name.plmn_name_len );
        }
        else if( nasi_convert_mm_info_oper_name( 
            plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_ptr,
            plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding,
            (char *)ind_msg->long_name.plmn_name,
            (uint8 *)&ind_msg->long_name.plmn_name_enc,
              NASI_MAX_LEN_NETWORK_NAME,
           (uint8) plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len) )
        {
          ind_msg->long_name_valid = TRUE;
          ind_msg->long_name.plmn_name_ci    = plmn_name->operator_info.plmn_long_name.plmn_name_ci;
          ind_msg->long_name.plmn_spare_bits = plmn_name->operator_info.plmn_long_name.plmn_name_spare_bits;
          if( (ind_msg->long_name.plmn_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
              (plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
            )
          {
            ind_msg->long_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len);
          }
          else
          {
            ind_msg->long_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)ind_msg->long_name.plmn_name, NAS_PLMN_NAME_MAX_V01 ));
          }
        }
      }

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      if ( qm_efs_csg_supported() )
      {
        if( plmn_name->operator_info.plmn_id.csg_id != SYS_CSG_ID_INVALID )
        {
          ind_msg->csg_id_valid = TRUE;
          ind_msg->csg_id = plmn_name->operator_info.plmn_id.csg_id;
        }
      }
#endif
#endif
    
      ind_msg->eons_display_bit_info_valid = TRUE;
      ind_msg->eons_display_bit_info.is_spn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( (mmgsdi_eons_rplmn_display_bit_enum_type) eons->spn_display_bit );
      ind_msg->eons_display_bit_info.is_plmn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( eons->rplmn_display_bit );

      ind_msg->is_home_network_valid = TRUE;
      ind_msg->is_home_network = qmi_nas_map_home_status_mmgsdi_to_qmi( plmn_name->roaming_status );
    
      ind_msg->rat_valid = TRUE;
      ind_msg->rat = (nas_radio_if_enum_v01)qmi_nas_rat_mmgsdi_to_qmi(rat);

      if ( plmn_name->operator_info.plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
           plmn_name->operator_info.plmn_additional_info.info_data.data_len != 0 ||
           plmn_name->operator_info.plmn_additional_info.info_data.data_ptr != NULL )
      {
        if ( plmn_name->operator_info.plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          ind_msg->addl_info_valid = TRUE;
          ind_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                     plmn_name->operator_info.plmn_additional_info.info_data.data_ptr,
                                     plmn_name->operator_info.plmn_additional_info.info_data.data_len,
                                     buff_ptr,
                                     NAS_PLMN_NAME_MAX_V01/2 );
          memscpy( (void*)ind_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->addl_info_len*2 );
        }
        else if ( plmn_name->operator_info.plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
        {
          ind_msg->addl_info_valid = TRUE;
          ind_msg->addl_info_len = plmn_name->operator_info.plmn_additional_info.info_data.data_len/2;
          memscpy( (void*)ind_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)plmn_name->operator_info.plmn_additional_info.info_data.data_ptr, plmn_name->operator_info.plmn_additional_info.info_data.data_len);
          convert_endianness16( (unsigned char*)ind_msg->addl_info, plmn_name->operator_info.plmn_additional_info.info_data.data_len );
        }
        else if ( plmn_name->operator_info.plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
        {
          if( !cm_util_gsm7_to_utf16( plmn_name->operator_info.plmn_additional_info.info_data.data_ptr, 
                                      plmn_name->operator_info.plmn_additional_info.info_data.data_len,
                                      FALSE,
                                      ind_msg->addl_info,
                                      NAS_PLMN_NAME_MAX_V01,
                                      (size_t *)&ind_msg->addl_info_len ) )
          {
            ind_msg->addl_info_valid = TRUE;
          }
        }
      }

      ind_msg->nw_name_source_valid = TRUE;
      ind_msg->nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( plmn_name->operator_info.plmn_name_source );

      if ( plmn_name->operator_info.num_plmn_additional_names > 0 )
      {
        ind_msg->lang_plmn_names_valid = TRUE;
        ind_msg->lang_plmn_names_len = MIN(MMGSDI_ADDITIONAL_NAMES_MAX, plmn_name->operator_info.num_plmn_additional_names);
        for ( i = 0; i < ind_msg->lang_plmn_names_len; i++ )
        {
          ind_msg->lang_plmn_names[i].lang_id = qmi_nas_map_lang_id_mmgsdi_to_qmi(plmn_name->operator_info.plmn_additional_names[i].plmn_lang);

          if ( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
            ind_msg->lang_plmn_names[i].plmn_long_name_len = qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                               plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                               ind_msg->lang_plmn_names[i].plmn_long_name,
                                                               NAS_ALT_LANG_NAME_LEN_MAX_V01 );
          }
          else if ( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
          {
            memscpy( tmp_buf, 
                     NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                     plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr, 
                     plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
            convert_endianness16( tmp_buf, 
                                  plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
            memscpy( ind_msg->lang_plmn_names[i].plmn_long_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
            ind_msg->lang_plmn_names[i].plmn_long_name_len = plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len/2;
          }

          if ( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
            ind_msg->lang_plmn_names[i].plmn_short_name_len = qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                               plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                               ind_msg->lang_plmn_names[i].plmn_short_name,
                                                               NAS_ALT_LANG_NAME_LEN_MAX_V01 );
          }
          else if ( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
          {
            memscpy( tmp_buf, 
                     NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                     plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr, 
                     plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
            convert_endianness16( tmp_buf, 
                                  plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
            memscpy( ind_msg->lang_plmn_names[i].plmn_short_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
            ind_msg->lang_plmn_names[i].plmn_short_name_len = plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len/2;
          }
        }
      }
    }
  }
  #else
  /*Populate PLMN List*/
  plmn_id_list.num_of_plmn_ids=1;
  plmn_id_list.plmn_list_ptr = (mmgsdi_plmn_id_type*)modem_mem_alloc(sizeof(mmgsdi_plmn_id_type), MODEM_MEM_CLIENT_QMI_MMODE);
  if(plmn_id_list.plmn_list_ptr == NULL)
  {
    qmi_voice_mem_error();
    return FALSE;
  }
  else
  {
    memset(plmn_id_list.plmn_list_ptr, 0, sizeof(mmgsdi_plmn_id_type));
    plmn_id_list.plmn_list_ptr->rat=rat;
    plmn_id_list.plmn_list_ptr->csg_id = SYS_CSG_ID_INVALID;
    memscpy( &plmn_id_list.plmn_list_ptr->plmn_id_val, sizeof(plmn), &plmn, sizeof(plmn));
    QM_MSG_HIGH_5("PLMN LIST : LEN=%d, rat =%d,PLMN %d %d %d",plmn_id_list.num_of_plmn_ids,plmn_id_list.plmn_list_ptr->rat,
                                               plmn_id_list.plmn_list_ptr->plmn_id_val[0], plmn_id_list.plmn_list_ptr->plmn_id_val[1],
                                               plmn_id_list.plmn_list_ptr->plmn_id_val[2]);
  }
  /*Allocate memory for output param*/
  operator_name_info_ptr=(mmgsdi_session_get_operator_name_info_type*)modem_mem_alloc(sizeof(mmgsdi_session_get_operator_name_info_type), MODEM_MEM_CLIENT_QMI_MMODE);
  if(operator_name_info_ptr == NULL)
  {
    qmi_voice_mem_error();
    return FALSE;
  }
  memset(operator_name_info_ptr, 0, sizeof(mmgsdi_session_get_operator_name_info_type));
  
  /*Allocate memory for PLMN List*/
  operator_name_info_ptr->plmn_info_ptr=(mmgsdi_plmn_info_static_type*)modem_mem_alloc((plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)), MODEM_MEM_CLIENT_QMI_MMODE);
  if(operator_name_info_ptr->plmn_info_ptr == NULL)
  {
    qmi_voice_mem_error();
    return FALSE;
  }
  memset(operator_name_info_ptr->plmn_info_ptr, 0, (plmn_id_list.num_of_plmn_ids * sizeof(mmgsdi_plmn_info_static_type)));

  cmmmgsdi_status=cm_mmgsdi_ssn_tbl_get_id_for_type(MMGSDI_GW_PROV_PRI_SESSION, &session_id);
  QM_MSG_HIGH_2("cm_mmgsdi_ssn_tbl_get_id_for_type : status=%d session_id %d",cmmmgsdi_status,session_id);

  mmgsdi_status=mmgsdi_session_get_operator_name_ext_sync( session_id,
                                                                    plmn_id_list,
                                                                    ignore_disp,
                                                                    operator_name_info_ptr);
  QM_MSG_HIGH_1("mmgsdi_session_get_operator_name_ext_sync : status=%d",mmgsdi_status);

  if( (operator_name_info_ptr != NULL) &&
      (cmmmgsdi_status== CM_MMGSDI_SUCCESS) &&
      ( MMGSDI_SUCCESS ==  mmgsdi_status))
  {
        QM_MSG_HIGH_6("SPN len=%d, short len=%d, long len=%d, Encoding: SPN = %d, short = %d, long = %d", 
        operator_name_info_ptr->spn.spn_data_len, operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_data_len, operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_data_len,
        operator_name_info_ptr->spn.eons_encoding, operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_encoding, operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_encoding);

        qm_util_print_bytes( operator_name_info_ptr->spn.spn_data, operator_name_info_ptr->spn.spn_data_len );
        qm_util_print_bytes( operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_data, 
                             operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_data_len );
        qm_util_print_bytes( operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_data, 
                             operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_data_len );
        
        // Check if newly in service, or compare previous sent message
        if ( cache->current_plmn_valid == FALSE ||
             memcmp( &cache->plmn, &plmn, sizeof(plmn) ) ||
             qmi_nas_is_different_from_last_sent_name( operator_name_info_ptr, ign_disp ))
        {
          if(operator_name_info_ptr->roaming_status != MMGSDI_EONS_NW_INFO_NOT_AVAILABLE &&
             operator_name_info_ptr->rplmn_display_bit != MMGSDI_EONS_RPLMN_DISPLAY_BIT_NOT_AVAILABLE &&
             operator_name_info_ptr->spn_display_bit != MMGSDI_EONS_SPN_DISPLAY_BIT_NOT_AVAILABLE)
          {
            display_spn=display_spn_param[operator_name_info_ptr->roaming_status-1][operator_name_info_ptr->rplmn_display_bit-1][operator_name_info_ptr->spn_display_bit-1];
            display_operator_info=display_operator_info_param[operator_name_info_ptr->roaming_status-1][operator_name_info_ptr->rplmn_display_bit-1][operator_name_info_ptr->spn_display_bit-1];
          }
          memscpy( &cache->plmn, sizeof(cache->plmn), &plmn, sizeof(plmn));
          memscpy( &cache->srv_prov_name, sizeof(cache->srv_prov_name), &operator_name_info_ptr->spn, sizeof(operator_name_info_ptr->spn));
          memscpy( &cache->plmn_short_name, sizeof(cache->plmn_short_name), &operator_name_info_ptr->plmn_info_ptr->plmn_short_name, sizeof(operator_name_info_ptr->plmn_info_ptr->plmn_short_name));
          memscpy( &cache->plmn_long_name, sizeof(cache->plmn_long_name), &operator_name_info_ptr->plmn_info_ptr->plmn_long_name, sizeof(operator_name_info_ptr->plmn_info_ptr->plmn_long_name));
          cache->current_plmn_valid = TRUE;
    
          ind_msg->plmn_id_valid = TRUE;
          sys_plmn_get_mcc_mnc( plmn, &plmn_undefined, &plmn_includes_pcs_digit_ptr, &mcc, &mnc );
          ind_msg->plmn_id.mcc = (uint16) mcc;
          ind_msg->plmn_id.mnc = (uint16) mnc;
          ind_msg->plmn_id.mnc_includes_pcs_digit = plmn_includes_pcs_digit_ptr;
    
          ind_msg->spn_valid = TRUE;
          ind_msg->spn_ext_valid = TRUE;
          if ( ign_disp || display_spn )
          {
            if( operator_name_info_ptr->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              ind_msg->spn.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
              ind_msg->spn.spn_len = 2*qm_util_decode_ucs2_80_81_82_encoding( operator_name_info_ptr->spn.spn_data,
                                                                              operator_name_info_ptr->spn.spn_data_len,
                                                                              buff_ptr,
                                                                              NAS_SPN_LEN_MAX_V01/2 );
              memscpy( (void*)ind_msg->spn.spn, NAS_SPN_LEN_MAX_V01, (void*)buff_ptr, ind_msg->spn.spn_len );
              
              //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
              temp_len = qm_util_decode_ucs2_80_81_82_encoding( operator_name_info_ptr->spn.spn_data,
                                                                operator_name_info_ptr->spn.spn_data_len,
                                                                buff_ptr,
                                                                NAS_SPN_EXT_LEN_MAX_V01/2 );
              memscpy((void*)ind_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)buff_ptr, 2*temp_len);
            }
            else if ( operator_name_info_ptr->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
            {
              ind_msg->spn.spn_enc = NAS_CODING_SCHEME_UCS2_V01; 
              ind_msg->spn.spn_len = operator_name_info_ptr->spn.spn_data_len;
              memscpy( (void*)ind_msg->spn.spn, NAS_SPN_LEN_MAX_V01, (void*)operator_name_info_ptr->spn.spn_data, operator_name_info_ptr->spn.spn_data_len);
              
              //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
              temp_len = operator_name_info_ptr->spn.spn_data_len/2;
              memscpy( (void*)ind_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)operator_name_info_ptr->spn.spn_data, 2*temp_len);
            }
            else
            {
              ind_msg->spn.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
              ind_msg->spn.spn_len = operator_name_info_ptr->spn.spn_data_len;
              memscpy( ind_msg->spn.spn, operator_name_info_ptr->spn.spn_data_len, operator_name_info_ptr->spn.spn_data, operator_name_info_ptr->spn.spn_data_len);
              
              qm_util_gsm7_to_utf16( operator_name_info_ptr->spn.spn_data, 
                                     operator_name_info_ptr->spn.spn_data_len,
                                     FALSE,
                                     ind_msg->spn_ext,
                                     NAS_SPN_EXT_LEN_MAX_V01,
                                     &temp_len);
            }
            QM_MSG_HIGH_5("spn_valid=%d, spn_enc=%d, spn_len=%d, spn_ext_valid=%d, spn_ext_len=%d", 
                ind_msg->spn_valid, ind_msg->spn.spn_enc, ind_msg->spn.spn_len, ind_msg->spn_ext_valid, temp_len);     
          }
          else
          {
            ind_msg->spn.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
            ind_msg->spn.spn_len = 0;
          }
    
          if ( ign_disp || display_operator_info )
          {
            if ( operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              ind_msg->short_name_valid = TRUE;
              ind_msg->short_name.plmn_name_ci      = operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_name_ci;
              ind_msg->short_name.plmn_spare_bits = operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_name_spare_bits;
              ind_msg->short_name.plmn_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
              ind_msg->short_name.plmn_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_data,
                                                                                             operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_data_len,
                                                                                             buff_ptr,
                                                                                             NAS_PLMN_NAME_MAX_V01/2 );
              memscpy( (void*)ind_msg->short_name.plmn_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->short_name.plmn_name_len );
            }
            else if( nasi_convert_mm_info_oper_name( 
                     operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_data,
                     operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_encoding,
                     (char *)ind_msg->short_name.plmn_name,
                     (uint8 *)&ind_msg->short_name.plmn_name_enc,
                     NASI_MAX_LEN_NETWORK_NAME,
                     (uint8)operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_data_len) )
            {
              ind_msg->short_name_valid = TRUE;
              ind_msg->short_name.plmn_name_ci      = operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_name_ci;
              ind_msg->short_name.plmn_spare_bits = operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_name_spare_bits;
              if( (ind_msg->short_name.plmn_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                  (operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                )
              {
                ind_msg->short_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, operator_name_info_ptr->plmn_info_ptr->plmn_short_name.plmn_data_len);
              }
              else
              {
                ind_msg->short_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)ind_msg->short_name.plmn_name, NAS_PLMN_NAME_MAX_V01 ));
              }
            }
    
            if ( operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              ind_msg->long_name_valid = TRUE;
              ind_msg->long_name.plmn_name_ci     = operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_name_ci;
              ind_msg->long_name.plmn_spare_bits = operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_name_spare_bits;
              ind_msg->long_name.plmn_name_enc     = NAS_CODING_SCHEME_UCS2_V01;
              ind_msg->long_name.plmn_name_len     = 2*qm_util_decode_ucs2_80_81_82_encoding( operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_data,
                                                                                            operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_data_len,
                                                                                            buff_ptr,
                                                                                            NAS_PLMN_NAME_MAX_V01/2 );
              memscpy( (void*)ind_msg->long_name.plmn_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->long_name.plmn_name_len );
            }
            else if( nasi_convert_mm_info_oper_name( 
                operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_data,
                operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_encoding,
                (char *)ind_msg->long_name.plmn_name,
                (uint8 *)&ind_msg->long_name.plmn_name_enc,
                  NASI_MAX_LEN_NETWORK_NAME,
               (uint8) operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_data_len) )
            {
              ind_msg->long_name_valid = TRUE;
              ind_msg->long_name.plmn_name_ci     = operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_name_ci;
              ind_msg->long_name.plmn_spare_bits = operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_name_spare_bits;
              if( (ind_msg->long_name.plmn_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                  (operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                )
              {
                ind_msg->long_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, operator_name_info_ptr->plmn_info_ptr->plmn_long_name.plmn_data_len);
              }
              else
              {
                ind_msg->long_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)ind_msg->long_name.plmn_name, NAS_PLMN_NAME_MAX_V01 ));
              }
            }
          }
    
#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
          if ( qm_efs_csg_supported() )
          {
            if( plmn_name->operator_info.plmn_id.csg_id != SYS_CSG_ID_INVALID )
            {
              ind_msg->csg_id_valid = TRUE;
              ind_msg->csg_id = plmn_name->operator_info.plmn_id.csg_id;
            }
          }
#endif
#endif
        
          ind_msg->eons_display_bit_info_valid = TRUE;
          ind_msg->eons_display_bit_info.is_spn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( (mmgsdi_eons_rplmn_display_bit_enum_type) operator_name_info_ptr->spn_display_bit );
          ind_msg->eons_display_bit_info.is_plmn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( operator_name_info_ptr->rplmn_display_bit );
    
          ind_msg->is_home_network_valid = TRUE;
          ind_msg->is_home_network = qmi_nas_map_home_status_mmgsdi_to_qmi( operator_name_info_ptr->roaming_status );
        
          ind_msg->rat_valid = TRUE;
          ind_msg->rat = (nas_radio_if_enum_v01)qmi_nas_rat_mmgsdi_to_qmi(rat);
  
          if ( operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
               operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data_len != 0 )
          {
            if ( operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              ind_msg->addl_info_valid = TRUE;
              ind_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                         operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data,
                                         operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data_len,
                                         buff_ptr,
                                         NAS_PLMN_NAME_MAX_V01/2 );
              memscpy( (void*)ind_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->addl_info_len*2 );
            }
            else if ( operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
            {
              ind_msg->addl_info_valid = TRUE;
              ind_msg->addl_info_len = operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data_len/2;
              memscpy( (void*)ind_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data, operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data_len);
              convert_endianness16( (unsigned char*)ind_msg->addl_info, operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data_len );
            }
            else if ( operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
            {
              if( !cm_util_gsm7_to_utf16( operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data, 
                                          operator_name_info_ptr->plmn_info_ptr->plmn_additional_info.info_data_len,
                                          FALSE,
                                          ind_msg->addl_info,
                                          NAS_PLMN_NAME_MAX_V01,
                                          (size_t *)&ind_msg->addl_info_len ) )
              {
                ind_msg->addl_info_valid = TRUE;
              }
            }
          }
  
          ind_msg->nw_name_source_valid = TRUE;
          ind_msg->nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( operator_name_info_ptr->plmn_info_ptr->plmn_name_source );
          #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
          if ( plmn_name->operator_info.num_plmn_additional_names > 0 )
          {
            ind_msg->lang_plmn_names_valid = TRUE;
            ind_msg->lang_plmn_names_len = MIN(MMGSDI_ADDITIONAL_NAMES_MAX, plmn_name->operator_info.num_plmn_additional_names);
            for ( i = 0; i < ind_msg->lang_plmn_names_len; i++ )
            {
              ind_msg->lang_plmn_names[i].lang_id = qmi_nas_map_lang_id_mmgsdi_to_qmi(plmn_name->operator_info.plmn_additional_names[i].plmn_lang);
    
              if ( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                ind_msg->lang_plmn_names[i].plmn_long_name_len = qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                   plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                   ind_msg->lang_plmn_names[i].plmn_long_name,
                                                                   NAS_ALT_LANG_NAME_LEN_MAX_V01 );
              }
              else if ( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                memscpy( tmp_buf, 
                         NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                         plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr, 
                         plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                convert_endianness16( tmp_buf, 
                                      plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                memscpy( ind_msg->lang_plmn_names[i].plmn_long_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                ind_msg->lang_plmn_names[i].plmn_long_name_len = plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len/2;
              }
    
              if ( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                ind_msg->lang_plmn_names[i].plmn_short_name_len = qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                   plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                   ind_msg->lang_plmn_names[i].plmn_short_name,
                                                                   NAS_ALT_LANG_NAME_LEN_MAX_V01 );
              }
              else if ( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                memscpy( tmp_buf, 
                         NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                         plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr, 
                         plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                convert_endianness16( tmp_buf, 
                                      plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                memscpy( ind_msg->lang_plmn_names[i].plmn_short_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                ind_msg->lang_plmn_names[i].plmn_short_name_len = plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len/2;
              }
            }
          }
          #endif
        }
  }
  else
  {
    QM_MSG_HIGH_3("CURRENT_PLMN_NAME_IND failed : status=%d , cmmmgsdi_status %d session id %d",mmgsdi_status,cmmmgsdi_status,session_id);
  }
  /*free memory*/
  if ( plmn_id_list.plmn_list_ptr != NULL ) { modem_mem_free( (void *) plmn_id_list.plmn_list_ptr, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( operator_name_info_ptr->plmn_info_ptr != NULL ) { modem_mem_free( (void *) operator_name_info_ptr->plmn_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( operator_name_info_ptr != NULL ) { modem_mem_free( (void *) operator_name_info_ptr, MODEM_MEM_CLIENT_QMI_MMODE ); }
  #endif
  return ind_msg->plmn_id_valid;
}

#ifndef REMOVE_QMI_NAS_CONFIG_EMBMS_V01
/*===========================================================================
  FUNCTION QMI_NASI_CONFIG_EMBMS()

  DESCRIPTION
    Message to request UE to enable/disable eMBMS

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_config_embms
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;
  struct nas_0062_req_s        req_msg;
  struct nas_0062_rsp_s        rsp_msg;
  errno_enum_type              msgr_err;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
    {
    errval = qmi_nas_0062_req_read( &req_msg, sdu_in );
    }

  if ( errval == QMI_ERR_NONE )
    {
    errval = qmi_nas_0062_req_check( &req_msg );
    }

  if ( errval == QMI_ERR_NONE )
  {
    if ( req_msg.t01.enable )
    {
      lte_rrc_embms_enable_req_s msg;

      msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_EMBMS_ENABLE_REQ );

      msg.debug_trace_id = req_msg.t10_valid ? req_msg.t10.trace_id : -1;

      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    }
    else
    {
      lte_rrc_embms_disable_req_s msg;

      msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_EMBMS_DISABLE_REQ );

      msg.debug_trace_id = req_msg.t10_valid ? req_msg.t10.trace_id : -1;

      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    }

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR_1("LTE_RRC_EMBMS_ENABLE/DISABLE_REQ send fail %d", msgr_err);
    }
  }

  memset(&rsp_msg, 0, sizeof(rsp_msg));

  rsp_msg.t02.result_code = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( rsp_msg.t02.result_code == QMI_ERR_NONE )
  {
    rsp_msg.t10.trace_id = req_msg.t10.trace_id;
    rsp_msg.t10_valid    = TRUE;
  }

  if ( qmi_nas_0062_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
}

  return response;
}
#endif

#ifndef REMOVE_QMI_NAS_GET_EMBMS_STATUS_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_EMBMS_STATUS()

  DESCRIPTION
    Message to query eMBMS status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_embms_status
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;
  nas_get_embms_status_resp_msg_v01 *rsp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  
  rsp_msg = (nas_get_embms_status_resp_msg_v01 *) 
      modem_mem_alloc( sizeof(nas_get_embms_status_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    return NULL;
  }

  memset(rsp_msg, 0, sizeof(nas_get_embms_status_resp_msg_v01));

#ifdef FEATURE_LTE_EMBMS
  if ( errval == QMI_ERR_NONE )
    {
    rsp_msg->enabled = qmi_nasi_global.embms_status;
    rsp_msg->enabled_valid= TRUE;

    rsp_msg->trace_id = qmi_nasi_global.trace_id;
    rsp_msg->trace_id_valid    = TRUE;
    }
#else
  if( errval == QMI_ERR_NONE )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
#endif

  if (cmd_buf_p != NULL)
  {
    rsp_msg->resp.result  = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_embms_status_resp_msg_v01),
                                  &response
                                );
  }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
  }
#endif

/*========================================================================
  FUNCTION qmi_nas_msgr_handler

  DESCRIPTION
    process messages received from msgr

  PARAMETERS
    msg pointer in *void. cast to qmi_mmodei_msgr_type before use.
    *void type is to avoid circular reference of headers

  RETURN VALUE
    None
===========================================================================*/
void qmi_nas_msgr_handler( void *param )
{

  #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  qmi_nasi_client_state_type *cl_sp;
  #endif
#ifdef FEATURE_LTE
#ifdef FEATURE_LTE_EMBMS
  struct nas_0064_ind_s       ind_msg;
  dsm_item_type              *ind;
#endif
#endif
  qmi_mmodei_msgr_type       *msg;
  qmi_nasi_cell_select_info_type cell_info;
  ASSERT( param );

  msg = (qmi_mmodei_msgr_type*)param;

  QM_MSG_HIGH_1("qmi_nas_msgr_hdlr rcvd %d", msg->cmd.hdr.id);
  switch ( msg->cmd.hdr.id )
  {
    #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    case MM_CM_MANUAL_SCAN_FAIL_IND:
      qmi_nasi_generate_manual_scan_fail_ind(INST_ID_TO_SYS_AS_ID(msg->cmd.hdr.inst_id));
      break;
    #endif
#ifdef FEATURE_GSM
   case GERAN_GRR_MTC_CFG_RSP: 
      QM_MSG_HIGH_1("GERAN_GRR_MTC_CFG_RSP(drx scaling factor) %d", msg->cmd.qmi_nas.drx_scaling_resp_grr.status);
      qmi_nasi_generate_set_drx_scaling_factor_rsp( msg->cmd.qmi_nas.drx_scaling_resp_grr.status );
      break;
#endif
 
#ifdef FEATURE_WCDMA
   case WCDMA_RRC_QMI_MTC_CFG_RSP: 
      QM_MSG_HIGH_1("WCDMA_RRC_QMI_MTC_CFG_CNF(drx scaling factor) %d", msg->cmd.qmi_nas.drx_scaling_resp_wrrc.status);
      qmi_nasi_generate_set_drx_scaling_factor_rsp( msg->cmd.qmi_nas.drx_scaling_resp_wrrc.status );
      break;
#endif
#ifdef FEATURE_LTE
    case LTE_RRC_MTC_CFG_CNF:
      QM_MSG_HIGH_1("LTE_RRC_MTC_CFG_CNF(drx scaling factor) %d", msg->cmd.qmi_nas.drx_scaling_resp.status);
      qmi_nasi_generate_set_drx_scaling_factor_rsp( msg->cmd.qmi_nas.drx_scaling_resp.status );
      break;


#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
#ifdef FEATURE_LTE_EMBMS
    case LTE_RRC_EMBMS_STATUS_CHANGE_IND:
      QM_MSG_HIGH_1("LTE_RRC_EMBMS_STATUS_CHANGE_IND %d", msg->cmd.qmi_nas.embms_status_change_ind.enabled_status);
      ind_msg.t01.enabled = qmi_nasi_global.embms_status = msg->cmd.qmi_nas.embms_status_change_ind.enabled_status;
      ind_msg.t01_valid   = TRUE;
      ind_msg.t10.trace_id = qmi_nasi_global.trace_id = msg->cmd.qmi_nas.embms_status_change_ind.debug_trace_id;
      ind_msg.t10_valid    = TRUE;

      cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
      while ( cl_sp != NULL )
      {
        if (  cl_sp->report_status.report_embms_status &&
              cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY ) // LTE can't be 2nd subscription yet
        {
          ind = NULL;

          if ( qmi_nas_0064_ind_write ( &ind_msg, &ind ) == QMI_ERR_NONE )
          {
            (void)qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_EMBMS_STATUS_IND, ind );
        }
        else
        {
            QM_MSG_ERROR_1("problem writing indication %p ", cl_sp->clnt);
          }
        }

        cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
      }
      break;
#endif   //FEATURE_LTE_EMBMS
#endif   //#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
    
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
    case LTE_CPHY_CA_EVENT_IND:
      qmi_nas_generate_lte_cphy_ca_ind(&msg->cmd.qmi_nas.cphy_ca_event_ind);
      break;
#endif
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
#ifdef FEATURE_LTE_EMBMS
  case LTE_RRC_EMBMS_SIGNAL_STRENGTH_CNF:
#ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_V01 
      qmi_nasi_generate_get_embms_sig_rsp( msg );
#endif
#ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_EXT_V01
      qmi_nasi_generate_get_embms_sig_ext_rsp( msg );
#endif
      break;
#endif
#endif

    case LTE_RRC_UTC_TIME_UPDATE_IND:
      qmi_nas_update_lte_sib16_network_time_cache(&msg->cmd.qmi_nas.lte_sib16_nw_time);
      qmi_nas_generate_lte_sib16_network_time_ind();
      break;
#endif  //FEATURE_LTE
#ifdef FEATURE_TDSCDMA
#ifndef REMOVE_QMI_NAS_GET_TDS_CELL_AND_POSITION_INFO_V01
    case TDSCDMA_RRC_GPS_POS_CELL_INFO_RSP:
      qmi_nasi_generate_get_tds_cell_and_position_info_rsp( msg );
      break;
#endif
    case TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND:
      qm_meas_process_tds_measurement_info( &msg->cmd.qmi_nas.tds_rrc_scell_sig_ind );
      break;
#endif
    case MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_CHANGED_IND:
      qmi_nas_gen_ims_pref_status_ind( &msg->cmd.qmi_nas.ims_pref_chg_ind.data );
      break;

    case MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_GET_EXT_RSP:
      qmi_nas_generate_get_ims_pref_resp( &msg->cmd.qmi_nas.ims_pref_rsp );
      break;
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
    case MM_CM_AC_EMERGENCY_ENTER_IND:
      qmi_nasi_generate_set_e911_state_resp( &msg->cmd.qmi_nas.e911_state_ind );
      break;

    case MM_CM_AC_EMERGENCY_READY_IND:
      qmi_nasi_generate_e911_state_ready_ind( &msg->cmd.qmi_nas.e911_state_ind );
      break;

    case MM_CM_AC_EMERGENCY_EXIT_IND:
      qmi_nasi_generate_set_e911_state_resp( &msg->cmd.qmi_nas.e911_state_ind );
      break;

    case MM_CM_SUBSC_CHGND_IND:
      qmi_nasi_generate_subscription_change_ind( &msg->cmd.qmi_nas.subscription_change_ind );
      break;
#endif 
#ifdef FEATURE_LTE
    case LTE_RRC_BAND_PRI_CHANGE_CNF:
      qmi_nasi_generate_set_lte_band_priority_resp( &msg->cmd.qmi_nas.lte_band_pri_cnf );
      break;
        
    case LTE_RRC_GET_BAND_PRI_LIST_CNF:
      qmi_nasi_generate_get_lte_band_priority_list_resp( &msg->cmd.qmi_nas.lte_get_band_pri_list_cnf );
      break;

    case LTE_RRC_DEACTIVATE_CNF:
      {
        lte_rrc_ac_barring_info_s lte_rrc_ac_barring_info_temp = {0};

        lte_rrc_ac_barring_info_temp.ac_barring_for_emergency_present = FALSE;
        lte_rrc_ac_barring_info_temp.ac_barring_MO_data_present          = FALSE;
        lte_rrc_ac_barring_info_temp.ac_barring_MO_signalling_present   = FALSE;
        
        qmi_nasi_acb_info_ind( &lte_rrc_ac_barring_info_temp );
        //Copying into cache
        qmi_nasi_global.lte_rrc_ac_barring_info_cache = lte_rrc_ac_barring_info_temp;
      }
      break;

    case LTE_RRC_BARRING_UPDATE_IND:
#ifndef REMOVE_QMI_NAS_GET_SSAC_INFO_V01
      qmi_nasi_ssac_info_ind( &msg->cmd.qmi_nas.lte_barring_ind.ssac_params );
      qmi_nasi_ssac_change_info_ind( &msg->cmd.qmi_nas.lte_barring_ind.ssac_params );
#endif
      qmi_nasi_acb_info_ind( &msg->cmd.qmi_nas.lte_barring_ind.ac_barring_info );
      
      memscpy( &qmi_nasi_global.lte_rrc_ac_barring_info_cache, sizeof(lte_rrc_ac_barring_info_s), &msg->cmd.qmi_nas.lte_barring_ind.ac_barring_info, sizeof(lte_rrc_ac_barring_info_s) );
      memscpy( &qmi_nasi_ssac_info.ssac_cache, sizeof(lte_rrc_ssac_params_s), &msg->cmd.qmi_nas.lte_barring_ind.ssac_params, sizeof(lte_rrc_ssac_params_s) );
      qmi_nasi_ssac_info.is_valid = TRUE;
      break;
#ifndef REMOVE_QMI_NAS_GET_SERV_CELL_SIB_V01
      case LTE_RRC_GET_SERV_CELL_SIB_CNF:
      QM_MSG_HIGH_1("Received LTE_RRC_GET_SERV_CELL_SIB_CNF: status = %d", msg->cmd.qmi_nas.lte_get_serv_cell_sib_cnf.status);
      cl_sp = qmi_nasi_get_cl_sp_by_cmd_buf(qmi_nasi_global.get_serv_cell_sib);
      if(cl_sp)
      {
        qmi_nasi_generate_get_serving_cell_sib_resp(&msg->cmd.qmi_nas.lte_get_serv_cell_sib_cnf);
        if(msg->cmd.qmi_nas.lte_get_serv_cell_sib_cnf.status == LTE_RRC_GET_SIB_SUCCESS)
        {
          qmi_nasi_generate_get_serving_cell_sib_ind(&msg->cmd.qmi_nas.lte_get_serv_cell_sib_cnf, cl_sp);
        }
      }
      else
      {
        QM_MSG_MED("NULL cl_sp for LTE_RRC_GET_SERV_CELL_SIB_CNF; no response or indication will be sent.");
      }
      break;
#endif
#endif
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
    case NAS_EMM_T3402_CHANGED_IND:
      QM_MSG_HIGH_1( "received NAS_EMM_T3402_CHANGED_IND, value=%d", msg->cmd.qmi_nas.emm_t3402_changed_ind.t3402_value);
      qmi_nasi_gen_emm_t3402_changed_ind( &msg->cmd.qmi_nas.emm_t3402_changed_ind );
      break;

    case MM_CM_T3346_INFO_IND:
      QM_MSG_HIGH_3("Received MM_CM_T3346_INFO_IND subs: %d rat: %d status: %d", msg->cmd.qmi_nas.t3346_timer_status_change.as_id, msg->cmd.qmi_nas.t3346_timer_status_change.active_rat, msg->cmd.qmi_nas.t3346_timer_status_change.timer_status);
      qmi_nasi_generate_t3346_timer_status_change_ind( msg );
      break;
#ifndef REMOVE_QMI_NAS_GET_CALL_MODE_V01
    case MM_CM_CALL_MODE_IND  :
      QM_MSG_HIGH_2("Received MM_CM_CALL_MODE_IND call_mode: %d subs: %d", msg->cmd.qmi_nas.call_mode_msg.call_mode, msg->cmd.qmi_nas.call_mode_msg.as_id);
      qmi_nasi_generate_call_mode_ind( msg );
      break;
#endif
#endif
    case LTE_RRC_CELL_LOCK_RSP:
      QM_MSG_HIGH_1("LTE_RRC_CELL_LOCK_RSP, status:%d", msg->cmd.qmi_nas.set_cell_lock_config_resp.status);
      if(qmi_nasi_global.set_cell_config_req_buf_p)
      {
        qmi_nasi_set_cell_config_resp( msg->cmd.qmi_nas.set_cell_lock_config_resp.status );
      }
      else
      {
        qmi_nasi_set_cell_lock_config_resp( msg->cmd.qmi_nas.set_cell_lock_config_resp.status );
      }
      break;
    #ifdef FEATURE_ENABLE_QMI_DMS
    case MM_CM_PSM_GET_CFG_PARAMS_RSP:
      QM_MSG_HIGH_1("PSM_GET_CFG_PARAMS_RSP, enabled:%d", msg->cmd.qmi_nas.psm_cfg_params_rsp.enabled);
      qmi_nasi_get_psm_config_params_resp( msg->cmd.qmi_nas.psm_cfg_params_rsp );
      break;
    
    case MM_CM_PSM_CFG_CHANGE_IND:
      QM_MSG_HIGH_1("PSM_CFG_CHANGE_IND, enabled:%d", msg->cmd.qmi_nas.psm_cfg_params_change_ind.psm_enabled);
      qmi_nasi_psm_config_params_change_ind ( msg->cmd.qmi_nas.psm_cfg_params_change_ind);
      break;

    case MM_CM_PSM_STATUS_IND:
      QM_MSG_HIGH_1("PSM_STATUS_IND, status:%d", msg->cmd.qmi_nas.psm_status_ind.status);
      qmi_nasi_psm_status_ind ( msg->cmd.qmi_nas.psm_status_ind);
      break;
    #endif
#ifndef REMOVE_QMI_NAS_GET_DRX_V01
    case NAS_EMM_GET_DRX_CNF:
	qmi_nas_get_drx_resp(msg->cmd.qmi_nas.cmd_get_drx_cnf.drx_coefficient);
	break;
#endif

#ifndef REMOVE_QMI_NAS_SET_DRX_V01
    case NAS_EMM_SET_DRX_CNF:
	qmi_nas_set_drx_resp(msg->cmd.qmi_nas.cmd_set_drx_cnf.result);
	break;
#endif

    case NAS_EMM_GET_EDRX_PARAMS_RSP:
	qmi_nas_get_edrx_params_resp(&msg->cmd.qmi_nas.get_edrx_params_rsp);
	break;
	

    case NAS_EMM_SET_EDRX_CFG_RSP:
        qmi_nas_set_edrx_params_resp();
	break;

   case LTE_CPHY_GET_NEXT_SFN_RSP:
        qmi_nas_get_next_sfn_resp(&msg->cmd.qmi_nas.lte_cphy_get_next_sfn);
   break;     
   
   case LTE_CPHY_SET_SFN_CONFIG_RSP:
        qmi_nas_set_sfn_config_resp(&msg->cmd.qmi_nas.lte_cphy_set_sfn_config_rsp); 
   break;
   
   case LTE_CPHY_SFN_THRESHOLD_REACHED_IND:
        qmi_nas_sfn_threshold_reached_ind(&msg->cmd.qmi_nas.lte_cphy_sfn_threshold_reached_ind);
   break;

   case MM_CM_3GPP_SRV_IND:
        qmi_nas_set_true_srv_status(&msg->cmd.qmi_nas.true_service_status_msg);
        break;
    case QMI_NAS_JAMMING_STATUS_CHGD_IND:
         qmi_nas_send_jamming_status(&msg->cmd.qmi_nas.jamming_status_info);
         break;
    #ifdef FEATURE_FSK_TX
    case GERAN_GL1_FSK_DATA_RSP:
          qmi_nas_fsk_data_resp(&msg->cmd.qmi_nas.fsk_data_rsp);
    break;
    case GERAN_GL1_FSK_HOP_TABLE_RSP:
          qmi_nas_set_fsk_hop_table_resp(&msg->cmd.qmi_nas.fsk_set_hop_table_rsp);
    break;
    case GERAN_GL1_FSK_HOP_TABLE_QUERY_RSP:
          qmi_nas_get_fsk_hop_table_resp(&msg->cmd.qmi_nas.fsk_get_hop_table_rsp);
    break;
    case GERAN_GL1_FSK_START_RSP:
          qmi_nas_fsk_start_resp(&msg->cmd.qmi_nas.fsk_start_rsp);
    break;
    case GERAN_GL1_FSK_DEBUG_RSP:
          qmi_nas_set_fsk_debug_resp(&msg->cmd.qmi_nas.fsk_set_debug_rsp);
    break;
    case GERAN_GL1_FSK_DEBUG_QUERY_RSP:
          qmi_nas_get_fsk_debug_resp(&msg->cmd.qmi_nas.fsk_get_debug_rsp);
    break;
    case GERAN_GL1_FSK_STOP_RSP:
          qmi_nas_fsk_stop_resp(&msg->cmd.qmi_nas.fsk_stop_rsp);
    break;
    case GERAN_GL1_FSK_PCL_RSP:
          qmi_nas_set_fsk_pcl_resp(&msg->cmd.qmi_nas.fsk_set_pcl_rsp);
    break;
    case GERAN_GL1_FSK_PCL_QUERY_RSP:
          qmi_nas_get_fsk_pcl_resp(&msg->cmd.qmi_nas.fsk_get_pcl_rsp);
    break;
    #endif
    case LTE_CPHY_CE_LEVEL_REPORT_RSP:
	      qmi_nas_get_ce_level_info_resp(&msg->cmd.qmi_nas.get_ce_level_info_rsp);
	break;
	case  LTE_ML1_SLEEPMGR_SLEEP_START_IND:
          qmi_nas_wwan_sleep_info_ind(msg->cmd.qmi_nas.lte_ml1_wwan_sleep_info_ind.est_sleep_duration);
    break;
	case  NB1_ML1_SLEEPMGR_SLEEP_START_IND:	
          qmi_nas_wwan_sleep_info_ind(msg->cmd.qmi_nas.nb1_wwan_sleep_info_ind.est_sleep_duration);
    break;
    case LTE_RRC_CELL_SELECT_INFO_RSP:
          memset ( &cell_info, 0x00, sizeof(qmi_nasi_cell_select_info_type) ); 
          cell_info.is_ue_camped =  msg->cmd.qmi_nas.lte_cell_select_info_rsp.is_ue_camped;
          if(cell_info.is_ue_camped == TRUE)
          {
             if(msg->cmd.qmi_nas.lte_cell_select_info_rsp.act_rat_type == LTE_ACTIVE_RAT_TYPE_M1)
             {
               cell_info.rat = SYS_SYS_MODE_LTE_M1;
             }   
             else 
             {
               cell_info.rat = SYS_SYS_MODE_LTE_NB1;     
             }  
			 cell_info.q_hyst = msg->cmd.qmi_nas.lte_cell_select_info_rsp.q_hyst;
			 cell_info.q_qualmin = msg->cmd.qmi_nas.lte_cell_select_info_rsp.q_qualmin;
             cell_info.qrxlevmin = msg->cmd.qmi_nas.lte_cell_select_info_rsp.q_rxlevmin;
             cell_info.qrxlevmin_ce = msg->cmd.qmi_nas.lte_cell_select_info_rsp.qrxlevmin_ce;
             cell_info.qrxlevmin_ce1 = msg->cmd.qmi_nas.lte_cell_select_info_rsp.qrxlevmin_ce1;
          }
          qmi_nas_get_cell_select_info_resp(&cell_info);
    break;
    
   case GERAN_GRR_CELL_SELECT_INFO_RSP:
          memset ( &cell_info, 0x00, sizeof(qmi_nasi_cell_select_info_type) ); 
          cell_info.is_ue_camped =  msg->cmd.qmi_nas.geran_cell_select_info_rsp.is_ue_camped;
          if(cell_info.is_ue_camped == TRUE)
          {
             cell_info.rat = SYS_SYS_MODE_GSM;
             cell_info.rxlev_access_min = msg->cmd.qmi_nas.geran_cell_select_info_rsp.rxlev_access_min;
          }
          qmi_nas_get_cell_select_info_resp(&cell_info);
    break;
       #ifdef FEATURE_FMD_SPEED_INFO
	case LTE_RRC_FMD_SPEED_INFO_RSP:
		qmi_nas_get_fmd_speed_info_resp(&msg->cmd.qmi_nas.lte_rrc_fmd_speed_info_rsp);
   #endif
    default:
      QM_MSG_HIGH_1("not a QMI_NAS handled msg %d", msg->cmd.hdr.id);
      break;
    }
  }

/*========================================================================
  FUNCTION qmi_nas_msgr_register

  DESCRIPTION
    register to msgr messages

  PARAMETERS
    msgr client object pointer

  RETURN VALUE
    None
===========================================================================*/
void qmi_nas_msgr_register( msgr_client_t *msgr_client )
{
  errno_enum_type err;

  #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_MANUAL_SCAN_FAIL_IND );
  ASSERT( err == E_SUCCESS );
  #endif

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_MTC_CFG_REQ );
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_MTC_CFG_CNF );
  ASSERT( err == E_SUCCESS );

#ifdef FEATURE_WCDMA
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, WCDMA_RRC_QMI_MTC_CFG_RSP );
  ASSERT( err == E_SUCCESS );
#endif

#ifdef FEATURE_GSM
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, GERAN_GRR_MTC_CFG_RSP );
  ASSERT( err == E_SUCCESS );
#endif

#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
#ifdef FEATURE_LTE_EMBMS
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_EMBMS_STATUS_CHANGE_IND );
  ASSERT( err == E_SUCCESS );
#endif
#endif

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_CPHY_CA_EVENT_IND );
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_UTC_TIME_UPDATE_IND );
  ASSERT( err == E_SUCCESS );

#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
#ifdef FEATURE_LTE_EMBMS
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_EMBMS_SIGNAL_STRENGTH_CNF );
  ASSERT( err == E_SUCCESS );
#endif
#endif

#ifdef FEATURE_TDSCDMA
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, TDSCDMA_RRC_GPS_POS_CELL_INFO_RSP);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND );
  ASSERT( err == E_SUCCESS );
#endif

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_CHANGED_IND );
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_GET_EXT_RSP );
  ASSERT( err == E_SUCCESS );
  
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_ENTER_REQ );
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_ENTER_IND );
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_READY_IND );
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_EXIT_REQ );
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_EXIT_IND );
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_SUBSC_CHGND_IND );
  ASSERT( err == E_SUCCESS );

#endif

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_BAND_PRI_CHANGE_CNF );
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_GET_BAND_PRI_LIST_CNF );
  ASSERT( err == E_SUCCESS );

  err = msgr_register(MSGR_QMI_NAS,msgr_client,MSGR_ID_REX,LTE_RRC_DEACTIVATE_CNF);
  ASSERT(err == E_SUCCESS);

  err = msgr_register(MSGR_QMI_NAS,msgr_client,MSGR_ID_REX,LTE_RRC_BARRING_UPDATE_IND);
  ASSERT(err == E_SUCCESS);

  err = msgr_register(MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_GET_SERV_CELL_SIB_CNF);
  ASSERT(err == E_SUCCESS);
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
  err = msgr_register(MSGR_QMI_NAS,msgr_client,MSGR_ID_REX,NAS_EMM_T3402_CHANGED_IND);
  ASSERT(err == E_SUCCESS);
#endif
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_T3346_INFO_IND );
  ASSERT( err == E_SUCCESS );

#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_CALL_MODE_IND );
  ASSERT( err == E_SUCCESS );
#endif
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_CELL_LOCK_RSP );
  ASSERT( err == E_SUCCESS );

#ifdef FEATURE_ENABLE_QMI_DMS
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_PSM_GET_CFG_PARAMS_RSP );
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_PSM_CFG_CHANGE_IND );
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_PSM_STATUS_IND );
  ASSERT( err == E_SUCCESS );
#endif

#ifndef REMOVE_QMI_NAS_SET_DRX_V01
  err=msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, NAS_EMM_SET_DRX_CNF);
  ASSERT( err == E_SUCCESS );
#endif

#ifndef REMOVE_QMI_NAS_GET_DRX_V01
  err=msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, NAS_EMM_GET_DRX_CNF);
  ASSERT( err == E_SUCCESS );
#endif
  
  err=msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, NAS_EMM_SET_EDRX_CFG_RSP);
  ASSERT( err == E_SUCCESS );

  err=msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, NAS_EMM_GET_EDRX_PARAMS_RSP);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_CPHY_GET_NEXT_SFN_RSP );
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_CPHY_SET_SFN_CONFIG_RSP );
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_CPHY_SFN_THRESHOLD_REACHED_IND );
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_3GPP_SRV_IND );
  ASSERT( err == E_SUCCESS );

  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, QMI_NAS_JAMMING_STATUS_CHGD_IND);
  ASSERT( err == E_SUCCESS );

  #ifdef FEATURE_FSK_TX
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_DATA_RSP);
  ASSERT( err == E_SUCCESS );

  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_HOP_TABLE_RSP);
  ASSERT( err == E_SUCCESS );
  
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_HOP_TABLE_QUERY_RSP);
  ASSERT( err == E_SUCCESS );

  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_START_RSP);
  ASSERT( err == E_SUCCESS );
  
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_DEBUG_RSP);
  ASSERT( err == E_SUCCESS );
  
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_DEBUG_QUERY_RSP);
  ASSERT( err == E_SUCCESS );
  
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_STOP_RSP);
  ASSERT( err == E_SUCCESS );
  
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_PCL_RSP);
  ASSERT( err == E_SUCCESS );
  
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GL1_FSK_PCL_QUERY_RSP);
  ASSERT( err == E_SUCCESS );  
  #endif
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, LTE_CPHY_CE_LEVEL_REPORT_RSP);
  ASSERT( err == E_SUCCESS );
  
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, LTE_ML1_SLEEPMGR_SLEEP_START_IND);
  ASSERT( err == E_SUCCESS );

  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, NB1_ML1_SLEEPMGR_SLEEP_START_IND);
  ASSERT( err == E_SUCCESS );
  
    err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, LTE_RRC_CELL_SELECT_INFO_RSP );
    ASSERT( err == E_SUCCESS );

  #ifdef FEATURE_GSM
  err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, GERAN_GRR_CELL_SELECT_INFO_RSP);
    ASSERT( err == E_SUCCESS );
  #endif
  #ifdef FEATURE_FMD_SPEED_INFO
   err=  msgr_register(MSGR_QMI_NAS, msgr_client,  MSGR_ID_REX, LTE_RRC_FMD_SPEED_INFO_RSP);
  ASSERT( err == E_SUCCESS );
#endif
  
}

/*===========================================================================
  FUNCTION qmi_nas_get_lac()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to determine which LAC to use.

  PARAMETERS
    p_ss_info : pointer to cm ss information to pull LAC from
    stack     : used to determine which stack to read LAC from

  RETURN VALUE
   sys_lac_type : the LAC value to use

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
sys_lac_type qmi_nas_get_lac(
  cm_mm_ss_info_s_type *p_ss_info
)
{
  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  if( stack_idx != STACK_INDEX_MAX )      
  {
    return p_ss_info->stack_info[stack_idx].sys_id.id.plmn_lac.lac;
  }
  #else
  {
    return p_ss_info->sys_id.id.plmn_lac.lac;
  }
  #endif
}


/*===========================================================================
  FUNCTION QMI_NAS_GEN_RF_BAND_INFO_IND()

  DESCRIPTION
    Generate a rf band information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    enum qmi_nas_stack_e          Stack

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_rf_band_info_ind(
  cm_mm_ss_info_s_type *p_ss_info
)
{
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  int index;
  #endif
  qmi_nasi_client_state_type *cl_sp;

  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {

    if (  cl_sp->report_status.report_rf_band_info_ind &&
            cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY)
    {
      #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
      for( index = 0; index < p_ss_info->number_of_stacks && index < STACK_INDEX_MAX; index++ )
      #endif
      {
        qmi_nas_send_rf_band_info_ind( p_ss_info, cl_sp );
      }
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
    qmi_nasi_global.rcvd_ss_info = TRUE;
  }
} //qmi_nas_gen_rf_band_info_ind

/*===========================================================================
  FUNCTION QMI_NAS_SEND_RF_BAND_INFO_IND()

  DESCRIPTION
    Populate a rf band information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    enum qmi_nas_stack_e          Stack
    qmi_nasi_state_type           Nas State
    qmi_nasi_client_state_type    Client
    inst                          NAS Instance
    clid                          Client ID

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_send_rf_band_info_ind(
  cm_mm_ss_info_s_type  *p_ss_info,
  qmi_nasi_client_state_type *cl_sp
)
{
  nas_rf_band_info_ind_msg_v01     *new_ind_msg, *old_ind_msg;
  boolean new_ind_msg_valid = FALSE;
  boolean send_ind =  FALSE;

  new_ind_msg = (nas_rf_band_info_ind_msg_v01  *) 
      modem_mem_alloc( sizeof(nas_rf_band_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  old_ind_msg = (nas_rf_band_info_ind_msg_v01  *) 
      modem_mem_alloc( sizeof(nas_rf_band_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( new_ind_msg == NULL || old_ind_msg == NULL)
    {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_send_rf_band_info_ind;
  }

  memset( new_ind_msg, 0x00, sizeof(nas_rf_band_info_ind_msg_v01) );
  memset( old_ind_msg, 0x00, sizeof(nas_rf_band_info_ind_msg_v01) );

  new_ind_msg_valid = qmi_nas_populate_rf_band_info_ind( p_ss_info,     new_ind_msg );
  (void)qmi_nas_populate_rf_band_info_ind( &qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY], old_ind_msg);

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
     send_ind = TRUE;
  }
  else if ( memcmp( old_ind_msg, new_ind_msg, sizeof(nas_rf_band_info_ind_msg_v01) ) )
    {
    if ( new_ind_msg_valid)
      {
       send_ind = TRUE;
    }
    else
    {
      QM_MSG_LOW_1("rf information changed but nothing to send %p", cl_sp->clnt);
    }
  }
  else
  {
    QM_MSG_LOW_1("rf info indication contents didn't change %p", cl_sp->clnt);
  }

  if ( send_ind )
  {
     dsm_item_type              *ind = NULL;
     if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_INDICATION,
                                                  (uint16_t)NASI_CMD_VAL_RF_BAND_INFO_IND,
                                                  (void *) new_ind_msg,
                                                  (uint32_t)sizeof(nas_rf_band_info_ind_msg_v01),
                                                  &ind
                                                ) )
     {
        qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_RF_BAND_INFO_IND, ind );
     }
     else
     {
        QM_MSG_ERROR_1("problem in writing indication for client %p", cl_sp->clnt);
     }
  }
  
end_send_rf_band_info_ind:
  if ( new_ind_msg != NULL ) { modem_mem_free( (void *) new_ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( old_ind_msg != NULL ) { modem_mem_free( (void *) old_ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }  
} // qmi_nas_send_rf_band_info_ind

/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_RF_BAND_INFO_IND()

  DESCRIPTION
    Populate a rf band information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    struct nas_0066_ind_s         Indication message to populate
    enum qmi_nas_stack_e          Stack

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_populate_rf_band_info_ind(
  cm_mm_ss_info_s_type *p_ss_info,
  nas_rf_band_info_ind_msg_v01 *ind_msg
)
{
  boolean ret = FALSE;
  if ( qmi_nas_sys_mode_2_radio_if( p_ss_info,FALSE ) != QMI_NAS_RADIO_IF_NONE )
  {
    ind_msg->rf_band_info.radio_if           = (nas_radio_if_enum_v01)qmi_nas_sys_mode_2_radio_if( p_ss_info, FALSE );
    ind_msg->rf_band_info.active_band    = qmi_nas_cm_bc_2_qmi_bc( p_ss_info->active_band );

    ind_msg->rf_band_info_list_ext.radio_if           = (nas_radio_if_enum_v01)qmi_nas_sys_mode_2_radio_if( p_ss_info, FALSE );
    ind_msg->rf_band_info_list_ext.active_band    = qmi_nas_cm_bc_2_qmi_bc( p_ss_info->active_band );

    switch ( ind_msg->rf_band_info.radio_if )
    {
      #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
      case QMI_NAS_RADIO_IF_CDMA20001X:
        ind_msg->rf_band_info.active_channel             = p_ss_info->stack_info[stack].active_channel;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->stack_info[stack].active_channel;
        break;
      #endif

      #if defined(FEATURE_HDR)
      case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
        ind_msg->rf_band_info.active_channel             = p_ss_info->stack_info[stack].active_channel;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->stack_info[stack].active_channel;
        break;
      #endif

      #if defined(FEATURE_GSM) 
      case QMI_NAS_RADIO_IF_GSM:
#ifdef FEATURE_CM_NEW_RR_CELL_INFO_INTERFACE
        ind_msg->rf_band_info.active_channel             = p_ss_info->cell_info.arfcn;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->cell_info.arfcn;
#else
        ind_msg->rf_band_info.active_channel             = 0;
        ind_msg->rf_band_info_list_ext.active_channel = 0;
#endif
        break;
      #endif

      #if defined(FEATURE_WCDMA) || defined(FEATURE_TDSCDMA)

      case QMI_NAS_RADIO_IF_UMTS:
      case QMI_NAS_RADIO_IF_TDSCDMA:
        ind_msg->rf_band_info.active_channel             = p_ss_info->cell_info.uarfcn_dl;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->cell_info.uarfcn_dl;
        break;
      #endif

      case QMI_NAS_RADIO_IF_LTE:
        ind_msg->rf_band_info.active_channel             = (uint16)p_ss_info->cell_info.earfcn_dl;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->cell_info.earfcn_dl;
        ind_msg->ciot_lte_op_mode = qmi_nas_map_camped_lte_mode_cm_to_qmi(p_ss_info->ciot_lte_mode);
        ind_msg->ciot_lte_op_mode_valid = TRUE;
        break;

      default:
        break;
    }
    ind_msg->rf_band_info_list_ext_valid = TRUE;
    ret = TRUE;
  }
  return ret;
} //qmi_nas_populate_rf_band_info_ind

#ifndef REMOVE_QMI_NAS_GET_CDMA_POSITION_INFO_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_CDMA_POSITION_INFO()

  DESCRIPTION
    Message to get cdma position info

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_cdma_position_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  qmi_error_e_type       errval = QMI_ERR_NONE;
  struct nas_0065_rsp_s  rsp_msg;
  dsm_item_type         *response = NULL;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  mcc_bs_info_type bs = {0};
  int              i, curr;
#endif

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  mccdma_get_cur_bs_info_ext( &bs );

  if ( bs.curr_plt_cnt + bs.nbr_plt_cnt > QMI_NAS_CDMA_POSITION_INFO_MAX )
  {
    QM_MSG_ERROR_2("unexpected bs list len curr %d nbr %d", bs.curr_plt_cnt, bs.nbr_plt_cnt);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    rsp_msg.t10.ue_in_idle = bs.ue_in_idle;
    rsp_msg.t10.bs_len     = bs.curr_plt_cnt + bs.nbr_plt_cnt;

    for ( i=0, curr=0; i<rsp_msg.t10.bs_len && i<QMI_NAS_CDMA_POSITION_INFO_MAX; i++, curr++ )
    {
      uint64 tmp;

      rsp_msg.t10.bs[i].pilot_type     = ( curr < bs.curr_plt_cnt ) ? QMI_NAS_CDMA_PILOT_CURR_ACT_PLT : QMI_NAS_CDMA_PILOT_NEIGHBOR_PLT;
      rsp_msg.t10.bs[i].sid            = bs.bs_info[i].sid;
      rsp_msg.t10.bs[i].nid            = bs.bs_info[i].nid;
      rsp_msg.t10.bs[i].base_id        = bs.bs_info[i].base_id;
      rsp_msg.t10.bs[i].pilot_pn       = bs.bs_info[i].pilot_pn;
      rsp_msg.t10.bs[i].pilot_strength = bs.bs_info[i].pilot_strength;
      rsp_msg.t10.bs[i].base_lat       = bs.bs_info[i].base_lat;
      rsp_msg.t10.bs[i].base_long      = bs.bs_info[i].base_long;
      tmp  = bs.bs_info[i].msg_time_stamp[1];
      tmp  = tmp << 32;
      tmp |= bs.bs_info[i].msg_time_stamp[0];
      rsp_msg.t10.bs[i].time_stamp     = tmp;
    }

    rsp_msg.t10_valid = TRUE;
  }
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
#endif

  rsp_msg.t02.result_code = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0065_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
}
#endif

/*===========================================================================
  FUNCTION QMI_NAS_GEN_network_reject_IND()

  DESCRIPTION
    Generate a network reject information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_network_reject_ind(
  cm_mm_ss_info_s_type *p_ss_info
)
{
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  int index;
  #endif
  qmi_nasi_client_state_type *cl_sp;

  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {

    if ( cl_sp->report_status.network_reject.report_network_reject_ind &&
         cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
      {
      #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
      for( index = 0; index < p_ss_info->number_of_stacks && index < STACK_INDEX_MAX; index++ )
      #endif
      {
        qmi_nas_send_network_reject_ind( p_ss_info, cl_sp );
      }
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
    qmi_nasi_global.rcvd_ss_info = TRUE;
  }
} //qmi_nas_gen_network_reject_ind

/*===========================================================================
  FUNCTION QMI_NAS_SEND_NETWORK_REJECT_IND()

  DESCRIPTION
    Send a network reject indication if it contains information

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    enum qmi_nas_stack_e          Stack
    qmi_nasi_state_type           Nas State
    qmi_nasi_client_state_type    Client
    inst                          NAS Instance
    clid                          Client ID

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_send_network_reject_ind(
  cm_mm_ss_info_s_type  *p_ss_info,
  qmi_nasi_client_state_type *cl_sp
)
{
  struct nas_0068_ind_s       ind_msg;
  dsm_item_type              *ind = NULL;

  memset( &ind_msg, 0x00, sizeof(ind_msg) );

  qmi_nas_populate_network_reject_ind( p_ss_info, &ind_msg);

  if ( ind_msg.t01_valid && ind_msg.t02_valid && ind_msg.t03_valid )
  {
    // we have something to send
    if ( qmi_nas_0068_ind_write ( &ind_msg, &ind ) == QMI_ERR_NONE )
    {
      qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_NETWORK_REJECT_IND, ind );
    }
  }
  else
  {
    QM_MSG_HIGH_1("no network reject information %p", cl_sp->clnt);
  }
} // qmi_nas_send_network_reject_ind

/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_NETWORK_REJECT_IND()

  DESCRIPTION
    Populate a network reject information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    struct nas_0068_ind_s         Indication message to populate
    enum qmi_nas_stack_e          Stack

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_network_reject_ind(
  cm_mm_ss_info_s_type *p_ss_info,
  struct nas_0068_ind_s *ind_msg
)
{
  boolean is_plmn_undefined, mnc_includes_pcs_digit;
  sys_mcc_type mcc;
  sys_mnc_type mnc;

  QM_MSG_HIGH_2( "Network Reject ind - :rej_cause=%d:rej_rat=%d",p_ss_info->reg_reject_info.reject_cause, p_ss_info->reg_reject_info.reg_rej_rat );
  
  #ifndef FEATURE_MMODE_QMI_LTE_ONLY
  if( p_ss_info->sys_mode == SYS_SYS_MODE_GSM || 
      #ifdef FEATURE_WCDMA
      p_ss_info->sys_mode == SYS_SYS_MODE_WCDMA ||
      #endif
      p_ss_info->sys_mode == SYS_SYS_MODE_LTE 
      #ifdef FEATURE_TDSCDMA
      || p_ss_info->sys_mode == SYS_SYS_MODE_TDS
      #endif
      )
  #else
  if( p_ss_info->sys_mode == SYS_SYS_MODE_LTE)
  #endif
    {
      ind_msg->t01_valid = TRUE;
      ind_msg->t01.radio_if = qmi_nas_rat_2_radio_if( p_ss_info->reg_reject_info.reg_rej_rat );

    if ( p_ss_info->srv_status != SYS_SRV_STATUS_NO_SRV &&
         p_ss_info->srv_status != SYS_SRV_STATUS_PWR_SAVE )
    {
      if( p_ss_info->reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
      {
        ind_msg->t02_valid = TRUE;
        ind_msg->t02.reject_srv_domain     = p_ss_info->reg_reject_info.reject_srv_domain;
  
        ind_msg->t03_valid = TRUE;
        ind_msg->t03.rej_cause             = p_ss_info->reg_reject_info.reject_cause;
  
        sys_plmn_get_mcc_mnc(p_ss_info->reg_reject_info.plmn,
                               &is_plmn_undefined,
                               &mnc_includes_pcs_digit,
                               &mcc,
                               &mnc );
      
        if( !is_plmn_undefined )
        {
          ind_msg->t10_valid = TRUE;
          ind_msg->t10.mcc = (uint16) mcc;
          ind_msg->t10.mnc = (uint16) mnc;
          ind_msg->t10.mnc_includes_pcs_digit = mnc_includes_pcs_digit;
        }
  
        #ifdef FEATURE_FEMTO_CSG
        #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
        if ( qm_efs_csg_supported() )
        {
          if( p_ss_info->reg_reject_info.csg_id != SYS_CSG_ID_INVALID )
          {
            ind_msg->t11_valid = TRUE;
            ind_msg->t11.csg_id = p_ss_info->reg_reject_info.csg_id;
          }
        }
        #endif
        #endif

        if(p_ss_info->sys_mode == SYS_SYS_MODE_LTE)
        {
          ind_msg->t12_valid = TRUE;
          ind_msg->t12.ciot_lte_op_mode = qmi_nas_map_camped_lte_mode_cm_to_qmi(p_ss_info->ciot_lte_mode);
        }
      }
    }
  }
} //qmi_nas_populate_network_reject_ind

/*===========================================================================
  FUNCTION QMI_NASI_FORCE_NETWORK_SEARCH()

  DESCRIPTION
    Force network search procedure

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_force_network_search
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval = QMI_ERR_NONE;
  struct nas_0067_rsp_s  rsp_msg;
  dsm_item_type         *response = NULL;

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( qmi_nasi_global.cm_ph_info.oprt_mode == SYS_OPRT_MODE_ONLINE )
  {
    // ignore CM response for now which allows easier management
    // of nested REQ messages
    if ( !cm_ph_cmd_wakeup_from_standby( NULL, NULL, qmi_nasi_global.cm_clnt_id ) )
  {
    errval = QMI_ERR_INTERNAL;
  }
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY;
  }

  rsp_msg.t02.result_code = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0067_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
  }
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_PLMN_NAME_RESP()

  DESCRIPTION
    send response for get_plmn_name after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_plmn_name_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf )
{
  dsm_item_type                        *response = NULL;
  qmi_error_type_v01                    errval = QMI_ERR_NONE_V01;
  nas_get_plmn_name_resp_msg_v01       *rsp_msg;
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_mmode_qcsi_transaction_type                     *cmd_buf_p = NULL;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  boolean send_all_fields = FALSE;
  uint32_t i = 0;
  size_t temp_len = 0;
  uint8 tmp_buf[NAS_ALT_LANG_NAME_LEN_MAX_V01*2] = { 0 };

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) callback_data->cmd_buf_ptr;
    send_all_fields = callback_data->send_all_info;
  }

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    if( callback_data != NULL )
    {
      modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    return;
  }

  rsp_msg = (nas_get_plmn_name_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_plmn_name_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if( rsp_msg != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_plmn_name_resp_msg_v01) );

    if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
    {
      if( name_cnf->plmn_list.num_of_plmn_ids == 1 && name_cnf->plmn_list.plmn_info_ptr != NULL ) // get_plmn_name request a single name
      {
        QM_MSG_HIGH_6("Names found: SPN len=%d, short len=%d, long len=%d, Encoding: SPN = %d, short = %d, long = %d", name_cnf->spn.eons_data.data_len, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len, 
            name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,name_cnf->spn.eons_encoding, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding, 
            name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding);


        qm_util_print_bytes( name_cnf->spn.eons_data.data_ptr, name_cnf->spn.eons_data.data_len );
        qm_util_print_bytes( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                             name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len );
        qm_util_print_bytes( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                             name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len );

        rsp_msg->eons_plmn_name_3gpp_valid = TRUE;
        rsp_msg->spn_ext_valid = TRUE;
        if( name_cnf->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
          rsp_msg->eons_plmn_name_3gpp.spn_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->spn.eons_data.data_ptr,
                                                                                          name_cnf->spn.eons_data.data_len,
                                                                                          buff_ptr,
                                                                                          NAS_SPN_LEN_MAX_V01/2 );
          memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.spn, NAS_SPN_LEN_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.spn_len );
          
          //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
          temp_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->spn.eons_data.data_ptr,
                                                            name_cnf->spn.eons_data.data_len,
                                                            buff_ptr,
                                                            NAS_SPN_EXT_LEN_MAX_V01/2 );
          memscpy((void*)rsp_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)buff_ptr, 2*temp_len);
        }
        else if ( name_cnf->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
        {
          rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
          rsp_msg->eons_plmn_name_3gpp.spn_len = name_cnf->spn.eons_data.data_len;
          memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.spn, NAS_SPN_LEN_MAX_V01, (void*)name_cnf->spn.eons_data.data_ptr, name_cnf->spn.eons_data.data_len );
          
          //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
          temp_len = name_cnf->spn.eons_data.data_len/2;
          memscpy((void*)rsp_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)name_cnf->spn.eons_data.data_ptr, 2*temp_len);
        }
        else
        {
          rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
          rsp_msg->eons_plmn_name_3gpp.spn_len = name_cnf->spn.eons_data.data_len;
          memscpy(rsp_msg->eons_plmn_name_3gpp.spn, name_cnf->spn.eons_data.data_len, 
                       name_cnf->spn.eons_data.data_ptr, name_cnf->spn.eons_data.data_len);
          
          qm_util_gsm7_to_utf16( name_cnf->spn.eons_data.data_ptr,
                                 name_cnf->spn.eons_data.data_len,
                                 FALSE,
                                 rsp_msg->spn_ext,
                                 NAS_SPN_EXT_LEN_MAX_V01,
                                 &temp_len);
        }
        QM_MSG_HIGH_5("eons_plmn_name_3gpp_valid=%d, spn_enc=%d, spn_len=%d, spn_ext_valid=%d, spn_ext_len=%d", 
            rsp_msg->eons_plmn_name_3gpp_valid = TRUE, rsp_msg->eons_plmn_name_3gpp.spn_enc, 
            rsp_msg->eons_plmn_name_3gpp.spn_len, rsp_msg->spn_ext_valid, temp_len);

        if( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
          rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
          rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
          rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,
                                                                                                       buff_ptr,
                                                                                                       NASI_MAX_LEN_NETWORK_NAME/2 );
          memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len );
        }
        else if( nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding,
                                                 (char *) rsp_msg->eons_plmn_name_3gpp.plmn_long_name,
                                                 (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc,
                                                 NASI_MAX_LEN_NETWORK_NAME,
                                                 (uint8)name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len ) )
        {
          rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
          rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
          if( (rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
              (name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
            )
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len);
          }
          else
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01 ));
          }
        }

        if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
          rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
          rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
          rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                     name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len,
                                                                                     buff_ptr,
                                                                                     NASI_MAX_LEN_NETWORK_NAME/2 );
          memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len );
        }
        else if ( nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                  name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding,
                                                  (char *) rsp_msg->eons_plmn_name_3gpp.plmn_short_name,
                                                  (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc,
                                                  NASI_MAX_LEN_NETWORK_NAME,
                                                  (uint8)name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len ) )
        {
          rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
          rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
          if( (rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
              (name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
            )
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len);
          }
          else
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01 ));
          }
        }

        if ( send_all_fields )
        {
          rsp_msg->eons_display_bit_info_valid = TRUE;
          rsp_msg->eons_display_bit_info.is_spn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( (mmgsdi_eons_rplmn_display_bit_enum_type) name_cnf->spn_display_bit );
          rsp_msg->eons_display_bit_info.is_plmn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( name_cnf->rplmn_display_bit );

          rsp_msg->is_home_network_valid = TRUE;
          rsp_msg->is_home_network = qmi_nas_map_home_status_mmgsdi_to_qmi( name_cnf->roaming_status );
        }

        if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
             name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len != 0 ||
             name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr != NULL )
        {
          if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
            rsp_msg->addl_info_valid = TRUE;
            rsp_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr,
                                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len,
                                       buff_ptr,
                                       NAS_PLMN_NAME_MAX_V01/2 );
            memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->addl_info_len*2 );
          }
          else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
          {
            rsp_msg->addl_info_valid = TRUE;
            rsp_msg->addl_info_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len/2;
            memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len );
            convert_endianness16( (unsigned char*)rsp_msg->addl_info, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len );
          }
          else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
          {
            if( !cm_util_gsm7_to_utf16( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr, 
                                        name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len,
                                        FALSE,
                                        rsp_msg->addl_info,
                                        NAS_PLMN_NAME_MAX_V01,
                                        (size_t *)&rsp_msg->addl_info_len ) )
            {
              rsp_msg->addl_info_valid = TRUE;
            }
          }
        }

        rsp_msg->nw_name_source_valid = TRUE;
        rsp_msg->nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( name_cnf->plmn_list.plmn_info_ptr[0].plmn_name_source );

        if ( name_cnf->plmn_list.plmn_info_ptr[0].num_plmn_additional_names > 0 )
        {
          rsp_msg->lang_plmn_names_valid = TRUE;
          rsp_msg->lang_plmn_names_len = MIN(NAS_ALT_LANG_MAX_V01, name_cnf->plmn_list.plmn_info_ptr[0].num_plmn_additional_names);
          for ( i = 0; i < rsp_msg->lang_plmn_names_len; i++ )
          {
            rsp_msg->lang_plmn_names[i].lang_id = qmi_nas_map_lang_id_mmgsdi_to_qmi(name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_lang);

            if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              rsp_msg->lang_plmn_names[i].plmn_long_name_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                 rsp_msg->lang_plmn_names[i].plmn_long_name,
                                                                 NAS_ALT_LANG_NAME_LEN_MAX_V01 );
            }
            else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
            {
              memscpy( tmp_buf, 
                       NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr, 
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
              convert_endianness16( tmp_buf, 
                                    name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
              memscpy( rsp_msg->lang_plmn_names[i].plmn_long_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
              rsp_msg->lang_plmn_names[i].plmn_long_name_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len/2;
            }

            if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              rsp_msg->lang_plmn_names[i].plmn_short_name_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                 rsp_msg->lang_plmn_names[i].plmn_short_name,
                                                                 NAS_ALT_LANG_NAME_LEN_MAX_V01 );
            }
            else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
            {
              memscpy( tmp_buf, 
                       NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr, 
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
              convert_endianness16( tmp_buf, 
                                    name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
              memscpy( rsp_msg->lang_plmn_names[i].plmn_short_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
              rsp_msg->lang_plmn_names[i].plmn_short_name_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len/2;
            }
        }
      }
    }
    else
    {
        errval = QMI_ERR_INTERNAL_V01;
    }
  }
  else
  {
      errval = QMI_ERR_INTERNAL_V01;
  }

  // Populate TLV 0x02 (Mandatory error code)
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;

    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                              QMI_IDL_RESPONSE,
                                              (uint16_t) QMI_NAS_GET_PLMN_NAME_RESP_MSG_V01,
                                              (void *) rsp_msg,
                                              (uint32_t) sizeof( nas_get_plmn_name_resp_msg_v01 ),
                                              &response
                                            ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
      qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
  }
  else
  {
    qmi_voice_mem_error();
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }

  if( rsp_msg != NULL ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if( callback_data != NULL ) { modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#endif
/*===========================================================================
  FUNCTION QMI_NAS_COMPARE_MMGSDI_CM_NETWORK_RAT()

  DESCRIPTION
    Compare RAT modes coming from MMGSDI and CM PH EVENT

  PARAMETERS
    rat : mmgsdi RAT received from callback information
    available_rat : RAT received from CM Phone Event


  RETURN VALUE
    True if comparision is success, FALSE otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_compare_mmgsdi_cm_network_rat( mmgsdi_rat_enum_type  rat, sys_radio_access_tech_e_type available_rat)
{
  boolean ret_val = FALSE;
  QM_MSG_MED_2("qmi_nas_compare_mmgsdi_cm_network_rat: mmgsdi rat = %d, cm rat = %d", rat, available_rat);

  switch (rat)
  {
    #ifndef FEATURE_MMODE_QMI_LTE_ONLY
    case MMGSDI_RAT_GSM:
      if( available_rat == SYS_RAT_GSM_RADIO_ACCESS ){ ret_val = TRUE; }
      break;
    #ifdef FEATURE_WCDMA
    case MMGSDI_RAT_UMTS:
      if( available_rat == SYS_RAT_UMTS_RADIO_ACCESS ){ ret_val = TRUE; }
      break;
    #endif
    #ifdef FEATURE_TDSCDMA
    case MMGSDI_RAT_TDS:
      if( available_rat == SYS_RAT_TDS_RADIO_ACCESS ){ ret_val = TRUE; }
      break;
    #endif
    #endif
    case MMGSDI_RAT_LTE:
      if( available_rat == SYS_RAT_LTE_RADIO_ACCESS ){ ret_val = TRUE; }
      break;
    default:
      break;
  }

  return ret_val;
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_NETWORK_SCAN_RESP_CELL_SEARCH()

  DESCRIPTION
    Generate response for cell serach request

  PARAMETERS
    plmn_list_rec : 

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_perform_network_scan_resp_cell_search( 
  sys_found_plmn_list_u_type *plmn_list_rec,
  sys_plmn_list_status_e_type    available_networks_list_cnf
)
{
  qmi_mmode_qcsi_transaction_type                     *cmd_buf_p = NULL;
  nas_perform_network_scan_resp_msg_v01                *rsp_msg   = NULL;
  dsm_item_type *                       response   = NULL;


  qmi_error_e_type       errval = QMI_ERR_NONE;

  boolean is_plmn_undefined      = FALSE;
  boolean mnc_includes_pcs_digit = FALSE;

  sys_mcc_type mcc                 = 0;
  sys_mnc_type mnc                 = 0;
  int          i                   = 0;
  int pci_loop = 0, plmn_loop = 0;
  int cell_cnt, plmn_cnt;

  qmi_nasi_global.net_scan_started = FALSE;
  
  if(available_networks_list_cnf == SYS_PLMN_LIST_PARTIAL)
  {
    QM_MSG_HIGH("CELL_SEARCH: qmi_nasi_generate_perform_network_scan_resp_cell_search Ignore partial results");
    return;
  }

  QM_MSG_HIGH_1("CELL_SEARCH: qmi_nasi_generate_perform_network_scan_resp_cell_search available_networks_list_cnf %d", available_networks_list_cnf);

  rsp_msg = ( nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( rsp_msg == NULL)
  {
    QM_MSG_ERROR("CELL_SEARCH: modem_mem_alloc failed");
    errval = QMI_ERR_NO_MEMORY;
  }

  qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_NW_SCAN );

  
    
  while((cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    response = NULL;
  
    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      QM_MSG_ERROR("Queued buffer does not match existing client transaction");
      continue;
    }
    
    if( errval == QMI_ERR_NONE)
    {
      memset(rsp_msg, 0, sizeof(nas_perform_network_scan_resp_msg_v01));
      
      for(cell_cnt = 0; (cell_cnt < plmn_list_rec->cell_info_list.lte_cell_list.num_cell) && (cell_cnt < 2*NAS_CELL_SEARCH_MAX_NUM_CELL_V01); cell_cnt++)
      {
        if(plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].rat == SYS_RAT_LTE_NB1_RADIO_ACCESS)
        {
          if(rsp_msg->lte_nb1_cell_search_info_len == NAS_CELL_SEARCH_MAX_NUM_CELL_V01)
          {
            continue;
          }
          rsp_msg->lte_nb1_cell_search_info_valid = TRUE;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].earfcn = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].earfcn;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].phy_cell_id = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].phy_cell_id;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].tac = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].tac;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].global_cell_id = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].global_cell_id;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].cell_is_barred = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].cell_barred;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].rsrp = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].rsrp;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].rsrq = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].rsrq;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].rssi = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].rssi;
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].cphy_ca_dl_bandwidth = 
            qmi_nas_map_lte_bw_to_qmi_bw((lte_bandwidth_e)plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].dl_bandwidth);
          rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].plmn_len = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].num_plmn;
          
          for(plmn_cnt = 0; plmn_cnt < plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].num_plmn &&
              plmn_cnt< NAS_PCI_SCAN_MAX_NUM_PLMN_V01; plmn_cnt++)
          {
              sys_plmn_get_mcc_mnc(plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].plmn[plmn_cnt],
              &is_plmn_undefined,
              &mnc_includes_pcs_digit,
              &mcc,
              &mnc );
              if(!is_plmn_undefined)
              {
                  rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].plmn[plmn_cnt].mcc = (uint16)mcc;
                  rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].plmn[plmn_cnt].mnc = (uint16)mnc;
                  rsp_msg->lte_nb1_cell_search_info[rsp_msg->lte_nb1_cell_search_info_len].plmn[plmn_cnt].mnc_includes_pcs_digit = mnc_includes_pcs_digit;
              }
          }
          rsp_msg->lte_nb1_cell_search_info_len++;
        }
        else if(plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].rat == SYS_RAT_LTE_M1_RADIO_ACCESS)
        {
          
          if(rsp_msg->lte_m1_cell_search_info_len == NAS_CELL_SEARCH_MAX_NUM_CELL_V01)
          {
            continue;
          }
          rsp_msg->lte_m1_cell_search_info_valid = TRUE;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].earfcn = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].earfcn;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].phy_cell_id = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].phy_cell_id;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].tac = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].tac;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].global_cell_id = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].global_cell_id;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].cell_is_barred = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].cell_barred;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].rsrp = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].rsrp;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].rsrq = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].rsrq;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].rssi = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].rssi;
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].cphy_ca_dl_bandwidth = 
            qmi_nas_map_lte_bw_to_qmi_bw((lte_bandwidth_e)plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].dl_bandwidth);
          rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].plmn_len = plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].num_plmn;
          
          for(plmn_cnt = 0; plmn_cnt < plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].num_plmn && 
              plmn_cnt< NAS_PCI_SCAN_MAX_NUM_PLMN_V01; plmn_cnt++)
          {
              sys_plmn_get_mcc_mnc(plmn_list_rec->cell_info_list.lte_cell_list.lte_cell_info[cell_cnt].plmn[plmn_cnt],
              &is_plmn_undefined,
              &mnc_includes_pcs_digit,
              &mcc,
              &mnc );
              if(!is_plmn_undefined)
              {
                  rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].plmn[plmn_cnt].mcc = (uint16)mcc;
                  rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].plmn[plmn_cnt].mnc = (uint16)mnc;
                  rsp_msg->lte_m1_cell_search_info[rsp_msg->lte_m1_cell_search_info_len].plmn[plmn_cnt].mnc_includes_pcs_digit = mnc_includes_pcs_digit;
              }
          }
          rsp_msg->lte_m1_cell_search_info_len++;
        }
      }

      if(plmn_list_rec->cell_info_list.geran_cell_list.num_cell > 0)
      {
        rsp_msg->geran_cell_search_info_valid = TRUE;
        rsp_msg->geran_cell_search_info_len = plmn_list_rec->cell_info_list.geran_cell_list.num_cell;
      }
      
      for(cell_cnt = 0; (cell_cnt < plmn_list_rec->cell_info_list.geran_cell_list.num_cell) && (cell_cnt < NAS_CELL_SEARCH_MAX_NUM_CELL_V01); cell_cnt++)
      {
        rsp_msg->geran_cell_search_info[cell_cnt].arfcn = plmn_list_rec->cell_info_list.geran_cell_list.geran_cell_info[cell_cnt].ARFCN.num;
        rsp_msg->geran_cell_search_info[cell_cnt].bsic = plmn_list_rec->cell_info_list.geran_cell_list.geran_cell_info[cell_cnt].BSIC;
        rsp_msg->geran_cell_search_info[cell_cnt].cell_identity = plmn_list_rec->cell_info_list.geran_cell_list.geran_cell_info[cell_cnt].cell_identity;
        rsp_msg->geran_cell_search_info[cell_cnt].cell_is_barred = plmn_list_rec->cell_info_list.geran_cell_list.geran_cell_info[cell_cnt].cell_barred;
        rsp_msg->geran_cell_search_info[cell_cnt].gprs_is_supported = (nas_gprs_support_e_type_v01)plmn_list_rec->cell_info_list.geran_cell_list.geran_cell_info[cell_cnt].gprs_supported;
        rsp_msg->geran_cell_search_info[cell_cnt].lac = plmn_list_rec->cell_info_list.geran_cell_list.geran_cell_info[cell_cnt].LAC;
        rsp_msg->geran_cell_search_info[cell_cnt].rxlev = (uint16)plmn_list_rec->cell_info_list.geran_cell_list.geran_cell_info[cell_cnt].RxLev;
        
        sys_plmn_get_mcc_mnc(plmn_list_rec->cell_info_list.geran_cell_list.geran_cell_info[cell_cnt].PLMN,
        &is_plmn_undefined,
        &mnc_includes_pcs_digit,
        &mcc,
        &mnc );
        if(!is_plmn_undefined)
        {
            rsp_msg->geran_cell_search_info[cell_cnt].plmn.mcc = (uint16)mcc;
            rsp_msg->geran_cell_search_info[cell_cnt].plmn.mnc = (uint16)mnc;
            rsp_msg->geran_cell_search_info[cell_cnt].plmn.mnc_includes_pcs_digit = mnc_includes_pcs_digit;
        }
      }
      
      QM_MSG_HIGH_3("CELL_SEARCH: CELL LEN geran %d, nb1 %d, m1 %d", rsp_msg->geran_cell_search_info_len,
        rsp_msg->lte_nb1_cell_search_info_len, rsp_msg->lte_m1_cell_search_info_len);
      
      
      // Populate TLV 0x02 (Mandatory error code)
      rsp_msg->resp.result  = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;
      rsp_msg->resp.error   = (qmi_error_type_v01)errval;
      
      response = NULL;
      
      QM_MSG_HIGH("CELL_SEARCH: encoding message qmi_nasi_generate_perform_network_scan_resp_cell_search");
      
      
      if( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
        QMI_IDL_RESPONSE,
        (uint16_t)cmd_buf_p->msg_id,
        (void *) rsp_msg,
        (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
        &response
        ) )
      {
        if( !qmi_nasi_send_response(cmd_buf_p, response) )
        {
            qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
        }
        QM_MSG_HIGH("CELL_SEARCH: 2 encoding message qmi_nasi_generate_perform_network_scan_resp_cell_search"); 
      }
      else
      {
        dsm_free_packet(&response);
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
      }
    } // End if
  }// end while (cmd buf queue is empty)
  // end while (cmd buf queue is empty)

  if ( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

#ifndef FEATURE_MMODE_DISABLE_UIM
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_NETWORK_SCAN_RESP()

  DESCRIPTION
    Generate response for perform network scan after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_perform_network_scan_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf )
{
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_mmode_qcsi_transaction_type                     *cmd_buf_p = NULL;
  nas_perform_network_scan_resp_msg_v01                *rsp_msg   = NULL;
  dsm_item_type *                       response   = NULL;
  sys_detailed_plmn_list_s_type        *available_networks = NULL;

  qmi_error_e_type       errval = QMI_ERR_NONE;

  boolean is_plmn_undefined      = FALSE;
  boolean mnc_includes_pcs_digit = FALSE;
  boolean net_info_available     = FALSE;
  boolean rat_match              = FALSE, rat_match_2 = FALSE;

  int          sys_plmn_list_index = 0;
  int          network_info_index  = 0;
  int          num_networks        = 0;
  sys_mcc_type mcc                 = 0;
  sys_mnc_type mnc                 = 0;
  uint32          i                   = 0;
  uint8 encoding_type = 0;
  int j = 0;
  uint8 network_name_len = 0;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  boolean is_plmn_2_valid=FALSE;
  sys_plmn_id_s_type current_plmn, current_plmn_2; //initialized for each cmd_buffer
  sys_sys_mode_e_type current_sys_mode = SYS_SYS_MODE_NONE, current_sys_mode_2 = SYS_SYS_MODE_NONE;

  // Initialize for SYS_MODEM_AS_ID_1
  sys_plmn_id_s_type plmn_main_stack = qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].mm_information.plmn_avail ?
                                              qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].mm_information.plmn :
                                              qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].sys_id.id.plmn ;
 
  sys_sys_mode_e_type sys_mode_main_stack = qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].sys_mode;
  sys_sys_mode_e_type sys_mode_gw_stack   = SYS_SYS_MODE_NONE;

  sys_srv_status_e_type main_stack_srv = qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].srv_status;
  sys_srv_status_e_type gw_stack_srv = SYS_SRV_STATUS_NO_SRV;
  #if defined(FEATURE_CIOT)
  uint8   lte_op_mode_len = 0;
  #endif

  // Clear pending network scan global var
  qmi_nasi_global.net_scan_started = FALSE;

  QM_MSG_HIGH_2("generate_perform_network_scan main_stack = %d,srv=%d", sys_mode_main_stack, main_stack_srv);  
  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
      qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )
  {
    sys_mode_gw_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode;
    gw_stack_srv = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].srv_status;
    QM_MSG_HIGH_2("generate_perform_network_scan gw_stack = %d,srv=%d", sys_mode_gw_stack, gw_stack_srv);
  }
  #endif
  rsp_msg = ( nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    available_networks = (sys_detailed_plmn_list_s_type *) callback_data->cmd_buf_ptr;
  }
  else
  {
    errval = QMI_ERR_INTERNAL;
  }

  if( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_NW_SCAN );

  while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    response = NULL;
    network_info_index  = 0;

    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      QM_MSG_ERROR("Queued buffer does not match existing client transaction");
      continue;
    }

    if( errval == QMI_ERR_NONE)
    {
      memset(rsp_msg, 0, sizeof(nas_perform_network_scan_resp_msg_v01));

      // Update current PLMN based on subscription
#ifdef FEATURE_DUAL_SIM
      if( ((qmi_nasi_client_state_type*)cmd_buf_p->clnt_info_ptr)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
      {
        current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_id.id.plmn ;
        current_sys_mode = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_mode;
      }
      else
#endif
#ifdef FEATURE_TRIPLE_SIM    
      if( ((qmi_nasi_client_state_type*)cmd_buf_p->clnt_info_ptr)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
      {
        current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].sys_id.id.plmn ;
        current_sys_mode = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].sys_mode;
      }
      else
#endif
      {
        #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
        if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
            qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )        
        {
          current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn_avail ?
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn :
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_id.id.plmn ;;
          current_sys_mode = sys_mode_gw_stack;

          if( (sys_mode_main_stack == SYS_SYS_MODE_GSM || sys_mode_main_stack == SYS_SYS_MODE_WCDMA || sys_mode_main_stack == SYS_SYS_MODE_TDS || sys_mode_main_stack == SYS_SYS_MODE_LTE) && 
              (main_stack_srv == SYS_SRV_STATUS_SRV) )
          {
            current_plmn_2 = plmn_main_stack;
            current_sys_mode_2 = sys_mode_main_stack;
            is_plmn_2_valid = TRUE;
            QM_MSG_HIGH_1("generate_perform_network_scan is_plmn_2_valid = %d", is_plmn_2_valid);
          }
        }
        else
        #endif
        {
          current_plmn = plmn_main_stack;
          current_sys_mode = sys_mode_main_stack;
        }
      }

      if( available_networks->length > NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX )
      {
        QM_MSG_ERROR_2("Received %d available networks, max is %d", available_networks->length, NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX);
        num_networks = NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX;
      }
      else
      {
        num_networks = available_networks->length;
      }
      // For every PLMN value in the list of available networks fill in TLVs
      // 0x10, 0x11, and 0x12
      for(sys_plmn_list_index=0; sys_plmn_list_index < num_networks; sys_plmn_list_index++)
      {
        net_info_available = FALSE;

        sys_plmn_get_mcc_mnc(available_networks->info[sys_plmn_list_index].plmn,
                             &is_plmn_undefined,
                             &mnc_includes_pcs_digit,
                             &mcc,
                             &mnc );
        if(!is_plmn_undefined)
        {
          // TLV 0x10 (3GPP NETWORK INFORMATION)
          rsp_msg->nas_3gpp_network_info[network_info_index].mobile_country_code = (uint16) mcc;
          rsp_msg->nas_3gpp_network_info[network_info_index].mobile_network_code = (uint16) mnc;

          rat_match = FALSE, rat_match_2 = FALSE;
          switch ( current_sys_mode )
          {
            #ifndef FEATURE_MMODE_QMI_LTE_ONLY
            case SYS_SYS_MODE_GSM:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
              break;
            #ifdef FEATURE_WCDMA
            case SYS_SYS_MODE_WCDMA:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
              break;
            #endif
            #ifdef FEATURE_TDSCDMA
            case SYS_SYS_MODE_TDS:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
              break;
            #endif
            #endif
            
            case SYS_SYS_MODE_LTE:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
              break;
            default:
              break;
          }
          #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
          if( is_plmn_2_valid )
          {
            switch ( current_sys_mode_2 )
          {
              case SYS_SYS_MODE_GSM:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
                break;
              case SYS_SYS_MODE_WCDMA:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
                break;
              case SYS_SYS_MODE_LTE:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
                break;
              case SYS_SYS_MODE_TDS:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
                break;
              default:
              break;
          }
          }
          #endif
          current_plmn_2 = plmn_main_stack;
          if( sys_plmn_match( current_plmn, available_networks->info[sys_plmn_list_index].plmn) &&  rat_match )
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
          }
          #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
          else if (is_plmn_2_valid && rat_match_2 &&
                   sys_plmn_match( current_plmn_2, available_networks->info[sys_plmn_list_index].plmn))
            {
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
            }
            #endif
            else
            {
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_AVAILABLE_MASK;
            }

          switch (available_networks->info[sys_plmn_list_index].list_category)
          {
            case SYS_DETAILED_PLMN_LIST_CATEGORY_HPLMN:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_HOME_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
              break;

            case SYS_DETAILED_PLMN_LIST_CATEGORY_PREFERRED:
            case SYS_DETAILED_PLMN_LIST_CATEGORY_USER_PREFERRED:
            case SYS_DETAILED_PLMN_LIST_CATEGORY_OPERATOR_PREFERRED:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
                break;

            case SYS_DETAILED_PLMN_LIST_CATEGORY_OTHER:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_PREFERRED_MASK;
                break;

            default:
                break;
          }

          if(available_networks->info[sys_plmn_list_index].plmn_forbidden)
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_FORBIDDEN_MASK;
          }
          else
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_FORBIDDEN_MASK;
          }

          if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
          {
            if( name_cnf->plmn_list.plmn_info_ptr != NULL )
            {
              for( i = 0; i < name_cnf->plmn_list.num_of_plmn_ids; i++ )
              {
                if ( !memcmp( name_cnf->plmn_list.plmn_info_ptr[i].plmn_id.plmn_id_val, available_networks->info[sys_plmn_list_index].plmn.identity, sizeof(sys_plmn_id_s_type) ) &&
                      qmi_nas_compare_mmgsdi_cm_network_rat( name_cnf->plmn_list.plmn_info_ptr[i].plmn_id.rat, available_networks->info[sys_plmn_list_index].rat ) )
                {
                  QM_MSG_HIGH_3("Perform net scan PLMN index %d, len %d, encoding %d", i, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding);

                  if ( qm_efs_always_return_plmn() )
                  {
                    if ( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                    {
                      network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                  name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                                  buff_ptr,
                                                                                  NASI_MAX_LEN_NETWORK_NAME/2 );
                      memscpy( (void*)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                      if ( network_name_len > 0 )
                      {
                        net_info_available = TRUE;
                      }
                    }
                    else
                    {
                      net_info_available = nasi_convert_mm_info_oper_name(
                                             name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                             name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_encoding,
                                             (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description,
                                             &encoding_type,
                                             NASI_MAX_LEN_NETWORK_NAME,
                                             (uint8)name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len);
                      if( (encoding_type == NAS_CODING_SCHEME_UCS2_V01) ||
                          (name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                        )
                      {
                        network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len);
                      }
                      else
                      {
                        network_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NAS_PLMN_NAME_MAX_V01 ));
                      }
                    }
                  }
                  else
                  {
                    if ( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                    {
                      network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                  name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                                  buff_ptr,
                                                                                  NASI_MAX_LEN_NETWORK_NAME/2 );
                      memscpy( (void*)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                      if ( network_name_len > 0 )
                      {
                        net_info_available = TRUE;
                      }
                    }
                    else
                    {
                    net_info_available = nasi_convert_mm_info_oper_name(
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding,
                                           (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description,
                                           &encoding_type,
                                           NASI_MAX_LEN_NETWORK_NAME,
                                           (uint8)name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len);
                      if( (encoding_type == NAS_CODING_SCHEME_UCS2_V01) ||
                          (name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                        )
                      {
                        network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len);
                      }
                      else
                      {
                        network_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NAS_PLMN_NAME_MAX_V01 ));
                      }
                    }
                  }

                  rsp_msg->nw_name_source[network_info_index] = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( name_cnf->plmn_list.plmn_info_ptr[i].plmn_name_source );
                  }
                }
              }
            }

          if( !net_info_available)
          {
             QM_MSG_HIGH_1("Could not get Network name for PLN index %d. Sending only mcc,mnc", sys_plmn_list_index);
          }
      

          // TLV 0x11 (Network Radio Access Technology)
          rsp_msg->nas_network_radio_access_technology[network_info_index].mcc = (uint16) mcc;
          rsp_msg->nas_network_radio_access_technology[network_info_index].mnc = (uint16) mnc;

          #ifndef FEATURE_MMODE_QMI_LTE_ONLY
          switch ( available_networks->info[sys_plmn_list_index].rat )
          {
            #ifdef FEATURE_GSM
            case SYS_RAT_GSM_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_GSM;
              break;
            #endif

            #ifdef FEATURE_WCDMA
            case SYS_RAT_UMTS_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_UMTS;
              break;
            #endif

            #ifdef FEATURE_LTE
            case SYS_RAT_LTE_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_LTE;

              #if defined(FEATURE_CIOT)
              rsp_msg->lte_op_mode[lte_op_mode_len].mcc = (uint16) mcc;
              rsp_msg->lte_op_mode[lte_op_mode_len].mnc = (uint16)mnc;
              rsp_msg->lte_op_mode[lte_op_mode_len].lte_op_mode =
                     qmi_nas_map_camped_lte_mode_cm_to_qmi(available_networks->info[sys_plmn_list_index].ciot_lte_mode);
              
              lte_op_mode_len++;
              #endif
              break;
            #endif

            #ifdef FEATURE_TDSCDMA
            case SYS_RAT_TDS_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_TDSCDMA;
              break;
            #endif

             default:
               break;
          }
          #else
          if( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS )
          {
             rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_LTE;
             
             #if defined(FEATURE_CIOT)
             rsp_msg->lte_op_mode[lte_op_mode_len].mcc =(uint16) mcc;
             rsp_msg->lte_op_mode[lte_op_mode_len].mnc =(uint16) mnc;
             rsp_msg->lte_op_mode[lte_op_mode_len].lte_op_mode =
                    qmi_nas_map_camped_lte_mode_cm_to_qmi(available_networks->info[sys_plmn_list_index].ciot_lte_mode);
             
             lte_op_mode_len++;
             #endif
          }
          else
          {

             QM_MSG_HIGH("RAT is not LTE");
          }
          #endif
          // End of TLV 0x11

          // TLV 0x12 (MNC PCS digit include status)
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mcc = (uint16) mcc;
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mnc = (uint16) mnc;
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mnc_includes_pcs_digit = mnc_includes_pcs_digit;
          // End of TLV 0x12

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
          if ( qm_efs_csg_supported() )
          {
          // TLV 0x14 (CSG Information)
          QM_MSG_HIGH_1("Efs csg supported with csg_id=%d", available_networks->info[sys_plmn_list_index].csg_info.csg_id);
          if( available_networks->info[sys_plmn_list_index].csg_info.csg_id != SYS_CSG_ID_INVALID )
          {
            rsp_msg->csg_info[network_info_index].mcc = (uint16) mcc;
            rsp_msg->csg_info[network_info_index].mnc = (uint16) mnc;
            rsp_msg->csg_info[network_info_index].csg_info.id = available_networks->info[sys_plmn_list_index].csg_info.csg_id;
            rsp_msg->csg_info[network_info_index].csg_info.name_len = MIN(available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length, NAS_CSG_NAME_MAX_LEN);
            memscpy(rsp_msg->csg_info[network_info_index].csg_info.name, 
                    rsp_msg->csg_info[network_info_index].csg_info.name_len,
                    available_networks->info[sys_plmn_list_index].csg_info.hnb_name.name, 
                    rsp_msg->csg_info[network_info_index].csg_info.name_len);

            //TLV 0x15
            rsp_msg->csg_sig_info[network_info_index].mcc = (uint16) mcc;
            rsp_msg->csg_sig_info[network_info_index].mnc = (uint16) mnc;
            rsp_msg->csg_sig_info[network_info_index].csg_id = available_networks->info[sys_plmn_list_index].csg_info.csg_id;
            rsp_msg->csg_sig_info[network_info_index].signal_strength = available_networks->info[sys_plmn_list_index].signal_strength;
            switch( available_networks->info[sys_plmn_list_index].list_category )
            {
              case SYS_DETAILED_PLMN_LIST_ALLOWED_CSG:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_ALLOWED;
                break;
              case SYS_DETAILED_PLMN_LIST_OPERATOR_CSG:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_OPERATOR;
                break;
              default:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_UNKNOWN;
                break;
            }
            QM_MSG_HIGH_3("network %d, csg_id %d, name_len %d", sys_plmn_list_index, available_networks->info[sys_plmn_list_index].csg_info.csg_id, available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length);
          }
          }
#endif
#else
        QM_MSG_HIGH("FEATURE_FEMTO_CSG undefined");
#endif

          // Increment network_info_index
          network_info_index++;
        }
        else
        {
          QM_MSG_HIGH_1("PLMN for index %d undefined", sys_plmn_list_index);
        }
      } // End for (all PLMNs in the list populated)

      // Update the # of instances for TLVs 0x10, 0x11, and 0x12
      rsp_msg->nas_3gpp_network_info_len                       = network_info_index;
      rsp_msg->nas_network_radio_access_technology_len = network_info_index;
      rsp_msg->mnc_includes_pcs_digit_len                       = network_info_index;
      #ifdef FEATURE_FEMTO_CSG
      #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      rsp_msg->csg_info_len                                             = network_info_index;
      rsp_msg->csg_sig_info_len                                       = network_info_index;
      #endif
      #endif
      rsp_msg->nw_name_source_len                                = network_info_index;

      #if defined(FEATURE_CIOT)
      rsp_msg->lte_op_mode_len = lte_op_mode_len;
      #endif
      
      if ( errval == QMI_ERR_NONE )
      {
        // TLV 0x10 will be available at all times. including for num_instances = 0
        // (Gobi backward compatibility)
        rsp_msg->nas_3gpp_network_info_valid = TRUE;

        if( rsp_msg->nas_network_radio_access_technology_len )
        {
          rsp_msg->nas_network_radio_access_technology_valid = TRUE;
        }

        if( rsp_msg->mnc_includes_pcs_digit_len )
        {
          rsp_msg->mnc_includes_pcs_digit_valid = TRUE;
        }

        if( rsp_msg->lte_op_mode_len )
        {
          rsp_msg->lte_op_mode_valid = TRUE;
          QM_MSG_HIGH_1("lte_op_mode_valid and len %d", rsp_msg->lte_op_mode_len);
        }
        
#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
        if ( qm_efs_csg_supported() )
        {
        if( rsp_msg->csg_info_len && (available_networks->info[0].csg_info.csg_id != SYS_CSG_ID_INVALID) )
        {
          rsp_msg->csg_info_valid = TRUE;
        }
        QM_MSG_HIGH_2("TLV 0x15 len=%d,csg_id=%d", rsp_msg->csg_sig_info_len, available_networks->info[0].csg_info.csg_id); 
        if( rsp_msg->csg_sig_info_len && (available_networks->info[0].csg_info.csg_id != SYS_CSG_ID_INVALID) )
        {
          rsp_msg->csg_sig_info_valid = TRUE;
        }
        }
#endif
#endif

        rsp_msg->scan_result_valid = TRUE;
        rsp_msg->scan_result = (nas_scan_result_enum_v01)QMI_NAS_SCAN_SUCCESS;

        if ( rsp_msg->nw_name_source_len )
        {
          rsp_msg->nw_name_source_valid = TRUE;
        }
      }

      // Populate TLV 0x02 (Mandatory error code)
      rsp_msg->resp.result  = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;
      rsp_msg->resp.error   = (qmi_error_type_v01)errval;

      response = NULL;

      if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                         QMI_IDL_RESPONSE,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         (void *) rsp_msg,
                                         (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
                                         &response
                                       ) )
      {
        if( !qmi_nasi_send_response(cmd_buf_p, response) )
        {
          qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );

        }
      }
      else
      {
        dsm_free_packet(&response);
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p);
      }
    } // End if
  }// end while (cmd buf queue is empty)

  if ( available_networks != NULL )
  {
    modem_mem_free( available_networks, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  if ( callback_data != NULL )
  {
    modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
  }

  if ( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#else

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_NETWORK_SCAN_RESP()

  DESCRIPTION
    Generate response for perform network scan after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_perform_network_scan_resp(   sys_detailed_plmn_list_s_type *available_networks,mmgsdi_session_get_operator_name_info_type *operator_name_info )
{
  //struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_mmode_qcsi_transaction_type                     *cmd_buf_p = NULL;
  nas_perform_network_scan_resp_msg_v01                *rsp_msg   = NULL;
  dsm_item_type *                       response   = NULL;

  qmi_error_e_type       errval = QMI_ERR_NONE;

  boolean is_plmn_undefined      = FALSE;
  boolean mnc_includes_pcs_digit = FALSE;
  boolean net_info_available     = FALSE;
  boolean rat_match              = FALSE, rat_match_2 = FALSE;

  int          sys_plmn_list_index = 0;
  int          network_info_index  = 0;
  int          num_networks        = 0;
  sys_mcc_type mcc                 = 0;
  sys_mnc_type mnc                 = 0;
  uint32          i                   = 0;
  uint8 encoding_type = 0;
  int j = 0;
  uint8 network_name_len = 0;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  boolean is_plmn_2_valid=FALSE;
  sys_plmn_id_s_type current_plmn_2; //initialized for each cmd_buffer
    sys_sys_mode_e_type current_sys_mode_2 = SYS_SYS_MODE_NONE;
  #endif
  sys_sys_mode_e_type current_sys_mode = SYS_SYS_MODE_NONE;
  sys_plmn_id_s_type current_plmn;

  // Initialize for SYS_MODEM_AS_ID_1
  sys_plmn_id_s_type plmn_main_stack = qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].mm_information.plmn_avail ?
                                              qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].mm_information.plmn :
                                              qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].sys_id.id.plmn ;
 
  sys_sys_mode_e_type sys_mode_main_stack = qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].sys_mode;
  sys_sys_mode_e_type sys_mode_gw_stack   = SYS_SYS_MODE_NONE;

  sys_srv_status_e_type main_stack_srv = qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].srv_status;
  sys_srv_status_e_type gw_stack_srv = SYS_SRV_STATUS_NO_SRV;
  #if defined(FEATURE_CIOT)
  uint8   lte_op_mode_len = 0;
  #endif

  // Clear pending network scan global var
  qmi_nasi_global.net_scan_started = FALSE;

  QM_MSG_HIGH_2("generate_perform_network_scan main_stack = %d,srv=%d", sys_mode_main_stack, main_stack_srv);  
  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
      qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )
  {
    sys_mode_gw_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode;
    gw_stack_srv = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].srv_status;
    QM_MSG_HIGH_2("generate_perform_network_scan gw_stack = %d,srv=%d", sys_mode_gw_stack, gw_stack_srv);
  }
  #endif
  rsp_msg = ( nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  /*callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    available_networks = (sys_detailed_plmn_list_s_type *) callback_data->cmd_buf_ptr;
  }
  else
  {
    QM_MSG_ERROR("qmi_nasi_generate_perform_network_scan_resp - callback_data is NULL!");
    errval = QMI_ERR_INTERNAL;
  }*/

  if( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_NW_SCAN );

  while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    response = NULL;
    network_info_index  = 0;

    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      QM_MSG_ERROR("Queued buffer does not match existing client transaction");
      continue;
    }

    if( errval == QMI_ERR_NONE)
    {
      memset(rsp_msg, 0, sizeof(nas_perform_network_scan_resp_msg_v01));

      // Update current PLMN based on subscription
#ifdef FEATURE_DUAL_SIM
      if( ((qmi_nasi_client_state_type*)cmd_buf_p->clnt_info_ptr)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
      {
        current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_id.id.plmn ;
        current_sys_mode = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_mode;
      }
      else
#endif
#ifdef FEATURE_TRIPLE_SIM    
      if( ((qmi_nasi_client_state_type*)cmd_buf_p->clnt_info_ptr)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
      {
        current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].sys_id.id.plmn ;
        current_sys_mode = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].sys_mode;
      }
      else
#endif
      {
        #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE)) && (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
        if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
            qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )        
        {
          current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn_avail ?
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn :
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_id.id.plmn ;;
          current_sys_mode = sys_mode_gw_stack;

          if( (sys_mode_main_stack == SYS_SYS_MODE_GSM || sys_mode_main_stack == SYS_SYS_MODE_WCDMA || sys_mode_main_stack == SYS_SYS_MODE_TDS || sys_mode_main_stack == SYS_SYS_MODE_LTE) && 
              (main_stack_srv == SYS_SRV_STATUS_SRV) )
          {
            current_plmn_2 = plmn_main_stack;
            current_sys_mode_2 = sys_mode_main_stack;
            is_plmn_2_valid = TRUE;
            QM_MSG_HIGH_1("generate_perform_network_scan is_plmn_2_valid = %d", is_plmn_2_valid);
          }
        }
        else
        #endif
        {
          current_plmn = plmn_main_stack;
          current_sys_mode = sys_mode_main_stack;
        }
      }

      if( available_networks->length > NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX )
      {
        QM_MSG_ERROR_2("Received %d available networks, max is %d", available_networks->length, NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX);
        num_networks = NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX;
      }
      else
      {
        num_networks = available_networks->length;
      }
      // For every PLMN value in the list of available networks fill in TLVs
      // 0x10, 0x11, and 0x12
      for(sys_plmn_list_index=0; sys_plmn_list_index < num_networks; sys_plmn_list_index++)
      {
        net_info_available = FALSE;

        sys_plmn_get_mcc_mnc(available_networks->info[sys_plmn_list_index].plmn,
                             &is_plmn_undefined,
                             &mnc_includes_pcs_digit,
                             &mcc,
                             &mnc );
        if(!is_plmn_undefined)
        {
          // TLV 0x10 (3GPP NETWORK INFORMATION)
          rsp_msg->nas_3gpp_network_info[network_info_index].mobile_country_code = (uint16) mcc;
          rsp_msg->nas_3gpp_network_info[network_info_index].mobile_network_code = (uint16) mnc;

          rat_match = FALSE, rat_match_2 = FALSE;
          switch ( current_sys_mode )
          {
            #ifndef FEATURE_MMODE_QMI_LTE_ONLY
            case SYS_SYS_MODE_GSM:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
              break;
            #ifdef FEATURE_WCDMA
            case SYS_SYS_MODE_WCDMA:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
              break;
            #endif
            #ifdef FEATURE_TDSCDMA
            case SYS_SYS_MODE_TDS:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
              break;
            #endif
            #endif
            
            case SYS_SYS_MODE_LTE:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
              break;
            default:
              QM_MSG_ERROR_1("generate_perform_network_scan no rat match current_sys_mode = %d", current_sys_mode);
              break;
          }
          #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
          if( is_plmn_2_valid )
          {
            switch ( current_sys_mode_2 )
          {
              case SYS_SYS_MODE_GSM:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
                break;
              case SYS_SYS_MODE_WCDMA:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
                break;
              case SYS_SYS_MODE_LTE:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
                break;
              case SYS_SYS_MODE_TDS:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
                break;
              default:
                QM_MSG_MED_1("generate_perform_network_scan no rat match current_sys_mode_2 = %d", current_sys_mode_2);
              break;
          }
          }
          current_plmn_2 = plmn_main_stack;
          #endif
          if( sys_plmn_match( current_plmn, available_networks->info[sys_plmn_list_index].plmn) &&  rat_match )
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
          }
          #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
          else if (is_plmn_2_valid && rat_match_2 &&
                   sys_plmn_match( current_plmn_2, available_networks->info[sys_plmn_list_index].plmn))
            {
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
            }
          #endif
          else
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_AVAILABLE_MASK;
          }

          switch (available_networks->info[sys_plmn_list_index].list_category)
          {
            case SYS_DETAILED_PLMN_LIST_CATEGORY_HPLMN:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_HOME_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
              break;

            case SYS_DETAILED_PLMN_LIST_CATEGORY_PREFERRED:
            case SYS_DETAILED_PLMN_LIST_CATEGORY_USER_PREFERRED:
            case SYS_DETAILED_PLMN_LIST_CATEGORY_OPERATOR_PREFERRED:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
                break;

            case SYS_DETAILED_PLMN_LIST_CATEGORY_OTHER:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_PREFERRED_MASK;
                break;

            default:
                QM_MSG_HIGH_2("Unhandled list_category (%d) for available networks.info[%d]", available_networks->info[sys_plmn_list_index].list_category, sys_plmn_list_index);
                break;
          }

          if(available_networks->info[sys_plmn_list_index].plmn_forbidden)
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_FORBIDDEN_MASK;
          }
          else
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_FORBIDDEN_MASK;
          }

          //if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
          { 
            mmgsdi_plmn_info_static_type operator_plmn;
            mmgsdi_plmn_info_static_type *operator_plmn_info=NULL;
            if( operator_name_info->plmn_info_ptr != NULL )
            {
              for( i = 0; i < available_networks->length; i++ )
              {
                memset(&operator_plmn, 0, sizeof(mmgsdi_plmn_info_static_type));
                operator_plmn_info=operator_name_info->plmn_info_ptr;
                memscpy( &operator_plmn, sizeof(mmgsdi_plmn_info_static_type), (void*)operator_plmn_info, sizeof(mmgsdi_plmn_info_static_type) );
                if ( !memcmp( operator_plmn.plmn_id.plmn_id_val, available_networks->info[sys_plmn_list_index].plmn.identity, sizeof(sys_plmn_id_s_type) ) &&
                      qmi_nas_compare_mmgsdi_cm_network_rat( operator_plmn.plmn_id.rat, available_networks->info[sys_plmn_list_index].rat ) )
                {
                  QM_MSG_HIGH_3("Perform net scan PLMN index %d, len %d, encoding %d", i, operator_plmn.plmn_short_name.plmn_data_len, operator_plmn.plmn_short_name.plmn_encoding);

                  if ( qm_efs_always_return_plmn() )
                  {
                    if ( operator_plmn.plmn_short_name.plmn_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                    {
                      network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( operator_plmn.plmn_long_name.plmn_data,
                                                                                  operator_plmn.plmn_long_name.plmn_data_len,
                                                                                  buff_ptr,
                                                                                  NASI_MAX_LEN_NETWORK_NAME/2 );
                      memscpy( (void*)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                      if ( network_name_len > 0 )
                      {
                        net_info_available = TRUE;
                      }
                    }
                    else
                    {
                      net_info_available = nasi_convert_mm_info_oper_name(
                                             operator_plmn.plmn_long_name.plmn_data,
                                             operator_plmn.plmn_long_name.plmn_encoding,
                                             (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description,
                                             &encoding_type,
                                             NASI_MAX_LEN_NETWORK_NAME,
                                             (uint8)operator_plmn.plmn_long_name.plmn_data_len);
                      if( (encoding_type == NAS_CODING_SCHEME_UCS2_V01) ||
                          (operator_plmn.plmn_long_name.plmn_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                        )
                      {
                        network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, operator_plmn.plmn_long_name.plmn_data_len);
                      }
                      else
                      {
                        network_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NAS_PLMN_NAME_MAX_V01 ));
                      }
                    }
                  }
                  else
                  {
                    if ( operator_plmn.plmn_short_name.plmn_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                    {
                      network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( operator_plmn.plmn_short_name.plmn_data,
                                                                                  operator_plmn.plmn_short_name.plmn_data_len,
                                                                                  buff_ptr,
                                                                                  NASI_MAX_LEN_NETWORK_NAME/2 );
                      memscpy( (void*)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                      if ( network_name_len > 0 )
                      {
                        net_info_available = TRUE;
                      }
                    }
                    else
                    {
                    net_info_available = nasi_convert_mm_info_oper_name(
                                           operator_plmn.plmn_short_name.plmn_data,
                                           operator_plmn.plmn_short_name.plmn_encoding,
                                           (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description,
                                           &encoding_type,
                                           NASI_MAX_LEN_NETWORK_NAME,
                                           (uint8)operator_plmn.plmn_short_name.plmn_data_len);
                      if( (encoding_type == NAS_CODING_SCHEME_UCS2_V01) ||
                          (operator_plmn.plmn_short_name.plmn_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                        )
                      {
                        network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, operator_plmn.plmn_short_name.plmn_data_len);
                      }
                      else
                      {
                        network_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NAS_PLMN_NAME_MAX_V01 ));
                      }
                    }
                  }

                  rsp_msg->nw_name_source[network_info_index] = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( operator_plmn.plmn_name_source );
                  }
                  operator_plmn_info++;
                }
              }
            }

          if( !net_info_available)
          {
             QM_MSG_HIGH_1("Could not get Network name for PLN index %d. Sending only mcc,mnc", sys_plmn_list_index);
          }
      

          // TLV 0x11 (Network Radio Access Technology)
          rsp_msg->nas_network_radio_access_technology[network_info_index].mcc = (uint16) mcc;
          rsp_msg->nas_network_radio_access_technology[network_info_index].mnc = (uint16) mnc;

          #ifndef FEATURE_MMODE_QMI_LTE_ONLY
          switch ( available_networks->info[sys_plmn_list_index].rat )
          {
            #ifdef FEATURE_GSM
            case SYS_RAT_GSM_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_GSM;
              break;
            #endif

            #ifdef FEATURE_WCDMA
            case SYS_RAT_UMTS_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_UMTS;
              break;
            #endif

            #ifdef FEATURE_LTE
            case SYS_RAT_LTE_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_LTE;

              #if defined(FEATURE_CIOT)
              rsp_msg->lte_op_mode[lte_op_mode_len].mcc = (uint16) mcc;
              rsp_msg->lte_op_mode[lte_op_mode_len].mnc = (uint16)mnc;
              rsp_msg->lte_op_mode[lte_op_mode_len].lte_op_mode =
                     qmi_nas_map_camped_lte_mode_cm_to_qmi(available_networks->info[sys_plmn_list_index].ciot_lte_mode);
              
              lte_op_mode_len++;
              #endif
              break;
            #endif

            #ifdef FEATURE_TDSCDMA
            case SYS_RAT_TDS_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_TDSCDMA;
              break;
            #endif

             default:
               break;
          }
          #else
          if( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS )
          {
             rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_LTE;
             
             #if defined(FEATURE_CIOT)
             rsp_msg->lte_op_mode[lte_op_mode_len].mcc =(uint16) mcc;
             rsp_msg->lte_op_mode[lte_op_mode_len].mnc =(uint16) mnc;
             rsp_msg->lte_op_mode[lte_op_mode_len].lte_op_mode =
                    qmi_nas_map_camped_lte_mode_cm_to_qmi(available_networks->info[sys_plmn_list_index].ciot_lte_mode);
             
             lte_op_mode_len++;
             #endif
          }
          else
          {

             QM_MSG_HIGH("RAT is not LTE");
          }
          #endif
          // End of TLV 0x11

          // TLV 0x12 (MNC PCS digit include status)
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mcc = (uint16) mcc;
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mnc = (uint16) mnc;
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mnc_includes_pcs_digit = mnc_includes_pcs_digit;
          // End of TLV 0x12

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
          if ( qm_efs_csg_supported() )
          {
          // TLV 0x14 (CSG Information)
          QM_MSG_HIGH_1("Efs csg supported with csg_id=%d", available_networks->info[sys_plmn_list_index].csg_info.csg_id);
          if( available_networks->info[sys_plmn_list_index].csg_info.csg_id != SYS_CSG_ID_INVALID )
          {
            rsp_msg->csg_info[network_info_index].mcc = (uint16) mcc;
            rsp_msg->csg_info[network_info_index].mnc = (uint16) mnc;
            rsp_msg->csg_info[network_info_index].csg_info.id = available_networks->info[sys_plmn_list_index].csg_info.csg_id;
            rsp_msg->csg_info[network_info_index].csg_info.name_len = MIN(available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length, NAS_CSG_NAME_MAX_LEN);
            memscpy(rsp_msg->csg_info[network_info_index].csg_info.name, 
                    rsp_msg->csg_info[network_info_index].csg_info.name_len,
                    available_networks->info[sys_plmn_list_index].csg_info.hnb_name.name, 
                    rsp_msg->csg_info[network_info_index].csg_info.name_len);

            //TLV 0x15
            rsp_msg->csg_sig_info[network_info_index].mcc = (uint16) mcc;
            rsp_msg->csg_sig_info[network_info_index].mnc = (uint16) mnc;
            rsp_msg->csg_sig_info[network_info_index].csg_id = available_networks->info[sys_plmn_list_index].csg_info.csg_id;
            rsp_msg->csg_sig_info[network_info_index].signal_strength = available_networks->info[sys_plmn_list_index].signal_strength;
            switch( available_networks->info[sys_plmn_list_index].list_category )
            {
              case SYS_DETAILED_PLMN_LIST_ALLOWED_CSG:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_ALLOWED;
                break;
              case SYS_DETAILED_PLMN_LIST_OPERATOR_CSG:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_OPERATOR;
                break;
              default:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_UNKNOWN;
                break;
            }
            QM_MSG_HIGH_3("network %d, csg_id %d, name_len %d", sys_plmn_list_index, available_networks->info[sys_plmn_list_index].csg_info.csg_id, available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length);
          }
          }
#endif
#else
        QM_MSG_HIGH("FEATURE_FEMTO_CSG undefined");
#endif

          // Increment network_info_index
          network_info_index++;
        }
        else
        {
          QM_MSG_HIGH_1("PLMN for index %d undefined", sys_plmn_list_index);
        }
      } // End for (all PLMNs in the list populated)

      // Update the # of instances for TLVs 0x10, 0x11, and 0x12
      rsp_msg->nas_3gpp_network_info_len                       = network_info_index;
      rsp_msg->nas_network_radio_access_technology_len = network_info_index;
      rsp_msg->mnc_includes_pcs_digit_len                       = network_info_index;
      #ifdef FEATURE_FEMTO_CSG
      #if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      rsp_msg->csg_info_len                                             = network_info_index;
      rsp_msg->csg_sig_info_len                                       = network_info_index;
      #endif
      #endif
      rsp_msg->nw_name_source_len                                = network_info_index;

      #if defined(FEATURE_CIOT)
      rsp_msg->lte_op_mode_len = lte_op_mode_len;
      #endif
      
      if ( errval == QMI_ERR_NONE )
      {
        // TLV 0x10 will be available at all times. including for num_instances = 0
        // (Gobi backward compatibility)
        rsp_msg->nas_3gpp_network_info_valid = TRUE;

        if( rsp_msg->nas_network_radio_access_technology_len )
        {
          rsp_msg->nas_network_radio_access_technology_valid = TRUE;
        }

        if( rsp_msg->mnc_includes_pcs_digit_len )
        {
          rsp_msg->mnc_includes_pcs_digit_valid = TRUE;
        }

        if( rsp_msg->lte_op_mode_len )
        {
          rsp_msg->lte_op_mode_valid = TRUE;
          QM_MSG_HIGH_1("lte_op_mode_valid and len %d", rsp_msg->lte_op_mode_len);
        }
        
#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
        if ( qm_efs_csg_supported() )
        {
        if( rsp_msg->csg_info_len && (available_networks->info[0].csg_info.csg_id != SYS_CSG_ID_INVALID) )
        {
          rsp_msg->csg_info_valid = TRUE;
        }
        QM_MSG_HIGH_2("TLV 0x15 len=%d,csg_id=%d", rsp_msg->csg_sig_info_len, available_networks->info[0].csg_info.csg_id); 
        if( rsp_msg->csg_sig_info_len && (available_networks->info[0].csg_info.csg_id != SYS_CSG_ID_INVALID) )
        {
          rsp_msg->csg_sig_info_valid = TRUE;
        }
        }
#endif
#endif

        rsp_msg->scan_result_valid = TRUE;
        rsp_msg->scan_result = (nas_scan_result_enum_v01)QMI_NAS_SCAN_SUCCESS;

        if ( rsp_msg->nw_name_source_len )
        {
          rsp_msg->nw_name_source_valid = TRUE;
        }
      }

      // Populate TLV 0x02 (Mandatory error code)
      rsp_msg->resp.result  = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;
      rsp_msg->resp.error   = (qmi_error_type_v01)errval;

      response = NULL;

      if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                         QMI_IDL_RESPONSE,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         (void *) rsp_msg,
                                         (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
                                         &response
                                       ) )
      {
        if( !qmi_nasi_send_response(cmd_buf_p, response) )
        {
          qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );

        }
      }
      else
      {
        dsm_free_packet(&response);
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p);
      }
    } // End if
  }// end while (cmd buf queue is empty)

  if ( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#endif
#ifndef FEATURE_MMODE_DISABLE_UIM
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_HOME_NETWORK_RESPONSE()

  DESCRIPTION
    Generate Get_home_network response after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_home_network_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf )
    {
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_mmode_qcsi_transaction_type                     *cmd_buf_p = NULL;
  dsm_item_type                        *response  = NULL;
  qmi_error_e_type                      errval = QMI_ERR_NONE;

   nas_get_home_network_resp_msg_v01  *resp_msg;

  struct qmi_nas_mmgsdi_cache_s *p_cache; // shorthand
  qmi_nas_mmgsdi_session_e_type  qmi_session = QMI_NAS_MMGSDI_SESSION_MAX;
  sys_plmn_id_s_type             home_plmn_id;
  boolean                        mnc_includes_pcs_digit = FALSE;
  uint8                          plmn_name_short_encoding;
  uint32 j = 0;

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if ( callback_data != NULL )
  {
    cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) callback_data->cmd_buf_ptr;
    if (!qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
    {
    if( callback_data != NULL )
    {
        modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
    }
      return;
    }
  }
  else
  {
    ASSERT(0);
    return;
  }

  resp_msg = (nas_get_home_network_resp_msg_v01 *) 
      modem_mem_alloc( sizeof( nas_get_home_network_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if( resp_msg == NULL)
  {
      qmi_voice_mem_error();
    if( callback_data != NULL )
       {
         modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
       }
    return;
  }
  
  memset(resp_msg, 0, sizeof(nas_get_home_network_resp_msg_v01));

  // Update current PLMN based on subscription
  switch ( ((qmi_nasi_client_state_type*)cmd_buf_p->clnt_info_ptr)->report_status.bound_subs )
  {
  case QMI_NAS_SUBS_PRIMARY:
    qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
    break;
#ifdef FEATURE_DUAL_SIM
  case QMI_NAS_SUBS_SECONDARY:
    qmi_session = QMI_NAS_MMGSDI_GW_SEC_SESSION;
    break;
#endif
#ifdef FEATURE_TRIPLE_SIM    
  case QMI_NAS_SUBS_TERTIARY:
    qmi_session = QMI_NAS_MMGSDI_GW_TER_SESSION;
    break;
#endif
  default:
    MSG_ERROR("Invalid subs %d", ((qmi_nasi_client_state_type*)cmd_buf_p->clnt_info_ptr)->report_status.bound_subs, 0, 0);
    break;
  }

  /*-----------------------------------------------------------------------
    Home MCC & MNC should be available by now. Copy from global to local
  -----------------------------------------------------------------------*/
  if ( qmi_nas_mmgsdi_is_valid_qmi_session(qmi_session) )
  {
    p_cache = &qmi_nasi_global.mmgsdi->cache[qmi_session]; // shorthand

    if ( p_cache->ef_ad_valid   == QMI_NAS_MMGSDI_VALID &&
         p_cache->ef_imsi_valid == QMI_NAS_MMGSDI_VALID )
    {
      if ( p_cache->ef_imsi[0] == 0xFF && p_cache->ef_imsi[1] == 0xFF && p_cache->ef_imsi[2] == 0xFF )
      {
        QM_MSG_ERROR("Invalid IMSI");
        errval = QMI_ERR_INTERNAL;
      }
      else
      {
        resp_msg->home_network.mobile_country_code = (100 * QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[1])) + (10 * QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[2])) + QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[2]);
        resp_msg->home_network.mobile_network_code = (10 * QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[3])) + QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[3]);
  
        // if EF_AD size is 4 or more, 4th byte carries MNC length info
        // marked as optional in 3GPP TS 11.11 V8.14.0 cl. 10.3.18 EFAD
        // marked as mandatory in 3GPP TS 31.102 V8.8.0 cl. 4.2.18 EFAD
        if ( p_cache->ef_ad_size >= 4 )
        {
          if ( (p_cache->ef_ad[3] & 0x0F) == 0x03 ) // MNC length is 3
          {
            resp_msg->home_network.mobile_network_code = (10 * resp_msg->home_network.mobile_network_code) + QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[4]);
            mnc_includes_pcs_digit = TRUE;
          }
        }
  
        resp_msg->nas_3gpp_mcs_include_digit.is_3gpp_network            = TRUE;
  
        if( resp_msg->home_network.mobile_network_code > 99 )
        {
          resp_msg->nas_3gpp_mcs_include_digit.mnc_includes_pcs_digit  = TRUE;
        }
        else
        {
          resp_msg->nas_3gpp_mcs_include_digit.mnc_includes_pcs_digit  = FALSE;
        }
  
        resp_msg->nas_3gpp_mcs_include_digit_valid = TRUE;
      }
    }
    else
    {
      errval = QMI_ERR_NOT_PROVISIONED;
    }
  }
  else
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( sys_plmn_set_mcc_mnc(mnc_includes_pcs_digit, resp_msg->home_network.mobile_country_code, resp_msg->home_network.mobile_network_code, &home_plmn_id) == TRUE )
    {
      if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
      {
        if( name_cnf->plmn_list.num_of_plmn_ids > 0 && name_cnf->plmn_list.plmn_info_ptr != NULL )
        {
          QM_MSG_HIGH_2("get home network len %d, encoding %d", name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding);
          for( j=0; j<name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len; j++ )
          {
            QM_MSG_HIGH_1("%d", name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr[j]);
          }

          if ( qm_efs_always_return_plmn() )
          {
            if ( !nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding,
                                                 (char *) resp_msg->home_network.network_description,
                                                 &plmn_name_short_encoding,
                                                 NAS_NETWORK_DESCRIPTION_MAX_V01,
                                                 (uint8)name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len ) )

            {
              QM_MSG_ERROR("qmi_nasi_generate_get_home_network_resp: decoding failed, sending encoded name in response");
              memscpy( resp_msg->home_network.network_description, name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr, 
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len );
            }
          }
          else
          {
            if ( !nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding,
                                                 (char *) resp_msg->home_network.network_description,
                                                 &plmn_name_short_encoding,
                                                 NAS_NETWORK_DESCRIPTION_MAX_V01,
                                                 (uint8)(name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len ) ))
  
            {
              QM_MSG_ERROR("qmi_nasi_generate_get_home_network_resp: decoding failed, sending encoded name in response");
            memscpy( resp_msg->home_network.network_description, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len,
                     name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr, 
                     name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len );
            }
          }

          resp_msg->nas_3gpp_nw_name_source_valid = TRUE;
          resp_msg->nas_3gpp_nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( name_cnf->plmn_list.plmn_info_ptr[0].plmn_name_source );
        }
      }
    }
  }

  resp_msg->resp.error  = (qmi_error_type_v01)errval;
  resp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;

  if( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t) QMI_NAS_GET_HOME_NETWORK_RESP_MSG_V01,
                                (void *)resp_msg,
                                (uint32_t)sizeof(nas_get_home_network_resp_msg_v01),
                                &response
                              ) )
  {
    if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
       /*Unable to send GET PLMN NAME response*/
      qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }

  }

  if( resp_msg != NULL ) { modem_mem_free( resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if( callback_data != NULL ) { modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE ); }

}
#endif
#if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_RTRE_CONFIG_IND()

  DESCRIPTION
    Generate RTRE config indication

  PARAMETERS
    cm_ph_info_s_type *p_ph_info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_rtre_config_ind(
    qmi_cm_ph_info_s_type *p_ph_info
)
{
  qmi_nasi_client_state_type *cl_sp;
  dsm_item_type              *ind;

  struct nas_006A_ind_s rtre_config_ind_msg;

  memset( &rtre_config_ind_msg, 0x00, sizeof(rtre_config_ind_msg));

  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {
    if ( cl_sp->report_status.report_rtre_config)
    {
      //Check if the ind is to be sent
      if ( p_ph_info->rtre_control != qmi_nasi_global.cm_ph_info.rtre_control ||
           p_ph_info->rtre_config  != qmi_nasi_global.cm_ph_info.rtre_config )
      {
        // Send both TLVs whenever sending this indication
        rtre_config_ind_msg.t10_valid    = TRUE;
        rtre_config_ind_msg.t11_valid    = TRUE;

        // TLV 0x10
        switch( p_ph_info->rtre_control )
        {
          case CM_RTRE_CONTROL_RUIM:
            rtre_config_ind_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_RUIM_ONLY;
            break;
          case CM_RTRE_CONTROL_NV:
            rtre_config_ind_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
            break;
          case CM_RTRE_CONTROL_SIM:
            rtre_config_ind_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_GSM_ON_1X;
            break;
          default:
            // Unkown RTRE CFG value. Not including the TLV
            QM_MSG_HIGH_1("Unkown rtre control value: %d.", p_ph_info->rtre_control);
            rtre_config_ind_msg.t10_valid    = FALSE;
            break;
        }

        // TLV 0x11
        switch( p_ph_info->rtre_config )
        {
          case CM_RTRE_CONFIG_RUIM_ONLY:
            rtre_config_ind_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_RUIM_ONLY;
            break;
          case CM_RTRE_CONFIG_NV_ONLY:
            rtre_config_ind_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
            break;
          case CM_RTRE_CONFIG_RUIM_OR_DROP_BACK:
            rtre_config_ind_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_RUIM_IF_AVAIL;
            break;
          case CM_RTRE_CONFIG_SIM_ACCESS:
            rtre_config_ind_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_GSM_ON_1X;
            break;
          default:
            // Error in Getting  rtre_pref data
            QM_MSG_HIGH_1("Unkown rtre config value: %d", p_ph_info->rtre_config);
            rtre_config_ind_msg.t11_valid    = FALSE;
            break;
        }
      }
      if( rtre_config_ind_msg.t10_valid || rtre_config_ind_msg.t11_valid)
      {
        ind = NULL;

        if( qmi_nas_006A_ind_write ( &rtre_config_ind_msg, &ind) == QMI_ERR_NONE  )
        {
          (void)qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_RTRE_CONFIG_IND, ind );
        }
      }
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }
} //qmi_nas_generate_rtre_config_ind
#endif
#ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_MANAGED_ROAMING_CONFIG ()

  DESCRIPTION
    Queries and returns the current managed roaming configuration information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_managed_roaming_config
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
     )
  {
  dsm_item_type *    response = NULL;
  qmi_error_e_type   errval   = QMI_ERR_NONE;
  nv_item_type       nv_item;

  struct nas_0069_rsp_s  nas_0069_rsp;
  nv_stat_enum_type      nv_status;

  if( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
    {
    QM_MSG_ERROR_4("qmi_nasi_get_managed_roaming_config: NULL ptr sp:%d cmd_buf_p:%d, cl_sp:%d sdu_in:%d", sp, cmd_buf_p, cl_sp, sdu_in);
    }

  memset(&nas_0069_rsp, 0x00, sizeof(struct nas_0069_rsp_s));

  nv_status = qmi_mmode_get_nv_item (NV_MGRF_SUPPORTED_I, &nv_item);

  if ( nv_status == NV_DONE_S )
      {
    nas_0069_rsp.t10.managed_roaming_supported = (uint8) nv_item.mgrf_supported;
    nas_0069_rsp.t10_valid = TRUE;
      }
      else
      {
    QM_MSG_ERROR_1("qmi_nasi_get_managed_roaming_config: Could not read NV_MGRF_SUPPORTED_I. nv status: %d", nv_status);
    errval = QMI_ERR_INTERNAL;
      }

  nas_0069_rsp.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  nas_0069_rsp.t02.error_code  = errval;
  nas_0069_rsp.t02_valid       = TRUE;

  if ( qmi_nas_0069_rsp_write( &nas_0069_rsp, &response) != QMI_ERR_NONE )
  {
    response = NULL;
    }

  return response;
  }
#endif
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
/*===========================================================================
  FUNCTION QMI_NASI_GET_CENTRALIZED_EONS_SUPPORT_STATUS ()

  DESCRIPTION
    Queries and returns the status of centralized eons support

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_centralized_eons_support_status
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
    {
  dsm_item_type *  response = NULL;

  qmi_error_e_type   errval = QMI_ERR_NONE;

  struct nas_006B_rsp_s nas_006B_rsp;

  memset( &nas_006B_rsp, 0x00, sizeof(nas_006B_rsp));

  if ( errval == QMI_ERR_NONE )
  {
    // always return true for centralized eons supported
    nas_006B_rsp.t10.centralized_eons_supported = TRUE;
    nas_006B_rsp.t10_valid = TRUE;
    }

  nas_006B_rsp.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  nas_006B_rsp.t02.error_code  = errval;
  nas_006B_rsp.t02_valid       = TRUE;

  if ( qmi_nas_006B_rsp_write( &nas_006B_rsp, &response) != QMI_ERR_NONE )
    {
    response = NULL;
  }

  return response;

    }
#endif
/*===========================================================================
  FUNCTION QMI_NASI_CONFIG_SIG_INFO2()

  DESCRIPTION
    To set thresholds for reporting sig info indication msg

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None
    (This message is DS/DS agnostic)

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_config_sig_info2
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_nasi_client_state_type        *nasi_client_sp = (qmi_nasi_client_state_type *)cl_sp;
  qmi_error_type_v01                errval          = QMI_ERR_NONE_V01;
  dsm_item_type                     * response      = NULL;
  nas_config_sig_info2_req_msg_v01        * req_msg;
  nas_config_sig_info2_resp_msg_v01       * rsp_msg;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  req_msg = (nas_config_sig_info2_req_msg_v01  *) modem_mem_alloc( sizeof(nas_config_sig_info2_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_config_sig_info2_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_config_sig_info2_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
    {
    memset( req_msg, 0x00, sizeof(nas_config_sig_info2_req_msg_v01) );
    }

  if ( errval == QMI_ERR_NONE_V01 )
    {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)   req_msg,
                                           (uint32_t) sizeof(nas_config_sig_info2_req_msg_v01)
                                         );
    }

  if ( errval == QMI_ERR_NONE_V01 )
    {
    errval = qmi_nas_006C_req_check( req_msg );
    }

  if ( errval == QMI_ERR_NONE_V01 )
    {
    qm_nas_clnt_process_config_sig_info2( nasi_client_sp, req_msg );
  } // End copy all thresholds

#ifdef FEATURE_LTE
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( req_msg->lte_sig_rpt_config_valid )
    {
      if ( ! cmapi_set_lte_signal_reporting_config( ( cmapi_lte_signal_reporting_rate_e )req_msg->lte_sig_rpt_config.rpt_rate,
                                                    ( cmapi_lte_signal_averaging_period_e )req_msg->lte_sig_rpt_config.avg_period ) )
      {
        QM_MSG_HIGH("cmapi_set_lte_signal_reporting_config failed");
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }
#endif // FEATURE_LTE

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !qmi_nasi_global.is_set_cm_ph_cmd_signal_strength_delta )
    {
      if (!cm_ph_cmd_signal_strength_delta_lte( qmi_nas_cmph_cmd_cb,
                                                (void *)cmd_buf_p,
                                                qmi_nasi_global.cm_clnt_id,
                                                NASI_MIN_SIG_INFO_DELTA, //rssi
                                                NASI_MIN_SIG_INFO_DELTA, //ecio
                                                NASI_MIN_SIG_INFO_DELTA, //io
                                                NASI_MIN_SIG_INFO_DELTA, //sinr
                                                NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //pathloss
                                                NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //cqi
                                                NASI_MIN_SIG_INFO_DELTA, //rsrp
                                                NASI_MIN_SIG_INFO_DELTA)) //rsrq
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
      else
      {
        QM_MSG_HIGH("Response pending for Set rssi, ecio, io, sinr, rsrp and rsrq delta ");
        qmi_nasi_global.is_pending_config_sig_info = TRUE;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.is_pending_config_sig_info )
  {
    response = (dsm_item_type*) QMI_SVC_RESPONSE_PENDING;
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if ( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_config_sig_info2_resp_msg_v01) );

    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = ( errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_config_sig_info2_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

#ifdef FEATURE_TDSCDMA
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_TDS_CELL_AND_POSITION_INFO_RSP ()

  DESCRIPTION
    Returns TDSCDMA Cell and Position information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_tds_cell_and_position_info_rsp
(
 qmi_mmodei_msgr_type * msg_p
)
{
  dsm_item_type *  response = NULL;
  int cell_idx = 0;
  qmi_error_e_type   errval = QMI_ERR_NONE;
  nas_get_tds_cell_and_position_info_resp_msg_v01 *rsp_msg;
  qmi_mmode_qcsi_transaction_type *cmd_buf_p = NULL;

  rsp_msg = (nas_get_tds_cell_and_position_info_resp_msg_v01 *) 
      modem_mem_alloc( sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_tds_cell_and_position_info_rsp;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01));


  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.p_usr_data;

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_HIGH_1("Received NULL cmd_buf in GET_TDS_CELL_AND_POS_INFO resp: %d", cmd_buf_p);
    goto end_get_tds_cell_and_position_info_rsp;
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.success_flag )
    {
      // TLV 0x10 cell info
      rsp_msg->tds_cell_info_valid = TRUE;

      rsp_msg->tds_cell_info.plmn.mcc = ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mcc[2] +
                                    msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mcc[1] * 10 +
                                    msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mcc[0] * 100);

      if ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.num_mnc_digits == 3)
      {
         rsp_msg->tds_cell_info.plmn.mnc_includes_pcs_digit = TRUE;

        rsp_msg->tds_cell_info.plmn.mnc = ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[2] +
                                      msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[1] * 10 +
                                      msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[0] * 100 ) ;
      }
      else
      {
        rsp_msg->tds_cell_info.plmn.mnc_includes_pcs_digit = FALSE;
        rsp_msg->tds_cell_info.plmn.mnc = ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[1] +
                                      msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[0] * 10 ) ;
      }

      rsp_msg->tds_cell_info.lac |=  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.lac[0] ;
      rsp_msg->tds_cell_info.lac <<= 8;
      rsp_msg->tds_cell_info.lac |=  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.lac[1] ;

      rsp_msg->tds_cell_info.uarfcn  =  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.uarfcn ;
      rsp_msg->tds_cell_info.cell_id =  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.cell_id ;
      rsp_msg->tds_cell_info.cell_parameter_id =  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.cell_parameter_id ;
      rsp_msg->tds_cell_info.pathloss =  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.pathloss ;
      rsp_msg->tds_cell_info.timing_advance =  (float)((float) msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.timing_advance * 128 / 8.0)/ 1000.0;
      rsp_msg->tds_cell_info.rscp     = (float) msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.rscp / 256.0;

      // Include TLV 0x11 only neighbor cell info available
      if ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.nbr_success_flag )
      {
        rsp_msg->tds_nbr_cell_info_valid = TRUE;

        rsp_msg->tds_nbr_cell_info_len = msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.num_ncell;

        for ( cell_idx = 0 ; cell_idx < msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.num_ncell && cell_idx < NAS_TDS_MAX_NBR_CELL_NUM_V01; cell_idx++ )
        {
          rsp_msg->tds_nbr_cell_info[cell_idx].uarfcn = msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.nbr_ncell[cell_idx].uarfcn ;
          rsp_msg->tds_nbr_cell_info[cell_idx].cell_parameter_id = msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.nbr_ncell[cell_idx].cell_parameter_id ;
          rsp_msg->tds_nbr_cell_info[cell_idx].rscp = (float) msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.nbr_ncell[cell_idx].rscp / 256.0;
        }
      }
    }
    else
    {
      errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }

  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                              QMI_IDL_RESPONSE,
                                              (uint16_t) QMI_NAS_GET_TDS_CELL_AND_POSITION_INFO_RESP_MSG_V01,
                                              (void *) rsp_msg,
                                              (uint32_t) sizeof( nas_get_tds_cell_and_position_info_resp_msg_v01 ),
                                              &response
                                            ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        /*Unable to send GET_TDS_CELL_AND_POSITION_INFO response*/
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
  
  end_get_tds_cell_and_position_info_rsp:
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#endif

#ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_V01 
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_EMBMS_SIG_RSP ()

  DESCRIPTION
    Returns eMBMS signal strength information

===========================================================================*/
void qmi_nasi_generate_get_embms_sig_rsp( qmi_mmodei_msgr_type * msg_p )
{
  dsm_item_type         *response = NULL;
#ifdef FEATURE_LTE_EMBMS
  int                   i;
#endif
  qmi_error_e_type      errval = QMI_ERR_NONE;
  nas_get_embms_sig_resp_msg_v01 *rsp_msg;
  qmi_mmode_qcsi_transaction_type      *cmd_buf_p = qmi_nasi_global.cmd_buf_p;

  rsp_msg = (nas_get_embms_sig_resp_msg_v01  *) 
      modem_mem_alloc( sizeof(nas_get_embms_sig_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_embms_sig_rsp;
  }

  memset( rsp_msg, 0x00, sizeof(nas_get_embms_sig_resp_msg_v01));

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    goto end_get_embms_sig_rsp; //nothing to send
  }

#ifdef FEATURE_LTE_EMBMS
  if ( errval == QMI_ERR_NONE )
  {
    rsp_msg->trace_id_valid= TRUE;
    rsp_msg->trace_id = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.debug_trace_id;

    for ( i=0; i<NAS_LTE_EMBMS_MAX_MBSFN_AREA_V01 && i<msg_p->cmd.qmi_nas.embms_sig_cnf_ext.num_mbsfn_areas ; i++ )
    {
      rsp_msg->sig_list[i].area_id      = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].area_id;
      rsp_msg->sig_list[i].snr          = (float)(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].snr)/8.0;
      //nas_006F_rsp.t11.sig_list[i].signal_level = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].signal_level;

      QM_MSG_HIGH_3("qmi_nasi_generate_get_embms_sig_rsp: area_id = %d, snr = %f, signal_level = %d", rsp_msg->sig_list[i].area_id, rsp_msg->sig_list[i].snr, rsp_msg->sig_list[i].signal_level);
    }
    rsp_msg->sig_list_len = i;
    rsp_msg->sig_list_valid        = TRUE;
  }
#else
  if( errval == QMI_ERR_NONE )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
#endif

  rsp_msg->resp.result  = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
  rsp_msg->resp.error   = (qmi_error_type_v01)errval;

  if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t)cmd_buf_p->msg_id,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_embms_sig_resp_msg_v01),
                                     &response
                                   ) )
  {
    if( !qmi_nasi_send_response(cmd_buf_p, response) )
    {
        /*Unable to send Network Scan response*/
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }

end_get_embms_sig_rsp:
  qmi_nasi_global.cmd_buf_p = NULL;
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
      
}
#endif

#ifdef FEATURE_TDSCDMA
/*===========================================================================
  FUNCTION QMI_NASI_GET_TDS_CELL_AND_POSITION_INFO ()

  DESCRIPTION
    Returns TDSCDMA Cell and Position information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_tds_cell_and_position_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
#ifdef FEATURE_TDSCDMA
  errno_enum_type      msgr_err;
#endif
  nas_get_tds_cell_and_position_info_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_tds_cell_and_position_info_resp_msg_v01 *) 
      modem_mem_alloc( sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_tds_cell_and_position_info;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01));

#ifdef FEATURE_TDSCDMA
  if ( !TARGET_SUPPORTS_TDS )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  if ( errval == QMI_ERR_NONE )
    {
    tds_rrc_gps_pos_cell_info_req_type msg;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, TDSCDMA_RRC_GPS_POS_CELL_INFO_REQ);

    msg.p_user_data = (void *) cmd_buf_p;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR_1("TDSCDMA_RRC_GPS_POS_CELL_INFO_REQ send fail %d", msgr_err);
    }

}
#else
  QM_MSG_HIGH("FEATURE_TDSCDMA not defined");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
#endif

  if ( errval == QMI_ERR_NONE )
    {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
      // Will respond after getting RSP message through MSGR
  }
  else
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01),
                                  &response
                                );
  }
end_get_tds_cell_and_position_info:
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_tds_cell_and_position_info() */
#endif
/*===========================================================================
  FUNCTION QMI_NASI_SET_HPLMN_IRAT_SEARCH_TIMER()

  DESCRIPTION
    Sets periodic search timer configuration for home-operator specific BPLMN search to LTE.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_hplmn_irat_search_timer
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  qmi_error_e_type   errval = QMI_ERR_NONE;

  struct nas_006E_req_s nas_006E_req;
  struct nas_006E_rsp_s nas_006E_rsp;
  uint32 cm_timer_value = 0xFFFFFFFF;

  memset( &nas_006E_req, 0x00, sizeof(nas_006E_req));
  memset( &nas_006E_rsp, 0x00, sizeof(nas_006E_rsp));

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
}

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_006E_req_read( &nas_006E_req, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_006E_req_check( &nas_006E_req );
  }

  if ( errval == QMI_ERR_NONE )
  {
     cm_timer_value = ( nas_006E_req.t01.timer_value < 0xFFFF ) ? 60000*nas_006E_req.t01.timer_value : 0xFFFFFFFF ;

     if( !cm_ph_cmd_set_tl_irat_search_timer_req( qmi_nas_cmph_cmd_cb,
                                                  (void *)cmd_buf_p,
                                                  qmi_nasi_global.cm_clnt_id,
                                                  cm_timer_value ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    // wait for cm callback
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    nas_006E_rsp.t02.result_code = QMI_RESULT_FAILURE;
    nas_006E_rsp.t02.error_code  = errval;
    nas_006E_rsp.t02_valid       = TRUE;

    if ( qmi_nas_006E_rsp_write ( &nas_006E_rsp, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }
  return response;
}
#ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_EMBMS_SIG ()

  DESCRIPTION
    Retrieves eMBMS signal strength information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_embms_sig
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
#ifdef FEATURE_LTE_EMBMS
  errno_enum_type       msgr_err;
#endif
  nas_get_embms_sig_req_msg_v01 req_msg;
  nas_get_embms_sig_resp_msg_v01 rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset( &req_msg, 0x00, sizeof(nas_get_embms_sig_req_msg_v01));
  memset( &rsp_msg, 0x00, sizeof(nas_get_embms_sig_resp_msg_v01));

  if ( qmi_nasi_global.cmd_buf_p == NULL )
  {
    qmi_nasi_global.cmd_buf_p = (void *)cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY;
  }

#ifdef FEATURE_LTE_EMBMS
  if (errval == QMI_ERR_NONE)
  {
     // extract information from REQ message
     errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) &req_msg,
                                           (uint32_t) sizeof(nas_get_embms_sig_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_006F_req_check (&req_msg);
  }

  if ( errval == QMI_ERR_NONE )
  {
    lte_rrc_embms_signal_strength_report_req_s msg;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_EMBMS_SIGNAL_STRENGTH_REQ );

    msg.debug_trace_id = req_msg.trace_id_valid? req_msg.trace_id : -1;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR_1("LTE_RRC_EMBMS_SIGNAL_STRENGTH_REQ send fail %d", msgr_err);
    }
  }
#else
  if( errval == QMI_ERR_NONE )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
#endif

  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    QM_MSG_HIGH("Sent response pending for QMI_NAS_GET_EMBMS_SIG to QMI Framework");
    // Will respond after getting RSP message through MSGR
  }
  else
  {
    rsp_msg.resp.result  = (qmi_result_type_v01)QMI_RESULT_FAILURE;
    rsp_msg.resp.error  = (qmi_error_type_v01)errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t)cmd_buf_p->msg_id,
                                (void *) &rsp_msg,
                                (uint32_t) sizeof(nas_get_embms_sig_resp_msg_v01),
                                &response
                              );

    qmi_nasi_global.cmd_buf_p = NULL;
  }
  return response;
}
#endif
/*===========================================================================
  FUNCTION QMI_NASI_LIMIT_SYS_INFO_IND_REPORTING ()

  DESCRIPTION
    Sets limitations on the reporting of QMI_NAS_SYS_INFO_IND.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_limit_sys_info_ind_reporting
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response  = NULL;
  qmi_nasi_client_state_type *nasi_client_sp;
  qmi_error_e_type            errval = QMI_ERR_NONE;
  struct nas_0070_req_s       req_msg;
  struct nas_0070_rsp_s       rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&req_msg, 0, sizeof(req_msg));
  memset(&rsp_msg, 0, sizeof(rsp_msg));

  nasi_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  errval = qmi_nas_0070_req_read(&req_msg, sdu_in);
  QM_MSG_HIGH_1("TLV 0x01 in QMI_NAS_LIMIT_SYS_INFO_IND_REPORTING %ull", req_msg.t01.limit_sys_info_rpt_chg);

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0070_req_check(&req_msg);
  }

  if (errval == QMI_ERR_NONE)
  {
    struct report_status_s *p_rs = &nasi_client_sp->report_status;

    p_rs->limit_sys_info_reporting_mask = req_msg.t01.limit_sys_info_rpt_chg;
  }

  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0070_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_NONE;
  }

  return response;
} /* qmi_nasi_limit_sys_info_ind_reporting */


/*===========================================================================
  FUNCTION QMI_NASI_GET_SYS_INFO_IND_REPORTING_LIMIT ()

  DESCRIPTION
    Returns limitations set on QMI_NAS_SYS_INFO_IND reporting.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_sys_info_ind_reporting_limit
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_nasi_client_state_type *nasi_client_sp;
  qmi_error_e_type            errval    = QMI_ERR_NONE;
  struct nas_0071_rsp_s       rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&rsp_msg, 0, sizeof(rsp_msg));

  nasi_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  rsp_msg.t01_valid = TRUE;
  rsp_msg.t01.limit_sys_info_rpt_chg = nasi_client_sp->report_status.limit_sys_info_reporting_mask;

  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0071_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_NONE;
  }

  return response;
} /* qmi_nasi_get_sys_info_ind_reporting_limit */

#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_SE13_PLMN_NAME_RESP()

  DESCRIPTION
    send response for get_plmn_name after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_se13_plmn_name_resp( const mmgsdi_get_se13_plmn_names_cnf_type *name_cnf )
{
  dsm_item_type                        *response = NULL;
  qmi_error_type_v01                    errval = QMI_ERR_NONE_V01;
  nas_get_plmn_name_resp_msg_v01       *rsp_msg;
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_mmode_qcsi_transaction_type                     *cmd_buf_p = NULL;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  uint32 i = 0;
  uint8 tmp_buf[NAS_ALT_LANG_NAME_LEN_MAX_V01*2] = { 0 };

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) callback_data->cmd_buf_ptr;
    if ( qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      rsp_msg = (nas_get_plmn_name_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_plmn_name_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

      if( rsp_msg != NULL )
      {
        memset( rsp_msg, 0x00, sizeof(nas_get_plmn_name_resp_msg_v01) );

      if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
      {
        if( name_cnf->plmn_list.num_of_plmn_ids == 1 && name_cnf->plmn_list.plmn_info_ptr != NULL ) // get_plmn_name request a single name
        {
            QM_MSG_HIGH_4("Names found: short len=%d, long len=%d, Encoding: short = %d, long = %d", name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len, 
                name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding, 
                name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding);


            qm_util_print_bytes( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr, 
                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len );
            qm_util_print_bytes( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr, 
                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len );

            rsp_msg->eons_plmn_name_3gpp_valid = TRUE;

            rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
            rsp_msg->eons_plmn_name_3gpp.spn_len = 0;

          if( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                        name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,
                                                                                        buff_ptr,
                                                                                        NASI_MAX_LEN_NETWORK_NAME/2 );
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len );
          }
          else if( nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                              name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding,
                                                     (char *) rsp_msg->eons_plmn_name_3gpp.plmn_long_name,
                                                     (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc,
                                              NASI_MAX_LEN_NETWORK_NAME,
                                              (uint8)(name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len )) )
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
            rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
            if( (rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                (name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
              )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len);
            }
            else
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01 ));
            }
          }

          if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len,
                                                                                         buff_ptr,
                                                                                         NASI_MAX_LEN_NETWORK_NAME/2 );
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len );
          }
          else if ( nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                               name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding,
                                                      (char *) rsp_msg->eons_plmn_name_3gpp.plmn_short_name,
                                                      (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc,
                                               NASI_MAX_LEN_NETWORK_NAME,
                                               (uint8)(name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len) ) )
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
            rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
            if( (rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                (name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
              )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len);
            }
            else
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01 ));
            }
          }

            if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len != 0 ||
                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr != NULL )
            {
              if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                rsp_msg->addl_info_valid = TRUE;
                rsp_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                           name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr,
                                           name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len,
                                           buff_ptr,
                                           NAS_PLMN_NAME_MAX_V01/2 );
                memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->addl_info_len*2 );
              }
              else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                rsp_msg->addl_info_valid = TRUE;
                rsp_msg->addl_info_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len/2;
                memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len );
                convert_endianness16( (unsigned char*)rsp_msg->addl_info, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len );
              }
              else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
              {
                if( !cm_util_gsm7_to_utf16( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr, 
                                            name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len,
                                            FALSE,
                                            rsp_msg->addl_info,
                                            NAS_PLMN_NAME_MAX_V01,
                                            (size_t *)&rsp_msg->addl_info_len ) )
                {
                  rsp_msg->addl_info_valid = TRUE;
                }
              }
            }

          if ( name_cnf->plmn_list.plmn_info_ptr[0].num_plmn_additional_names > 0 )
          {
            rsp_msg->lang_plmn_names_valid = TRUE;
            rsp_msg->lang_plmn_names_len = MIN(NAS_ALT_LANG_MAX_V01, name_cnf->plmn_list.plmn_info_ptr[0].num_plmn_additional_names);
            for ( i = 0; i < rsp_msg->lang_plmn_names_len; i++ )
            {
              rsp_msg->lang_plmn_names[i].lang_id = qmi_nas_map_lang_id_mmgsdi_to_qmi(name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_lang);

              if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                rsp_msg->lang_plmn_names[i].plmn_long_name_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                   name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                   rsp_msg->lang_plmn_names[i].plmn_long_name,
                                                                   NAS_ALT_LANG_NAME_LEN_MAX_V01 );
              }
              else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                memscpy( tmp_buf, 
                         NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr, 
                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                convert_endianness16( tmp_buf, 
                                      name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                memscpy( rsp_msg->lang_plmn_names[i].plmn_long_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                rsp_msg->lang_plmn_names[i].plmn_long_name_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len/2;
              }

              if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                rsp_msg->lang_plmn_names[i].plmn_short_name_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                   name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                   rsp_msg->lang_plmn_names[i].plmn_short_name,
                                                                   NAS_ALT_LANG_NAME_LEN_MAX_V01 );
              }
              else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                memscpy( tmp_buf, 
                         NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr, 
                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                convert_endianness16( tmp_buf, 
                                      name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                memscpy( rsp_msg->lang_plmn_names[i].plmn_short_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                rsp_msg->lang_plmn_names[i].plmn_short_name_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len/2;
              }
            }
          }
        }
        else
        {
            errval = QMI_ERR_INTERNAL_V01;
        }
      }
      else
      {
          errval = QMI_ERR_INTERNAL_V01;
      }

      // Populate TLV 0x02 (Mandatory error code)
        rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
        rsp_msg->resp.error  = (qmi_error_type_v01)errval;

        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_RESPONSE,
                                                  (uint16_t) QMI_NAS_GET_PLMN_NAME_RESP_MSG_V01,
                                                  (void *) rsp_msg,
                                                  (uint32_t) sizeof( nas_get_plmn_name_resp_msg_v01 ),
                                                  &response
                                                ) )
      {
          if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
        {
            /*Unable to send GET PLMN NAME response*/
            qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
        }
      }
      else
      {
        dsm_free_packet(&response);
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
      }
    }
    else
    {
        qmi_voice_mem_error();
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
      }

      if( rsp_msg != NULL ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    }
  }
  else
  {
    QM_MSG_ERROR("callback_data is NULL!");
    ASSERT(0);
  }

  if( callback_data != NULL ) { modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#endif
/*===========================================================================
  FUNCTION QMI_NASI_UPDATE_IMS_STATUS()

  DESCRIPTION
    Message to update IMS status to CM

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_update_ims_status
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_type_v01           errval    = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_update_ims_status_req_msg_v01  *nas_update_ims_req;
  nas_update_ims_status_resp_msg_v01 *nas_update_ims_resp;
  uint32 i;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  nas_update_ims_req  = (nas_update_ims_status_req_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof(nas_update_ims_status_req_msg_v01) );
  nas_update_ims_resp = (nas_update_ims_status_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof(nas_update_ims_status_resp_msg_v01) );

  if ( nas_update_ims_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( nas_update_ims_req, 0x00, sizeof( nas_update_ims_status_req_msg_v01 ) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) nas_update_ims_req,
                                           (uint32_t) sizeof( nas_update_ims_status_req_msg_v01 )
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0072_req_check( nas_update_ims_req );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    for ( i = 0; i < nas_update_ims_req->registration_state_len; i++ )
    {
      cm_domain_sel_update_ims_reg_status_req_msg_type msg;

      msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_DOM_SEL_UPDATE_IMS_REG_STATUS_IND );

      msg.data.system = qmi_nas_radio_if_2_sys_mode(nas_update_ims_req->sys_mode);

      switch ( nas_update_ims_req->registration_state[i].call_type )
      {
        case NAS_CALL_TYPE_E_VOICE_V01:
          msg.data.call_type_mask = CM_CALL_TYPE_VOICE_MASK;
          msg.data.is_registered = nas_update_ims_req->registration_state[i].is_registered;
          break;

        case NAS_CALL_TYPE_E_SMS_V01:
          msg.data.call_type_mask = CM_CALL_TYPE_SMS_MASK;
          msg.data.is_registered = nas_update_ims_req->registration_state[i].is_registered;
          break;

        default:
          errval = QMI_ERR_INTERNAL_V01;
          break;
      }

     
     if( nas_update_ims_req->registration_end_cause_valid )
     {
      QM_MSG_HIGH_1("IMS reg end cause %d", nas_update_ims_req->registration_end_cause);
      switch( nas_update_ims_req->registration_end_cause )
      {
       case NAS_IMS_REG_END_CAUSE_NORMAL_V01:
        msg.data.end_cause = SYS_IMS_REG_END_CAUSE_NORMAL;
        break;

       case NAS_IMS_REG_END_CAUSE_TEMPORARY_V01:
        msg.data.end_cause = SYS_IMS_REG_END_CAUSE_TEMPORARY;
        break;

       case NAS_IMS_REG_END_CAUSE_BLOCK_TILL_POWER_CYCLE_V01:
        msg.data.end_cause = SYS_IMS_REG_END_CAUSE_BLOCK_TILL_PWR_CYCLE;
        break;

       default:
        break;
      }
     }
  

      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("UPDATE IMS send fail %d", msgr_err);
      }
    }
  }

  if ( (nas_update_ims_resp != NULL )  && (cmd_buf_p != NULL) )
  {
    memset( nas_update_ims_resp, 0x00, sizeof( nas_update_ims_status_resp_msg_v01 ) );

    nas_update_ims_resp->resp.error  = errval;
    nas_update_ims_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) nas_update_ims_resp,
                                  (uint32_t) sizeof( nas_update_ims_status_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_update_ims_req  != NULL ) { QMI_NAS_MEM_FREE( (void *) nas_update_ims_req ); }
  if ( nas_update_ims_resp != NULL ) { QMI_NAS_MEM_FREE( (void *) nas_update_ims_resp ); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_IMS_PREF_STATUS()

  DESCRIPTION
    Message to get IMS preference

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_ims_pref_status
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_type_v01           errval   = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_get_ims_pref_status_resp_msg_v01 *get_ims_pref_resp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( qmi_nasi_global.ims_cmd_buf_p == NULL )
  {
    qmi_nasi_global.ims_cmd_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    cm_domain_sel_get_ims_pref_msg_type msg;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_GET_EXT_REQ );

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("GET_IMS_PREF send fail %d", msgr_err);
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    return QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    get_ims_pref_resp = (nas_get_ims_pref_status_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_ims_pref_status_resp_msg_v01 ) );
    if ( ( get_ims_pref_resp != NULL ) && (cmd_buf_p!= NULL) )
    {
      memset( get_ims_pref_resp, 0x00, sizeof( nas_get_ims_pref_status_resp_msg_v01 ) );

      get_ims_pref_resp->resp.error  = errval;
      get_ims_pref_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)cmd_buf_p->msg_id,
                                    (void *) get_ims_pref_resp,
                                    (uint32_t) sizeof( nas_get_ims_pref_status_resp_msg_v01 ),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }

    if ( get_ims_pref_resp != NULL ) { QMI_NAS_MEM_FREE( (void *) get_ims_pref_resp ); }
    qmi_nasi_global.ims_cmd_buf_p = NULL;

    return response;
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_GEN_IMS_PREF_STATUS_IND()

  DESCRIPTION
    Generate a ims preference status indication

  PARAMETERS
    cm_domain_sel_ims_pref_info_s_type    IMS Preference info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_ims_pref_status_ind(
  cm_domain_sel_ims_pref_info_s_type *ims_pref
)
{
  qmi_nasi_client_state_type      *cl_sp;
  nas_ims_pref_status_ind_msg_v01 *nas_ims_pref_ind;
  dsm_item_type                   *ind = NULL;
  boolean                          send_ind;

  nas_ims_pref_ind = (nas_ims_pref_status_ind_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_ims_pref_status_ind_msg_v01 ) );

  if ( nas_ims_pref_ind != NULL )
  {
    memset( nas_ims_pref_ind, 0x00, sizeof(nas_ims_pref_status_ind_msg_v01) );

    send_ind = qmi_nas_populate_ims_pref_status_ind( ims_pref, nas_ims_pref_ind );

    if ( send_ind )
    {
      cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
      while ( cl_sp != NULL )
      {

        if ( cl_sp->report_status.report_ims_pref_status)
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_IMS_PREF_STATUS_IND_V01,
                                                    (void *) nas_ims_pref_ind,
                                                    (uint32_t)sizeof(nas_ims_pref_status_ind_msg_v01),
                                                    &ind
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_IMS_PREF_STATUS_IND, ind );
          }
        }

        cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
      }
    }
    else
    {
      QM_MSG_HIGH("ims preference status didnt change");
    }

    QMI_NAS_MEM_FREE( (void *) nas_ims_pref_ind );
  }
  else
  {
    qmi_voice_mem_error();
  }
} //qmi_nas_gen_ims_pref_status_ind


/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_IMS_PREF_STATUS_IND()

  DESCRIPTION
    Populate a ims preference status indication

  PARAMETERS
    cm_domain_sel_ims_pref_info_s_type  IMS Preference info
    nas_ims_pref_status_ind_msg_v01     Indication message to populate

  RETURN VALUE
    indicates whether ims pref changed and indication should be sent

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_populate_ims_pref_status_ind(
  cm_domain_sel_ims_pref_info_s_type *ims_pref,
  nas_ims_pref_status_ind_msg_v01    *ind_msg
)
{
  boolean pref_changed = FALSE;
  uint64  pref_mask = 0;

  QM_MSG_HIGH_3("IND resp: sys_mode %d, call_type %d, pref %d", ims_pref->system, ims_pref->call_type_mask, ims_pref->ims_pref_mask);

  switch ( ims_pref->system )
  {
    case SYS_SYS_MODE_LTE:
      QM_MSG_HIGH_2("IND resp: lte_mask_valid %d, lte_call_mask %d",
        qmi_nasi_global.ims_pref_cache.lte_mask_valid,  qmi_nasi_global.ims_pref_cache.lte_call_mask);
      pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.lte_call_mask,
                                                ims_pref->call_type_mask,
                                                ims_pref->ims_pref_mask );

      if ( qmi_nasi_global.ims_pref_cache.lte_mask_valid )
      {
        if ( qmi_nasi_global.ims_pref_cache.lte_call_mask != pref_mask )
        {
          pref_changed = TRUE;
          ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_LTE_V01;
          ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.lte_call_mask = pref_mask;
        }
      }
      else
      {
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_LTE_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.lte_call_mask = pref_mask;
        qmi_nasi_global.ims_pref_cache.lte_mask_valid = TRUE;
        pref_changed = TRUE;
      }
      break;
    #if defined(FEATURE_HDR)
    case SYS_SYS_MODE_HDR:
      QM_MSG_HIGH_2("IND resp: hdr_mask_valid %d, hdr_call_mask %d",
        qmi_nasi_global.ims_pref_cache.hdr_mask_valid,  qmi_nasi_global.ims_pref_cache.hdr_call_mask);
      pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.hdr_call_mask,
                                                ims_pref->call_type_mask,
                                                ims_pref->ims_pref_mask );

      if ( qmi_nasi_global.ims_pref_cache.hdr_mask_valid )
      {
        if ( qmi_nasi_global.ims_pref_cache.hdr_call_mask != pref_mask )
        {
          pref_changed = TRUE;
          ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1XEVDO_V01;
          ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.hdr_call_mask = pref_mask;
        }
      }
      else
      {
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1XEVDO_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.hdr_call_mask = pref_mask;
        qmi_nasi_global.ims_pref_cache.hdr_mask_valid = TRUE;
        pref_changed = TRUE;
      }
      break;
    #endif

    #if defined(FEATURE_GSM) 
    case SYS_SYS_MODE_GSM:
      QM_MSG_HIGH_2("IND resp: gsm_mask_valid %d, gsm_call_mask %d",
        qmi_nasi_global.ims_pref_cache.gsm_mask_valid,  qmi_nasi_global.ims_pref_cache.gsm_call_mask);
      pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.gsm_call_mask,
                                                ims_pref->call_type_mask,
                                                ims_pref->ims_pref_mask );

      if ( qmi_nasi_global.ims_pref_cache.gsm_mask_valid )
      {
        if ( qmi_nasi_global.ims_pref_cache.gsm_call_mask != pref_mask )
        {
          pref_changed = TRUE;
          ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_GSM_V01;
          ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.gsm_call_mask = pref_mask;
        }
      }
      else
      {
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_GSM_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.gsm_call_mask = pref_mask;
        qmi_nasi_global.ims_pref_cache.gsm_mask_valid = TRUE;
        pref_changed = TRUE;
      }
      break;
    #endif

    #if defined(FEATURE_WCDMA) 
    case SYS_SYS_MODE_WCDMA:
      QM_MSG_HIGH_2("IND resp: wcdma_mask_valid %d, wcdma_call_mask %d",
        qmi_nasi_global.ims_pref_cache.wcdma_mask_valid,  qmi_nasi_global.ims_pref_cache.wcdma_call_mask);
      pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.wcdma_call_mask,
                                                ims_pref->call_type_mask,
                                                ims_pref->ims_pref_mask );

      if ( qmi_nasi_global.ims_pref_cache.wcdma_mask_valid )
      {
        if ( qmi_nasi_global.ims_pref_cache.wcdma_call_mask != pref_mask )
        {
          pref_changed = TRUE;
          ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_UMTS_V01;
          ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.wcdma_call_mask = pref_mask;
        }
      }
      else
      {
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_UMTS_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.wcdma_call_mask = pref_mask;
        qmi_nasi_global.ims_pref_cache.wcdma_mask_valid = TRUE;
        pref_changed = TRUE;
      }
      break;
   #endif

  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
  case SYS_SYS_MODE_CDMA:
    QM_MSG_HIGH_2("IND resp: cdma_mask_valid %d, cdma_call_mask %d",
      qmi_nasi_global.ims_pref_cache.cdma_mask_valid,  qmi_nasi_global.ims_pref_cache.cdma_call_mask);
    pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.cdma_call_mask,
                                              ims_pref->call_type_mask,
                                              ims_pref->ims_pref_mask );

    if ( qmi_nasi_global.ims_pref_cache.cdma_mask_valid )
    {
      if ( qmi_nasi_global.ims_pref_cache.cdma_call_mask != pref_mask )
      {
        pref_changed = TRUE;
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1X_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.cdma_call_mask = pref_mask;
      }
    }
    else
    {
      ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1X_V01;
      ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.cdma_call_mask = pref_mask;
      qmi_nasi_global.ims_pref_cache.cdma_mask_valid = TRUE;
      pref_changed = TRUE;
    }
    break;
  #endif

  #if defined(FEATURE_TDSCDMA)
  case SYS_SYS_MODE_TDS:
    QM_MSG_HIGH_2("IND resp: tds_mask_valid %d, tds_call_mask %d",
      qmi_nasi_global.ims_pref_cache.tds_mask_valid,  qmi_nasi_global.ims_pref_cache.tds_call_mask);
    pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.tds_call_mask,
                                              ims_pref->call_type_mask,
                                              ims_pref->ims_pref_mask );

    if ( qmi_nasi_global.ims_pref_cache.tds_mask_valid )
    {
      if ( qmi_nasi_global.ims_pref_cache.tds_call_mask != pref_mask )
      {
        pref_changed = TRUE;
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_TDSCDMA_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.tds_call_mask = pref_mask;
      }
    }
    else
    {
      ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_TDSCDMA_V01;
      ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.tds_call_mask = pref_mask;
      qmi_nasi_global.ims_pref_cache.tds_mask_valid = TRUE;
      pref_changed = TRUE;
    }
    break;
  #endif

    default:
      break;
  }

  return pref_changed;
} //qmi_nas_populate_ims_pref_status_ind

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_GET_IMS_PREF_RESP()

  DESCRIPTION
    Populate a ims preference status indication

  PARAMETERS
    cm_domain_sel_ims_pref_info_s_type  IMS Preference info
    nas_ims_pref_status_ind_msg_v01     Indication message to populate

  RETURN VALUE
    indicates whether ims pref changed and indication should be sent

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_get_ims_pref_resp(
  cm_domain_sel_ims_pref_rsp_msg_type_ext *ims_pref
)
{
  dsm_item_type                        *response = NULL;
  qmi_error_type_v01                    errval = QMI_ERR_NONE_V01;
  nas_get_ims_pref_status_resp_msg_v01 *get_ims_pref_resp = NULL;
  qmi_mmode_qcsi_transaction_type                     *cmd_buf_p = qmi_nasi_global.ims_cmd_buf_p;

  if ( cmd_buf_p == NULL )
  {
    qmi_nasi_global.ims_cmd_buf_p = NULL;
    return; //nothing to send
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    get_ims_pref_resp = (nas_get_ims_pref_status_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_ims_pref_status_resp_msg_v01 ) );

    if ( get_ims_pref_resp != NULL )
    {
      memset( get_ims_pref_resp, 0x00, sizeof( nas_get_ims_pref_status_resp_msg_v01 ) );

      QM_MSG_HIGH_3("GET resp: sys_mode %d, voice %d, sms %d", ims_pref->sys_mode_mask, ims_pref->ims_voice_pref_mask, ims_pref->ims_sms_pref_mask);

      if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_LTE )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_LTE_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_LTE )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }

        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_LTE )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      #if defined(FEATURE_HDR)
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_HDR )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1XEVDO_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_HDR )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }

        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_HDR )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      #endif
      #if defined(FEATURE_GSM) 
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_GSM )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_GSM_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_GSM )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }
  
        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_GSM )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      #endif
      #if defined(FEATURE_WCDMA)
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_WCDMA )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_UMTS_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_WCDMA )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }
  
        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_WCDMA )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      #endif
      #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900) 
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_CDMA )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1X_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_CDMA )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }
  
        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_CDMA )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      #endif
      #if defined(FEATURE_TDSCDMA)
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_TDS )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_TDSCDMA_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_TDS )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }
  
        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_TDS )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      #endif
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
      }

      if ( errval == QMI_ERR_NONE_V01 )
      {
        get_ims_pref_resp->ims_pref_valid = TRUE;
      }

      get_ims_pref_resp->resp.error  = errval;
      get_ims_pref_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

      if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                QMI_IDL_RESPONSE,
                                                (uint16_t)cmd_buf_p->msg_id,
                                                (void *) get_ims_pref_resp,
                                                (uint32_t) sizeof( nas_get_ims_pref_status_resp_msg_v01 ),
                                                &response
                                              ) )
      {
        if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
        {
          /*Unable to send GET_IMS_PREF response*/
          qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
        }
      }
    }
    else
    {
      qmi_voice_mem_error();
      qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }
  }

  if ( get_ims_pref_resp != NULL ) { QMI_NAS_MEM_FREE( (void *) get_ims_pref_resp ); }
  qmi_nasi_global.ims_cmd_buf_p = NULL;
} //qmi_nas_populate_ims_pref_status_ind

#if defined (FEATURE_CDMA)
/*===========================================================================
  FUNCTION QMI_NASI_CDMA_AVOID_SYSTEM()

  DESCRIPTION
    Avoid a CDMA system or Clear avoided systems list
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_cdma_avoid_system
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01           errval        = QMI_ERR_NONE_V01;
  nas_cdma_avoid_system_req_msg_v01* req_msg;
  nas_cdma_avoid_system_resp_msg_v01* rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_cdma_avoid_system_req_msg_v01  *) modem_mem_alloc( sizeof(nas_cdma_avoid_system_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_cdma_avoid_system_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_cdma_avoid_system_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( req_msg, 0x00, sizeof(nas_cdma_avoid_system_req_msg_v01) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                            sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_cdma_avoid_system_req_msg_v01)
                                               );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0076_req_check( req_msg );
  }

  if ( errval == QMI_ERR_NONE_V01 )
          {
    QM_MSG_MED_1("cm_ph_cmd_avoid_sys() with avoid_type=%d", req_msg->avoid_type);
    if(! cm_ph_cmd_avoid_sys( qmi_nas_cmph_cmd_cb,
                              (void *)cmd_buf_p,
                              qmi_nasi_global.cm_clnt_id,
                              (cm_ss_avoid_sys_e_type)req_msg->avoid_type,
                              0 /* avoid time is obsolete */) )
            {
      QM_MSG_ERROR("cm_ph_cmd_avoid_sys returned failure");
      errval = QMI_ERR_INTERNAL_V01;
    }
            }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_MED("qmi_nasi_cdma_avoid_system() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
          }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_cdma_avoid_system_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)rsp_msg,
                                  (uint32_t) sizeof(nas_cdma_avoid_system_resp_msg_v01),
                                   &response
                                  );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_cdma_avoid_system() */


/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_CDMA_AVOID_SYSTEM_RESP()

  DESCRIPTION
    Called when cmd_cb() supplied in cm_ph_cmd_avoid_system() is called
    by CM. Sends response to control point.

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_cdma_avoid_system_resp
(
  void *               user_data,
  cm_ph_cmd_err_e_type ph_cmd_err
)
{
  dsm_item_type *        response = NULL;
  qmi_mmode_qcsi_transaction_type *     cmd_buf_p;
  boolean                retval = FALSE;
  qmi_error_type_v01     errval   = QMI_ERR_NONE_V01;
  nas_cdma_avoid_system_resp_msg_v01* resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE_V01;
  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) user_data;

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
          {
    return;
  }
  else if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Null cmd_buf ptr");
    return;
  }


  /*-------------------------------------------------------------------------
    Send SUCCESS or FAILURE response to control point based on ph_cmd_err
  -------------------------------------------------------------------------*/
  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

      /* If there is an existing call */
    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

      /*Avoid type is NAS_AVOID_SYS_USERZONE_V01 But
           MS is not in a user zone*/
    case CM_PH_CMD_ERR_SYS_NOT_IN_UZ:
      errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
      break;

      /* Phone is not Online */
    case CM_PH_CMD_ERR_ONLINE_S:
      errval = QMI_ERR_DEVICE_NOT_READY_V01;
      break;

         default:
      errval = QMI_ERR_INTERNAL_V01;
           break;
      }

  resp_msg = (nas_cdma_avoid_system_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_cdma_avoid_system_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_cdma_avoid_system_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_cdma_avoid_system_resp_msg_v01),
                                           &response
                                         );
    }
    else
    {
    qmi_voice_mem_error();
    }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
  else if ( !qmi_nasi_send_response( cmd_buf_p, response ) )
  {
    QM_MSG_MED("QMI_NAS_CDMA_AVOID_SYSTEM_RESP send failed");
}
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nas_generate_cdma_avoid_system_resp() */



/*===========================================================================
  FUNCTION QMI_NASI_GET_CDMA_AVOID_SYSTEM_LIST()

  DESCRIPTION
    Retrieve the avoided systems from EFS

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_cdma_avoid_system_list
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_error_type_v01           errval        = QMI_ERR_NONE_V01;
  nas_get_cdma_avoid_system_list_resp_msg_v01* rsp_msg;
  uint8 i=0, cnt=0;
  struct
  {
    byte               nam;
    struct
    {
      uint16             sid;
      uint16             nid;
      uint16             mnc;
      uint16             mcc;
    } sys_info[NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01];
  } avoid_sys_list;


  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_cdma_avoid_system_list_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_cdma_avoid_system_list_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    QM_MSG_MED("Fetch the avoid list from EFS");
    memset( rsp_msg, 0x00, sizeof(nas_get_cdma_avoid_system_list_resp_msg_v01) );

    if (qm_util_read_efs("/nv/item_files/modem/mmode/lock_parameters", &avoid_sys_list, sizeof(avoid_sys_list)))
    {
      /* Check if NAM is valid. Only NAM1 is supported currently */
      if(avoid_sys_list.nam == CM_NAM_1)
      {
        rsp_msg->nam1_systems_valid = TRUE;

        for(i=0; i<NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01; i++)
        {
          /* Ignore invalid sid, nid data */
          if( (avoid_sys_list.sys_info[i].sid == SD_WILDCARD_SID) &&
               (avoid_sys_list.sys_info[i].nid == SD_WILDCARD_NID) )
          {
            continue;
          }
          memscpy(&rsp_msg->nam1_systems[cnt], sizeof(rsp_msg->nam1_systems[cnt]),
                        &avoid_sys_list.sys_info[i], sizeof(avoid_sys_list.sys_info[i]));
          cnt++;
        }
        rsp_msg->nam1_systems_len = cnt;
        QM_MSG_HIGH_1("Number of avoided systems =%d", cnt);
    }
    else
    {
        QM_MSG_HIGH_1("Invalid NAM value %d from EFS", avoid_sys_list.nam);
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
    else
  {
      QM_MSG_ERROR("EFS read failed");
    errval = QMI_ERR_INTERNAL_V01;
  }

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_cdma_avoid_system_list_resp_msg_v01),
                                  &response
                                );

  }
  else if ( rsp_msg == NULL )
  {
    QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_GET_CDMA_AVOID_SYSTEM_LIST request. %p", rsp_msg);
}

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_get_cdma_avoid_system_list() */
#endif

#ifndef REMOVE_QMI_NAS_SET_HPLMN_SEARCH_TIMER_V01
/*===========================================================================
  FUNCTION QMI_NASI_SET_HPLMN_SEARCH_TIMER ()

  DESCRIPTION
    Sets the HPLMN search timer.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_hplmn_search_timer 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response  = NULL;
  qmi_error_e_type            errval = QMI_ERR_NONE;
  struct nas_0078_req_s       req_msg;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  mm_cmd_set_hplmn_search_timer_req_s    hplmn_search_timer;
  qmi_result_e_type         result;
  boolean                   retval;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&req_msg, 0, sizeof(req_msg));

  errval = qmi_nas_0078_req_read(&req_msg, sdu_in);

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0078_req_check(&req_msg);
  }

  if (errval == QMI_ERR_NONE)
  {
  
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif

    hplmn_search_timer.timer_value = req_msg.t01.timer_value;
	if( nas_reg_cmd_set_hplmn_search_timer (&hplmn_search_timer)
    {
      errval = QMI_ERR_INTERNAL;
    }
  }


  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS 
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
    /*Send qmi_nas_set_hplmn_search_timer_resp response*/
  }

  return response;
} /* qmi_nasi_set_hplmn_search_timer */
#endif

#ifndef REMOVE_QMI_NAS_GET_HPLMN_SEARCH_TIMER_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_HPLMN_SEARCH_TIMER ()

  DESCRIPTION
    Gets the HPLMN search timer.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_hplmn_search_timer 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response  = NULL;
  qmi_error_e_type            errval = QMI_ERR_NONE;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  struct nas_0079_rsp_s *rsp_msg   = NULL;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(rsp_msg, 0, sizeof(struct nas_0079_rsp_s));
  rsp_msg->t10.timer_value = nas_cmd_get_hplmn_search_timer();
  rsp_msg->t10_valid = TRUE;

  rsp_msg->t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg->t02.error_code  = errval;
  rsp_msg->t02_valid       = TRUE;

  if ( qmi_nas_0079_rsp_write ( rsp_msg, &response ) == QMI_ERR_NONE )
  {
     qmi_nasi_send_response( cmd_buf_p, response);
    }
  else
  {
    dsm_free_packet(&response); 
	response = NULL;
  }

  if ( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_hplmn_search_timer */
#endif
#ifndef REMOVE_QMI_NAS_SET_BUILTIN_PLMN_LIST_V01
/*===========================================================================
  FUNCTION QMI_NASI_SET_BUILTIN_PLMN_LIST

  DESCRIPTION
    Set the built in PLMN List on the modem

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_builtin_plmn_list
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_error_type_v01           errval        = QMI_ERR_NONE_V01;
  nas_set_builtin_plmn_list_req_msg_v01* req_msg;
  nas_set_builtin_plmn_list_resp_msg_v01* rsp_msg = NULL;
  boolean                    wait_for_more_entries = FALSE;
  enum qmi_nas_subs_e as_id    = QMI_NAS_SUBS_PRIMARY;
  uint16                       offset=0;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  //Extract as_id
  as_id  = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
    QM_MSG_ERROR("qmi_nasi_set_builtin_plmn_list(): Received invalid as_id from client state pointer.");
    return response;
  }

  rsp_msg = (nas_set_builtin_plmn_list_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_builtin_plmn_list_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );


  if( qmi_nasi_global.builtin_plmn_list[as_id].list_op_in_prog )
  {
    errval = QMI_ERR_DEVICE_IN_USE_V01;
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    req_msg  = (nas_set_builtin_plmn_list_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_builtin_plmn_list_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    memset( req_msg, 0x00, sizeof(nas_set_builtin_plmn_list_req_msg_v01) );
    
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t) sizeof(nas_set_builtin_plmn_list_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = (qmi_error_type_v01)qmi_nas_0084_req_check( req_msg );
  }
  
  if (errval == QMI_ERR_NONE_V01)
  {
    //Store the clnt so as to send the indication
    qmi_nasi_global.builtin_plmn_list[as_id].clnt = ((qmi_nasi_client_state_type *)cl_sp)->clnt;

    QM_MSG_HIGH_3("QMI_NAS_SET_BUILTIN_PLMN_LIST recv with list_id %d, oplmn len %d on client %p", 
        req_msg->oplmn_list.list_id, req_msg->oplmn_list.oplmn_len, qmi_nasi_global.builtin_plmn_list[as_id].clnt);

    //If we have partial list  then add new list to the existing list
    if( qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total > 0 )
    {
      if(qmi_nasi_global.builtin_plmn_list[as_id].list_id == req_msg->oplmn_list.list_id)
      {
        offset = qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total;
        qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total += (uint16)(req_msg->oplmn_list.oplmn_len);
        
        if(req_msg->ind_token_valid)
        {
          qmi_nasi_global.builtin_plmn_list[as_id].ind_tok_valid = TRUE;
          qmi_nasi_global.builtin_plmn_list[as_id].ind_token = req_msg->ind_token;
        }
        if(qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total < req_msg->oplmn_list.total_list_entries)
        {
          wait_for_more_entries = TRUE;
  }

        if( (qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total > req_msg->oplmn_list.total_list_entries) ||
            (qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total > NAS_MAX_BUILTIN_OPLMN_ENTRIES_V01) )
        {
          errval = QMI_ERR_ARG_TOO_LONG_V01;
        }
        else
        {
          QM_MSG_HIGH("Appending the list...");
          qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_list_len = qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total;
          memscpy(&qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_entry[offset], 
                  (NAS_MAX_BUILTIN_OPLMN_ENTRIES_V01 - offset)*sizeof(nas_oplmn_entry_type_v01),
                  req_msg->oplmn_list.oplmn, (sizeof(nas_oplmn_entry_type_v01)*req_msg->oplmn_list.oplmn_len));
        }
      }
      else
      {
        /* Incorrect list id passed in the second iteration while splitting the large request into multiple small requests 
                    List needs to be sent from beginning again. So clear the context for existing list */
        errval = QMI_ERR_INVALID_ID_V01;
        if(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr != NULL)
        {
          modem_mem_free(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr,MODEM_MEM_CLIENT_QMI_MMODE);
        }
        memset(&qmi_nasi_global.builtin_plmn_list[as_id],0,sizeof(qmi_nasi_global.builtin_plmn_list[as_id]));
      }
    }
    else //Fresh list operation
    {
      qmi_nasi_global.builtin_plmn_list[as_id].list_id = req_msg->oplmn_list.list_id;
      qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total = (uint16)(req_msg->oplmn_list.oplmn_len);
      qmi_nasi_global.builtin_plmn_list[as_id].total_entries = (uint16)(req_msg->oplmn_list.total_list_entries);
      if(req_msg->ind_token_valid)
      {
        qmi_nasi_global.builtin_plmn_list[as_id].ind_tok_valid = TRUE;
        qmi_nasi_global.builtin_plmn_list[as_id].ind_token = req_msg->ind_token;
      }

      if(req_msg->oplmn_list.oplmn_len < req_msg->oplmn_list.total_list_entries)
      {
        wait_for_more_entries = TRUE;
      }
      //Prepare the list
      qmi_nasi_global.builtin_plmn_list[as_id].list_ptr = modem_mem_alloc( sizeof(qmi_nas_builtin_plmn_list_type), MODEM_MEM_CLIENT_QMI_MMODE );
      if( qmi_nasi_global.builtin_plmn_list[as_id].list_ptr != NULL)
      {
        memset(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr, 0, sizeof(qmi_nas_builtin_plmn_list_type));
        qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_list_len = req_msg->oplmn_list.oplmn_len;
        //oplmn_len can be 0 and should be treated as CLEAR EFS operation. No need to copy any data if len is 0
        if(req_msg->oplmn_list.oplmn_len != 0)
        {
          QM_MSG_HIGH("Copying the list...");
          memscpy(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_entry, sizeof(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_entry),
                   req_msg->oplmn_list.oplmn, (sizeof(nas_oplmn_entry_type_v01)*req_msg->oplmn_list.oplmn_len));
        }
      }
      else
  {
        errval = QMI_ERR_NO_MEMORY_V01;
      }
      
    }
  }

  if ( (errval == QMI_ERR_NONE_V01) && !wait_for_more_entries && (qmi_nasi_global.builtin_plmn_list[as_id].list_ptr!=NULL))
    {
    qmi_nas_builtin_plmn_list_type *builtin_plmn_list_ptr =  (qmi_nas_builtin_plmn_list_type *)qmi_nasi_global.builtin_plmn_list[as_id].list_ptr;
    mmgsdi_builtin_plmn_list_type mmgsdi_builtin_plmn_list =  {0};

    mmgsdi_return_enum_type mmgsdi_ret = MMGSDI_SUCCESS;
    uint32 i=0;

    for(i=0;i<builtin_plmn_list_ptr->oplmn_list_len;i++)
    {
        QM_MSG_LOW_4("PLMN %d %d %d, Acess Tech %d", builtin_plmn_list_ptr->oplmn_entry[i].plmn_id_val[0], 
                                   builtin_plmn_list_ptr->oplmn_entry[i].plmn_id_val[1], builtin_plmn_list_ptr->oplmn_entry[i].plmn_id_val[2],
                                   builtin_plmn_list_ptr->oplmn_entry[i].access_tech);
      }

    mmgsdi_builtin_plmn_list.num_of_plmn_ids  = (uint16)builtin_plmn_list_ptr->oplmn_list_len;
    mmgsdi_builtin_plmn_list.plmn_list_ptr    = builtin_plmn_list_ptr->oplmn_list_len ?  (mmgsdi_builtin_plmn_id_type  *)builtin_plmn_list_ptr->oplmn_entry : NULL;
   
    //Calling mmgsdi_set_builtin_plmn_list()...
    if((mmgsdi_ret = mmgsdi_set_builtin_plmn_list(qmi_nasi_global.mmgsdi->client_id, mmgsdi_builtin_plmn_list,
                                                     qmi_nas_mmgsdi_cmd_rsp_cb, (uint32) as_id) ) != MMGSDI_SUCCESS)
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("mmgsdi_set_builtin_plmn_list fail %d", mmgsdi_ret);
    }
    else
    {
      QM_MSG_HIGH_1("mmgsdi_set_builtin_plmn_list sent successfully for as_id %d", as_id);
      qmi_nasi_global.builtin_plmn_list[as_id].list_op_in_prog = TRUE;
    }
  }

  // take care of result
  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_set_builtin_plmn_list_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)rsp_msg,
                                  (uint32_t) sizeof(nas_set_builtin_plmn_list_resp_msg_v01),
                                  &response
                                  );
  }

  if(errval != QMI_ERR_NONE_V01)
  {
    //If the list is not being used at lower layers, free it 
    if( !qmi_nasi_global.builtin_plmn_list[as_id].list_op_in_prog )
    {
      if(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr != NULL)
      {
        modem_mem_free(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr,MODEM_MEM_CLIENT_QMI_MMODE);
      }
      memset(&qmi_nasi_global.builtin_plmn_list[as_id],0,sizeof(qmi_nasi_global.builtin_plmn_list[as_id]));
    }
  }
  else
  {
    //If we are waiting for more entries, send an indication for the client to send the next set of plmn entries
    if(wait_for_more_entries)
    {
      qmi_nas_post_internal_builtin_plmn_cmd((uint8)as_id);
    }
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_set_builtin_plmn_list() */



/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_SET_BUILT_PLMN_LIST_IND

  DESCRIPTION
    Set the built in PLMN List on the modem

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_set_builtin_plmn_list_ind(qmi_error_type_v01 err, enum qmi_nas_subs_e as_id)
{
  qmi_nasi_client_state_type      *cl_sp;
 
  nas_set_builtin_plmn_list_ind_msg_v01 *builtin_plmn_list_ind;

  dsm_item_type                   *ind = NULL;
  
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
      return;
  }


  builtin_plmn_list_ind = (nas_set_builtin_plmn_list_ind_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_set_builtin_plmn_list_ind_msg_v01 ) );

  if ( builtin_plmn_list_ind != NULL )
  {
    memset( builtin_plmn_list_ind, 0x00, sizeof(*builtin_plmn_list_ind) );

    builtin_plmn_list_ind->error = err;
    QM_MSG_HIGH_2("qmi_nas_generate_set_builtin_plmn_list_ind err %d, as_id %d", err, as_id);

      if(qmi_nasi_global.builtin_plmn_list[as_id].ind_tok_valid)
      {
        builtin_plmn_list_ind->ind_token_valid = TRUE;
        builtin_plmn_list_ind->ind_token = qmi_nasi_global.builtin_plmn_list[as_id].ind_token;
      }
      if(err == QMI_ERR_NONE_V01)
      {
        builtin_plmn_list_ind->received_list_entry_count_valid = TRUE;
        builtin_plmn_list_ind->received_list_entry_count = qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total;
        
        builtin_plmn_list_ind->remaining_list_entry_count_valid = TRUE;
        builtin_plmn_list_ind->remaining_list_entry_count = (qmi_nasi_global.builtin_plmn_list[as_id].total_entries - \
                                                            qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total);
      }

      cl_sp = q_linear_search( &qmi_nas_state.client_q,
                                 qmi_nas_qcsi_compare_client_handle,
                                 qmi_nasi_global.builtin_plmn_list[as_id].clnt );      

      if ( cl_sp )
      {
        QM_MSG_HIGH_2("builtin_plmn_list_ind to be sent for client %p, as_id %d", qmi_nasi_global.builtin_plmn_list[as_id].clnt, as_id);
        ind = NULL;
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                  QMI_IDL_INDICATION, 
                                                  (uint16_t)QMI_NAS_SET_BUILTIN_PLMN_LIST_IND_MSG_V01, 
                                                  (void *) builtin_plmn_list_ind,
                                                  (uint32_t)sizeof(nas_set_builtin_plmn_list_ind_msg_v01), 
                                                  &ind
                                                ) )
        {
          qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_SET_BUILTIN_PLMN_LIST, ind );
        }
      }
      else
      {
        QM_MSG_HIGH_1("Client with id %p de-allocated", qmi_nasi_global.builtin_plmn_list[as_id].clnt);
      }

    //If this is the final result, clear the global context maintained for the builtin plmn
    if((err != QMI_ERR_NONE_V01) ||
        (qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total == qmi_nasi_global.builtin_plmn_list[as_id].total_entries) )
    {
      memset(&qmi_nasi_global.builtin_plmn_list[as_id],0,sizeof(qmi_nasi_global.builtin_plmn_list[as_id]));
    }
    QMI_NAS_MEM_FREE( (void *) builtin_plmn_list_ind ); 
  }
  else
  {
    qmi_voice_mem_error();
  }


}/* qmi_nas_generate_set_builtin_plmn_list_ind */
#endif
/*===========================================================================
  FUNCTION QMI_NAS_MAP_LTE_SIB16_DLSAVINGTIME_LTE_TO_QMI()

  DESCRIPTION
    This function maps LTE SIB16 Daylight Saving Time to QMI upon receiving MSG Router LTE Event.
    
  PARAMETERS
    dayLightSavingTime : LTE SIB16  Daylight Saving Time data from MSGR

  RETURN VALUE
    QMI_NAS value of daylight savings in uint8 (values are 0, 1 or 2)
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 qmi_nas_map_lte_sib16_dlsavingtime_lte_to_qmi( lte_rrc_utc_dayLightSaving_type_e dayLightSavingTime )
  {
  uint8 retval = 0;

  switch(dayLightSavingTime)
    {
    case LTE_UTC_DAYLIGHT_PLUS_ONE:
      retval = 1;
      break;
    case LTE_UTC_DAYLIGHT_PLUS_TWO:
      retval = 2;
          break;
    case LTE_UTC_DAYLIGHT_NONE:
         default:
           break;
      }
    
  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_UPDATE_LTE_SIB16_NETWORK_TIME_CACHE()

  DESCRIPTION
    This function updates LTE SIB16 NETWORK TIME CACHE upon receiving MSG Router LTE Event.
    
  PARAMETERS
    lte_sib16_nw_time : Pointer to LTE SIB16 NETWORK TIME data from MSGR

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nas_update_lte_sib16_network_time_cache(lte_rrc_utc_time_update_ind_s *lte_sib16_nw_time)
{
  if(lte_sib16_nw_time)
  {
    qmi_nasi_global.lte_sib16_nw_time_cache.is_valid           = TRUE; 
    qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired = lte_sib16_nw_time->utc_sib16_acquired;
    qmi_nasi_global.lte_sib16_nw_time_cache.asubs_id           = lte_sib16_nw_time->as_subs_id;
    
    qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled = lte_sib16_nw_time->utc_dayLightSavingTime_enabled;
    qmi_nasi_global.lte_sib16_nw_time_cache.dayLightSavingTime = (uint8)qmi_nas_map_lte_sib16_dlsavingtime_lte_to_qmi(lte_sib16_nw_time->dayLightSavingTime);
    
    qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled = lte_sib16_nw_time->utc_leapSeconds_enabled;
    qmi_nasi_global.lte_sib16_nw_time_cache.leapSeconds        = lte_sib16_nw_time->leapSeconds;
    
    qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled = lte_sib16_nw_time->utc_localTimeOffset_enabled;
    qmi_nasi_global.lte_sib16_nw_time_cache.localTimeOffset    = lte_sib16_nw_time->localTimeOffset;

    QM_MSG_HIGH_5("LTE SIB16 NW TIME INFO: sib16_acq = %d, asubs_id = %d, DlSavingsTime = %d, leap_sec = %d, LocalTimeOffset = %d", lte_sib16_nw_time->utc_sib16_acquired, 
        lte_sib16_nw_time->as_subs_id, lte_sib16_nw_time->dayLightSavingTime,lte_sib16_nw_time->leapSeconds, lte_sib16_nw_time->localTimeOffset);
    }
}


/*===========================================================================
  FUNCTION QMI_NASI_GET_LTE_SIB16_NETWORK_TIME()

  DESCRIPTION
    Retrieve the LTE SIB16 Network time
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_lte_sib16_network_time
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  time_genoff_args_struct_type    time_genoff_args;
  uint64                          abs_time = 0;
  time_julian_type                jul_val;

  nas_get_lte_sib16_network_time_resp_msg_v01 *resp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp,sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  resp_msg = (nas_get_lte_sib16_network_time_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_lte_sib16_network_time_resp_msg_v01 ) );

  if ( resp_msg != NULL )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_lte_sib16_network_time_resp_msg_v01 ) );

    resp_msg->lte_sib16_acquired_valid = TRUE;
    if(qmi_nasi_global.lte_sib16_nw_time_cache.is_valid)
    {
      resp_msg->lte_sib16_acquired = (qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired == TRUE ? NAS_TRI_TRUE_V01 : NAS_TRI_FALSE_V01);
    }
      else
  {
     resp_msg->lte_sib16_acquired = NAS_TRI_UNKNOWN_V01;
  }

    if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired)
  {
      resp_msg->daylt_sav_adj_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled == TRUE)
      resp_msg->daylt_sav_adj       = qmi_nasi_global.lte_sib16_nw_time_cache.dayLightSavingTime;

      resp_msg->leap_sec_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled == TRUE)
      resp_msg->leap_sec            = qmi_nasi_global.lte_sib16_nw_time_cache.leapSeconds;

      resp_msg->time_zone_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled == TRUE)
      resp_msg->time_zone           = qmi_nasi_global.lte_sib16_nw_time_cache.localTimeOffset;

      time_genoff_args.base        = ATS_LTE_HR; 
      time_genoff_args.base_source = TIME_SCLK;
      time_genoff_args.ts_val      = (void*)(&abs_time);  // abs_time is same as msec (format is uint64)
      time_genoff_args.unit        = TIME_MSEC;
      time_genoff_args.operation   = T_GET;

      time_genoff_opr( &time_genoff_args );

      resp_msg->abs_time = abs_time;
      resp_msg->abs_time_valid = TRUE;

      time_jul_from_secs( (uint32)(abs_time/1000), &jul_val ); // convert to julian, first parameter is time in sec since Jan 6, 1980 00:00:00 hrs

      resp_msg->universal_time.year        = jul_val.year;
      resp_msg->universal_time.month       = jul_val.month;
      resp_msg->universal_time.day         = jul_val.day;
      resp_msg->universal_time.hour        = jul_val.hour;
      resp_msg->universal_time.minute      = jul_val.minute;
      resp_msg->universal_time.second      = jul_val.second;
      resp_msg->universal_time.millisecond = (uint16)(abs_time % 1000);
      resp_msg->universal_time.day_of_week = jul_val.day_of_week;
      resp_msg->universal_time_valid       = TRUE;
      }

    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                  QMI_NAS_GET_LTE_SIB16_NETWORK_TIME_RESP_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_lte_sib16_network_time_resp_msg_v01 ),
                                    &response
                                  );
    }
    else
    {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) resp_msg ); }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nas_update_cached_time_info()

  DESCRIPTION
    save NITZ information from NW.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_update_cached_time_info( cm_mm_ss_info_s_type *p_info )
{
  #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
  int index;
  #endif
  #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)  || defined(FEATURE_HDR)
  for( index = 0; index < p_info->number_of_stacks && index < STACK_INDEX_MAX; index++ )
  #endif
  {
    QM_MSG_HIGH_3("sys_mode=%d unexpected bitmask %x %x", p_info->sys_mode,
        (dword)(p_info->changed_fields & (uint64)0xFFFFFFFF), (dword)(p_info->changed_fields >> 32));
    

    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)  || defined(FEATURE_HDR)
    if( p_info->stack_info[index].changed_fields & CM_SS_EVT_CDMA_TIME_CHGD_MASK &&
        ( p_info->stack_info[index].sys_mode == SYS_SYS_MODE_CDMA || p_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR ) )
  {
      if ( p_info->stack_info[index].mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_CDMA )
    {
        QM_MSG_HIGH_3("CDMA TZ=%d,DST=%d,lp_sec=%d ", p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.ltm_offset, p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.daylt_savings, p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.lp_sec);
      
      qmi_nasi_nitz_time.cdma_cache.is_valid = TRUE;
      qmi_nasi_nitz_time.hdr_cache.is_valid = FALSE;
        qmi_nasi_nitz_time.cdma_cache.lp_sec = p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.lp_sec;
      // cdma reports in units of 30 min
        qmi_nasi_nitz_time.cdma_cache.time_zone = QMI_NAS_6BIT_2_8BIT( p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.ltm_offset ) * 2;
        qmi_nasi_nitz_time.cdma_cache.daylt_savings = p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.daylt_savings;
        QM_MSG_HIGH_1("CDMA Calc TZ=%d", qmi_nasi_nitz_time.cdma_cache.time_zone);
      qmi_nasi_nitz_time.radio_if = QMI_NAS_RADIO_IF_CDMA20001X;
        break;
    }
      else if ( p_info->stack_info[index].mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_HDR )
    {

      qmi_nasi_nitz_time.hdr_cache.is_valid = TRUE;
      qmi_nasi_nitz_time.cdma_cache.is_valid = FALSE;
        qmi_nasi_nitz_time.hdr_cache.lp_sec = p_info->stack_info[index].mode_info.cdma_info.time_info.time.hdr_time.lp_sec;
        qmi_nasi_nitz_time.hdr_cache.time_zone = (uint8)(p_info->stack_info[index].mode_info.cdma_info.time_info.time.hdr_time.ltm_offset/15);
      qmi_nasi_nitz_time.hdr_cache.daylt_savings = NAS_DAYLT_SAV_ADJ_NONE;
        QM_MSG_HIGH_3("HDR TZ=%d,lp_sec=%d,calc TZ=%d", p_info->stack_info[index].mode_info.cdma_info.time_info.time.hdr_time.ltm_offset, p_info->stack_info[index].mode_info.cdma_info.time_info.time.hdr_time.lp_sec, qmi_nasi_nitz_time.hdr_cache.time_zone);
      qmi_nasi_nitz_time.radio_if = QMI_NAS_RADIO_IF_CDMA20001XEVDO;
        break;
    }
  }
  else 
  #endif
  if( p_info->changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK &&
            #ifndef FEATURE_MMODE_QMI_LTE_ONLY
             ( p_info->sys_mode == SYS_SYS_MODE_GSM ||
               #if defined(FEATURE_WCDMA)
               p_info->sys_mode == SYS_SYS_MODE_WCDMA || 
               #endif
               p_info->sys_mode == SYS_SYS_MODE_LTE 
               #if defined(FEATURE_TDSCDMA)
               || p_info->sys_mode == SYS_SYS_MODE_TDS 
               #endif
               ) 
            #else
            ( p_info->sys_mode == SYS_SYS_MODE_LTE ) 
            #endif
     )
  {
    if (!p_info->mm_information.univ_time_and_time_zone_avail &&
        !p_info->mm_information.time_zone_avail &&
        !p_info->mm_information.daylight_saving_adj_avail)
    {
      QM_MSG_HIGH("Mobility management mask set, but no time data available");
      #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)  || defined(FEATURE_HDR)
      continue;
      #endif
    }
    #if defined(FEATURE_CDMA)
    qmi_nasi_nitz_time.cdma_cache.is_valid = FALSE;
    #endif
    #if defined(FEATURE_HDR)
    qmi_nasi_nitz_time.hdr_cache.is_valid = FALSE;
    #endif
    #if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
    qmi_nasi_nitz_time.umts_cache.is_valid = TRUE;

    if ( p_info->mm_information.univ_time_and_time_zone_avail )
    {

      qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone_avail = TRUE;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.year = p_info->mm_information.univ_time_and_time_zone.year;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.month = p_info->mm_information.univ_time_and_time_zone.month;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.day = p_info->mm_information.univ_time_and_time_zone.day;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.hour = p_info->mm_information.univ_time_and_time_zone.hour;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.minute = p_info->mm_information.univ_time_and_time_zone.minute;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.second = p_info->mm_information.univ_time_and_time_zone.second;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.time_zone = p_info->mm_information.univ_time_and_time_zone.time_zone;

        QM_MSG_HIGH_3("From NW GW time: %d:%d:%d ", p_info->mm_information.univ_time_and_time_zone.hour, p_info->mm_information.univ_time_and_time_zone.minute, p_info->mm_information.univ_time_and_time_zone.second);
    

    }
      else if ( p_info->mm_information.time_zone_avail )
    {
      qmi_nasi_nitz_time.umts_cache.time_zone_avail = TRUE;
      qmi_nasi_nitz_time.umts_cache.time_zone = (int8)p_info->mm_information.time_zone;
      QM_MSG_HIGH_1("From NW GW only TZ: %d ", p_info->mm_information.time_zone);
    
    }

    if ( p_info->mm_information.daylight_saving_adj_avail )
    {
      qmi_nasi_nitz_time.umts_cache.daylight_saving_adj_avail = TRUE;
      qmi_nasi_nitz_time.umts_cache.daylight_saving_adj = (uint8)p_info->mm_information.daylight_saving_adj;
      QM_MSG_HIGH_1("From NW GW only DST: %d ", p_info->mm_information.daylight_saving_adj);
    }
    #endif
    qmi_nasi_nitz_time.radio_if = (uint8)qmi_nas_sys_mode_2_radio_if( p_info, FALSE );
    #if defined(FEATURE_MMODE_CDMA_800) || defined(FEATURE_MMODE_CDMA_1900)  || defined(FEATURE_HDR)
    break;
    #endif
  }
      }
}

/*===========================================================================
  FUNCTION qmi_nas_get_nitz_time_from_cache()

  DESCRIPTION
    Retrieve the 1x/HDR/GW Network time from Cache
    
  PARAMETERS

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

boolean qmi_nas_get_nitz_time_from_cache(nas_get_network_time_resp_msg_v01 *resp)
{

  time_genoff_args_struct_type time_genoff_args;
  time_julian_type             jul_val;
  time_type                    ts_val_secs; // genoff time in secs
  uint32                       secs; // genoff time in secs temp var
  byte                         lp_sec = 0;
  time_bases_type              time_base  = ATS_RTC;
  
  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))

  if ( qmi_nasi_nitz_time.cdma_cache.is_valid )
  {
    time_base = ATS_TOD;
    lp_sec    = qmi_nasi_nitz_time.cdma_cache.lp_sec;
    resp->nas_3gpp2_time_valid = TRUE;
    resp->nas_3gpp2_time.daylt_sav_adj = qmi_nasi_nitz_time.cdma_cache.daylt_savings;
    resp->nas_3gpp2_time.time_zone = qmi_nasi_nitz_time.cdma_cache.time_zone;
    resp->nas_3gpp2_time.radio_if = (nas_radio_if_enum_v01)qmi_nasi_nitz_time.radio_if;
  }
  else if ( qmi_nasi_nitz_time.hdr_cache.is_valid )
  {
    time_base = ATS_TOD;
    lp_sec    = qmi_nasi_nitz_time.hdr_cache.lp_sec;
    resp->nas_3gpp2_time_valid = TRUE;
    resp->nas_3gpp2_time.daylt_sav_adj = qmi_nasi_nitz_time.hdr_cache.daylt_savings;
    resp->nas_3gpp2_time.time_zone = qmi_nasi_nitz_time.hdr_cache.time_zone;
    resp->nas_3gpp2_time.radio_if = (nas_radio_if_enum_v01)qmi_nasi_nitz_time.radio_if;
  }
  else 
  #endif
  #if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  if( qmi_nasi_nitz_time.umts_cache.is_valid )
  {
    time_base = ATS_3GPP;
    resp->nas_3gpp_time.radio_if = (nas_radio_if_enum_v01)qmi_nasi_nitz_time.radio_if;
    resp->nas_3gpp_time_valid = TRUE;
    if(qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone_avail)
    {
      resp->nas_3gpp_time.time_zone = qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.time_zone;
      resp->nas_3gpp_time.daylt_sav_adj = NAS_DAYLT_SAV_ADJ_NONE;
    }

    if(qmi_nasi_nitz_time.umts_cache.time_zone_avail)
    {
      resp->nas_3gpp_time.time_zone = qmi_nasi_nitz_time.umts_cache.time_zone;
    }

    if(qmi_nasi_nitz_time.umts_cache.daylight_saving_adj_avail)
    {
      resp->nas_3gpp_time.daylt_sav_adj = qmi_nasi_nitz_time.umts_cache.daylight_saving_adj;
    }
  }
  else
  #endif
  {
    QM_MSG_ERROR("Invalid Nitz Cache GET_NITZ_TIME response.");
    return FALSE;
  }

  // read time from time service
  time_genoff_args.base        = time_base; 
  time_genoff_args.base_source = TIME_SCLK;
  time_genoff_args.ts_val      = (void *)&ts_val_secs;
  time_genoff_args.unit        = TIME_SECS;
  time_genoff_args.operation   = T_GET;
  
  time_genoff_opr( &time_genoff_args );
  secs  = ts_val_secs[0];
  secs -= lp_sec; // subtract leap seconds
  QM_MSG_HIGH_2("secs %d lp_sec %d", secs, lp_sec);
  
  time_jul_from_secs( secs, &jul_val ); // convert to julian
  
  QM_MSG_HIGH_6("y %d m %d d %d h %d m %d s %d", jul_val.year, jul_val.month, jul_val.day, jul_val.hour, jul_val.minute, jul_val.second);
  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  if(resp->nas_3gpp2_time_valid)
  { 
    QM_MSG_HIGH_3("TZ %d DST %d lp_sec %d", resp->nas_3gpp2_time.time_zone, resp->nas_3gpp2_time.daylt_sav_adj, lp_sec);
    resp->nas_3gpp2_time.universal_time.year        = jul_val.year;
    resp->nas_3gpp2_time.universal_time.month       = jul_val.month;
    resp->nas_3gpp2_time.universal_time.day         = jul_val.day;
    resp->nas_3gpp2_time.universal_time.hour        = jul_val.hour;
    resp->nas_3gpp2_time.universal_time.minute      = jul_val.minute;
    resp->nas_3gpp2_time.universal_time.second      = jul_val.second;
    resp->nas_3gpp2_time.universal_time.day_of_week = jul_val.day_of_week;
  }
  else 
  #endif
  #if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  if(resp->nas_3gpp_time_valid)
  {
    QM_MSG_HIGH_3("TZ %d DST %d lp_sec %d", resp->nas_3gpp_time.time_zone, resp->nas_3gpp_time.daylt_sav_adj, lp_sec);
    resp->nas_3gpp_time.universal_time.year        = jul_val.year;
    resp->nas_3gpp_time.universal_time.month       = jul_val.month;
    resp->nas_3gpp_time.universal_time.day         = jul_val.day;
    resp->nas_3gpp_time.universal_time.hour        = jul_val.hour;
    resp->nas_3gpp_time.universal_time.minute      = jul_val.minute;
    resp->nas_3gpp_time.universal_time.second      = jul_val.second;
    resp->nas_3gpp_time.universal_time.day_of_week = jul_val.day_of_week;
    }
  else
  #endif
    {
    QM_MSG_ERROR("Invalid Nitz data in GET_NITZ_TIME response.");
    return FALSE;
  }

  return TRUE;
}

/*===========================================================================
  FUNCTION qmi_nasi_get_network_time()

  DESCRIPTION
    Retrieve the GW/1X/HDR Network time from Cached information.

  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_network_time
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_network_time_resp_msg_v01 *resp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp,sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  resp_msg = (nas_get_network_time_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_network_time_resp_msg_v01 ) );

  if ( resp_msg != NULL )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_network_time_resp_msg_v01 ) );

    if(
        #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
        !qmi_nasi_nitz_time.cdma_cache.is_valid && !qmi_nasi_nitz_time.hdr_cache.is_valid  &&
        #endif
        !qmi_nasi_nitz_time.umts_cache.is_valid)
    {
      QM_MSG_ERROR("Nitz time information not available from NW");
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
    else
    {
      if(!qmi_nas_get_nitz_time_from_cache(resp_msg))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("Invalid NITZ time cache NW err=%d", errval);
      }
    }

    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  QMI_NAS_GET_NETWORK_TIME_RESP_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_network_time_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) 
  { 
    QMI_NAS_MEM_FREE( (void *) resp_msg ); 
    resp_msg = NULL;
  }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_LTE_SIB16_NETWORK_TIME_IND()

  DESCRIPTION
    Generates and sends the LTE SIB16 Network time IND
    
  PARAMETERS
    None

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nas_generate_lte_sib16_network_time_ind(void)
{
  time_genoff_args_struct_type time_genoff_args;
  time_julian_type             jul_val;
  uint64                       abs_time;

  nas_lte_sib16_network_time_ind_msg_v01        *ind_msg;
  dsm_item_type               *ind;

  qmi_nasi_client_state_type  *cl_sp;
  enum qmi_nas_subs_e          bound_subs = QMI_NAS_SUBS_PRIMARY;

  ind_msg = (nas_lte_sib16_network_time_ind_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_lte_sib16_network_time_ind_msg_v01 ) );

  if ( ind_msg != NULL )
{  
    memset( ind_msg, 0x00, sizeof( nas_lte_sib16_network_time_ind_msg_v01 ) );

    ind_msg->lte_sib16_acquired = (qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired == TRUE ? NAS_TRI_TRUE_V01 : NAS_TRI_FALSE_V01);
    ind_msg->lte_sib16_acquired_valid = TRUE;

    if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired)
    {
      ind_msg->daylt_sav_adj_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled == TRUE)
      ind_msg->daylt_sav_adj       = qmi_nasi_global.lte_sib16_nw_time_cache.dayLightSavingTime;

      ind_msg->leap_sec_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled == TRUE)
      ind_msg->leap_sec            = qmi_nasi_global.lte_sib16_nw_time_cache.leapSeconds;

      ind_msg->time_zone_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled == TRUE)
      ind_msg->time_zone           = qmi_nasi_global.lte_sib16_nw_time_cache.localTimeOffset;

      time_genoff_args.base        = ATS_LTE_HR; 
      time_genoff_args.base_source = TIME_SCLK;
      time_genoff_args.ts_val      = (void*)(&abs_time);  // abs_time is same as msec (format is uint64)
      time_genoff_args.unit        = TIME_MSEC;
      time_genoff_args.operation   = T_GET;

      time_genoff_opr( &time_genoff_args );

      ind_msg->abs_time = abs_time;
      ind_msg->abs_time_valid = TRUE;

      time_jul_from_secs( (uint32)(abs_time/1000), &jul_val ); // convert to julian, first parameter is time in sec since Jan 6, 1980 00:00:00 hrs

      ind_msg->universal_time.year        = jul_val.year;
      ind_msg->universal_time.month       = jul_val.month;
      ind_msg->universal_time.day         = jul_val.day;
      ind_msg->universal_time.hour        = jul_val.hour;
      ind_msg->universal_time.minute      = jul_val.minute;
      ind_msg->universal_time.second      = jul_val.second;
      ind_msg->universal_time.millisecond = (uint16)(abs_time % 1000);
      ind_msg->universal_time.day_of_week = jul_val.day_of_week;
      ind_msg->universal_time_valid = TRUE;

      QM_MSG_HIGH_8("y %d m %d d %d h %d m %d s %d msec %d abs_time %llu", jul_val.year, jul_val.month, jul_val.day,
          jul_val.hour, jul_val.minute, jul_val.second, ind_msg->universal_time.millisecond, abs_time);
    }


    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {

      if ( cl_sp->report_status.report_lte_sib16_network_time && cl_sp->report_status.bound_subs == bound_subs )
      {
        ind = NULL;
 
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_INDICATION,
                                                  QMI_NAS_LTE_SIB16_NETWORK_TIME_IND_V01,
                                                  (void *) ind_msg,
                                                  (uint32_t) sizeof( nas_lte_sib16_network_time_ind_msg_v01 ),
                                                  &ind
                                                )
          )
      {
          qmi_nasi_send_ind( cl_sp, (uint16)QMI_NAS_LTE_SIB16_NETWORK_TIME_IND_V01, ind );
      }
      else
      {
           QM_MSG_ERROR_1("failed to send LTE_SIB16_NETWORK_TIME ind, client %p", cl_sp->clnt);
        }
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( ind_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) ind_msg ); }
}

/*===========================================================================
  FUNCTION QMI_NASI_SET_LTE_BAND_PRIORITY()

  DESCRIPTION
    Message to set the lte band priority list
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_lte_band_priority
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  errno_enum_type             msgr_err = E_SUCCESS;
  uint8                       b_cnt = 0;

  nas_set_lte_band_priority_req_msg_v01  *req_msg = NULL;
  nas_set_lte_band_priority_resp_msg_v01 *rsp_msg = NULL;

  lte_rrc_band_pri_change_req_s msg;
  int i;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( qmi_nasi_global.set_lte_band_p == NULL )
  {
    qmi_nasi_global.set_lte_band_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    req_msg = (nas_set_lte_band_priority_req_msg_v01 *) modem_mem_alloc( sizeof(nas_set_lte_band_priority_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0x00, sizeof(nas_set_lte_band_priority_req_msg_v01) );

    
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           QMI_NAS_SET_LTE_BAND_PRIORITY_REQ_MSG_V01,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_lte_band_priority_req_msg_v01)
                                         );
  }
  
  
  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_0080_req_check(req_msg);
    }

  if( errval == QMI_ERR_NONE_V01 )
    {
    memset(&msg, 0x00, sizeof(lte_rrc_band_pri_change_req_s) );

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_BAND_PRI_CHANGE_REQ );
    QM_MSG_HIGH_1("Number of bands recv = %d", req_msg->band_priority_list_len);

    for ( i = 0; i < (int)MIN(SYS_SBAND_LTE_EUTRAN_BAND_MAX, req_msg->band_priority_list_len); i++ )
    {
      if( (msg.band_priority_list[i] = qmi_nas_qmi_lte_bc_2_sys_lte_bc( req_msg->band_priority_list[i] )) == SYS_SBAND_LTE_EUTRAN_BAND_MAX )
  {
        errval = QMI_ERR_INTERNAL_V01;
        break;
      }
      b_cnt++;
      QM_MSG_HIGH_3("Band%d = %d, rrc band = %d ", b_cnt, req_msg->band_priority_list[i], msg.band_priority_list[i]);
  }

    if ( errval == QMI_ERR_NONE_V01 )
  {
      msg.num_prioritized_bands = b_cnt;
      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
    }
    else
    {
      response = QMI_SVC_RESPONSE_PENDING;
    }
  }
  }

  if ( errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_set_lte_band_priority_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_lte_band_priority_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

    if( rsp_msg != NULL )
    {
      memset(rsp_msg, 0x00, sizeof(nas_set_lte_band_priority_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    QMI_NAS_SET_LTE_BAND_PRIORITY_RESP_MSG_V01,
                                    (void *)rsp_msg,
                                    (uint32_t)sizeof(nas_set_lte_band_priority_resp_msg_v01),
                                    &response
                                  );
      //Free the cmd_buf_p stored
      qmi_nasi_global.set_lte_band_p = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg != NULL ) { modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_SET_E911_STATE_RESP()

  DESCRIPTION
    Generate and send response for putting modem into enter/exit emergency state
    
  PARAMETERS
    msg_p  Pointer to MSGR data for E911 state info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_set_lte_band_priority_resp
( 
  lte_rrc_band_pri_change_cnf_s * lte_band_pri_cnf
)
{  
  dsm_item_type *             response = NULL;
  boolean                     retval = FALSE;
  qmi_mmode_qcsi_transaction_type           *cmd_buf_p = qmi_nasi_global.set_lte_band_p;

  nas_set_lte_band_priority_resp_msg_v01 *rsp_msg = NULL;
  
  if ( cmd_buf_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in SET_LTE_BAND_PRIORITY resp: %d", cmd_buf_p);
    qmi_nasi_global.set_lte_band_p = NULL;
    return; //nothing to send
  }
  
  if(lte_band_pri_cnf)
  {
    rsp_msg = (nas_set_lte_band_priority_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_lte_band_priority_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  
    if(rsp_msg)
    {
      memset(rsp_msg, 0, sizeof(nas_set_lte_band_priority_resp_msg_v01) );
      QM_MSG_HIGH_1("LTE band priority conf status recv = %d", lte_band_pri_cnf->status);
  
      if ( lte_band_pri_cnf->status == TRUE )
      {
          rsp_msg->resp.error  = QMI_ERR_NONE_V01;
          rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
      }
      else
      {
        rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
      }
    
          retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                 QMI_IDL_RESPONSE,
                                             QMI_NAS_SET_LTE_BAND_PRIORITY_RESP_MSG_V01,
                                                 (void *)rsp_msg,
                                             (uint32_t)sizeof(nas_set_lte_band_priority_resp_msg_v01),
                                                 &response
                                               );
          if( retval )
          {
            if( !qmi_nasi_send_response(cmd_buf_p, response) )
            {
          QM_MSG_ERROR_2("Unable to send QMI_NAS_SET_LTE_BAND_PRIORITY resp result %d, cmd_buf_p %x", lte_band_pri_cnf->status, cmd_buf_p);
        }
      }
      //Free the cmd_buf_p stored
      qmi_nasi_global.set_lte_band_p = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
    
    if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  }
  else
  {
    QM_MSG_ERROR("MSGR set_lte_band_pri is NULL, no response sent");
  }
}

#ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_EXT_V01
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_EMBMS_SIG_EXT_RSP ()

  DESCRIPTION
    Returns eMBMS signal strength information
    
===========================================================================*/
void qmi_nasi_generate_get_embms_sig_ext_rsp( qmi_mmodei_msgr_type * msg_p )
{
  dsm_item_type         *response = NULL;
#ifdef FEATURE_LTE_EMBMS
  int                                 i, j;
#endif
  qmi_error_type_v01                  errval = QMI_ERR_NONE_V01;
  nas_get_embms_sig_ext_resp_msg_v01 *rsp_msg;
  qmi_mmode_qcsi_transaction_type                   *cmd_buf_p = qmi_nasi_global.embms_ext_cmd_buf_p;

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in QMI_NAS_GET_EMBMS_SIG_EXT resp: %d", cmd_buf_p);
    qmi_nasi_global.cmd_buf_p = NULL;
    return; //nothing to send
  }

  rsp_msg = (nas_get_embms_sig_ext_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_embms_sig_ext_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg != NULL )
  {
    memset( rsp_msg, 0, sizeof( nas_get_embms_sig_ext_resp_msg_v01 ) );

#ifdef FEATURE_LTE_EMBMS
    if ( errval == QMI_ERR_NONE_V01 )
    {
      rsp_msg->trace_id_valid = TRUE;
      rsp_msg->trace_id = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.debug_trace_id;

      for ( i=0; i<NAS_LTE_EMBMS_MAX_MBSFN_AREA_V01 && i<msg_p->cmd.qmi_nas.embms_sig_cnf_ext.num_mbsfn_areas ; i++ )
      {
        rsp_msg->snr_and_tmgi_list[i].area_id      = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].area_id;
        rsp_msg->snr_and_tmgi_list[i].snr          = (float)(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].snr)/8.0;

        QM_MSG_HIGH_2("qmi_nasi_generate_get_embms_sig_ext_rsp: area_id = %d, snr = %f", rsp_msg->snr_and_tmgi_list[i].area_id, rsp_msg->snr_and_tmgi_list[i].snr);

        rsp_msg->snr_and_tmgi_list[i].excess_snr = (float)(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].excess_snr)/8.0;

        for ( j=0; j<NAS_TMGI_BEARER_INFO_MAX_V01 && j<msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].num_active_embms_sessions && j<LTE_EMBMS_MAX_ACTIVE_SESSIONS; j++ )
        {
          rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].mrb_id = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].mrb_id;
          rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].session_id_valid = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].session_info.session_id_present;
          if ( rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].session_id_valid )
          {
            rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].session_id = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].session_info.session_id;
          }

          memscpy((void*)rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].tmgi_identifier, NAS_EMBMS_TMGI_SVC_ID_SIZE,
                       (void*)&(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].session_info.tmgi.service_id), NAS_EMBMS_TMGI_SVC_ID_SIZE);

          memscpy((void*)(rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].tmgi_identifier + NAS_EMBMS_TMGI_PLMN_OFFSET), NAS_EMBMS_TMGI_PLMN_ID_SIZE,
                       (void*)&(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].session_info.tmgi.plmn_id.identity), NAS_EMBMS_TMGI_PLMN_ID_SIZE);

        }
        rsp_msg->snr_and_tmgi_list[i].tmgi_info_len = j;
      }
      rsp_msg->snr_and_tmgi_list_len   = i;
      rsp_msg->snr_and_tmgi_list_valid = TRUE;
            }
#else
  if( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
          }
#endif
  
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = errval;
         
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                 QMI_IDL_RESPONSE,
                                              (uint16_t)QMI_NAS_GET_EMBMS_SIG_EXT_RESP_MSG_V01,
                                                 (void *)rsp_msg,
                                              (uint32_t) sizeof( nas_get_embms_sig_ext_resp_msg_v01 ),
                                                 &response
                                            ) )
    {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
      {
        /*Unable to send GET_EMBMS_SIG_EXT response*/
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
      }
    }
    else
    {
      qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }    
  }
  else
  {
    qmi_voice_mem_error();
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
 
  if ( rsp_msg!= NULL ) { modem_mem_free((void*)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  qmi_nasi_global.cmd_buf_p = NULL;
          }
#endif      
/*===========================================================================
  FUNCTION QMI_NASI_GET_LTE_BAND_PRIORITY_LIST()

  DESCRIPTION
    Message to get the lte band priority list
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_lte_band_priority_list
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01            errval   = QMI_ERR_NONE_V01;
  errno_enum_type             msgr_err = E_SUCCESS;

  nas_get_lte_band_priority_list_resp_msg_v01 *rsp_msg = NULL;

  lte_rrc_get_band_pri_list_req_s msg;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( qmi_nasi_global.get_lte_band_p == NULL )
  {
    qmi_nasi_global.get_lte_band_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
      }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset(&msg, 0x00, sizeof(lte_rrc_get_band_pri_list_req_s) );
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_GET_BAND_PRI_LIST_REQ );
    msg.lte_band_cap = qmi_nasi_global.cm_ph_info.lte_band_capability;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("LTE Get Band Priority send fail %d", msgr_err);
    }
    else
    {
      response = QMI_SVC_RESPONSE_PENDING;
      QM_MSG_HIGH("LTE Get Band Priority Sent successfully to LTE-RRC pending response");
    }
    }
  
  if ( errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_get_lte_band_priority_list_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_lte_band_priority_list_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

    if( rsp_msg != NULL )
    {
      memset(rsp_msg, 0x00, sizeof(nas_get_lte_band_priority_list_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    QMI_NAS_GET_LTE_BAND_PRIORITY_LIST_RESP_MSG_V01,
                                    (void *)rsp_msg,
                                    (uint32_t)sizeof(nas_get_lte_band_priority_list_resp_msg_v01),
                                    &response
                                  );
      //Free the cmd_buf_p stored
      qmi_nasi_global.get_lte_band_p = NULL;
  }
  else
  {
      qmi_voice_mem_error();
    }
  }

  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nasi_generate_get_lte_band_priority_list_resp()

  DESCRIPTION
    Generate and send response for get lte band priority list.
    
  PARAMETERS
    msg_p  

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_lte_band_priority_list_resp
(
  lte_rrc_get_band_pri_list_cnf_s * lte_get_band_pri_cnf
)
{
  dsm_item_type *             response = NULL;
  boolean                     retval = FALSE;
  qmi_mmode_qcsi_transaction_type           *cmd_buf_p = qmi_nasi_global.get_lte_band_p;
  qmi_error_type_v01            errval   = QMI_ERR_NONE_V01;
  nas_get_lte_band_priority_list_resp_msg_v01 *rsp_msg = NULL;
  int i=0;


  if ( cmd_buf_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GET_LTE_BAND_PRIORITY_LIST resp: %d", cmd_buf_p);
    qmi_nasi_global.get_lte_band_p = NULL;
    return; //nothing to send
  }
  
  if(lte_get_band_pri_cnf)
    {

    QM_MSG_HIGH_2("LTE get band priority conf recv = %d, Supported = %d", lte_get_band_pri_cnf->num_configured_bands, lte_get_band_pri_cnf->num_supported_bands);

    rsp_msg = (nas_get_lte_band_priority_list_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_lte_band_priority_list_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

    if(rsp_msg)
    {
      memset(rsp_msg, 0, sizeof(nas_get_lte_band_priority_list_resp_msg_v01) );

      for ( i = 0; (i<(int)NAS_LTE_BAND_PRIORITY_LIST_MAX_V01)&&(i <(int) MIN(SYS_SBAND_LTE_EUTRAN_BAND_MAX, lte_get_band_pri_cnf->num_configured_bands)); i++ )
      {
        if( (rsp_msg->configured_band_priority_list[i] = qmi_nas_qmi_sys_lte_bc_2_lte_bc( lte_get_band_pri_cnf->configured_band_pri_list[i] )) == NAS_ACTIVE_BAND_ENUM_MAX_ENUM_VAL_V01 )
        {
          errval = QMI_ERR_INTERNAL_V01;
          rsp_msg->configured_band_priority_list_valid = FALSE;
          QM_MSG_ERROR_1("Received Invalid configured band from LTE RRC %d", lte_get_band_pri_cnf->configured_band_pri_list[i]);
          break;
        }
        QM_MSG_HIGH_2("Index=%d : configured band = %d", i, rsp_msg->configured_band_priority_list[i]);
      }

      if (errval == QMI_ERR_NONE_V01 && i > 0)
      {
        rsp_msg->configured_band_priority_list_valid = TRUE;
        rsp_msg->configured_band_priority_list_len = i;
      }

      i = 0;

      for ( i = 0; (i<(int)NAS_LTE_BAND_PRIORITY_LIST_MAX_V01)&&(i < (int)MIN(SYS_SBAND_LTE_EUTRAN_BAND_MAX, lte_get_band_pri_cnf->num_supported_bands)); i++ )
      {
        if( (rsp_msg->supported_band_priority_list[i] = qmi_nas_qmi_sys_lte_bc_2_lte_bc( lte_get_band_pri_cnf->supported_band_pri_list[i] )) == NAS_ACTIVE_BAND_ENUM_MAX_ENUM_VAL_V01 )
        {
          errval = QMI_ERR_INTERNAL_V01;
          rsp_msg->supported_band_priority_list_valid = FALSE;
          QM_MSG_ERROR_1("Received Invalid supported band from LTE RRC %d", lte_get_band_pri_cnf->supported_band_pri_list[i]);
          break;
        }
        QM_MSG_HIGH_2("Index=%d : supported band = %d", i, rsp_msg->supported_band_priority_list[i]);
      }

      if (errval == QMI_ERR_NONE_V01 && i > 0)
      {
        rsp_msg->supported_band_priority_list_valid = TRUE;
        rsp_msg->supported_band_priority_list_len = i;
      }

      
      if ( errval == QMI_ERR_NONE_V01 )
      {
        rsp_msg->resp.error  = QMI_ERR_NONE_V01;
        rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
    }
    else
    {
        rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
      }
    
      retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_RESPONSE,
                                             QMI_NAS_GET_LTE_BAND_PRIORITY_LIST_RESP_MSG_V01,
                                             (void *)rsp_msg,
                                             (uint32_t)sizeof(nas_get_lte_band_priority_list_resp_msg_v01),
                                             &response
                                           );
      if( retval )
      {
        qmi_nasi_send_response(cmd_buf_p, response);
        /*Send QMI_NAS_GET_LTE_BAND_PRIORITY_LIST resp result*/        
      }
      //Free the cmd_buf_p stored
      qmi_nasi_global.get_lte_band_p = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
    
    if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
    }
  else
  {
    QM_MSG_ERROR("MSGR get_lte_band_pri is NULL, no response sent");
  }
}
#ifndef REMOVE_QMI_NAS_GET_SERV_CELL_SIB_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_SERVING_CELL_SIB()

  DESCRIPTION
    Message to get the serving cell sib
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_serving_cell_sib
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type                *response   = NULL;
  qmi_error_type_v01            errval     = QMI_ERR_NONE_V01;
  errno_enum_type               msgr_err   = E_SUCCESS;
  nas_get_serv_cell_sib_req_msg_v01  *req_msg = NULL;
  nas_get_serv_cell_sib_resp_msg_v01 *rsp_msg = NULL;

  lte_rrc_get_serv_cell_sib_req_s msg;


  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_get_serv_cell_sib_req_msg_v01 *)modem_mem_alloc(sizeof(nas_get_serv_cell_sib_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if(!TARGET_SUPPORTS_LTE)
  {
    QM_MSG_ERROR("Target not supporting LTE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }
  else if(req_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset(req_msg, 0x00, sizeof(nas_get_serv_cell_sib_req_msg_v01));
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_mmode_idl_message_decode(qmi_nasi_global.svc_obj,
                                          (uint16_t)cmd_buf_p->msg_id,
                                          sdu_in,
                                          (void *) req_msg,
                                          (uint32_t) sizeof(nas_get_serv_cell_sib_req_msg_v01)
                                         );
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_008F_req_check(req_msg);
  }

  if ( qmi_nasi_global.get_serv_cell_sib == NULL )
  {
    qmi_nasi_global.get_serv_cell_sib = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset(&msg, 0x00, sizeof(lte_rrc_get_serv_cell_sib_req_s) );
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_GET_SERV_CELL_SIB_REQ );
    msg.sib_num = req_msg->sib_num;
    QM_MSG_HIGH_1("sending sib_num = %d", msg.sib_num);

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Get Serving Cell SIB send fail %d", msgr_err);
    }
    else
    {
      response = QMI_SVC_RESPONSE_PENDING;
      QM_MSG_HIGH("Get Serving Cell SIB sent successfully to LTE-RRC pending response");
    }
  }
  
  if ( errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_get_serv_cell_sib_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_serv_cell_sib_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

    if( rsp_msg != NULL )
    {
      memset(rsp_msg, 0x00, sizeof(nas_get_serv_cell_sib_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

     qmi_mmode_idl_message_encode(qmi_nasi_global.svc_obj,
                                       QMI_IDL_RESPONSE,
                                       QMI_NAS_GET_SERV_CELL_SIB_RESP_MSG_V01,
                                       (void *)rsp_msg,
                                       (uint32_t)sizeof(nas_get_serv_cell_sib_resp_msg_v01),
                                       &response
                                      );

      //Free the cmd_buf_p stored
      qmi_nasi_global.get_serv_cell_sib = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg != NULL ) { modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}


/*===========================================================================
  FUNCTION qmi_nasi_generate_get_serving_cell_sib_resp()

  DESCRIPTION
    Generate and send response for get serving cell SIB.
    
  PARAMETERS
    msg_p  

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_serving_cell_sib_resp
(
  lte_rrc_get_serv_cell_sib_cnf_s* lte_get_serv_cell_cnf
)
{
  dsm_item_type                        *response     = NULL;
  boolean                               retval       = FALSE;
  qmi_mmode_qcsi_transaction_type                     *cmd_buf_p    = qmi_nasi_global.get_serv_cell_sib;
  nas_get_serv_cell_sib_resp_msg_v01   *rsp_msg      = NULL;
  msgr_attach_struct_type *att_ptr;
  dsm_item_type *dsm_ptr;


  if( cmd_buf_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GET_SERV_CELL_SIB resp: %d", cmd_buf_p);
    qmi_nasi_global.get_serv_cell_sib = NULL;
    return; //nothing to send
  }

  if(lte_get_serv_cell_cnf)
  {
    QM_MSG_HIGH_1("LTE get serving cell conf recv: lte_get_serv_cell_cnf->status = %d", lte_get_serv_cell_cnf->status);

    rsp_msg = (nas_get_serv_cell_sib_resp_msg_v01 *)modem_mem_alloc(sizeof(nas_get_serv_cell_sib_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

    if(rsp_msg)
    {
      memset(rsp_msg, 0, sizeof(nas_get_serv_cell_sib_resp_msg_v01));

      if(lte_get_serv_cell_cnf->status == LTE_RRC_GET_SIB_SUCCESS)
      {
        if(msgr_get_num_attach(&(lte_get_serv_cell_cnf->msgr_hdr)) == 1)
        {
          att_ptr = msgr_get_attach(&(lte_get_serv_cell_cnf->msgr_hdr), 0);
          msgr_get_dsm_attach(att_ptr, &dsm_ptr);
          if(dsm_ptr != NULL)
          {
            rsp_msg->total_size_valid   = TRUE;
            rsp_msg->total_size = dsm_length_packet(dsm_ptr);
          }
          else
          {
            QM_MSG_ERROR("Received a NULL dsm_ptr.");
            rsp_msg->resp.result   = QMI_RESULT_FAILURE_V01;
            rsp_msg->resp.error    = QMI_ERR_INTERNAL_V01;
          }
        }
        else
        {
          QM_MSG_ERROR_1("Invalid value for num_attach = %d.", msgr_get_num_attach(&(lte_get_serv_cell_cnf->msgr_hdr)));
          rsp_msg->resp.result   = QMI_RESULT_FAILURE_V01;
          rsp_msg->resp.error    = QMI_ERR_INTERNAL_V01;
        }
      }
      else
      {
        QM_MSG_ERROR_1("lte_get_serv_cell_cnf->status = %d.", lte_get_serv_cell_cnf->status);
        rsp_msg->resp.result   = QMI_RESULT_FAILURE_V01;
        rsp_msg->resp.error    = QMI_ERR_INTERNAL_V01;
      }

      retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_RESPONSE,
                                             QMI_NAS_GET_SERV_CELL_SIB_RESP_MSG_V01,
                                             (void *)rsp_msg,
                                             (uint32_t)sizeof(nas_get_serv_cell_sib_resp_msg_v01),
                                             &response
                                           );
      if( retval )
      {
        qmi_nasi_send_response(cmd_buf_p, response);
        /*Send QMI_NAS_GET_SERV_CELL_SIB resp result*/
      }

      //Free the cmd_buf_p stored
      qmi_nasi_global.get_serv_cell_sib = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
    
    if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
    }
  else
  {
    QM_MSG_ERROR("MSGR get_serv_cell_sib is NULL, no response sent");
  }
}



/*===========================================================================
  FUNCTION qmi_nasi_generate_get_serving_cell_sib_ind()

  DESCRIPTION
    Generate and send indication for get serving cell SIB.
    
  PARAMETERS
    msg_p  

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_serving_cell_sib_ind
(
  lte_rrc_get_serv_cell_sib_cnf_s *lte_get_serv_cell_cnf,
  qmi_nasi_client_state_type      *cl_sp
)
{
  nas_get_serv_cell_sib_ind_msg_v01   *ind_msg;
  dsm_item_type                       *ind = NULL;
  msgr_attach_struct_type             *att_ptr;
  dsm_item_type                       *dsm_ptr;
  uint16                               total_size, partial_pkt_size;
  uint8                                i, num_full_pkts;


  ind_msg = (nas_get_serv_cell_sib_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_get_serv_cell_sib_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if(ind_msg != NULL)
  {
    if(lte_get_serv_cell_cnf->status == LTE_RRC_GET_SIB_SUCCESS)
    {
      if(msgr_get_num_attach(&(lte_get_serv_cell_cnf->msgr_hdr)) == 1)
      {
        total_size = 0;
        att_ptr = msgr_get_attach(&(lte_get_serv_cell_cnf->msgr_hdr), 0);
        msgr_get_dsm_attach(att_ptr, &dsm_ptr);
        if(dsm_ptr != NULL)
        {
          total_size = dsm_length_packet(dsm_ptr);
        }
        num_full_pkts = (uint8)(total_size / NAS_GET_SERV_CELL_SIB_MAX_V01);
        partial_pkt_size = (uint16)(total_size % NAS_GET_SERV_CELL_SIB_MAX_V01);

        //Populate the packets with data
        for(i = 0; i < num_full_pkts; i++)
        {
          memset(ind_msg, 0, sizeof(nas_get_serv_cell_sib_ind_msg_v01));
          ind_msg->sequence = i;
          ind_msg->sib_pkt_len = dsm_pullup(&dsm_ptr, ind_msg->sib_pkt, (uint16)NAS_GET_SERV_CELL_SIB_MAX_V01);
          QM_MSG_HIGH_2("get_serv_cell_sib_ind: sequence = %d, sib_pkt_len = %d", ind_msg->sequence, ind_msg->sib_pkt_len);

          if( cl_sp )
          {
            ind = NULL;
            if(TRUE == qmi_mmode_idl_message_encode(qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_GET_SERV_CELL_SIB_IND_MSG_V01, 
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_get_serv_cell_sib_ind_msg_v01), 
                                                    &ind
                                                   )
              )
            {
              qmi_nasi_send_ind(cl_sp, NASI_CMD_VAL_GET_SERVING_CELL_SIB, ind);
            }
            /*Else, False returned by qmi_mmode_idl_message_encode(). No indication sent*/
          }
        }

        //Populate the last packet with any pending data
        if(partial_pkt_size > 0)
        {
          memset(ind_msg, 0, sizeof(nas_get_serv_cell_sib_ind_msg_v01));
          ind_msg->sequence = i;
          ind_msg->sib_pkt_len = dsm_pullup(&dsm_ptr, ind_msg->sib_pkt, (uint16)partial_pkt_size);
          QM_MSG_HIGH_2("get_serv_cell_sib_ind: sequence = %d, sib_pkt_len = %d", ind_msg->sequence, ind_msg->sib_pkt_len);

          if( cl_sp )
          {
            ind = NULL;
            if(TRUE == qmi_mmode_idl_message_encode(qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_GET_SERV_CELL_SIB_IND_MSG_V01, 
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_get_serv_cell_sib_ind_msg_v01), 
                                                    &ind
                                                   )
              )
            {
              qmi_nasi_send_ind(cl_sp, NASI_CMD_VAL_GET_SERVING_CELL_SIB, ind);
            }
            else
            {
              QM_MSG_ERROR("False returned by qmi_mmode_idl_message_encode(). No indication sent.");
            }
          }
        }
      }
    }

    modem_mem_free((void *)ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}
#endif
#ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_EXT_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_EMBMS_SIG_EXT ()

  DESCRIPTION
    Retrieves eMBMS signal strength information
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_embms_sig_ext
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
#ifdef FEATURE_LTE_EMBMS
  errno_enum_type       msgr_err;
  nas_get_embms_sig_ext_req_msg_v01  *req_msg;
#endif
  nas_get_embms_sig_ext_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_embms_sig_ext_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_embms_sig_ext_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( qmi_nasi_global.cmd_buf_p == NULL )
  {
    qmi_nasi_global.embms_ext_cmd_buf_p = (void *)cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

#ifdef FEATURE_LTE_EMBMS
  req_msg = (nas_get_embms_sig_ext_req_msg_v01 *) modem_mem_alloc( sizeof( nas_get_embms_sig_ext_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( req_msg, 0, sizeof( nas_get_embms_sig_ext_req_msg_v01 ) );
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_GET_EMBMS_SIG_EXT_REQ_MSG_V01,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_get_embms_sig_ext_req_msg_v01)
                                         );

  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0081_req_check ( req_msg );
  }

  if( errval == QMI_ERR_NONE_V01 )
  {
    lte_rrc_embms_signal_strength_report_req_s msg;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_EMBMS_SIGNAL_STRENGTH_REQ );

    msg.debug_trace_id = req_msg->trace_id_valid ? req_msg->trace_id : -1;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
    }
  }
#else
  if( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }
#endif

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    QM_MSG_HIGH("Sent response pending for QMI_NAS_GET_EMBMS_SIG to QMI Framework");
    // Will respond after getting RSP message through MSGR
  }
  else
  {
  if ( rsp_msg != NULL )
  {
      memset( rsp_msg, 0, sizeof( nas_get_embms_sig_ext_resp_msg_v01 ) );

      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                    (uint16_t)QMI_NAS_GET_EMBMS_SIG_EXT_RESP_MSG_V01,
                                  (void *) rsp_msg,
                                    (uint32_t) sizeof( nas_get_embms_sig_ext_resp_msg_v01 ),
                                  &response
                                );
  }
    else
    {
      qmi_voice_mem_error();
    }
  }

#ifdef FEATURE_LTE_EMBMS
  if ( req_msg!= NULL ) { modem_mem_free((void*)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
#endif
  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}
#endif
/*===========================================================================
  FUNCTION QMI_NASI_CONFIG_PLMN_NAME_IND_REPORTING()

  DESCRIPTION
    Message to configure the current_plmn_name_ind sending, whether to use
    legacy behavior or ignoring display condition.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_config_plmn_name_ind_reporting
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_nasi_client_state_type *nasi_client_sp;
  qmi_error_type_v01          errval    = QMI_ERR_NONE_V01;

  nas_config_plmn_name_ind_reporting_req_msg_v01  *req_msg = NULL;
  nas_config_plmn_name_ind_reporting_resp_msg_v01 *rsp_msg = NULL;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  nasi_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  req_msg = (nas_config_plmn_name_ind_reporting_req_msg_v01 *) modem_mem_alloc( sizeof(nas_config_plmn_name_ind_reporting_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg == NULL )
    {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if(errval == QMI_ERR_NONE_V01)
      {
    memset(req_msg, 0x00, sizeof(nas_config_plmn_name_ind_reporting_req_msg_v01) );

    
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_CONFIG_PLMN_NAME_IND_REPORTING_REQ_MSG_V01,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_config_plmn_name_ind_reporting_req_msg_v01)
                                         );
      }
  
  if (errval == QMI_ERR_NONE_V01)
      {
    errval = qmi_nas_0075_req_check(req_msg);
    }

  if (errval == QMI_ERR_NONE_V01)
    {
    struct report_status_s *p_rs = &nasi_client_sp->report_status;

    p_rs->ignore_plmn_display_cond_in_ind = req_msg->send_all_information ? TRUE : FALSE ;
          }

  rsp_msg = (nas_config_plmn_name_ind_reporting_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_config_plmn_name_ind_reporting_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( rsp_msg != NULL )
    {
    memset(rsp_msg, 0x00, sizeof(nas_config_plmn_name_ind_reporting_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)QMI_NAS_CONFIG_PLMN_NAME_IND_REPORTING_RESP_MSG_V01,
                                  (void *)rsp_msg,
                                  (uint32_t)sizeof(nas_config_plmn_name_ind_reporting_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( req_msg != NULL ) { modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

 #ifndef REMOVE_QMI_NAS_GET_SUBSCRIPTION_INFO_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_SUBSCRIPTION_INFO()

  DESCRIPTION
    Provides current subscription information
    
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_subscription_info
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  nas_get_subscription_info_resp_msg_v01 * rsp_msg;
#ifdef FEATURE_DUAL_SIM
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
#endif

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_subscription_info_resp_msg_v01 *) 
              modem_mem_alloc( sizeof(nas_get_subscription_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_subscription_info_resp_msg_v01) );

#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;

    rsp_msg->is_active = 
      qmi_nasi_global.subs_info[asubs_id].is_operational ? NAS_SUBSCRIPTION_ACTIVE_V01 : NAS_SUBSCRIPTION_NOT_ACTIVE_V01;

    rsp_msg->is_default_data_subs = qmi_nasi_global.subs_info[asubs_id].is_default_data ;
    rsp_msg->is_priority_subs = qmi_nasi_global.subs_info[asubs_id].is_priority_subs ? NAS_PRIORITY_SUBSCRIPTION_TRUE_V01: NAS_PRIORITY_SUBSCRIPTION_FALSE_V01;
    rsp_msg->voice_system_id = qmi_nasi_global.subs_info[asubs_id].hw_id[SYS_VSID_APP_CS_VOICE];
    rsp_msg->lte_voice_system_id = qmi_nasi_global.subs_info[asubs_id].hw_id[SYS_VSID_APP_IMS_LTE];
    rsp_msg->wlan_voice_system_id = qmi_nasi_global.subs_info[asubs_id].hw_id[SYS_VSID_APP_IMS_WLAN];
    
    rsp_msg->is_active_valid = TRUE;
    rsp_msg->is_default_data_subs_valid = TRUE;
    rsp_msg->is_priority_subs_valid = TRUE;
    rsp_msg->voice_system_id_valid = TRUE;
    rsp_msg->lte_voice_system_id_valid = TRUE;
    rsp_msg->wlan_voice_system_id_valid = TRUE;

    
    QM_MSG_HIGH_5("is_operational:%d, is_default_data_subs:%d, is_priority_subs:%d, asubs_id:%d, voice_system_id:%d", 
    rsp_msg->is_active, rsp_msg->is_default_data_subs, rsp_msg->is_priority_subs, asubs_id, rsp_msg->voice_system_id);
    
#else
    rsp_msg->resp.error  = QMI_ERR_NOT_SUPPORTED_V01;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    QM_MSG_HIGH("NOT SUPPORTED");
#endif

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_subscription_info_resp_msg_v01),
                                  &response
                                );
  }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}
#endif
#ifndef REMOVE_QMI_NAS_SET_DRX_V01
/*===========================================================================
  FUNCTION QMI_NAS_SET_DRX_RESP() 

  DESCRIPTION
    Send response for SET_DRX
        
  PARAMETERS
    p_cmd_buf   : user data
    err         : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_drx_resp(boolean result)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type          errval;
  qmi_result_e_type         qmi_result;
  boolean                   retval;
  qmi_mmode_qcsi_transaction_type          *cmd_buf_p;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = qmi_nasi_global.set_drx_req_buf_p;
  qmi_nasi_global.set_drx_req_buf_p = NULL;


  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_DRX callback");
    return;
  }

  if(result == 0)
  {
    errval = QMI_ERR_INTERNAL_V01;
  }


  qmi_result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS 
                                   : QMI_RESULT_FAILURE);
  
  retval = qmi_svc_put_result_tlv(&response, qmi_result, errval);
  
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
    /*Unable to send qmi_nas_set_drx_resp response*/
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_SET_DRX ()

  DESCRIPTION
    Sets the DRX.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_drx 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_set_drx_req_msg_v01  * req_msg;
  nas_set_drx_resp_msg_v01 * rsp_msg;
  mm_cmd_set_drx_req_s set_drx_req;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_set_drx_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_drx_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_drx_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_drx_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_drx_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_SET_DRX_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_drx_req_msg_v01)
                                         );
  }

  // check for error in REQ message
  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_0088_req_check( req_msg );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    set_drx_req.drx_coefficient = (sys_drx_cn_coefficient_s1_e_type) req_msg->drx;


    if(!nas_mm_cmd_set_drx_req(&set_drx_req))
    {
      errval = QMI_ERR_INTERNAL_V01;
    }

  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_drx() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
    qmi_nasi_global.set_drx_req_buf_p = cmd_buf_p;
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_set_drx_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_SET_DRX_RESP_MSG_V01,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_drx_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_drx */
#endif

/*===========================================================================
  FUNCTION QMI_NAS_SET_GNSS_SESSION_STATUS_RESP() 

  DESCRIPTION
    Send response for SET_GNSS_SESSION_STATUS
        
  PARAMETERS
    p_cmd_buf   : user data
    err         : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_gnss_session_status_resp(qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ss_cmd_err_e_type cm_ss_cmd_err)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type          errval;
  qmi_result_e_type         result;
  boolean                   retval;
  qmi_mmode_qcsi_transaction_type          *cmd_buf_p;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) p_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_GNSS_SESSION_STATUS callback");
    return;
  }

  switch (cm_ss_cmd_err)
  {
    case CM_SS_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS 
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
    /*Unable to send qmi_nas_set_gnss_session_status_resp*/
  }
}


/*===========================================================================
  FUNCTION QMI_NASI_SET_GNSS_SESSION_STATUS ()

  DESCRIPTION
    Inform Modem, If External GNSS session status is Active or not .

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_gnss_session_status 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_set_gnss_session_status_req_msg_v01  * req_msg;
  nas_set_gnss_session_status_resp_msg_v01 * rsp_msg;
  boolean gnss_session_active = FALSE;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_set_gnss_session_status_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_gnss_session_status_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_gnss_session_status_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_gnss_session_status_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_gnss_session_status_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_SET_GNSS_SESSION_STATUS_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_gnss_session_status_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    gnss_session_active = (boolean) req_msg->gnss_session_active;

    if ( !cm_ss_cmd_send_gnss_session_status( qmi_nas_cmss_cmd_cb,
                                 (void *)cmd_buf_p,
                                 qmi_nasi_global.cm_clnt_id,
                                 gnss_session_active ) )
    {
      errval = QMI_ERR_INTERNAL_V01;
    }
  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_gnss_session_status() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_set_gnss_session_status_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_SET_GNSS_SESSION_STATUS_REQ_MSG_V01,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_gnss_session_status_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_gnss_tx_activity */

#ifndef REMOVE_QMI_NAS_GET_DRX_V01
/*===========================================================================
  FUNCTION QMI_NAS_GET_DRX_RESP()

  DESCRIPTION
    Send response for GET_DRX
        
  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_get_drx_resp( sys_drx_cn_coefficient_s1_e_type drx_coefficient )
{
  dsm_item_type *           response = NULL;
  qmi_error_type_v01        errval = QMI_ERR_NONE_V01;
  nas_get_drx_resp_msg_v01 *rsp_msg;
  qmi_mmode_qcsi_transaction_type         *cmd_buf_p = qmi_nasi_global.get_drx_cmd_buf_p;

  if ( cmd_buf_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GET_DRX resp: %d", cmd_buf_p);
    qmi_nasi_global.get_drx_cmd_buf_p = NULL;
    return; //nothing to send
  }

  rsp_msg = (nas_get_drx_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_drx_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
    qmi_nasi_global.get_drx_cmd_buf_p = NULL;
    return;
  }

  memset( rsp_msg, 0x00, sizeof(nas_get_drx_resp_msg_v01) );

  if ( errval == QMI_ERR_NONE_V01 )
  {
    rsp_msg->drx = (nas_drx_enum_v01) drx_coefficient;
    rsp_msg->drx_valid = TRUE;
  }

  rsp_msg->resp.error  = errval;
  rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;


  if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_DRX_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_drx_resp_msg_v01),
                                     &response
                                   ) )
  {
    qmi_nasi_send_response( cmd_buf_p, response);
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }

  if( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  qmi_nasi_global.get_drx_cmd_buf_p = NULL;
} /* qmi_nas_get_drx_resp() */



/*===========================================================================
  FUNCTION QMI_NASI_GET_DRX ()

  DESCRIPTION
    Gets the DRX.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_drx 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  if ( qmi_nasi_global.get_drx_cmd_buf_p == NULL )
  {
    qmi_nasi_global.get_drx_cmd_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    if(!nas_mm_cmd_get_drx_req())
    {
      errval = QMI_ERR_INTERNAL_V01;
    }
  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_drx() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    nas_get_drx_resp_msg_v01 * rsp_msg;
    rsp_msg = (nas_get_drx_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_drx_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL )
    {
      qmi_voice_mem_error();
    }
    else
    {
      memset( rsp_msg, 0x00, sizeof(nas_get_drx_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_GET_DRX_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_get_drx_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    }

    qmi_nasi_global.get_drx_cmd_buf_p = NULL;
  }

  return response;
} /* qmi_nasi_get_drx */

#endif

/*===========================================================================
  FUNCTION QMI_NASI_GET_LTE_RRC_TX_INFO ()

  DESCRIPTION
    Gets the LTE TX Info.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_lte_rrc_tx_info 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  {
    nas_get_lte_rrc_tx_info_resp_msg_v01 * rsp_msg;
    rsp_msg = (nas_get_lte_rrc_tx_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_lte_rrc_tx_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL )
    {
      qmi_voice_mem_error();
    }
    else
    {
      memset( rsp_msg, 0x00, sizeof(nas_get_lte_rrc_tx_info_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

     /* As this message is only for LTE CAT-M targets, LTE will be activated on Main stack */
      rsp_msg->lte_tx_is_active = qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].lte_rrc_tx_info.lte_tx_is_active;
      rsp_msg->lte_tx_is_active_valid = TRUE;
     
      if (rsp_msg->lte_tx_is_active)
      {
          rsp_msg->lte_tx_band = qmi_nas_qmi_sys_lte_bc_2_lte_bc(qmi_nasi_global.cm_ss_info[SYS_MODEM_AS_ID_1].lte_rrc_tx_info.lte_tx_band);
          rsp_msg->lte_tx_band_valid = TRUE;
      }
      else
      {
          rsp_msg->lte_tx_band_valid = FALSE;
      }


      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_GET_LTE_RRC_TX_INFO_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_get_lte_rrc_tx_info_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    
  }

  return response;
} /* qmi_nasi_get_lte_rrc_tx_info */

/*===========================================================================
  FUNCTION QMI_NAS_GEN_LTE_RRC_TX_INFO_IND()

  DESCRIPTION
    generate QMI_NAS_LTE_RRC_TX_INFO_IND

  PARAMETERS
    pointer to new CM SS event
===========================================================================*/
void qmi_nas_gen_lte_rrc_tx_info_ind( cm_mm_ss_info_s_type       * p_ss_info )
{
  nas_lte_rrc_tx_info_ind_v01    *ind_msg;
  dsm_item_type                         *ind;
  qmi_nasi_client_state_type            *cl_sp;

  ind_msg = (nas_lte_rrc_tx_info_ind_v01 *) modem_mem_alloc( sizeof( nas_lte_rrc_tx_info_ind_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if(ind_msg != NULL)
  {
    memset( ind_msg, 0x00, sizeof(nas_lte_rrc_tx_info_ind_v01) );
    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {

      if (cl_sp->report_status.bound_subs == SYS_MODEM_AS_ID_1 &&
          cl_sp->report_status.report_lte_rrc_tx_info_ind)
      {
           QM_MSG_HIGH_1("lte_cphy_tx_info_ind() - sending to client %p", cl_sp->clnt);
           ind_msg->lte_tx_is_active = p_ss_info->lte_rrc_tx_info.lte_tx_is_active;
       if (ind_msg->lte_tx_is_active)
        {
         ind_msg->lte_tx_band = qmi_nas_qmi_sys_lte_bc_2_lte_bc(p_ss_info->lte_rrc_tx_info.lte_tx_band);
         ind_msg->lte_tx_band_valid = TRUE;
         }
        else
        {
         ind_msg->lte_tx_band_valid = FALSE;
        }
           ind = NULL;
           if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_LTE_RRC_TX_INFO_IND_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_lte_rrc_tx_info_ind_v01 ),
                                             &ind ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_LTE_RRC_TX_INFO_IND, ind );
          }
         /*else, Encoding has failed*/
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_gen_lte_rrc_tx_info_ind() */

#ifndef REMOVE_QMI_NAS_GET_SSAC_INFO_V01
/*===========================================================================
  FUNCTION QMI_NASI_SSAC_INFO_IND()

  DESCRIPTION
    Generate and send SSAC info indication
    
  PARAMETERS
    msg_p  Pointer to MSGR data for ssac params info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_ssac_info_ind
(
  lte_rrc_ssac_params_s * ssac_ind
)
{
  qmi_nasi_client_state_type      *cl_sp;
  nas_ssac_info_ind_msg_v01 *ind_msg;
  dsm_item_type                   *ind = NULL;

  ind_msg = (nas_ssac_info_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_ssac_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof(nas_ssac_info_ind_msg_v01) );

    QM_MSG_HIGH_4("SSAC INFO IND: barring_factor_voice %d, barring_time %d, barring_factor_video %d,barring_time %d", 
        ssac_ind->barring_factor_mmtel_voice, ssac_ind->barring_time_mmtel_voice,ssac_ind->barring_factor_mmtel_video, ssac_ind->barring_time_mmtel_video);

    if(ssac_ind->barring_time_mmtel_voice == QMI_NAS_SSAC_INVALID_BARR_TIME )
    {
      ssac_ind->barring_factor_mmtel_voice = 100;
      ssac_ind->barring_time_mmtel_voice = 0;
      ind_msg->ssac_info.barring_factor_voice = 100;
      ind_msg->ssac_info.barring_time_voice = 0;
    }
    else 
    {
      if(ssac_ind->barring_time_mmtel_voice == 0xFFFF)
      {
        ind_msg->ssac_info.barring_time_voice = 0;
      }
      else
      {
        ind_msg->ssac_info.barring_time_voice = ssac_ind->barring_time_mmtel_voice;
      }
      if(ssac_ind->barring_factor_mmtel_voice == 0xFF)
      {
        ind_msg->ssac_info.barring_factor_voice = 100;
      }
      else
      {
        ind_msg->ssac_info.barring_factor_voice = ssac_ind->barring_factor_mmtel_voice;
      }
    }
    if(ssac_ind->barring_time_mmtel_video == QMI_NAS_SSAC_INVALID_BARR_TIME )
    {
      ssac_ind->barring_factor_mmtel_video = 100;
      ssac_ind->barring_time_mmtel_video = 0;
      ind_msg->ssac_info.barring_factor_video = 100;
      ind_msg->ssac_info.barring_time_video = 0;
    }
    else 
    {
      if(ssac_ind->barring_time_mmtel_video == 0xFFFF)
      {
        ind_msg->ssac_info.barring_time_video = 0;
      }
      else
      {
    ind_msg->ssac_info.barring_time_video = ssac_ind->barring_time_mmtel_video;
      }
      if(ssac_ind->barring_factor_mmtel_video == 0xFF)
      {
        ind_msg->ssac_info.barring_factor_video = 100;
      }
      else
      {
        ind_msg->ssac_info.barring_factor_video = ssac_ind->barring_factor_mmtel_video;
      }
    }

    ind_msg->ssac_info_valid = TRUE;

    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {
  
      if ( cl_sp->report_status.report_ssac_info )
      {
        ind = NULL;
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                  QMI_IDL_INDICATION, 
                                                  (uint16_t)QMI_NAS_SSAC_INFO_IND_V01, 
                                                  (void *) ind_msg,
                                                  (uint32_t)sizeof(nas_ssac_info_ind_msg_v01), 
                                                  &ind
                                                ) )
        {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_SSAC_INFO_IND, ind );
        }
      }
  
      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }

    modem_mem_free((void *)ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}
#endif
#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))

/*===========================================================================
  FUNCTION FILTER_PERIODIC_CSG_NETWORKS_TO_SCAN()

  DESCRIPTION
    Given QMI_NAS_CSG_SEARCH_SELECTION_CONFIG_REQ with network_type,
    filter mask based on networks supported by target,
    masking off bits of unsupported networks.

  PARAMETERS
    network_type - Bitmask representing the network types to scan. Values:
      Bit 1 -- UMTS
      Bit 2 -- LTE

  RETURN VALUE
    modified network scan mask (see parameter above)

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 filter_periodic_csg_networks_to_scan( uint8 network_type )
{
  // mask off network scan bits that the target does not support

  if ( ! TARGET_SUPPORTS_GSM   ) { network_type &= ~ NAS_NETWORK_TYPE_GSM_ONLY_V01;   }

  if ( ! TARGET_SUPPORTS_WCDMA ) { network_type &= ~ NAS_NETWORK_TYPE_WCDMA_ONLY_V01; }

  if ( ! TARGET_SUPPORTS_LTE   ) { network_type &= ~ NAS_NETWORK_TYPE_LTE_ONLY_V01;   }

  // NOTE:  NI-3.2 and beyond supports TD-SCDMA, so we test and mask it, like the RATS above.

  if ( ! TARGET_SUPPORTS_TDS   ) { network_type &= ~ NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01;   }

  // NOTE:  For pre-NI-3.2, TD-SCDMA is not supported, so we need to mask off the bit for TDS network scan also

  network_type &= ( NAS_NETWORK_TYPE_WCDMA_ONLY_V01 | NAS_NETWORK_TYPE_LTE_ONLY_V01 );

  QM_MSG_HIGH_2("mode_capability = %d,network_type=%d", qmi_nasi_global.cm_ph_info.mode_capability, network_type);

  return network_type;
}

/*===========================================================================
  FUNCTION QMI_NASI_CSG_SEARCH_SELECTION_CONFIG()

  DESCRIPTION
    Configures and triggers Periodic CSG search.and selection.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_csg_search_selection_config
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type             * response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  boolean                     retval   = TRUE;
  nas_csg_search_selection_config_req_msg_v01  * req_msg;
  nas_csg_search_selection_config_resp_msg_v01 * rsp_msg;
  int                         i;
  cm_mode_pref_e_type         mode_pref = CM_MODE_PREF_WCDMA_LTE;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  cm_network_list_type_e_type list_type = CM_NETWORK_LIST_CSG_USER;
  cm_band_pref_e_type         umts_band_pref     = CM_BAND_PREF_ANY,
                              lte_band_pref = CM_BAND_PREF_LTE_ANY;
  errno_enum_type              msgr_err;
  uint8                       filtered_network_type;
  mmode_qmi_nas_csg_search_select_config_cmd_msg_type csg_search_sel_config;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_csg_search_selection_config_req_msg_v01*) modem_mem_alloc( sizeof(nas_csg_search_selection_config_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_csg_search_selection_config_resp_msg_v01*) modem_mem_alloc( sizeof(nas_csg_search_selection_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#ifdef FEATURE_TRIPLE_SIM
   else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
   {
     asubs_id = SYS_MODEM_AS_ID_3;
   }
#endif
#endif
  if ( ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE )
  {
    QM_MSG_ERROR("Target not supporting UMTS/LTE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset( req_msg, 0x00, sizeof(nas_csg_search_selection_config_req_msg_v01) );
    memset( &csg_search_sel_config, 0x00, sizeof(mmode_qmi_nas_csg_search_select_config_cmd_msg_type));
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_csg_search_selection_config_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_008A_req_check( req_msg );
  }


  if ( errval == QMI_ERR_NONE_V01 )
  {
    
    if( req_msg->network_type_valid )
    {
      if ( req_msg->network_type == 0 )
      {
        mode_pref = CM_MODE_PREF_NO_CHANGE;
      }
      else
      {
        filtered_network_type = filter_periodic_csg_networks_to_scan( req_msg->network_type );
        retval = FALSE; // assume no match, until proven otherwise by the loop below...
        for( i = 0 ; i < QMI_NAS_ARR_SIZE(qmi_nas_allowed_network_types) ; i++ )
        {
          if ( filtered_network_type == qmi_nas_allowed_network_types[i].network_type )
          {
            mode_pref = qmi_nas_allowed_network_types[i].cm_val;
            retval = TRUE; // a match has been found, proceed as before.
            break;
          }
        }

        if ( !retval ) 
        { 
          errval = QMI_ERR_INVALID_OPERATION_V01;
        }

        QM_MSG_HIGH_3("qmi_nasi_search_select_config() network_type = %d, filtered = %d, change = %d.", req_msg->network_type, filtered_network_type, req_msg->network_type ^ filtered_network_type);
      }
    }

    QM_MSG_HIGH_3("network_type_valid = %d mode_pref = %d retval = %d (T/F)", req_msg->network_type_valid, mode_pref, retval);
    #if defined(FEATURE_WCDMA)
    if ( req_msg->umts_band_pref_valid )
    {
      umts_band_pref = (cm_band_pref_e_type) req_msg->umts_band_pref;
    }
    #endif
    if ( req_msg->lte_band_pref_valid )
    {
      lte_band_pref = (cm_band_pref_e_type) req_msg->lte_band_pref;
    }
  }

if (errval == QMI_ERR_NONE_V01)
{
    msgr_init_hdr( (msgr_hdr_struct_type*)&csg_search_sel_config, MSGR_QMI_NAS, QMI_NAS_CSG_SEARCH_SELECTION_CONFIG_CMD );
    csg_search_sel_config.csg_search_select_config_req.asubs_id = asubs_id;
    csg_search_sel_config.csg_search_select_config_req.select_config = req_msg->selection_config_type;
    csg_search_sel_config.csg_search_select_config_req.network_type = mode_pref;
    csg_search_sel_config.csg_search_select_config_req.list_type = list_type;
    #if defined(FEATURE_WCDMA)
    csg_search_sel_config.csg_search_select_config_req.umts_band_pref = umts_band_pref;
    #endif
    csg_search_sel_config.csg_search_select_config_req.lte_band_pref = lte_band_pref;
    if( req_msg->search_type_valid )
    {
      csg_search_sel_config.csg_search_select_config_req.search_mode = req_msg->search_type;
    }
    else
    {
      csg_search_sel_config.csg_search_select_config_req.search_mode = 1; //Home+Roaming
    }

    if(req_msg->search_timer_valid)
    {
      csg_search_sel_config.csg_search_select_config_req.search_timer = req_msg->search_timer;
    }

    #if defined(FEATURE_WCDMA)
    QM_MSG_HIGH_8("asubs_id = %d select_config = %d nw_type = %d, list_type = %d umts_band = %ld retval = %d, lte_band =%ld,Search timer = %d", 
        asubs_id, req_msg->selection_config_type, mode_pref,list_type, umts_band_pref, csg_search_sel_config.csg_search_select_config_req.search_mode,
        lte_band_pref, csg_search_sel_config.csg_search_select_config_req.search_timer);
    #else
    QM_MSG_HIGH_7("asubs_id = %d select_config = %d nw_type = %d, list_type = %d  retval = %d, lte_band =%ld,Search timer = %d", 
        asubs_id, req_msg->selection_config_type, mode_pref,list_type, csg_search_sel_config.csg_search_select_config_req.search_mode,
        lte_band_pref, csg_search_sel_config.csg_search_select_config_req.search_timer);
    #endif

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&csg_search_sel_config, sizeof(csg_search_sel_config) );

    if(msgr_err != E_SUCCESS)
    {
       QM_MSG_ERROR_1("Error sending QMI_NAS_CSG_SEARCH_SELECTION_CONFIG_CMD response %d", msgr_err);
       errval = QMI_ERR_MALFORMED_MSG_V01;
    }
}

if ( rsp_msg != NULL )
{
  memset(rsp_msg, 0, sizeof(nas_csg_search_selection_config_resp_msg_v01) );
  rsp_msg->resp.error  = errval;
  rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t)cmd_buf_p->msg_id,
                                (void *)rsp_msg,
                                (uint32_t)sizeof(nas_csg_search_selection_config_resp_msg_v01),
                                &response
                              );
}
else
{
  qmi_voice_mem_error();
}

if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
if ( rsp_msg != NULL ){ modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

return response;

}
/*===========================================================================
  FUNCTION qmi_nasi_csg_immediate_search_selection()

  DESCRIPTION
   Triggers immediate CSG search.and selection based on configured params.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_csg_immediate_search_selection
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type             * response = NULL;
  nas_csg_immediate_search_selection_resp_msg_v01 *rsp_msg;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  mmode_qmi_nas_csg_immediate_search_select_cmd_msg_type csg_trigger;
  errno_enum_type              msgr_err;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_csg_immediate_search_selection_resp_msg_v01*) modem_mem_alloc( sizeof(nas_csg_immediate_search_selection_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if(rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    asubs_id = SYS_MODEM_AS_ID_3;
  }
#endif
#endif
  if ( ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE )
  {
    QM_MSG_ERROR("Target not supporting UMTS/LTE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    msgr_init_hdr( (msgr_hdr_struct_type*)&csg_trigger, MSGR_QMI_NAS, QMI_NAS_CSG_IMMEDIATE_SEARCH_SELECTION_CMD );
    csg_trigger.csg_immediate_search_select_req.asubs_id = asubs_id;
    QM_MSG_HIGH_1("Sending asubs_id = %d select_config = %d network_type = %d", asubs_id);
    msgr_err = msgr_send( (msgr_hdr_struct_type*)&csg_trigger, sizeof(csg_trigger) );

    if(msgr_err != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Error sending QMI_NAS_CSG_IMMEDIATE_SEARCH_SELECTION_CMD response %d", msgr_err);
      errval = QMI_ERR_MALFORMED_MSG_V01;
    }
  }
  
  if ( rsp_msg != NULL )
  {
    memset(rsp_msg, 0, sizeof(nas_csg_immediate_search_selection_resp_msg_v01) );
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
  
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)rsp_msg,
                                  (uint32_t)sizeof(nas_csg_immediate_search_selection_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
   /*Not enough memory to allocate for QMI_NAS_CSG_SEARCH_SELECT_CONFIG response*/
  }
  
  if ( rsp_msg != NULL ){ modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  
  return response;

}

/*===========================================================================
  FUNCTION qmi_nasi_get_csg_search_selection_config()

  DESCRIPTION
   Get CSG search.and selection params.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_csg_search_selection_config
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type             * response = NULL;
  nas_get_csg_search_selection_configuration_resp_msg_v01 *rsp_msg;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  int status=0,i=0;
  qmi_nas_csg_search_select_config_s_type csg_search_select_config;
  boolean retval=FALSE;
  uint8 network_type=0;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_csg_search_selection_configuration_resp_msg_v01*) modem_mem_alloc( sizeof(nas_get_csg_search_selection_configuration_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if(rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE )
  {
    QM_MSG_ERROR("Target not supporting UMTS/LTE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( rsp_msg != NULL )
  {
  memset(rsp_msg, 0, sizeof(nas_get_csg_search_selection_configuration_resp_msg_v01) );
  memset(&csg_search_select_config,0,sizeof(csg_search_select_config));

  // read efs file and mark is_efs_read as TRUE so that EFS file is not attempted to read next time
  status = efs_get(QMI_NAS_TUI_CSG_CONFIG_EFS_FILE, (void *)&csg_search_select_config, sizeof(qmi_nas_csg_search_select_config_s_type) );
  
  if( status == sizeof(csg_search_select_config) )
  {
      #if defined(FEATURE_WCDMA)
      QM_MSG_HIGH_7("CSG interval %d in minutes, mode=%d, list type %d,network_type=%d, band_pref %ld,lte_band=%ld,select_config = %d", 
          csg_search_select_config.search_timer, csg_search_select_config.search_mode, csg_search_select_config.list_type, csg_search_select_config.network_type,
          csg_search_select_config.umts_band_pref, csg_search_select_config.lte_band_pref, csg_search_select_config.select_config);
      #else
      QM_MSG_HIGH_6("CSG interval %d in minutes, mode=%d, list type %d,network_type=%d, lte_band=%ld,select_config = %d", 
      csg_search_select_config.search_timer, csg_search_select_config.search_mode, csg_search_select_config.list_type, csg_search_select_config.network_type,
      csg_search_select_config.lte_band_pref, csg_search_select_config.select_config);
      #endif
    rsp_msg->search_timer_valid = TRUE;
    rsp_msg->search_timer = csg_search_select_config.search_timer;
    rsp_msg->search_type_valid = TRUE;
    rsp_msg->search_type = csg_search_select_config.search_mode;
    #if defined(FEATURE_WCDMA)
    rsp_msg->umts_band_pref_valid = TRUE;
    rsp_msg->umts_band_pref = csg_search_select_config.umts_band_pref;
    #endif
    rsp_msg->lte_band_pref_valid = TRUE;
    rsp_msg->lte_band_pref = csg_search_select_config.lte_band_pref;
    rsp_msg->selection_config_type_valid = TRUE;
    rsp_msg->selection_config_type = csg_search_select_config.select_config;

    for( i = 0 ; i < QMI_NAS_ARR_SIZE(qmi_nas_allowed_network_types) ; i++ )
    {
      if ( csg_search_select_config.network_type == qmi_nas_allowed_network_types[i].cm_val)
      {
        network_type = qmi_nas_allowed_network_types[i].network_type;
        retval = TRUE; // a match has been found, proceed as before.
        break;
      }
    }
    if(retval == TRUE)
    {
      rsp_msg->network_type_valid = TRUE;
      rsp_msg->network_type = network_type;
    }
  }
  else
  {
    QM_MSG_ERROR_1("efs_get QMI_NAS_TUI_CSG_CONFIG_EFS_FILE read failed status %d", status);
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
  
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)rsp_msg,
                                  (uint32_t)sizeof(nas_get_csg_search_selection_configuration_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }
  
  if ( rsp_msg != NULL ){ modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  
  return response;

}
#endif
#endif
#ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
/*===========================================================================
  FUNCTION QMI_NASI_PERFORM_INCREMENTAL_NETWORK_SCAN()

  DESCRIPTION
    Performs the network scan and gives results incrementally.
    
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_perform_incremental_network_scan 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_type_v01  errval   = QMI_ERR_NONE_V01;
  boolean              retval = TRUE;
  nas_perform_incremental_network_scan_req_msg_v01  * req_msg;
  nas_perform_incremental_network_scan_resp_msg_v01 * rsp_msg;
  int i;
  cm_mode_pref_e_type mode_pref = CM_MODE_PREF_GWL;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  cm_network_list_type_e_type list_type = CM_NETWORK_LIST_AVAILABLE;

  uint8                       filtered_network_type;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_perform_incremental_network_scan_req_msg_v01  *) 
              modem_mem_alloc( sizeof(nas_perform_incremental_network_scan_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_perform_incremental_network_scan_resp_msg_v01 *) 
              modem_mem_alloc( sizeof(nas_perform_incremental_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    asubs_id = SYS_MODEM_AS_ID_3;
  }
#endif
#endif
  if ( !TARGET_SUPPORTS_GSM && !TARGET_SUPPORTS_WCDMA && !TARGET_SUPPORTS_LTE && !TARGET_SUPPORTS_TDS )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset( req_msg, 0x00, sizeof(nas_perform_network_scan_req_msg_v01) );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_perform_incremental_network_scan_req_msg_v01)
                                         );
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0085_req_check( req_msg );
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( qmi_nasi_global.net_scan_started )
    {
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      QM_MSG_HIGH_2( "Net scan ongoing on subscription:%d, %d", qmi_nasi_global.net_scan_asubs_id, asubs_id );
    }
    else
    {
      if( req_msg->network_type_valid )
      {
        if ( req_msg->network_type == 0 )
        {
          mode_pref = CM_MODE_PREF_NO_CHANGE;
        }
        else
        {
          filtered_network_type = filter_networks_to_scan( req_msg->network_type );
          retval = FALSE; // assume no match, until proven otherwise by the loop below...

          for( i = 0; i < QMI_NAS_ARR_SIZE(qmi_nas_allowed_network_types); i++ )
          {
            if ( filtered_network_type == qmi_nas_allowed_network_types[i].network_type )
            {
              mode_pref = qmi_nas_allowed_network_types[i].cm_val;
              retval = TRUE; // a match has been found, proceed as before.
              break;
            }
          }
          if ( ! retval ) { errval = QMI_ERR_INTERNAL_V01; }
          QM_MSG_HIGH_3( "qmi_nasi_perform_network_scan() network_type = %d, filtered = %d, change = %d.",
                     req_msg->network_type, filtered_network_type, req_msg->network_type ^ filtered_network_type );
        }
      }

      QM_MSG_HIGH_3( "network_type_valid = %d mode_pref = %d retval = %d (T/F)", req_msg->network_type_valid, mode_pref, retval );

      if( req_msg->scan_type_valid )
      {
        if( req_msg->scan_type == NAS_SCAN_TYPE_CSG_V01 )
        {
#if defined( FEATURE_FEMTO_CSG ) && !defined( FEATURE_MMODE_QMI_LTE_ONLY ) && !defined(FEATURE_MMODE_QMI_GPRS_LTE)
          list_type = CM_NETWORK_LIST_CSG;
#else
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif
        }
      }

      if ( errval == QMI_ERR_NONE_V01 )
      {
        if ( asubs_id == SYS_MODEM_AS_ID_1 )
        {
          retval = cm_ph_cmd_get_networks(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref);
        }
#if defined(FEATURE_DUAL_SIM) || defined(FEATURE_TRIPLE_SIM) 
        else 
        {
          retval = cm_ph_cmd_get_networks_per_subs(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref, asubs_id );
        }
#endif
      }

      if ( retval )
      {
        qm_cbpq_add ( QM_CBPQ_QTYPE_NW_SCAN, cmd_buf_p, ((qmi_nasi_client_state_type *)cl_sp)->clnt );
            
        QM_MSG_HIGH( "Starting Incremental Net Scan, waiting for response");
        qmi_nasi_global.net_scan_started = TRUE;
        qmi_nasi_global.net_scan_asubs_id = asubs_id;
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_INPROGRESS;
        qmi_nasi_global.incremental_net_scan_clnt = ((qmi_nasi_client_state_type *)cl_sp)->clnt;
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    // shall react to CM_PH_CMD_GET_NETWORKS and CM_PH_EVENT_AVAILABLE_NETWORKS_CONF later
  } 
  else  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_perform_incremental_network_scan_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_perform_incremental_network_scan_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_INCREMENTAL_NETWORK_SCAN_IND()

  DESCRIPTION
    Generate indication for perform incremental network scan after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_perform_incremental_network_scan_ind(const mmgsdi_session_get_operator_name_cnf_type * name_cnf)
{
  nas_perform_incremental_network_scan_ind_msg_v01  *ind_msg   = NULL;
  dsm_item_type                  * indication      = NULL;
  qmi_nasi_client_state_type     *cl_sp = NULL;

  sys_detailed_plmn_list_s_type        *available_networks = NULL;
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;

  qmi_error_e_type       errval = QMI_ERR_NONE;

  boolean is_plmn_undefined      = FALSE;
  boolean mnc_includes_pcs_digit = FALSE;
  boolean net_info_available     = FALSE;
  boolean rat_match              = FALSE, rat_match_2 = FALSE;

  int          sys_plmn_list_index = 0;
  int          network_info_index  = 0;
  int          csg_network_info_index  = 0;
  int          num_networks        = 0;
  sys_mcc_type mcc                 = 0;
  sys_mnc_type mnc                 = 0;
  uint32          i                   = 0;
  uint8 encoding_type = 0;
  uint32 j = 0;
  uint8 network_name_len = 0;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  boolean is_plmn_2_valid=FALSE;
  sys_plmn_id_s_type current_plmn, current_plmn_2; //initialized for each cmd_buffer
  sys_sys_mode_e_type current_sys_mode = SYS_SYS_MODE_NONE, current_sys_mode_2 = SYS_SYS_MODE_NONE;

  sys_plmn_id_s_type plmn_main_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                                              qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                                              qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_id.id.plmn ;

  sys_sys_mode_e_type sys_mode_main_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode;
  sys_sys_mode_e_type sys_mode_gw_stack   = SYS_SYS_MODE_NONE;

  sys_srv_status_e_type main_stack_srv = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].srv_status;
  sys_srv_status_e_type gw_stack_srv = SYS_SRV_STATUS_NO_SRV;

  cl_sp = q_linear_search( &qmi_nas_state.client_q,
                             qmi_nas_qcsi_compare_client_handle,
                             qmi_nasi_global.incremental_net_scan_clnt );  

  //Get the client cl_sp
  if(cl_sp == NULL)
  {
    QM_MSG_HIGH_2( "qmi_nasi_generate_perform_incremental_network_scan_ind - cl_sp is NULL(%d),clnt:%p!",
           cl_sp, qmi_nasi_global.incremental_net_scan_clnt);
    errval = QMI_ERR_INVALID_CLIENT_ID;
  }

  QM_MSG_HIGH_2( "generate_perform_incremental_network_scan main_stack = %d,srv=%d", sys_mode_main_stack, main_stack_srv );  
  #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
  if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
      qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )
  {
    sys_mode_gw_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode;
    gw_stack_srv = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].srv_status;
    QM_MSG_HIGH_2( "generate_perform_incremental_network_scan gw_stack = %d,srv=%d", sys_mode_gw_stack, gw_stack_srv );
  }
  #endif
  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    available_networks = (sys_detailed_plmn_list_s_type *) callback_data->cmd_buf_ptr;
  }
  else
  {
    QM_MSG_ERROR( "qmi_nasi_generate_perform_incremental_network_scan_ind - callback_data is NULL!");
    errval = QMI_ERR_INTERNAL;
  }

  ind_msg = ( nas_perform_incremental_network_scan_ind_msg_v01 *) modem_mem_alloc( 
                                           sizeof(nas_perform_incremental_network_scan_ind_msg_v01), 
                                           MODEM_MEM_CLIENT_QMI_MMODE );
  if( ind_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  if( errval == QMI_ERR_NONE )
  {
    memset(ind_msg, 0, sizeof(nas_perform_incremental_network_scan_ind_msg_v01));

    // Update current PLMN based on subscription
    if( qmi_nasi_global.net_scan_asubs_id == SYS_MODEM_AS_ID_2 )
    {
        current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_id.id.plmn ;
        current_sys_mode = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_mode;
    }
    else 
    {
        #if (defined(FEATURE_CDMA) || defined(FEATURE_HDR))
        if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
            qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )        
        {
          current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn_avail ?
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn :
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_id.id.plmn ;;
          current_sys_mode = sys_mode_gw_stack;

          if( (sys_mode_main_stack == SYS_SYS_MODE_GSM || sys_mode_main_stack == SYS_SYS_MODE_WCDMA || sys_mode_main_stack == SYS_SYS_MODE_TDS || sys_mode_main_stack == SYS_SYS_MODE_LTE) && 
              (main_stack_srv == SYS_SRV_STATUS_SRV) )
          {
            current_plmn_2 = plmn_main_stack;
            current_sys_mode_2 = sys_mode_main_stack;
            is_plmn_2_valid = TRUE;
            QM_MSG_HIGH_1( "generate_perform_incremental_network_scan is_plmn_2_valid = %d", is_plmn_2_valid );
          }
        }
      else
        #endif
      
      {
        current_plmn = plmn_main_stack;
        current_sys_mode = sys_mode_main_stack;
      }
    }

    if( available_networks->length > NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX )
    {
      QM_MSG_ERROR_2( "Received %d available networks, max is %d", available_networks->length, NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX );
      num_networks = NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX;
    }
    else
    {
      num_networks = available_networks->length;
    }

    // For every PLMN value in the list of available networks fill in TLVs
      // 0x10, 0x11
    for(sys_plmn_list_index=0; sys_plmn_list_index < num_networks; sys_plmn_list_index++)
    {
      net_info_available = FALSE;
      sys_plmn_get_mcc_mnc(available_networks->info[sys_plmn_list_index].plmn,
                           &is_plmn_undefined,
                           &mnc_includes_pcs_digit,
                           &mcc,
                           &mnc ); 
      if(!is_plmn_undefined)
      {
        // TLV 0x10 (3GPP NETWORK INFORMATION)
        ind_msg->nas_network_scan_info[network_info_index].mobile_country_code = (uint16) mcc;
        ind_msg->nas_network_scan_info[network_info_index].mobile_network_code = (uint16) mnc;
        rat_match = FALSE, rat_match_2 = FALSE;
        switch ( current_sys_mode )
        {
          case SYS_SYS_MODE_GSM:
            rat_match = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
            break;
          #if defined(FEATURE_WCDMA)
          case SYS_SYS_MODE_WCDMA:        
            rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
            break;
          #endif
          case SYS_SYS_MODE_LTE:
            rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
            break;
          #if defined(FEATURE_TDSCDMA)
          case SYS_SYS_MODE_TDS:
            rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
            break;
          #endif
          default:
              QM_MSG_ERROR_1( "generate_perform_incremental_network_scan no rat match current_sys_mode = %d", current_sys_mode);
              break;
        }
        if( is_plmn_2_valid )
        {
          switch ( current_sys_mode_2 )
          {
            case SYS_SYS_MODE_GSM:
              rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
              break;
            #if defined(FEATURE_WCDMA)
            case SYS_SYS_MODE_WCDMA:
              rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
              break;
            #endif
            case SYS_SYS_MODE_LTE:
              rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
              break;
            #if defined(FEATURE_TDSCDMA)
            case SYS_SYS_MODE_TDS:
              rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
              break;
            #endif
            default:
              QM_MSG_HIGH_1( "generate_perform_incremental_network_scan no rat match current_sys_mode_2 = %d", current_sys_mode_2);
              break;
          }
        }
        current_plmn_2 = plmn_main_stack;
        if( sys_plmn_match( current_plmn, available_networks->info[sys_plmn_list_index].plmn) &&  rat_match )
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
        }
        else if (is_plmn_2_valid && rat_match_2 &&
                 sys_plmn_match( current_plmn_2, available_networks->info[sys_plmn_list_index].plmn))
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
        }
        else
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_AVAILABLE_MASK;
        }
        switch (available_networks->info[sys_plmn_list_index].list_category)
        {
          case SYS_DETAILED_PLMN_LIST_CATEGORY_HPLMN:         
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_HOME_MASK;
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
            break;
             
          case SYS_DETAILED_PLMN_LIST_CATEGORY_PREFERRED:
          case SYS_DETAILED_PLMN_LIST_CATEGORY_USER_PREFERRED:
          case SYS_DETAILED_PLMN_LIST_CATEGORY_OPERATOR_PREFERRED:
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
              break;

          case SYS_DETAILED_PLMN_LIST_CATEGORY_OTHER:
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_PREFERRED_MASK;
              break;

          default:
              QM_MSG_HIGH_2( "Unhandled list_category (%d) for available networks.info[%d]", 
                  available_networks->info[sys_plmn_list_index].list_category, sys_plmn_list_index);
              break;
        }

        if(available_networks->info[sys_plmn_list_index].plmn_forbidden)
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_FORBIDDEN_MASK;
        }
        else
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_FORBIDDEN_MASK;
        }

        if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
        {
          if( name_cnf->plmn_list.plmn_info_ptr != NULL )
          {
            for( i = 0; i < name_cnf->plmn_list.num_of_plmn_ids; i++ )
            {
              if ( !memcmp( name_cnf->plmn_list.plmn_info_ptr[i].plmn_id.plmn_id_val, available_networks->info[sys_plmn_list_index].plmn.identity, sizeof(sys_plmn_id_s_type) ) && 
                    qmi_nas_compare_mmgsdi_cm_network_rat( name_cnf->plmn_list.plmn_info_ptr[i].plmn_id.rat, available_networks->info[sys_plmn_list_index].rat ) )
              {
                QM_MSG_HIGH_3("Perform net scan PLMN index %d, len %d, encoding %d", i, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding );
                for( j=0; j<name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len; j++ )
                {
                  QM_MSG_HIGH_1("%d", name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr[j] );
                }
                if ( qm_efs_always_return_plmn() )
                {
                  if ( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                  {
                    network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                                buff_ptr,
                                                                                NASI_MAX_LEN_NETWORK_NAME/2 );
                    memscpy( (void*)ind_msg->nas_network_scan_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                    if ( network_name_len > 0 )
                    {
                      net_info_available = TRUE;
                    }
                  }
                  else
                  {
                    net_info_available = nasi_convert_mm_info_oper_name(
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_encoding,
                                           (char *)ind_msg->nas_network_scan_info[network_info_index].network_description,
                                           &encoding_type,
                                           NASI_MAX_LEN_NETWORK_NAME,
                                           (uint8)name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len);
                    network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, strlen((char *)ind_msg->nas_network_scan_info[network_info_index].network_description));
                  }
                }
                else
                {
                  if ( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                  {
                    network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                                buff_ptr,
                                                                                NASI_MAX_LEN_NETWORK_NAME/2 );
                    memscpy( (void*)ind_msg->nas_network_scan_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                    if ( network_name_len > 0 )
                    {
                      net_info_available = TRUE;
                    }
                  }
                  else
                  {
                    net_info_available = nasi_convert_mm_info_oper_name( 
                                         name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                         name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding,
                                         (char *)ind_msg->nas_network_scan_info[network_info_index].network_description,
                                         &encoding_type,
                                         NASI_MAX_LEN_NETWORK_NAME,
                                         (uint8)name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len);
                    network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, strlen((char *)ind_msg->nas_network_scan_info[network_info_index].network_description));
                  }
                }
              }
            }
          }
        }

        if( !net_info_available)
        {
           QM_MSG_HIGH_1( "Could not get Network name for PLMN index %d. Sending only mcc,mnc", sys_plmn_list_index);         
        }

        switch ( available_networks->info[sys_plmn_list_index].rat )
        {
          case SYS_RAT_GSM_RADIO_ACCESS:  
            ind_msg->nas_network_scan_info[network_info_index].rat = QMI_NAS_RADIO_IF_GSM;   
            break;
          #if defined(FEATURE_WCDMA)
          case SYS_RAT_UMTS_RADIO_ACCESS:  
            ind_msg->nas_network_scan_info[network_info_index].rat = QMI_NAS_RADIO_IF_UMTS;
            break;
          #endif
          case SYS_RAT_LTE_RADIO_ACCESS: 
            ind_msg->nas_network_scan_info[network_info_index].rat = QMI_NAS_RADIO_IF_LTE; 
            
            #if defined(FEATURE_CIOT)
            ind_msg->nas_network_scan_info[network_info_index].lte_op_mode = 
                   qmi_nas_map_camped_lte_mode_cm_to_qmi(available_networks->info[sys_plmn_list_index].ciot_lte_mode);
            #endif
            break;
          #if defined(FEATURE_TDSCDMA)
          case SYS_RAT_TDS_RADIO_ACCESS: 
            ind_msg->nas_network_scan_info[network_info_index].rat = QMI_NAS_RADIO_IF_TDSCDMA; 
            break;
           #endif
           default:                                                   
             break;
        }
        ind_msg->nas_network_scan_info[network_info_index].mnc_includes_pcs_digit = mnc_includes_pcs_digit;

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
        if ( qm_efs_csg_supported() )
        {
          // TLV 0x14 (CSG Information)
          QM_MSG_HIGH_1( "Efs csg supported with csg_id=%d", available_networks->info[sys_plmn_list_index].csg_info.csg_id);
          if( available_networks->info[sys_plmn_list_index].csg_info.csg_id != SYS_CSG_ID_INVALID )
          {
            ind_msg->csg_info[csg_network_info_index].mcc = (uint16) mcc;
            ind_msg->csg_info[csg_network_info_index].mnc = (uint16) mnc;
            ind_msg->csg_info[csg_network_info_index].csg_info.id = available_networks->info[sys_plmn_list_index].csg_info.csg_id;
            ind_msg->csg_info[csg_network_info_index].csg_info.name_len = MIN(available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length, NAS_CSG_NAME_MAX_LEN);
            memscpy(ind_msg->csg_info[csg_network_info_index].csg_info.name, 
                    ind_msg->csg_info[csg_network_info_index].csg_info.name_len,
                    available_networks->info[sys_plmn_list_index].csg_info.hnb_name.name, 
                    ind_msg->csg_info[csg_network_info_index].csg_info.name_len);

            switch( available_networks->info[sys_plmn_list_index].list_category )
            {
              case SYS_DETAILED_PLMN_LIST_ALLOWED_CSG:
                ind_msg->csg_info[csg_network_info_index].csg_list_cat = NAS_CSG_LIST_CAT_ALLOWED_V01;
                break;
              case SYS_DETAILED_PLMN_LIST_OPERATOR_CSG:
                ind_msg->csg_info[csg_network_info_index].csg_list_cat = NAS_CSG_LIST_CAT_OPERATOR_V01;
                break;
              default:
                ind_msg->csg_info[csg_network_info_index].csg_list_cat = NAS_CSG_LIST_CAT_UNKNOWN_V01;
                QM_MSG_HIGH_1("Received list category %d", available_networks->info[sys_plmn_list_index].list_category );
                break;
            }
            csg_network_info_index++;
            QM_MSG_HIGH_3("network %d, csg_id %d, name_len %d", sys_plmn_list_index, available_networks->info[sys_plmn_list_index].csg_info.csg_id, available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length );
          }
        }
#endif
#endif
        // Increment network_info_index
        network_info_index++;
      }
      else
      {
        QM_MSG_HIGH_1( "PLMN for index %d undefined", sys_plmn_list_index);
      }
    } // End for (all PLMNs in the list populated)

    ind_msg->nas_network_scan_info_len = network_info_index; 
    ind_msg->csg_info_len              = csg_network_info_index;

    if ( errval == QMI_ERR_NONE )
    {
      ind_msg->nas_network_scan_info_valid = TRUE;

#ifdef FEATURE_FEMTO_CSG
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
      if( qm_efs_csg_supported() && ind_msg->csg_info_len )
      {
        ind_msg->csg_info_valid = TRUE;
      }
#endif
#endif
      if(qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_INPROGRESS)
      {
        ind_msg->scan_status = NAS_SCAN_STATUS_PARTIAL_V01;
      }
      else
      {
        if( qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_DONE )
        {
          ind_msg->scan_status = NAS_SCAN_STATUS_COMPLETE_V01;
        }
        else if( qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_AS_ABORT )
        {
          ind_msg->scan_status = NAS_SCAN_STATUS_ABORT_V01;
        }
        else
        {
          QM_MSG_ERROR_1("Not Handled %d ",qmi_nasi_global.incremental_net_scan_status);
        }
        // Clear pending network scan global var
        qmi_nasi_global.net_scan_started = FALSE;
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;
      }
    }
    if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                       QMI_IDL_INDICATION,
                                       (uint16_t) QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_IND_MSG_V01, // message_id = 0x0085 for _IND
                                       (void *)   ind_msg,
                                       (uint32_t) sizeof(nas_perform_incremental_network_scan_ind_msg_v01),
                                       &indication ) )
    {
      qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_PERFORM_INCREMENTAL_NETWORK_SCAN, indication );
    }
                
  } // End if

  if ( available_networks != NULL )
  {
    modem_mem_free( available_networks, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  if ( callback_data != NULL )
  {
    modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
  }

  if ( ind_msg )
  {
    // Free heap mem for unpacked response struct
    modem_mem_free( ind_msg, MODEM_MEM_CLIENT_QMI_MMODE );
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_INCREMENTAL_NETWORK_SCAN_ERR_IND()

  DESCRIPTION
    Called when error_cb() supplied in cm_ph_cmd_get_networks() is called 
    by CM. Sends error response to control point if error is reported by CM
    
  PARAMETERS
    ph_cmd_err  : Error type

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_perform_incremental_network_scan_err_ind
(
  nas_scan_status_enum_v01 scan_status
)
{
  nas_perform_incremental_network_scan_ind_msg_v01 *ind_msg   = NULL;
  dsm_item_type                                    *indication = NULL;
  qmi_nasi_client_state_type                       *cl_sp = NULL;
  qmi_error_e_type       errval = QMI_ERR_NONE;
    
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  qmi_nasi_global.net_scan_started = FALSE;
  qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;

  cl_sp = q_linear_search( &qmi_nas_state.client_q,
                             qmi_nas_qcsi_compare_client_handle,
                             qmi_nasi_global.incremental_net_scan_clnt );
  //Get the client cl_sp
  if(cl_sp == NULL)
  {
    QM_MSG_HIGH_2( "qmi_nasi_generate_perform_incremental_network_scan_err_ind - cl_sp is NULL(%d),clnt:%p!",
           cl_sp,qmi_nasi_global.incremental_net_scan_clnt);
    errval = QMI_ERR_INVALID_CLIENT_ID;
  }

  if ( errval != QMI_ERR_NONE) { return; };


  // Allocating heap mem.
  ind_msg = (nas_perform_incremental_network_scan_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_incremental_network_scan_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  if( ind_msg == NULL)
  {
    qmi_voice_mem_error(); 
    return;
   }

  memset(ind_msg, 0, sizeof(nas_perform_incremental_network_scan_ind_msg_v01));

  /*-------------------------------------------------------------------------
    Return response with appropriate error code
  -------------------------------------------------------------------------*/

  ind_msg->scan_status = scan_status;

  /*-------------------------------------------------------------------------
    Complete pending network_scan transaction
  -------------------------------------------------------------------------*/
  indication = NULL;
  if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_INDICATION,
                                     (uint16_t) QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_IND_MSG_V01, // message_id = 0x0085 for _IND
                                     (void *)   ind_msg,
                                     (uint32_t) sizeof(nas_perform_incremental_network_scan_ind_msg_v01),
                                     &indication ) )
  {
    qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_PERFORM_INCREMENTAL_NETWORK_SCAN, indication );
    QM_MSG_HIGH_1("Sending network scan indication with scan status %d",ind_msg->scan_status);
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_generate_perform_incremental_network_scan_err_ind() */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_INCREMENTAL_NETWORK_SCAN_RESP()

  DESCRIPTION
    Called when error_cb() supplied in cm_ph_cmd_get_networks() is called 
    by CM. Sends error response to control point if error is reported by CM
    
  PARAMETERS
    ph_cmd_err  : Error type

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_perform_incremental_network_scan_resp ( 
void *               user_data,
cm_ph_cmd_err_e_type ph_cmd_err
)
{
  dsm_item_type      *response = NULL;
  nas_perform_incremental_network_scan_resp_msg_v01 *rsp_msg = NULL;
  qmi_mmode_qcsi_transaction_type   *cmd_buf_p;
  qmi_error_e_type    errval;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  /*-------------------------------------------------------------------------
    Return response with appropriate error code
  -------------------------------------------------------------------------*/
  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;
            
    case CM_PH_CMD_ERR_NET_TYPE_P:
      errval = QMI_ERR_INVALID_OPERATION;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE;
      break;
            
    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }
  if( errval != QMI_ERR_NONE )
  {
    qmi_nasi_global.net_scan_started = FALSE;
    qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;
  }

  /*-------------------------------------------------------------------------
    Complete pending network_scan transaction
  -------------------------------------------------------------------------*/
  rsp_msg = (nas_perform_incremental_network_scan_resp_msg_v01 *) 
  modem_mem_alloc( sizeof(nas_perform_incremental_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    return;
  }

  memset( rsp_msg, 0x00, sizeof(nas_perform_incremental_network_scan_resp_msg_v01) );

  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      continue;
    }

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_perform_incremental_network_scan_resp_msg_v01),
                                  &response
                                );
        
      qmi_nasi_send_response( cmd_buf_p, response);
     /*Send Network Scan response*/
  }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#endif
#ifdef FEATURE_LTE_EMBMS
/*===========================================================================
  FUNCTION qmi_nasi_get_lte_embms_info()

  DESCRIPTION
    Retrieve the LTE EMBMS statistics information.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_lte_embms_info
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_lte_embms_info_resp_msg_v01 *resp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4( "null ptr in qmi_nasi_get_lte_embms_info %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in );

    errval = QMI_ERR_INTERNAL_V01;
  }


  resp_msg = (nas_get_lte_embms_info_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_lte_embms_info_resp_msg_v01 ) );

  if ( resp_msg != NULL )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_lte_embms_info_resp_msg_v01 ) );

#ifdef FEATURE_LTE
  if ( errval == QMI_ERR_NONE_V01 )
  {
    cmapi_lte_eMBPS_info_s embms_info;
    uint8 i=0,j=0;
    memset( &embms_info, 0x00, sizeof( embms_info ) );
    cmapi_lte_get_eMBMS_info( &embms_info );

    QM_MSG_HIGH_5( "coverage status=%d,pmch_data_mcs=%d,num_active_embms_comb=%d, num_mbsfn_areas=%d,num_area=%d", 
        embms_info.eMBMS_coverage_status, embms_info.datamcs.num_pmch_datamcs_info, embms_info.mac_active.num_active_embms_comb,embms_info.pmch.mbsfn_snr_info.num_mbsfn_areas, embms_info.pmch.pmch_bler_info.num_area );

    resp_msg->coverage_status_valid = TRUE;
    resp_msg->coverage_status = embms_info.eMBMS_coverage_status;

    resp_msg->pmch_data_mcs_len = MIN(embms_info.datamcs.num_pmch_datamcs_info,NAS_LTE_ACTIVE_PMCH_MAX_V01);
    for(i=0;i < resp_msg->pmch_data_mcs_len;i++)
    {
      resp_msg->pmch_data_mcs[i].mbsfn_area_id = embms_info.datamcs.pmch_datamcs[i].mbsfn_area_id;
      resp_msg->pmch_data_mcs[i].pmch_id = embms_info.datamcs.pmch_datamcs[i].pmch_id;
      resp_msg->pmch_data_mcs[i].data_mcs = embms_info.datamcs.pmch_datamcs[i].datamcs;
    }
    if(resp_msg->pmch_data_mcs_len > 0)
    {
      resp_msg->pmch_data_mcs_valid = TRUE;
    }

    resp_msg->is_active_tmgi_valid_valid = TRUE;
    resp_msg->is_active_tmgi_valid = embms_info.pmch.is_valid;

    resp_msg->mbsfn_area_signal_data_len = MIN(embms_info.pmch.mbsfn_snr_info.num_mbsfn_areas,NAS_LTE_EMBMS_MBSFN_AREAS_MAX_V01);
    for(i=0;i<resp_msg->mbsfn_area_signal_data_len;i++)
    {
      resp_msg->mbsfn_area_signal_data[i].area_id = embms_info.pmch.mbsfn_snr_info.mbsfn_area_signal_strength[i].area_id;
      resp_msg->mbsfn_area_signal_data[i].snr = embms_info.pmch.mbsfn_snr_info.mbsfn_area_signal_strength[i].snr;
      resp_msg->mbsfn_area_signal_data[i].excess_snr = embms_info.pmch.mbsfn_snr_info.mbsfn_area_signal_strength[i].excess_snr;
      resp_msg->mbsfn_area_signal_data[i].signal_level = embms_info.pmch.mbsfn_snr_info.mbsfn_area_signal_strength[i].signal_level;
    }
    if( resp_msg->mbsfn_area_signal_data_len > 0 )
    {
      resp_msg->mbsfn_area_signal_data_valid = TRUE;
    }

    resp_msg->pmch_bler_info_len = MIN(embms_info.pmch.pmch_bler_info.num_area,NAS_LTE_EMBMS_MBSFN_AREAS_MAX_V01);
    for(i=0;i<resp_msg->pmch_bler_info_len;i++)
    {
      resp_msg->pmch_bler_info[i].area_id = embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].area_id;
      resp_msg->pmch_bler_info[i].pmch_bler_len = MIN(embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].num_pmch,NAS_LTE_PMCH_PER_MBSFN_AREA_MAX_V01);
      for(j=0;j<resp_msg->pmch_bler_info[i].pmch_bler_len;j++)
      {
        resp_msg->pmch_bler_info[i].pmch_bler[j].pmch_id = embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].pmch_bler[j].pmch_id;
        resp_msg->pmch_bler_info[i].pmch_bler[j].num_crc_pass = embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].pmch_bler[j].num_crc_pass;
        resp_msg->pmch_bler_info[i].pmch_bler[j].num_crc_fail = embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].pmch_bler[j].num_crc_fail;
      }
    }
    if( resp_msg->pmch_bler_info_len > 0 )
    {
      resp_msg->pmch_bler_info_valid = TRUE;
    }

    resp_msg->mtch_info_len = MIN(embms_info.mac_active.num_active_embms_comb,NAS_LTE_EMBMS_ACTIVE_SESSIONS_MAX_V01);
    for(i=0;i<resp_msg->mtch_info_len;i++)
    {
      resp_msg->mtch_info[i].area_id = embms_info.mac_active.mtch_info_arr[i].area_id;
      resp_msg->mtch_info[i].pmch_id = embms_info.mac_active.mtch_info_arr[i].pmch_id;
      resp_msg->mtch_info[i].lc_id= embms_info.mac_active.mtch_info_arr[i].lc_id;
      resp_msg->mtch_info[i].num_mtch_tb_bytes = embms_info.mac_active.mtch_info_arr[i].num_mtch_tb_bytes;
    }
    if( resp_msg->mtch_info_len > 0 )
    {
      resp_msg->mtch_info_valid = TRUE;
    }

  }
#else
  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }
#endif

    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  QMI_NAS_GET_LTE_EMBMS_INFO_RESP_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_lte_embms_info_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) 
  { 
    QMI_NAS_MEM_FREE( (void *) resp_msg ); 
    resp_msg = NULL;
  }

  return response;
}
#endif
#ifndef REMOVE_QMI_NAS_GET_SSAC_INFO_V01
/*===========================================================================
  FUNCTION QMI_NASI_SSAC_CHANGE_INFO_IND()

  DESCRIPTION
    Generate and change in SSAC info indication (which includes both idle and connected mode)
    
  PARAMETERS
    msg_p  Pointer to MSGR data for ssac params info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_ssac_change_info_ind
(
  lte_rrc_ssac_params_s * ssac_params
)
{
  qmi_nasi_client_state_type      *cl_sp;
  nas_ssac_change_info_ind_msg_v01 *ind_msg;
  dsm_item_type                   *ind = NULL;

  ind_msg = (nas_ssac_change_info_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_ssac_change_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof(nas_ssac_change_info_ind_msg_v01) );

    QM_MSG_HIGH_5( "SSAC CHANGE INFO IND Voice:is valid=%d barring_factor_voice %d, barring_time %d, sib2_barring_factor_voice %d, sib2_barring_time %d",
        ssac_params->ssac_param_voice_valid, ssac_params->barring_factor_mmtel_voice, ssac_params->barring_time_mmtel_voice, ssac_params->sib2_barring_factor_mmtel_voice, ssac_params->sib2_barring_time_mmtel_voice );
    QM_MSG_HIGH_5( "SSAC CHANGE INFO IND Video:is valid=%d  barring_factor_video %d, barring_time %d, sib2_barring_factor_video %d, sib2_barring_time %d",
        ssac_params->ssac_param_video_valid, ssac_params->barring_factor_mmtel_video, ssac_params->barring_time_mmtel_video,ssac_params->sib2_barring_factor_mmtel_video, ssac_params->sib2_barring_time_mmtel_video);

    if ( !qmi_nasi_ssac_info.is_valid || memcmp(&qmi_nasi_ssac_info.ssac_cache, ssac_params, sizeof(lte_rrc_ssac_params_s)) )
    {
    ind_msg->ssac_voice_info_valid = TRUE;
    ind_msg->ssac_video_info_valid = TRUE;
    ind_msg->ssac_voice_info.barring_factor_voice = ssac_params->barring_factor_mmtel_voice;
    ind_msg->ssac_voice_info.barring_time_voice = ssac_params->barring_time_mmtel_voice;
    ind_msg->ssac_video_info.barring_factor_video = ssac_params->barring_factor_mmtel_video;
    ind_msg->ssac_video_info.barring_time_video = ssac_params->barring_time_mmtel_video;

    ind_msg->sib2_ssac_voice_info_valid = TRUE;
    ind_msg->sib2_ssac_video_info_valid = TRUE;
    ind_msg->sib2_ssac_voice_info.sib2_barring_factor_voice = ssac_params->sib2_barring_factor_mmtel_voice;
    ind_msg->sib2_ssac_voice_info.sib2_barring_time_voice = ssac_params->sib2_barring_time_mmtel_voice;
    ind_msg->sib2_ssac_video_info.sib2_barring_factor_video = ssac_params->sib2_barring_factor_mmtel_video;
    ind_msg->sib2_ssac_video_info.sib2_barring_time_video = ssac_params->sib2_barring_time_mmtel_video;

      //Sending SSAC_CHANGE_INFO_IND
      
      cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
      while ( cl_sp != NULL )
      {

        if ( cl_sp->report_status.report_ssac_change_info || cl_sp->report_status.report_ssac_info )
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_SSAC_CHANGE_INFO_IND_V01, 
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_ssac_change_info_ind_msg_v01), 
                                                    &ind
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, QMI_NAS_SSAC_CHANGE_INFO_IND_V01, ind );
          }
        }

        cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
      }
    }
    else
    {
      QM_MSG_HIGH( "SSAC info did not change - not sending indication" );
    }
    modem_mem_free((void *)ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}
#endif
#ifndef FEATURE_MMODE_QMI_DISABLE_IMS_EXT
/*===========================================================================
  FUNCTION qmi_nasi_gen_emm_t3402_changed_ind()

  DESCRIPTION
    Generate the T3402 timer changed indicatio
    
  PARAMETERS
    msg_p  Pointer to MSGR data for T3402 info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_gen_emm_t3402_changed_ind
(
  emm_t3402_changed_ind_s_type * timer_val
)
{
  qmi_nasi_client_state_type        *cl_sp;
  nas_emm_t3402_changed_ind_msg_v01 ind_msg;
  dsm_item_type                     *ind = NULL;

  memset( &ind_msg, 0x00, sizeof(nas_emm_t3402_changed_ind_msg_v01) );
  ind_msg.t3402_timer_val_valid = TRUE;
  ind_msg.t3402_timer_val = timer_val-> t3402_value;


  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {

    if ( cl_sp->report_status.report_t3402_timer_change )
    {
      ind = NULL;
      if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                QMI_IDL_INDICATION, 
                                                (uint16_t)QMI_NAS_EMM_T3402_CHANGED_IND_V01, 
                                                (void *) &ind_msg,
                                                (uint32_t)sizeof(nas_emm_t3402_changed_ind_msg_v01), 
                                                &ind
                                              ) )
      {
        qmi_nasi_send_ind( cl_sp, QMI_NAS_EMM_T3402_CHANGED_IND_V01, ind );
      }
    }

    cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
  }
}
#endif
#ifndef REMOVE_QMI_NAS_GET_SSAC_INFO_V01
/*===========================================================================
  FUNCTION qmi_nasi_get_ssac_info()

  DESCRIPTION
    Retrieve the LTE SSAC cached information.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_ssac_info
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_ssac_info_resp_msg_v01 *resp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4( "null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp ,  sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  resp_msg = (nas_get_ssac_info_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_ssac_info_resp_msg_v01 ) );

  if ( resp_msg != NULL )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_ssac_info_resp_msg_v01 ) );

    if( !qmi_nasi_ssac_info.is_valid )
    {
      QM_MSG_ERROR( "SSAC information not available from LTE-RRC" );
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
    else
    {
      //Sending both the optional TLV's always when success.
      resp_msg->ssac_voice_info_valid = TRUE;
      resp_msg->ssac_video_info_valid = TRUE;
      resp_msg->ssac_voice_info.barring_factor_voice = qmi_nasi_ssac_info.ssac_cache.barring_factor_mmtel_voice;
      resp_msg->ssac_video_info.barring_factor_video = qmi_nasi_ssac_info.ssac_cache.barring_factor_mmtel_video;
      resp_msg->ssac_voice_info.barring_time_voice = qmi_nasi_ssac_info.ssac_cache.barring_time_mmtel_voice;
      resp_msg->ssac_video_info.barring_time_video = qmi_nasi_ssac_info.ssac_cache.barring_time_mmtel_video;
      
      resp_msg->sib2_ssac_voice_info_valid = TRUE;
      resp_msg->sib2_ssac_video_info_valid = TRUE;
      resp_msg->sib2_ssac_voice_info.sib2_barring_factor_voice = qmi_nasi_ssac_info.ssac_cache.sib2_barring_factor_mmtel_voice;
      resp_msg->sib2_ssac_video_info.sib2_barring_factor_video = qmi_nasi_ssac_info.ssac_cache.sib2_barring_factor_mmtel_video;
      resp_msg->sib2_ssac_voice_info.sib2_barring_time_voice = qmi_nasi_ssac_info.ssac_cache.sib2_barring_time_mmtel_voice;
      resp_msg->sib2_ssac_video_info.sib2_barring_time_video = qmi_nasi_ssac_info.ssac_cache.sib2_barring_time_mmtel_video;
    }

    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  QMI_NAS_GET_SSAC_INFO_RESP_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_ssac_info_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) 
  { 
    QMI_NAS_MEM_FREE( (void *) resp_msg ); 
    resp_msg = NULL;
  }

  return response;
}
#endif
#ifndef REMOVE_QMI_NAS_SET_PERIODIC_SEARCH_ALLOWED_V01
/*===========================================================================
  FUNCTION qmi_nasi_set_periodic_search_allowed()

  DESCRIPTION
    Enable/Disable periodic search.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
dsm_item_type* qmi_nasi_set_periodic_search_allowed
(
     qmi_mmode_svc_info_type *sp,
     qmi_mmode_qcsi_transaction_type *cmd_buf_p,
     void *            cl_sp, 
     dsm_item_type **  sdu_in
)
{
   dsm_item_type     *response = NULL;
   qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

   nas_set_periodic_search_allowed_req_msg_v01  * req_msg;
   nas_set_periodic_search_allowed_resp_msg_v01 * rsp_msg;
   sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;

   ASSERT(sp);
   ASSERT(cmd_buf_p);
   ASSERT(cl_sp);
   ASSERT(sdu_in);
   
   if ( ! TARGET_SUPPORTS_GSM && ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE && ! TARGET_SUPPORTS_TDS )
   {
     QM_MSG_ERROR("OP UNSUPPORTED");
     errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
   }

#ifdef FEATURE_DUAL_SIM
   if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
   {
     asubs_id = SYS_MODEM_AS_ID_2;
   }
#ifdef FEATURE_TRIPLE_SIM
   else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
   {
      asubs_id = SYS_MODEM_AS_ID_3;
   }
#endif
#endif
   req_msg = (nas_set_periodic_search_allowed_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_periodic_search_allowed_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   rsp_msg = (nas_set_periodic_search_allowed_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_periodic_search_allowed_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

   if ( req_msg == NULL )
   {
      qmi_voice_mem_error();
      errval = QMI_ERR_NO_MEMORY_V01;
   }

   if ( errval == QMI_ERR_NONE_V01 )
   {
      memset ( req_msg, 0x00, sizeof(nas_set_periodic_search_allowed_req_msg_v01) );

      // extract information from REQ message
      errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                    (uint16_t)QMI_NAS_SET_PERIODIC_SEARCH_ALLOWED_REQ_MSG_V01,
                                    sdu_in,
                                    (void *) req_msg,
                                    (uint32_t) sizeof(nas_set_periodic_search_allowed_req_msg_v01)
                                  );
   }

   // check for error in REQ message
   if (errval == QMI_ERR_NONE_V01)
   {
      errval = qmi_nas_0092_req_check( req_msg );
   }

   if (errval == QMI_ERR_NONE_V01)
   {
      policyman_set_periodic_plmn_search_allowed(asubs_id, req_msg->allowed);
   }

   if ( rsp_msg == NULL )
   {
      qmi_voice_mem_error();
   }
   else if( cmd_buf_p != NULL )
   {
      memset( rsp_msg, 0x00, sizeof(nas_set_periodic_search_allowed_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                           QMI_IDL_RESPONSE,
                           (uint16_t) QMI_NAS_SET_PERIODIC_SEARCH_ALLOWED_RESP_MSG_V01,
                           (void *) rsp_msg,
                           (uint32_t) sizeof(nas_set_periodic_search_allowed_resp_msg_v01),
                           &response
                         );
   }
   else
   {
      QM_MSG_ERROR("cmd_buf_p is NULL");
   }

   if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
   if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

   return response;
}

#endif

#ifndef REMOVE_QMI_NAS_GET_CURRENT_SCAN_INFO_V01
/*===========================================================================
  FUNCTION qmi_nasi_get_current_scan_info()

  DESCRIPTION
    Retrieve the configured scan parameters
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_current_scan_info
  (
    qmi_mmode_svc_info_type *sp,
    qmi_mmode_qcsi_transaction_type *cmd_buf_p,
    void *            cl_sp, 
    dsm_item_type **  sdu_in
  )
  {
    dsm_item_type     *response = NULL;
    qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
    nas_get_current_scan_info_resp_msg_v01 * rsp_msg;
    sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
    sys_scan_params_s_type      current_scan_info;

    ASSERT(sp);
    ASSERT(cmd_buf_p);
    ASSERT(cl_sp);
    ASSERT(sdu_in);

#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
       asubs_id = SYS_MODEM_AS_ID_2;
     }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
       asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif


    rsp_msg = (nas_get_current_scan_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_current_scan_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL )
    {
      qmi_voice_mem_error();
    }
    else
    {

      memset( rsp_msg, 0x00, sizeof(nas_get_current_scan_info_resp_msg_v01) );
      memset( &current_scan_info, 0x00, sizeof(sys_scan_params_s_type) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

      nas_command_get_scan_params(&current_scan_info);

      rsp_msg->current_camped_rat_valid = TRUE;

      rsp_msg->current_camped_rat = (nas_radio_if_enum_v01)qmi_nas_sys_mode_2_radio_if_ciot(current_scan_info.current_camped_rat,
                                      &rsp_msg->current_camped_ciot_lte_rat);

      if (rsp_msg->current_camped_rat == NAS_RADIO_IF_LTE_V01)
      {
        rsp_msg->current_camped_ciot_lte_rat_valid = TRUE;
      }

      rsp_msg->current_scanning_rat_valid = TRUE;

      rsp_msg->current_scanning_rat = (nas_radio_if_enum_v01)qmi_nas_sys_mode_2_radio_if_ciot(current_scan_info.scanning_rat,
                                      &rsp_msg->current_scanning_ciot_lte_rat);

      if (rsp_msg->current_scanning_rat == NAS_RADIO_IF_LTE_V01)
      {
        rsp_msg->current_scanning_ciot_lte_rat_valid = TRUE;
      }

      if(rsp_msg->current_camped_rat != NAS_RADIO_IF_NO_SVC_V01)
      {
        rsp_msg->current_roaming_status_valid = TRUE;
        switch ( current_scan_info.roam_state )
        {
          case SYS_ROAM_STATUS_OFF:
            rsp_msg->current_roaming_status = NAS_SYS_ROAM_STATUS_OFF_V01;
            break; /* home */
          case SYS_ROAM_STATUS_ON:
            rsp_msg->current_roaming_status = NAS_SYS_ROAM_STATUS_ON_V01;
            break; /* roaming */
          default:
            rsp_msg->current_roaming_status = (nas_roam_status_enum_type_v01) current_scan_info.roam_state;
            QM_MSG_HIGH_1("ENUM, %d, being returned as roaming indicator.", rsp_msg->current_roaming_status);
            break;
        }
      }

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_GET_CURRENT_SCAN_INFO_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_get_current_scan_info_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    }

    return response;
  } /* qmi_nasi_get_current_scan_info */

#endif

#ifndef REMOVE_QMI_NAS_GET_SCAN_CONFIG_V01
/*===========================================================================
  FUNCTION qmi_nasi_get_scan_config()

  DESCRIPTION
    Retrieve the configured scan parameters
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_scan_config
  (
    qmi_mmode_svc_info_type *sp,
    qmi_mmode_qcsi_transaction_type *cmd_buf_p,
    void *            cl_sp, 
    dsm_item_type **  sdu_in
  )
  {
    dsm_item_type     *response = NULL;
    qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
    nas_get_scan_config_resp_msg_v01 * rsp_msg;
    sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;

    ASSERT(sp);
    ASSERT(cmd_buf_p);
    ASSERT(cl_sp);
    ASSERT(sdu_in);

#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
       asubs_id = SYS_MODEM_AS_ID_2;
     }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
       asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif


    rsp_msg = (nas_get_scan_config_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_scan_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL )
    {
      qmi_voice_mem_error();
    }
    else
    {

      memset( rsp_msg, 0x00, sizeof(nas_get_scan_config_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

      rsp_msg->scan_counter_valid = TRUE;
      rsp_msg->scan_counter            = (uint8_t)sd_misc_efs_get_scan_counter(asubs_id);

      rsp_msg->power_save_duration_min_valid = TRUE;
      rsp_msg->power_save_duration_min = sd_misc_efs_get_power_save_duration_min(asubs_id);

      rsp_msg->power_save_duration_inc_type_valid = TRUE;
      if(sd_misc_efs_get_power_save_duration_delta(asubs_id) == 0)
      {
        rsp_msg->power_save_duration_inc_type = NAS_POWER_SAVE_DURATION_INC_STATIC_V01;
      }
      else
      {
        rsp_msg->power_save_duration_inc_type = NAS_POWER_SAVE_DURATION_INC_LINEAR_V01;
      }

      rsp_msg->power_save_duration_max_valid = TRUE;
      rsp_msg->power_save_duration_max = sd_misc_efs_get_power_save_duration_max(asubs_id);

      rsp_msg->hplmn_scan_interval_valid = TRUE;
      rsp_msg->hplmn_scan_interval = nas_cmd_get_hplmn_search_timer();

#ifdef FEATURE_CIOT
      rsp_msg->ciot_pref_rat_scan_interval_valid = TRUE;
      rsp_msg->ciot_pref_rat_scan_interval = nas_cmd_get_ciot_irat_search_timer();
#else
      rsp_msg->ciot_pref_rat_scan_interval_valid = FALSE;
#endif

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_GET_SCAN_CONFIG_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_get_scan_config_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    }

    return response;
  } /* qmi_nasi_get_scan_config */

#endif

/*===========================================================================
  FUNCTION qmi_nas_map_ac_barring_factor_lte_to_qmi()

  DESCRIPTION
    
  PARAMETERS

  RETURN VALUE
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8_t qmi_nas_map_ac_barring_factor_lte_to_qmi(lte_rrc_ac_barring_factor_e ac_barring_factor_lte)
{
  uint8_t ac_barring_factor_qmi = 0xFF;

  switch(ac_barring_factor_lte)
  {
  case LTE_RRC_AC_BARRING_FACTOR_P00:
    ac_barring_factor_qmi = 0; // 0.00 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P05:
    ac_barring_factor_qmi = 5; // 0.05 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P10:
    ac_barring_factor_qmi = 10; // 0.10 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P15:
    ac_barring_factor_qmi = 15; // 0.15 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P20:
    ac_barring_factor_qmi = 20; // 0.20 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P25:
    ac_barring_factor_qmi = 25; // 0.25 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P30:
    ac_barring_factor_qmi = 30; // 0.30 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P40:
    ac_barring_factor_qmi = 40; // 0.40 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P50:
    ac_barring_factor_qmi = 50; // 0.50 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P60:
    ac_barring_factor_qmi = 60; // 0.60 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P70:
    ac_barring_factor_qmi = 70; // 0.70 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P75:
    ac_barring_factor_qmi = 75; // 0.75 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P80:
    ac_barring_factor_qmi = 80; // 0.80 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P85:
      ac_barring_factor_qmi = 85; // 0.85 * 100
      break;
  case LTE_RRC_AC_BARRING_FACTOR_P90:
      ac_barring_factor_qmi = 90; // 0.90 * 100
      break;
  case LTE_RRC_AC_BARRING_FACTOR_P95:
      ac_barring_factor_qmi = 95; // 0.95 * 100
      break;
  case LTE_RRC_AC_BARRING_FACTOR_INVALID:
  default:
    ac_barring_factor_qmi = 0xFF;
    break;
  }
  return ac_barring_factor_qmi;
}

/*===========================================================================
  FUNCTION qmi_nas_populate_acb_info_ind()

  DESCRIPTION
    <QMI NAS internal use only>
    Helper function to generate qmi_nas_acb_info_ind type message from a given ac barring info.
    To be used in QMI_NAS_ACB_INFO_IND.

  PARAMETERS
    lte_rrc_ac_barring_info_s  LTE ACB info type
    nas_acb_info_ind_msg_v01   QMI NAS ACB Info Ind type

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_acb_info_ind
(
    lte_rrc_ac_barring_info_s *acb_info_ind,
    nas_acb_info_ind_msg_v01  *ind_msg
)
{
    QM_MSG_HIGH_4( "ACB INFO :: emergency_present:%d, MO_data_present:%d, MO_signalling_present:%d ac_barring_for_emergency %d", 
                              acb_info_ind->ac_barring_for_emergency_present,
                              acb_info_ind->ac_barring_MO_data_present,
                              acb_info_ind->ac_barring_MO_signalling_present,
                              acb_info_ind->ac_barring_for_emergency_present);

    ind_msg->ac_barring_for_emergency_valid   =  acb_info_ind->ac_barring_for_emergency_present;
    if( acb_info_ind->ac_barring_for_emergency_present ) 
    {
      ind_msg->ac_barring_for_emergency            =  acb_info_ind->ac_barring_for_emergency;
    }

    ind_msg->ac_barring_mo_data_valid             =  acb_info_ind->ac_barring_MO_data_present;
    if(acb_info_ind->ac_barring_MO_data_present)
    {
    
      QM_MSG_HIGH_3( "ACB INFO :: ac_barring_mo_data(%d,%d,%d) ", 
                                acb_info_ind->ac_barring_MO_data.ac_barring_factor,
                                acb_info_ind->ac_barring_MO_data.barring_time, 
                                acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC );
      // ac_barring_factorin multiple of 100s
      ind_msg->ac_barring_mo_data.ac_barring_factor = 
           qmi_nas_map_ac_barring_factor_lte_to_qmi( acb_info_ind->ac_barring_MO_data.ac_barring_factor);

      ind_msg->ac_barring_mo_data.ac_barring_time   = (uint16_t)acb_info_ind->ac_barring_MO_data.barring_time;
      if(acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC_present)
      {
         ind_msg->ac_barring_mo_data.ac_barring_for_special_ac =(uint8_t)acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC;
      }
      else
      {
         ind_msg->ac_barring_mo_data.ac_barring_for_special_ac = 0xFF; //Indicates ac_barring_for_special_ac is not available
      }
    }

    ind_msg->ac_barring_mo_signalling_valid      =  acb_info_ind->ac_barring_MO_signalling_present;
    if(acb_info_ind->ac_barring_MO_signalling_present)
    {
      QM_MSG_HIGH_3( "ACB INFO :: ac_barring_mo_signalling(%d,%d,%d) ", 
                                acb_info_ind->ac_barring_MO_signalling.ac_barring_factor, 
                                acb_info_ind->ac_barring_MO_signalling.barring_time, 
                                acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC );
      // ac_barring_factorin multiple of 100s
      ind_msg->ac_barring_mo_signalling.ac_barring_factor = 
          qmi_nas_map_ac_barring_factor_lte_to_qmi( acb_info_ind->ac_barring_MO_signalling.ac_barring_factor);
      
      ind_msg->ac_barring_mo_signalling.ac_barring_time   = (uint16_t)acb_info_ind->ac_barring_MO_signalling.barring_time;
      if(acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC_present)
      {
         ind_msg->ac_barring_mo_signalling.ac_barring_for_special_ac =(uint8_t)acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC;
      }
      else
      {
         ind_msg->ac_barring_mo_signalling.ac_barring_for_special_ac = 0xFF; //Indicates ac_barring_for_special_ac is not available
      }
    }
}

/*===========================================================================
  FUNCTION QMI_NASI_ACB_INFO_IND()

  DESCRIPTION
    Generate and send ACB(Access Class Barring) info indication
    
  PARAMETERS
    msg_p  Pointer to MSGR data for ssac params info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_acb_info_ind
(
  lte_rrc_ac_barring_info_s * acb_info_ind 
)
{
  qmi_nasi_client_state_type      *cl_sp;
  nas_acb_info_ind_msg_v01        *new_ind_msg;
  nas_acb_info_ind_msg_v01        *old_ind_msg;
  dsm_item_type                   *ind = NULL;

  new_ind_msg = (nas_acb_info_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_acb_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  old_ind_msg = (nas_acb_info_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_acb_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );


  if ( new_ind_msg != NULL  && old_ind_msg != NULL )
  {
    memset( new_ind_msg, 0x00, sizeof(nas_acb_info_ind_msg_v01) );
    memset( old_ind_msg, 0x00, sizeof(nas_acb_info_ind_msg_v01) );

    qmi_nas_populate_acb_info_ind(   &qmi_nasi_global.lte_rrc_ac_barring_info_cache, old_ind_msg);
    qmi_nas_populate_acb_info_ind( acb_info_ind, new_ind_msg);
    
    if(memcmp(old_ind_msg, new_ind_msg, sizeof(nas_acb_info_ind_msg_v01)))
    {
      cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
      while ( cl_sp != NULL )
      {
  
        if ( cl_sp->report_status.reg_acb_info_change )
        {
        
          QM_MSG_HIGH_1( "ACB INFO :: Sending qmi_nasi_acb_info_ind() for clnt:%p", cl_sp->clnt);
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_ACB_INFO_IND_V01, 
                                                    (void *) new_ind_msg,
                                                    (uint32_t)sizeof(nas_acb_info_ind_msg_v01), 
                                                    &ind
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, QMI_NAS_ACB_INFO_IND_V01, ind );
          }
        }

        cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
      }
    }
    /*Else, No change in the ACB Info*/
    modem_mem_free((void *)new_ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
    modem_mem_free((void *)old_ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}
/*===========================================================================
  FUNCTION qmi_nasi_get_acb_info()

  DESCRIPTION
    Retrieve the LTE ACB(Access Class Barring) cached information.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_acb_info  
  (
    qmi_mmode_svc_info_type *sp,
    qmi_mmode_qcsi_transaction_type *cmd_buf_p,
    void *            cl_sp, 
    dsm_item_type **  sdu_in
  )
  {
    dsm_item_type     *response = NULL;
    qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
    nas_get_acb_info_resp_msg_v01 * rsp_msg;
  
    ASSERT(sp);
    ASSERT(cmd_buf_p);
    ASSERT(cl_sp);
    ASSERT(sdu_in);

    rsp_msg = (nas_get_acb_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_acb_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL )
    {
      qmi_voice_mem_error();
    }
    else
    {
      lte_rrc_ac_barring_info_s *acb_info_ind = &qmi_nasi_global.lte_rrc_ac_barring_info_cache; 

      memset( rsp_msg, 0x00, sizeof(nas_get_acb_info_resp_msg_v01) );
      
      QM_MSG_HIGH_3( "ACB INFO :: emergency_present:%d, MO_data_present:%d, MO_signalling_present:%d", 
                                acb_info_ind->ac_barring_for_emergency_present,
                                acb_info_ind->ac_barring_MO_data_present,
                                acb_info_ind->ac_barring_MO_signalling_present );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
      
      rsp_msg->ac_barring_for_emergency_valid   =  acb_info_ind->ac_barring_for_emergency_present;
      if( acb_info_ind->ac_barring_for_emergency_present ) 
      {
        rsp_msg->ac_barring_for_emergency            =  acb_info_ind->ac_barring_for_emergency;
      }
      
      rsp_msg->ac_barring_mo_data_valid             =  acb_info_ind->ac_barring_MO_data_present;
      if(acb_info_ind->ac_barring_MO_data_present)
      {
      
        QM_MSG_HIGH_3( "ACB INFO :: ac_barring_mo_data(%d,%d,%d) ", 
                                  acb_info_ind->ac_barring_MO_data.ac_barring_factor,
                                  acb_info_ind->ac_barring_MO_data.barring_time, 
                                  acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC );

        rsp_msg->ac_barring_mo_data.ac_barring_factor = 
          qmi_nas_map_ac_barring_factor_lte_to_qmi(acb_info_ind->ac_barring_MO_data.ac_barring_factor);
        
        rsp_msg->ac_barring_mo_data.ac_barring_time   = (uint16_t)acb_info_ind->ac_barring_MO_data.barring_time;
        if(acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC_present)
        {
           rsp_msg->ac_barring_mo_data.ac_barring_for_special_ac =(uint8_t)acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC;
        }
        else
        {
           rsp_msg->ac_barring_mo_data.ac_barring_for_special_ac = 0xFF; //Indicates ac_barring_for_special_ac is not available
        }
      }
      
      rsp_msg->ac_barring_mo_signalling_valid      =  acb_info_ind->ac_barring_MO_signalling_present;
      if(acb_info_ind->ac_barring_MO_signalling_present)
      {
        QM_MSG_HIGH_3( "ACB INFO :: ac_barring_mo_signalling(%d,%d,%d) ", 
                                  acb_info_ind->ac_barring_MO_signalling.ac_barring_factor, 
                                  acb_info_ind->ac_barring_MO_signalling.barring_time, 
                                  acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC );

        rsp_msg->ac_barring_mo_signalling.ac_barring_factor = 
            qmi_nas_map_ac_barring_factor_lte_to_qmi(acb_info_ind->ac_barring_MO_signalling.ac_barring_factor);
        
        rsp_msg->ac_barring_mo_signalling.ac_barring_time   = (uint16_t)acb_info_ind->ac_barring_MO_signalling.barring_time;
        if(acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC_present)
        {
           rsp_msg->ac_barring_mo_signalling.ac_barring_for_special_ac =(uint8_t)acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC;
        }
        else
        {
           rsp_msg->ac_barring_mo_signalling.ac_barring_for_special_ac = 0xFF; //Indicates ac_barring_for_special_ac is not available
        }
      }


      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_GET_ACB_INFO_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_get_acb_info_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    }

  
    return response;
  } /* qmi_nasi_get_acb_info */

#ifndef REMOVE_QMI_NAS_SET_DATA_SUBS_PRIORITY_V01
/*===========================================================================
  FUNCTION QMI_NASI_SET_DATA_SUBS_PRIORITY()

  DESCRIPTION
    This message configures data priority
    for the client's bound subscription.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_data_subs_priority(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_set_data_subs_priority_resp_msg_v01 *resp_msg;

  nas_set_data_subs_priority_req_msg_v01  *req_msg;

  qmi_nasi_client_state_type *    client;
  client = (qmi_nasi_client_state_type*)cl_sp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_data_subs_priority_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_data_subs_priority_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_set_data_subs_priority_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_data_subs_priority_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_set_data_subs_priority_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_data_subs_priority_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
      QM_MSG_HIGH_3("set_data_subs_priority() - client %p subs %d priority %d", client->clnt, client->report_status.bound_subs, qmi_nasi_global.data_subs_priority[(int)(client->report_status.bound_subs)]);

      if(cm_ph_cmd_set_data_priority_per_subs(qmi_nas_cmph_cmd_cb,
                                              (void *)cmd_buf_p,
                                              qmi_nasi_global.cm_clnt_id,
                                              (sys_data_priority_e_type)(req_msg->data_subs_priority),
                                              (sys_modem_as_id_e_type)client->report_status.bound_subs))
      {
        QM_MSG_HIGH("set_data_subs_priority() - cm_ph_cmd_set_data_priority_per_subs sent, awaiting response");
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
        /*cm_ph_cmd_set_data_priority_per_subs() failed*/
      }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( resp_msg != NULL )
    {
      memset(resp_msg, 0, sizeof(nas_set_data_subs_priority_resp_msg_v01) );
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)cmd_buf_p->msg_id,
                                    (void *)resp_msg,
                                    (uint32_t)sizeof(nas_set_data_subs_priority_resp_msg_v01),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NAS_SET_DATA_SUBS_PRIORITY_RESP()

  DESCRIPTION
    Send response for SET_DATA_SUBS_PRIORITY_REQ

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_set_data_subs_priority_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_data_subs_priority_resp_msg_v01 *resp_msg;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf )
  {
    QM_MSG_ERROR("Null cmd_buf ptr");
    return;
  }

  errval = ( err == CM_PH_CMD_ERR_NOERR ) ? QMI_ERR_NONE_V01 : QMI_ERR_INTERNAL_V01;

  resp_msg = (nas_set_data_subs_priority_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_data_subs_priority_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_data_subs_priority_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)p_cmd_buf->msg_id,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_data_subs_priority_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &p_cmd_buf );
  }
  else 
  {
    qmi_nasi_send_response( p_cmd_buf, response );
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_set_data_subs_priority_resp() */
#endif
#ifndef REMOVE_QMI_NAS_GET_DATA_SUBS_PRIORITY_V01
/*===========================================================================
  FUNCTION qmi_nasi_get_data_subs_priority()

  DESCRIPTION
    Retrieve the cached data priority for
    the client's bound subscruption.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_data_subs_priority
( 
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *                 response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_data_subs_priority_resp_msg_v01 *resp_msg;
  qmi_nasi_client_state_type *    client;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4( "null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in );
    errval = QMI_ERR_INTERNAL_V01;
  }

  client = (qmi_nasi_client_state_type*)cl_sp;

  resp_msg = (nas_get_data_subs_priority_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_data_subs_priority_resp_msg_v01 ) );

  if ( (resp_msg != NULL) && (client != NULL) )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_data_subs_priority_resp_msg_v01 ) );

    if (errval == QMI_ERR_NONE_V01)
    {
      resp_msg->data_subs_priority_valid = TRUE;
      resp_msg->data_subs_priority = (nas_data_subs_priority_enum_v01)qmi_nasi_global.data_subs_priority[(int)(client->report_status.bound_subs)];
    }
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_GET_DATA_SUBS_PRIORITY_REQ_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_data_subs_priority_resp_msg_v01 ),
                                  &response
                                );
    /*Else, get_data_subs_priority() - Failed to encode*/

  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) 
  { 
    QMI_NAS_MEM_FREE( (void *) resp_msg ); 
    resp_msg = NULL;
  }

  return response;
} /* qmi_nasi_get_data_subs_priority() */
/*===========================================================================
  FUNCTION QMI_NAS_GEN_DATA_SUBS_PRIORITY_IND()

  DESCRIPTION
    generate QMI_NAS_ATA_SUBS_PRIORITY_IND

  PARAMETERS
    pointer to new CM PH event
===========================================================================*/
void qmi_nas_gen_data_subs_priority_ind( qmi_cm_ph_info_s_type *p_info )
{
  nas_data_subs_priority_ind_msg_v01    *ind_msg;
  dsm_item_type                         *ind;
  qmi_nasi_client_state_type            *cl_sp;
  int                                   client;

  QM_MSG_HIGH_2("data_subs_priority_ind() - subs: %d, priority: %d", p_info->asubs_id, p_info->priority_subs);

  ind_msg = (nas_data_subs_priority_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_data_subs_priority_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if(ind_msg != NULL)
  {
    memset( ind_msg, 0x00, sizeof(nas_data_subs_priority_ind_msg_v01) );
    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {
      if ( cl_sp->report_status.bound_subs == p_info->asubs_id &&
           #ifdef FEATURE_DUAL_SIM
           qmi_nasi_global.data_subs_priority[(int)(p_info->asubs_id)] != p_info->priority_type &&
           #endif
           cl_sp->report_status.report_data_priority_subs_change ) 
      {
           QM_MSG_HIGH_1("data_subs_priority_ind() - sending to client %d", client);
           ind_msg->data_subs_priority_valid = TRUE;
           #ifdef FEATURE_DUAL_SIM
           ind_msg->data_subs_priority = (nas_data_subs_priority_enum_v01) p_info->priority_type;
           #endif
           ind = NULL;
           if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_DATA_SUBS_PRIORITY_IND_MSG_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_data_subs_priority_ind_msg_v01 ),
                                             &ind ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_DATA_SUBS_PRIORITY_IND, ind );
          }
         /*else, Encoding has failed*/
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
  else
  {
    qmi_voice_mem_error();
  }
#ifdef FEATURE_DUAL_SIM
  qmi_nasi_global.data_subs_priority[(int)(p_info->asubs_id)] = p_info->priority_type;
#endif
  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_gen_data_subs_priority_ind() */
#endif

#ifndef REMOVE_QMI_NAS_SET_SRVCC_V01
/*===========================================================================
  FUNCTION qmi_nas_set_srvcc_resp()

  DESCRIPTION
    Send response for SET_SRVCC

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_set_srvcc_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_srvcc_resp_msg_v01 *resp_msg;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf )
  {
    return;
  }

  errval = ( err == CM_PH_CMD_ERR_NOERR ) ? QMI_ERR_NONE_V01 : QMI_ERR_INTERNAL_V01;

  if(err == CM_PH_CMD_ERR_OPRT_MODE_S)
  {
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
  }

  resp_msg = (nas_set_srvcc_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_srvcc_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_srvcc_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)p_cmd_buf->msg_id,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_srvcc_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &p_cmd_buf );
  }
  else qmi_nasi_send_response( p_cmd_buf, response );
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_set_srvcc_resp() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_SRVCC()

  DESCRIPTION
    This message configures data priority
    for the client's bound subscription.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_srvcc(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_set_srvcc_resp_msg_v01 *resp_msg;

  nas_set_srvcc_req_msg_v01  *req_msg;

  qmi_nasi_client_state_type *    client;
  client = (qmi_nasi_client_state_type*)cl_sp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_srvcc_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_srvcc_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_set_srvcc_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_srvcc_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_set_srvcc_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_srvcc_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if( errval == QMI_ERR_NONE_V01 && req_msg != NULL && req_msg->srvcc_status != TRUE && req_msg->srvcc_status != FALSE)
  {
    errval = QMI_ERR_INVALID_ARG_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
      QM_MSG_HIGH_3("set_srvcc_req() - client %p subs %d srvcc_status=%d", client->clnt, client->report_status.bound_subs, req_msg->srvcc_status);

      if(cm_set_srvcc_capability(qmi_nas_cmph_cmd_cb,
                                  (void *)cmd_buf_p,
                                  qmi_nasi_global.cm_clnt_id,
                                  (sys_modem_as_id_e_type)client->report_status.bound_subs,
                                   req_msg->srvcc_status))
      {
        QM_MSG_HIGH("set_data_subs_priority() - cm_ph_cmd_set_data_priority_per_subs sent, awaiting response");
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( resp_msg != NULL )
    {
      memset(resp_msg, 0, sizeof(nas_set_srvcc_resp_msg_v01) );
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)cmd_buf_p->msg_id,
                                    (void *)resp_msg,
                                    (uint32_t)sizeof(nas_set_srvcc_resp_msg_v01),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}
#endif

#ifndef REMOVE_QMI_NAS_SET_BSR_TIMER_V01
/*===========================================================================
  FUNCTION QMI_NASI_SET_BSR_TIMER()

  DESCRIPTION
    This message sets the BSR value of the NV item NV_SD_CFG_ITEMS_I 

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_bsr_timer(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_e_type                       errval            = QMI_ERR_NONE;
  nas_set_bsr_timer_resp_msg_v01 *resp_msg;

  nas_set_bsr_timer_req_msg_v01  *req_msg;

  nv_stat_enum_type retval;
  nv_item_type data;
  
  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_bsr_timer_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_bsr_timer_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_set_bsr_timer_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_bsr_timer_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  if( errval == QMI_ERR_NONE)
  {
    memset(req_msg, 0, sizeof(nas_set_bsr_timer_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_bsr_timer_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL;
  }

  if( errval == QMI_ERR_NONE && req_msg->bsr_value > 600)
  {
    QM_MSG_ERROR_1("Invalid value for BSR timer set request - %d", req_msg->bsr_value);
    errval = QMI_ERR_INVALID_ARG;
  }
  
  if ( errval == QMI_ERR_NONE )
  {
      retval = qm_nv_get(NV_SD_CFG_ITEMS_I, &data, 0);
      
      if(retval != NV_DONE_S)
      {
        QM_MSG_ERROR_1("Failed to retreive current BSR timer value - %d", retval);
        errval = QMI_ERR_INTERNAL;
      }
  }
  
  if ( errval == QMI_ERR_NONE )
  {
      QM_MSG_HIGH_2("Setting BSR Timer value - Old %d New %d", data.sd_cfg_items.items[1], req_msg->bsr_value);
      
      data.sd_cfg_items.items[1] = req_msg->bsr_value;
      
      retval = qm_nv_put(NV_SD_CFG_ITEMS_I, &data, 0);
      
      if(retval != NV_DONE_S)
      {
        QM_MSG_ERROR_1("Failed to set BSR timer value - %d", retval);
        errval = QMI_ERR_INTERNAL;
      }
  }
  

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_bsr_timer_resp_msg_v01) );
    resp_msg->resp.error  = (qmi_error_type_v01)errval;
    if ( errval == QMI_ERR_NONE )
    {
      resp_msg->delayed_until_reset_valid = TRUE;
      resp_msg->delayed_until_reset = qm_nv_bsr_changed();
      resp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
    }
    else
    {
      resp_msg->delayed_until_reset_valid = FALSE;
      resp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    }
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)resp_msg,
                                  (uint32_t)sizeof(nas_set_bsr_timer_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_set_bsr_timer() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_BSR_TIMER()

  DESCRIPTION
    This message retreives the BSR value of the NV item NV_SD_CFG_ITEMS_I 

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_bsr_timer(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_e_type                       errval            = QMI_ERR_NONE;
  nas_get_bsr_timer_resp_msg_v01 *resp_msg;

  nas_get_bsr_timer_req_msg_v01  *req_msg;

  nv_stat_enum_type retval;
  nv_item_type data;
  
  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_get_bsr_timer_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_bsr_timer_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_get_bsr_timer_req_msg_v01  *) modem_mem_alloc( sizeof( nas_get_bsr_timer_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  if( errval == QMI_ERR_NONE)
  {
    memset(req_msg, 0, sizeof(nas_get_bsr_timer_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_get_bsr_timer_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL;
  }
  
  if ( errval == QMI_ERR_NONE )
  {
      retval = qm_nv_get(NV_SD_CFG_ITEMS_I, &data, 0);
      
      if(retval != NV_DONE_S)
      {
        QM_MSG_ERROR_1("Failed to retreive current BSR timer value - %d", retval);
        errval = QMI_ERR_INTERNAL;
      }
      else
      {
        QM_MSG_HIGH_1("Successfully retreived BSR Timer value - %d", data.sd_cfg_items.items[1]);
      }
  }
  
  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_get_bsr_timer_resp_msg_v01) );
    resp_msg->resp.error  = (qmi_error_type_v01)errval;
    if ( errval == QMI_ERR_NONE )
    {
      resp_msg->bsr_value_valid = TRUE;
      resp_msg->bsr_value = data.sd_cfg_items.items[1];
      resp_msg->delayed_until_reset_valid = TRUE;
      resp_msg->delayed_until_reset = qm_nv_bsr_changed();
      resp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
    }
    else
    {
      resp_msg->bsr_value_valid = FALSE;
      resp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    }
    
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)resp_msg,
                                  (uint32_t)sizeof(nas_get_bsr_timer_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_get_bsr_timer() */
#endif

#ifndef REMOVE_QMI_NAS_SET_MCC_V01
/*===========================================================================
  FUNCTION QMI_NASI_SET_MCC()

  DESCRIPTION
    This message communicates MCC, status and confidence
    values to PM to help speed up network scan times

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_mcc(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_set_mcc_resp_msg_v01 *resp_msg;

  nas_set_mcc_req_msg_v01  *req_msg;

 // policyman_status_t pm_response;
  boolean            ret_val;
  cm_set_location_info                 loc_info;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_mcc_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_mcc_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_set_mcc_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_mcc_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_set_mcc_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_mcc_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
      QM_MSG_HIGH_3("set_mcc() - MCC %d Confidence %d Status %d", req_msg->mcc, req_msg->confidence, req_msg->mcc_status);

      #if defined(FEATURE_CIOT)

      loc_info.asubs_id = SYS_MODEM_AS_ID_1;
      loc_info.mcc = (sys_mcc_type)req_msg->mcc;
      
      ret_val = cm_ph_cmd_set_location_info( qmi_nas_cmph_cmd_cb,
                                             (void *)cmd_buf_p,
                                             qmi_nasi_global.cm_clnt_id,
                                             &loc_info );

      QM_MSG_HIGH_1("set_mcc() - cm_ph_cmd_set_location_info() ret_val=%d", ret_val);

      if( ret_val == FALSE )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
      #else
      pm_response = policyman_set_hlos_mcc((sys_mcc_type)req_msg->mcc,
                                            (uint32_t)req_msg->confidence,
                                            (uint32_t)req_msg->mcc_status);


      if(pm_response == POLICYMAN_STATUS_SUCCESS)
      {
        QM_MSG_HIGH("set_mcc() - policyman_set_hlos_mcc() successful");
      }
      else
      {
        switch(pm_response)
        {
            case POLICYMAN_STATUS_ERR_NOT_READY: errval = QMI_ERR_DEVICE_NOT_READY_V01; break;             /**< policyman is not ready */
            case POLICYMAN_STATUS_ERR_INVALID_ARGS: errval = QMI_ERR_INVALID_ARG_V01; break;          /**< call was made with invalid arguments */
            case POLICYMAN_STATUS_ERR_MALFORMED_XML: errval = QMI_ERR_MALFORMED_MSG_V01; break;         /**< XML in config file for policy is not well-formed */
            default: errval = QMI_ERR_INTERNAL_V01; break;
        }
        QM_MSG_ERROR_1("set_mcc() - policyman_set_hlos_mcc() failed %d", pm_response);
      }
      #endif
  }

  #if defined(FEATURE_CIOT)
  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_mcc() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else
  #endif
  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_mcc_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *)resp_msg,
                                  (uint32_t)sizeof(nas_set_mcc_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_set_mcc() */
#endif

#ifndef REMOVE_QMI_NAS_AVOID_TUNEAWAY_V01
/*===========================================================================
  FUNCTION QMI_NASI_AVOID_TUNEAWAY_REQ()

  DESCRIPTION
    Request to block/unblock  tuneaway on other sub when AP IMS
    call ongoing

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_avoid_tuneaway_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_avoid_tuneaway_resp_msg_v01 *resp_msg;

  nas_avoid_tuneaway_req_msg_v01  *req_msg;

  qmi_nasi_client_state_type *    client;
  client = (qmi_nasi_client_state_type*)cl_sp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_avoid_tuneaway_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_avoid_tuneaway_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_avoid_tuneaway_req_msg_v01  *) modem_mem_alloc( sizeof( nas_avoid_tuneaway_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_avoid_tuneaway_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_avoid_tuneaway_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
      QM_MSG_HIGH_3("qmi_nasi_avoid_tuneaway_req() - client %p subs %d tuneaway %d", 
        client->clnt, client->report_status.bound_subs, req_msg->trm_priority);

      if(cm_ph_set_trm_priority(qmi_nas_cmph_cmd_cb,
                                (void *)cmd_buf_p,
                                qmi_nasi_global.cm_clnt_id,
                                (sys_modem_as_id_e_type)client->report_status.bound_subs,
                                req_msg->trm_priority))
      {
        QM_MSG_HIGH("qmi_nasi_avoid_tuneaway_req() - cm_ph_set_trm_priority sent, awaiting response");
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( resp_msg != NULL )
    {
      memset(resp_msg, 0, sizeof(nas_avoid_tuneaway_resp_msg_v01) );
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)cmd_buf_p->msg_id,
                                    (void *)resp_msg,
                                    (uint32_t)sizeof(nas_avoid_tuneaway_resp_msg_v01),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_avoid_tuneaway_req() */

/*===========================================================================
  FUNCTION QMI_NASI_AVOID_TUNEAWAY_RESP()

  DESCRIPTION
    Send response for AVOID_TUNEAWAY_REQ

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_avoid_tuneaway_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_avoid_tuneaway_resp_msg_v01 *resp_msg;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf )
  {
    QM_MSG_ERROR("Null cmd_buf ptr");
    return;
  }

  switch (err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

    case CM_PH_CMD_ERR_PLMN_P:
      errval = QMI_ERR_NO_NETWORK_FOUND_V01;
      break;

    case CM_PH_CMD_ERR_SYS_SEL_PREF_S:
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      break;

    case CM_PH_CMD_ERR_API_NOT_SUPPORTED_S:
    case CM_PH_CMD_ERR_PS_LOCAL_DETACH_NOT_ALLOWED_S:
    case CM_PH_CMD_ERR_FUNCTION_NOT_APPLICABLE:
      errval = QMI_ERR_INVALID_OPERATION_V01;
      break;

    default:
      errval = QMI_ERR_INTERNAL_V01;
      break;
  }

  resp_msg = (nas_avoid_tuneaway_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_avoid_tuneaway_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_avoid_tuneaway_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)p_cmd_buf->msg_id,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_avoid_tuneaway_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_MED("QMI_NAS_AVOID_TUNEAWAY_RESP send failed");
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nasi_avoid_tuneaway_resp() */
#endif
/*===========================================================================
  FUNCTION QMI_NASI_SET_DRX_SCALING_FACTOR ()

  DESCRIPTION
    Changes how often the device initiates a DRX cycle.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_drx_scaling_factor
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  
  lte_rrc_mtc_cfg_req_s msg;
  geran_grr_mtc_cfg_req_t msg_g;
  #if defined(FEATURE_WCDMA)
  wcdma_rrc_qmi_mtc_cfg_req_type msg_w;
  #endif
  errno_enum_type      msgr_err;
  
  nas_set_drx_scaling_factor_req_msg_v01  *req_msg;
  nas_set_drx_scaling_factor_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_set_drx_scaling_factor_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_drx_scaling_factor_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_drx_scaling_factor_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_drx_scaling_factor_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    qmi_voice_mem_error();
    return response;
  }
  else if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    qmi_voice_mem_error();
    return response;
  }
  
  memset(req_msg, 0, sizeof(nas_set_drx_scaling_factor_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_set_drx_scaling_factor_resp_msg_v01));

  if(qmi_efs_drx_scaling_enabled() == FALSE)
  {
    QM_MSG_ERROR("enable_drx_scaling_skip_meas efs check failed for QMI_NASI_SET_DRX_SCALING_FACTOR response");
    errval = QMI_ERR_INTERNAL;
  }
  
  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_drx_scaling_factor_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_DRX_SCALING_FACTOR request: %d", errval);
  }
  
  if(errval == QMI_ERR_NONE && (req_msg->radio_access_technology != NAS_RADIO_IF_LTE_V01 
                                && req_msg->radio_access_technology != NAS_RADIO_IF_GSM_V01
                                #if defined(FEATURE_WCDMA)
                                && req_msg->radio_access_technology != NAS_RADIO_IF_UMTS_V01
                                #endif
                                ))
  {
    errval = QMI_ERR_NOT_SUPPORTED;
  }

  if(errval == QMI_ERR_NONE && req_msg->drx_scaling_factor_valid == FALSE && req_msg->skip_idle_meas_valid == FALSE)
  {
    errval = QMI_ERR_MALFORMED_MSG;
  }
  
  if(errval == QMI_ERR_NONE && req_msg->drx_scaling_factor_valid == TRUE && (req_msg->drx_scaling_factor == 0 || req_msg->drx_scaling_factor > 10))
  {
    QM_MSG_ERROR_1("Invalid DRX scaling factor in QMI_NASI_SET_DRX_SCALING_FACTOR request: %d", req_msg->drx_scaling_factor);
    errval = QMI_ERR_MALFORMED_MSG;
  }
  
  if ( qmi_nasi_global.set_drx_scaling_cmd_buf_p != NULL )
  {
    errval = QMI_ERR_DEVICE_NOT_READY;
  }
  
  if(errval == QMI_ERR_NONE)
  {
    QM_MSG_HIGH_3("QMI_NASI_SET_DRX_SCALING_FACTOR request - scaling factor: %d skip_idle_meas_valid: %d, skip_idle_meas: %d", req_msg->drx_scaling_factor, req_msg->skip_idle_meas_valid, req_msg->skip_idle_meas);
    switch (req_msg->radio_access_technology)
    {
      case NAS_RADIO_IF_LTE_V01:
      {
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_MTC_CFG_REQ);
    if(req_msg->drx_scaling_factor_valid == TRUE)
    {
      msg.drx_scaling_factor_valid = TRUE;
      msg.drx_scaling_factor = (uint8_t)req_msg->drx_scaling_factor;
    }
    else
    {
      msg.drx_scaling_factor_valid = FALSE;
    }
    
    if(req_msg->skip_idle_meas_valid == TRUE)
    {
      msg.skip_idle_srch_meas_valid = TRUE;
      msg.skip_idle_srch_meas = req_msg->skip_idle_meas;
    }
    else
    {
      msg.skip_idle_srch_meas_valid = FALSE;
    }
       msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
       break;
      }
      case NAS_RADIO_IF_GSM_V01:
      {
       msgr_init_hdr( (msgr_hdr_struct_type*)&msg_g, MSGR_QMI_NAS, GERAN_GRR_MTC_CFG_REQ);
       if(req_msg->drx_scaling_factor_valid == TRUE)
       {
          msg_g.drx_scaling_factor_valid = TRUE;
          msg_g.drx_scaling_factor = (uint8_t)req_msg->drx_scaling_factor;
       }
       else
       {
         msg_g.drx_scaling_factor_valid = FALSE;
       }

       if(req_msg->skip_idle_meas_valid == TRUE)
       {
          msg_g.skip_idle_mode_meas_valid = TRUE;
          msg_g.skip_idle_mode_meas = req_msg->skip_idle_meas;
       }
       else
       {
          msg_g.skip_idle_mode_meas_valid = FALSE;
       }
       msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg_g, sizeof(msg_g) );
       break;
      }
#if defined(FEATURE_WCDMA)
case NAS_RADIO_IF_UMTS_V01:
     {
        msgr_init_hdr( (msgr_hdr_struct_type*)&msg_w, MSGR_QMI_NAS, WCDMA_RRC_QMI_MTC_CFG_REQ);
        if(req_msg->drx_scaling_factor_valid == TRUE)
        {
        msg_w.drx_scaling_factor_valid = TRUE;
        msg_w.drx_scaling_factor = (uint8_t)req_msg->drx_scaling_factor;
        }
        else
        {
        msg_w.drx_scaling_factor_valid = FALSE;
        }
        
        if(req_msg->skip_idle_meas_valid == TRUE)
        {
        msg_w.skip_idle_srch_meas_valid = TRUE;
        msg_w.skip_idle_srch_meas = req_msg->skip_idle_meas;
        }
        else
        {
        msg_w.skip_idle_srch_meas_valid = FALSE;
        }
        msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg_w, sizeof(msg_w) );
        break;
     }
#endif
     default:
     break;
    }    
    
    if ( msgr_err != E_SUCCESS )
    {
      QM_MSG_ERROR_1("QMI_NASI_SET_DRX_SCALING_FACTOR send fail %d", msgr_err);
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      qmi_nasi_global.set_drx_scaling_cmd_buf_p = cmd_buf_p;
    }
  }
  

  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_drx_scaling_factor_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
  
} /* qmi_nasi_set_drx_scaling_factor() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_DRX_SCALING_FACTOR ()

  DESCRIPTION
    Returns result of setting a new DRX scaling factor.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_set_drx_scaling_factor_rsp
(
 errno_enum_type status
)
{
  qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.set_drx_scaling_cmd_buf_p;
  dsm_item_type *  response = NULL;
  nas_set_drx_scaling_factor_resp_msg_v01 *rsp_msg;

  qmi_nasi_global.set_drx_scaling_cmd_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NASI_SET_DRX_SCALING_FACTOR resp");
    return;
  }
  
  rsp_msg = (nas_set_drx_scaling_factor_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_drx_scaling_factor_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
   qmi_voice_mem_error();
    return;
  }
  
  memset (rsp_msg, 0x00, sizeof(nas_set_drx_scaling_factor_resp_msg_v01));

  if(status == E_SUCCESS)
  {
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  }
  else
  {
    rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
  }
  
  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                            QMI_IDL_RESPONSE,
                                            (uint16_t) QMI_NAS_SET_DRX_SCALING_FACTOR_RESP_MSG_V01,
                                            (void *) rsp_msg,
                                            (uint32_t) sizeof( nas_set_drx_scaling_factor_resp_msg_v01 ),
                                            &response
                                           ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        /*Unable to send QMI_NASI_SET_DRX_SCALING_FACTOR response*/
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
  
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_generate_set_drx_scaling_factor_rsp() */

#ifndef REMOVE_QMI_NAS_GET_DATA_ROAMING_V01
/*===========================================================================
  FUNCTION QMI_NASI_SET_DATA_ROAMING_STATUS ()

  DESCRIPTION
    Sets the Data roaming status, which requires power cycle to take effect.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_data_roaming_status 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_set_data_roaming_req_msg_v01  * req_msg = NULL;
  nas_set_data_roaming_resp_msg_v01 * rsp_msg = NULL;

  enum qmi_nas_subs_e subs;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  subs = ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs;

  req_msg = (nas_set_data_roaming_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_data_roaming_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    qmi_voice_mem_error();
    return NULL;
  }

  if(qmi_nasi_global.data_roam_temp_valid)
  {
    QM_MSG_ERROR_2("QMI_NAS_SET_DATA_ROAMING response already pending - pending sub %d, curr sub %d", qmi_nasi_global.data_roam_temp_subs, subs);
    errval = QMI_ERR_DEVICE_IN_USE_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_data_roaming_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_SET_DATA_ROAMING_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_data_roaming_req_msg_v01)
                                         );
  }

  // check for error in REQ message
  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_009A_req_check( req_msg );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_2("calling cm_ph_cmd_data_roaming_per_subs() - roam %d subs %d", req_msg->data_roam_status, subs);
    if ( !cm_ph_cmd_data_roaming_per_subs( qmi_nas_cmph_cmd_cb, (void *)cmd_buf_p, qmi_nasi_global.cm_clnt_id, (sys_data_roaming_e_type)req_msg->data_roam_status, (sys_modem_as_id_e_type)subs ) )
    {
      errval = QMI_ERR_INTERNAL_V01;
    }
    else
    {
      qmi_nasi_global.data_roam_temp = (sys_data_roaming_e_type)req_msg->data_roam_status;
      qmi_nasi_global.data_roam_temp_subs = subs;
      qmi_nasi_global.data_roam_temp_valid = TRUE;
      response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    }
  }

  // take care of result if error
  if( cmd_buf_p != NULL && errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_set_data_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_data_roaming_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL)
    {
      qmi_voice_mem_error();
      if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
      return NULL;
    }
    else
    {
      memset( rsp_msg, 0x00, sizeof(nas_set_data_roaming_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
      rsp_msg->pending_device_reset_valid = FALSE;

      QM_MSG_HIGH_1("Set Data roaming status with error=%d", (uint16)errval);
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_SET_DATA_ROAMING_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_set_data_roaming_resp_msg_v01),
                                    &response
                                  );
    }
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_data_roaming_status */

/*===========================================================================
  FUNCTION QMI_NASI_SET_DATA_ROAMING_STATUS_RESP()

  DESCRIPTION
    Send response for SET_DATA_ROAMING

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_set_data_roaming_status_resp( qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_data_roaming_resp_msg_v01 *resp_msg;

  qmi_nasi_global.data_roam_temp_valid = FALSE;
  
  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf )
  {
    /*Null cmd_buf ptr*/
    return;
  }

  switch (err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

    case CM_PH_CMD_ERR_PLMN_P:
      errval = QMI_ERR_NO_NETWORK_FOUND_V01;
      break;

    case CM_PH_CMD_ERR_SYS_SEL_PREF_S:
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      break;

    case CM_PH_CMD_ERR_API_NOT_SUPPORTED_S:
    case CM_PH_CMD_ERR_PS_LOCAL_DETACH_NOT_ALLOWED_S:
    case CM_PH_CMD_ERR_FUNCTION_NOT_APPLICABLE:
      errval = QMI_ERR_INVALID_OPERATION_V01;
      break;

    default:
      errval = QMI_ERR_INTERNAL_V01;
      break;
  }
  
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_2("QMI_NASI_SET_DATA_ROAMING_STATUS_RESP successful - subs %d roam %d", qmi_nasi_global.data_roam_temp_subs, qmi_nasi_global.data_roam_temp);
    qmi_nasi_global.data_roam_cache_valid[qmi_nasi_global.data_roam_temp_subs] = TRUE;
    qmi_nasi_global.data_roam_cache[qmi_nasi_global.data_roam_temp_subs] = qmi_nasi_global.data_roam_temp;
  }

  resp_msg = (nas_set_data_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_data_roaming_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_data_roaming_resp_msg_v01) );

    resp_msg->resp.error  = errval;
    if(errval == QMI_ERR_NONE_V01)
    {
      resp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
      resp_msg->pending_device_reset_valid = TRUE;
      resp_msg->pending_device_reset = FALSE;
    }
    else
    {
      resp_msg->resp.result = QMI_RESULT_FAILURE_V01;
      resp_msg->pending_device_reset_valid = FALSE;
    }

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)p_cmd_buf->msg_id,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_data_roaming_resp_msg_v01),
                                           &response
                                         );
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_MED("QMI_NASI_SET_DATA_ROAMING_STATUS_RESP send failed");
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nasi_set_data_roaming_status_resp */
#endif
#ifndef REMOVE_QMI_NAS_GET_DATA_ROAMING_V01
/*===========================================================================
  FUNCTION QMI_NASI_GET_DATA_ROAMING_STATUS ()

  DESCRIPTION
    Sets the Data roaming status, which requires power cycle to take effect.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_data_roaming_status 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_get_data_roaming_req_msg_v01  * req_msg;
  nas_get_data_roaming_resp_msg_v01 * rsp_msg;
  
  enum qmi_nas_subs_e subs;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  
  subs = ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs;

  if ((subs <= QMI_NAS_SUBS_NONE) || (subs >= QMI_NAS_SUBS_MAX))
  {
    QM_MSG_ERROR_1("qmi_nasi_get_data_roaming_status: unsupported subs %d", subs);
    return NULL;
  }

  req_msg = (nas_get_data_roaming_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_data_roaming_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_data_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_data_roaming_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL || rsp_msg == NULL )
  {
    if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    return NULL;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_data_roaming_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_GET_DATA_ROAMING_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_data_roaming_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    if(!qmi_nasi_global.data_roam_cache_valid[subs])
    {
      errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
      QM_MSG_ERROR_1("data_roam_cache not initialized for subs %d", subs);
    }
  }

  // take care of result
  if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_data_roaming_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    if(rsp_msg->resp.error == QMI_ERR_NONE_V01)
    {
      rsp_msg->data_roam_status_valid = TRUE;
      rsp_msg->data_roam_status = (nas_data_roaming_enum_v01)qmi_nasi_global.data_roam_cache[subs];
      rsp_msg->pending_device_reset_valid = TRUE;
      rsp_msg->pending_device_reset = FALSE;
    }

    QM_MSG_HIGH_3("Get Data roaming status with error=%d, data roam status=%d subs=%d", (uint16)errval,(uint32)qmi_nasi_global.data_roam_cache[subs], subs);
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_GET_DATA_ROAMING_RESP_MSG_V01,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_data_roaming_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_data_roaming_status */
#endif
#ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_CSP_PLMN_MODE_BIT_RESP()

  DESCRIPTION
    Send response for QMI_NAS_GET_CSP_PLMN_MODE_BIT 

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

void qmi_nasi_generate_get_csp_plmn_mode_bit_resp( void )
{
  dsm_item_type *             response = NULL;
  boolean                     retval = FALSE;
  qmi_result_e_type           result;
  qmi_error_e_type            errval   = QMI_ERR_NONE;
  struct nas_003B_rsp_s msg;

  qmi_mmode_qcsi_transaction_type              *cmd_buf_p = qmi_nasi_global.mmgsdi->csp_req_buffer;
  qmi_nas_mmgsdi_session_e_type qmi_session = qmi_nasi_global.mmgsdi->csp_req_buffer_session;

  ASSERT(cmd_buf_p);
  if(qmi_session < QMI_NAS_MMGSDI_SESSION_MIN || qmi_session > QMI_NAS_MMGSDI_SESSION_MAX)
  {
    QM_MSG_ERROR_1("invalid qmi session %d", qmi_session);
    ASSERT(FALSE);
  }

  if ( cmd_buf_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in QMI_NAS_GET_CSP_PLMN_MODE_BIT resp: %d", cmd_buf_p);
    qmi_nasi_global.mmgsdi->csp_req_buffer_valid = FALSE;
    qmi_nasi_global.mmgsdi->csp_req_buffer = NULL;
    return; //nothing to send
  }

  memset (&msg, 0x00, sizeof(msg));

  if ( errval == QMI_ERR_NONE )
  {
    if(!qmi_nasi_get_csp_plmn_mode_val( qmi_session, &errval, &msg.t10.plmn_mode ))
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  // pack response message

  if ( errval == QMI_ERR_NONE )
  {
    msg.t10_valid = TRUE;
    if ( !qmi_svc_put_param_tlv( &response, NAS_003B_RSP_T10, sizeof(msg.t10.plmn_mode), &msg.t10.plmn_mode ) )
    {
      QM_MSG_ERROR("error while packaging response");
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);

  if ((errval != QMI_ERR_NONE) && (response != NULL))
  {
    dsm_free_packet(&response);
  }
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval) 
  { 
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response(cmd_buf_p, response);
    /*Send QMI_NAS_GET_CSP_PLMN_MODE_BIT resp result*/
  }

  //Free the cmd_buf_p stored
  qmi_nasi_global.mmgsdi->csp_req_buffer_valid = FALSE;
  qmi_nasi_global.mmgsdi->csp_req_buffer = NULL;
  
} /* qmi_nasi_generate_get_csp_plmn_mode_bit_resp */
#endif
#if !(defined(FEATURE_MMODE_QMI_LTE_ONLY) || defined(FEATURE_MMODE_QMI_GPRS_LTE))
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_MANUAL_SCAN_FAIL_IND()

  DESCRIPTION
    Generate a QMI_NAS_MANUAL_SCAN_FAIL_IND indication message
    
  PARAMETERS
    msg_p  Pointer to MSGR data for ssac params info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_manual_scan_fail_ind( sys_modem_as_id_e_type asid )
{
  qmi_nasi_client_state_type      *cl_sp;

  if(qm_efs_modem_centric_solution_disabled())
  {
    QM_MSG_HIGH( "Modem centric sol enabled: Sending QMI_NAS_MANUAL_SCAN_FAIL_IND");  
    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {

      if ( (cl_sp->report_status.report_manual_scan_fail) &&
             cl_sp->report_status.bound_subs == asid )
      {
        qmi_nasi_send_ind( cl_sp, QMI_NAS_MANUAL_SCAN_FAIL_IND_MSG_V01, NULL );
      }

      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
    }
  }
  /*Else, NV73671 (Disable Modem Centric solution) is disabled or missing*/
} /* qmi_nasi_generate_manual_scan_fail_ind() */
#endif
/*===========================================================================
  FUNCTION QMI_NASI_SET_CELL_LOCK_CONFIG ()

  DESCRIPTION
    Set the cell list to limit the service acquisition.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_cell_lock_config
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  nas_set_cell_lock_config_resp_msg_v01 *rsp_msg;
  nas_set_cell_lock_config_req_msg_v01 *req_msg;
  errno_enum_type      msgr_err = E_SUCCESS;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_set_cell_lock_config_req_msg_v01 *) modem_mem_alloc( sizeof(nas_set_cell_lock_config_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_cell_lock_config_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_cell_lock_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_GET_RPM_PARAMETERS request*/
    return response;
  }
  else if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    /*Not enough memory to allocate for QMI_NASI_GET_RPM_PARAMETERS response*/
    return response;
  }
  
  
    memset(req_msg, 0, sizeof(nas_set_cell_lock_config_req_msg_v01));
    memset(rsp_msg, 0, sizeof(nas_set_cell_lock_config_resp_msg_v01));
  

  if((errval == QMI_ERR_NONE) &&
     (qmi_nasi_global.set_cell_lock_config_req_buf_p != NULL ||
      qmi_nasi_global.set_cell_config_req_buf_p != NULL))
  {
    QM_MSG_ERROR("Already processing a QMI_NASI_SET_CELL_LOCK_CONFIG request");
    errval = QMI_ERR_DEVICE_NOT_READY;
  }

  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_cell_lock_config_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE)
    {
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_CELL_LOCK_CONFIG request: %d", errval);
    } 
    else if(req_msg->cell_list_len > LTE_RRC_MAX_NUM_CELL_LOCK)
    {
      QM_MSG_ERROR_2("More cell entries than expected, cell_list_len: %d, max: %d", req_msg->cell_list_len, LTE_RRC_MAX_NUM_CELL_LOCK);
      errval = QMI_ERR_ARG_TOO_LONG;
    }
  }


  if(errval == QMI_ERR_NONE)
  {
    lte_rrc_cell_lock_req_s msg;
    int cell_list_index = 0;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_CELL_LOCK_REQ );

    msg.num_cell_id = (uint8)req_msg->cell_list_len;
    for (cell_list_index = 0; cell_list_index < msg.num_cell_id; cell_list_index++)
    {
      msg.cell_id_list[cell_list_index].phy_cell_id = req_msg->cell_list[cell_list_index].pci;
      msg.cell_id_list[cell_list_index].freq        = req_msg->cell_list[cell_list_index].freq;
    }

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    QM_MSG_HIGH_1("SET_CELL_LOCK_CONFIG request msgr_err:%d ", msgr_err);
    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      qmi_nasi_global.set_cell_lock_config_req_buf_p = cmd_buf_p;
    }
  }
 
  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_cell_lock_config_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;  
} /* qmi_nasi_set_cell_lock_config() */


/*===========================================================================
  FUNCTION qmi_nasi_set_cell_lock_config_resp()

  DESCRIPTION
    Returns status of set cell lock config request.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_set_cell_lock_config_resp 
(
  lte_rrc_cell_lock_status_e status
)
{
  qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.set_cell_lock_config_req_buf_p;
  dsm_item_type *  response = NULL;
  nas_set_cell_lock_config_resp_msg_v01 *rsp_msg;

  qmi_nasi_global.set_cell_lock_config_req_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NASI_SET_CELL_LOCK_CONFIG_RESP ");
    return;
  }
  
  rsp_msg = (nas_set_cell_lock_config_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_cell_lock_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    return;
  }
  
  memset (rsp_msg, 0x00, sizeof(nas_set_cell_lock_config_resp_msg_v01));

  if( status == LTE_RRC_CELL_LOCK_STATUS_SUCCESS)
  {
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  }
  else
  {
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    switch(status)
    {
      case LTE_RRC_CELL_LOCK_STATUS_FAIL_LTE_ACTIVE:
        rsp_msg->resp.error  = QMI_ERR_INCOMPATIBLE_STATE_V01;
        break;
      case LTE_RRC_CELL_LOCK_STATUS_FAIL_OTHER:
      default:
        rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        break;
    }
  }

  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                            QMI_IDL_RESPONSE,
                                            (uint16_t) QMI_NAS_SET_CELL_LOCK_CONFIG_RESP_MSG_V01,
                                            (void *) rsp_msg,
                                            (uint32_t) sizeof( nas_set_cell_lock_config_resp_msg_v01 ),
                                            &response
                                           ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        QM_MSG_ERROR("Unable to send QMI_NAS_SET_CELL_LOCK_CONFIG_RESP");
        qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }
  
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_set_cell_lock_config_resp() */
/*===========================================================================
  FUNCTION QMI_NASI_SET_EDRX_PARAMS ()

  DESCRIPTION
    Sets the DRX.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_edrx_params 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
  qmi_nasi_client_state_type *nasi_client_sp;
  nas_set_edrx_params_req_msg_v01  * req_msg = NULL;
  nas_set_edrx_params_resp_msg_v01 * rsp_msg = NULL;
  sys_radio_access_tech_e_type       edrx_rat_type; 
  boolean     edrx_enabled;       /* Indicates EDRX is enabled or disabled*/
  uint8       edrx_ptw;            /* Paging Time window for EDRX*/
  uint8       edrx_cycle_length;   /* Cycle Length for EDRX*/
  uint16      change_mask_edrx = QMI_NAS_SYS_EDRX_CONFIG_INFO_MASK_NONE;          /*Mask to indicate which parameter for EDRX has change*/
  mm_cmd_set_edrx_cfg_req_s set_edrx_cfg_req;
  

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  nasi_client_sp = (qmi_nasi_client_state_type*)cl_sp;
  req_msg = (nas_set_edrx_params_req_msg_v01  *) modem_mem_alloc( sizeof(
nas_set_edrx_params_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_edrx_params_resp_msg_v01 *) modem_mem_alloc( sizeof(
nas_set_edrx_params_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  QM_MSG_MED(" Received SET EDRX PARAMS REQ");
  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  if ( (errval == QMI_ERR_NONE) && qmi_nasi_global.get_edrx_cmd_buf_p != NULL )
  {
    QM_MSG_ERROR("Cannot SET while GET is already in progress");
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_edrx_params_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_SET_EDRX_PARAMS_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_edrx_params_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {

    if(req_msg->edrx_rat_type_valid)
    {
      edrx_rat_type = qmi_nas_radio_if_2_sys_radio_access( req_msg->edrx_rat_type );
    }
    else
    {
      edrx_rat_type = SYS_RAT_LTE_RADIO_ACCESS;
    }  

     if (edrx_rat_type == SYS_RAT_LTE_RADIO_ACCESS)
     {
       if(!req_msg->edrx_ciot_lte_mode_valid)
       {
         errval= QMI_ERR_MALFORMED_MSG_V01;
       }
       else
       {
         edrx_rat_type = qmi_nas_radio_if_2_sys_radio_access_ciot(req_msg->edrx_rat_type,
                                                              req_msg->edrx_ciot_lte_mode);
       }
     }

     edrx_enabled      = (boolean)req_msg->edrx_enabled;
     edrx_ptw          = (uint8)req_msg->edrx_ptw;
     edrx_cycle_length = (uint8)req_msg->edrx_cycle_length;
     QM_MSG_MED_5("asubs_id = %d, rat = %d, edrx_enabled = %d, ptw =%d, cycle length = %d",
                  nasi_client_sp->report_status.bound_subs,edrx_rat_type, edrx_enabled,edrx_ptw , edrx_cycle_length);
     
     QM_MSG_MED_2("edrx_ciot_lte_mode_valid = %d, edrx_ciot_lte_mode = %d",
                  req_msg->edrx_ciot_lte_mode_valid, req_msg->edrx_ciot_lte_mode);

     if(req_msg->edrx_enabled_valid)
     {
       change_mask_edrx |= QMI_NAS_SYS_EDRX_CONFIG_INFO_MASK_EDRX_ENABLED;
     }

     /* Other params are valid only when edrx is enabled */
     if(req_msg->edrx_enabled)
     { 
       if (req_msg->edrx_ptw_valid && (edrx_rat_type == SYS_RAT_LTE_RADIO_ACCESS ||
                                       edrx_rat_type == SYS_RAT_LTE_M1_RADIO_ACCESS||
                                       edrx_rat_type == SYS_RAT_LTE_NB1_RADIO_ACCESS))
       {
         /*Paging Time Window for eDRX is valid only for LTE*/
         change_mask_edrx |= QMI_NAS_SYS_EDRX_CONFIG_INFO_MASK_PTW ;
       }

       if(req_msg->edrx_cycle_length_valid)
       { 
         change_mask_edrx |= QMI_NAS_SYS_EDRX_CONFIG_INFO_MASK_EDRX_CYCLE_LENGTH;
       }
     }

     if( ( edrx_rat_type == SYS_RAT_LTE_RADIO_ACCESS || edrx_rat_type == SYS_RAT_LTE_M1_RADIO_ACCESS || 
           edrx_rat_type == SYS_RAT_LTE_NB1_RADIO_ACCESS) && 
         (req_msg->edrx_ptw > NAS_LTE_MAX_VAL_EDRX_PTW || 
        req_msg->edrx_cycle_length > NAS_LTE_MAX_VAL_EDRX_CYCLE))
     {
       errval= QMI_ERR_ARG_TOO_LONG_V01;
     }
     else if(edrx_rat_type == SYS_RAT_GSM_RADIO_ACCESS && (req_msg->edrx_cycle_length > NAS_GSM_MAX_VAL_EDRX_CYCLE))
    {
       errval= QMI_ERR_ARG_TOO_LONG_V01;
     }     
    }

  if (errval == QMI_ERR_NONE_V01)
  {
     set_edrx_cfg_req.change_mask=change_mask_edrx;
     set_edrx_cfg_req.edrx_cycle_length=edrx_cycle_length;
     set_edrx_cfg_req.edrx_enabled=edrx_enabled;
     set_edrx_cfg_req.edrx_ptw=edrx_ptw;
     set_edrx_cfg_req.rat_type=edrx_rat_type;

 

     if(!nas_mm_cmd_set_edrx_req(&set_edrx_cfg_req))                                      
     {
       errval = QMI_ERR_INTERNAL_V01;
     }
  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_edrx_params() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
    qmi_nasi_global.set_edrx_req_buf_p = cmd_buf_p;

  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_set_edrx_params_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_SET_EDRX_PARAMS_RESP_MSG_V01,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_edrx_params_resp_msg_v01),
                                  &response);
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_edrx_params */
 /*===========================================================================
  FUNCTION QMI_NAS_SET_EDRX_PARAMS_RESP() 

  DESCRIPTION
    Send response for SET_EDRX_PARAMS
        
  PARAMETERS
    p_cmd_buf   : user data
    err         : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_edrx_params_resp()
{
  dsm_item_type *response = NULL;
  qmi_error_e_type          errval = QMI_ERR_NONE;
  qmi_result_e_type         result = QMI_RESULT_SUCCESS;
  boolean                   retval = FALSE;
  qmi_mmode_qcsi_transaction_type          *cmd_buf_p=qmi_nasi_global.set_edrx_req_buf_p;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  qmi_nasi_global.set_edrx_req_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NAS_SET_EDRX_PARAMS_RESP ");
    return;
  }

  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
   /*Unable to send qmi_nas_set_edrx_params_resp response*/
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
  }
}
 /*===========================================================================
  FUNCTION QMI_NASI_GET_EDRX_PARAMS ()

  DESCRIPTION
    Gets the EDRX Parameter values.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_edrx_params 
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
  qmi_nasi_client_state_type *nasi_client_sp;
  nas_get_edrx_params_req_msg_v01  * req_msg = NULL;
  cm_get_edrx_info_s_type      get_edrx_info;
  sys_radio_access_tech_e_type edrx_rat_type;
  mm_cmd_get_edrx_params_req_s  edrx_param_req_s;
    
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  nasi_client_sp = (qmi_nasi_client_state_type*)cl_sp;
  req_msg = (nas_get_edrx_params_req_msg_v01  *) modem_mem_alloc( sizeof(
               nas_get_edrx_params_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  
  if ( qmi_nasi_global.get_edrx_cmd_buf_p == NULL )
  {
    qmi_nasi_global.get_edrx_cmd_buf_p = cmd_buf_p;
  }
  else
  {
        QM_MSG_ERROR("Already processing a GET EDRX Params request");
        errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_edrx_params_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_GET_EDRX_PARAMS_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_edrx_params_req_msg_v01)
                                         );
  }
  
  if (errval == QMI_ERR_NONE_V01)
  {
    if(req_msg->edrx_rat_type_valid)
    {
      edrx_rat_type = qmi_nas_radio_if_2_sys_radio_access( req_msg->edrx_rat_type );
    }
    else
    {
      edrx_rat_type = SYS_RAT_LTE_RADIO_ACCESS;
    }

    if (edrx_rat_type == SYS_RAT_LTE_RADIO_ACCESS)
    {
      if(!req_msg->edrx_ciot_lte_mode_valid)
      {
        errval = QMI_ERR_MALFORMED_MSG_V01;
        QM_MSG_ERROR("ciot_lte_mode TLV is not present");
      }
      else
      {
        edrx_rat_type = qmi_nas_radio_if_2_sys_radio_access_ciot(req_msg->edrx_rat_type,
                                                             req_msg->edrx_ciot_lte_mode);
      }
    }
    edrx_param_req_s.rat_type=edrx_rat_type;

    if (errval == QMI_ERR_NONE_V01)
    {
      get_edrx_info.asubs_id      = (sys_modem_as_id_e_type)nasi_client_sp->report_status.bound_subs;
      get_edrx_info.rat_type_edrx = edrx_rat_type;    
      if(!nas_mm_cmd_get_edrx_req(&edrx_param_req_s))
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_edrx_params() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    nas_get_edrx_params_resp_msg_v01 * rsp_msg;
    rsp_msg = (nas_get_edrx_params_resp_msg_v01 *) modem_mem_alloc( 
    sizeof(nas_get_edrx_params_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL )
    {
      qmi_voice_mem_error();
    }
    else
    {
      memset( rsp_msg, 0x00, sizeof(nas_get_edrx_params_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_GET_EDRX_PARAMS_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_get_edrx_params_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    }

    qmi_nasi_global.get_edrx_cmd_buf_p = NULL;
  }

  if ( req_msg != NULL ) 
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  
  return response;
} /* qmi_nasi_get_edrx_params */

  /*===========================================================================
   FUNCTION QMI_NAS_GET_EDRX_PARAMS_RESP()
 
   DESCRIPTION
     Send response for GET_EDRX PARAMS
         
   PARAMETERS
     user_data   : user data
     ph_cmd_err  : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_get_edrx_params_resp( mm_cmd_get_edrx_params_rsp_s *p_info)
 {
   dsm_item_type *           response = NULL;
   qmi_error_type_v01        errval = QMI_ERR_NONE_V01;
   nas_get_edrx_params_resp_msg_v01 *rsp_msg = NULL;
   qmi_mmode_qcsi_transaction_type         *cmd_buf_p = qmi_nasi_global.get_edrx_cmd_buf_p;
   if ( cmd_buf_p == NULL )
   {
     QM_MSG_ERROR_1("Received NULL cmd_buf in GET_EDRX PARAMS resp: %d", cmd_buf_p);
     qmi_nasi_global.get_edrx_cmd_buf_p = NULL;
     return; //nothing to send
   }
 
   rsp_msg = (nas_get_edrx_params_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_edrx_params_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   if ( rsp_msg == NULL )
   {
     qmi_voice_mem_error();
     qmi_nasi_global.get_edrx_cmd_buf_p = NULL;
     return;
   }
 
   memset( rsp_msg, 0x00, sizeof(nas_get_edrx_params_resp_msg_v01) );
 
   if ( errval == QMI_ERR_NONE_V01 )
   {
     rsp_msg->edrx_enabled_valid = TRUE;
     rsp_msg->edrx_enabled = p_info->edrx_enabled;
     
     rsp_msg->edrx_ptw_valid = TRUE;
     rsp_msg->edrx_ptw = p_info->edrx_ptw;
     
     rsp_msg->edrx_cycle_length_valid = TRUE;
     rsp_msg->edrx_cycle_length = p_info->edrx_cycle_length;

     rsp_msg->edrx_rat_type_valid = TRUE;
     rsp_msg->edrx_rat_type = (nas_radio_if_enum_v01)qmi_nas_sys_radio_access_2_radio_if_ciot(p_info->rat_type,
                                 &rsp_msg->edrx_ciot_lte_mode);

     if (rsp_msg->edrx_rat_type == NAS_RADIO_IF_LTE_V01)
     {
       rsp_msg->edrx_ciot_lte_mode_valid = TRUE;
     }
     QM_MSG_HIGH_5("Sending  Resp for GET EDRX with , rat = %d, edrx_enabled %d, ptw = %d, Cycle Length = %d, edrx_ciot_lte_mode = %d",
                   p_info->rat_type, p_info->edrx_enabled, p_info->edrx_ptw, p_info->edrx_cycle_length,
                   rsp_msg->edrx_ciot_lte_mode);
   }
 
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
 
 
   if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                      QMI_IDL_RESPONSE,
                                      (uint16_t) QMI_NAS_GET_EDRX_PARAMS_RESP_MSG_V01,
                                      (void *) rsp_msg,
                                      (uint32_t) sizeof(nas_get_edrx_params_resp_msg_v01),
                                      &response
                                    ) )
   {
     qmi_nasi_send_response( cmd_buf_p, response);
   }
   else
   {
     dsm_free_packet(&response);
     qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
   }
 
   if( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
   qmi_nasi_global.get_edrx_cmd_buf_p = NULL;
} /* qmi_nas_get_edrx_params_resp() */

 /*===========================================================================
    FUNCTION qmi_nas_set_mcc_resp() 
  
    DESCRIPTION
      Send response for SET_MCC
          
    PARAMETERS
      p_cmd_buf   : user data
      err         : error type
      
    RETURN VALUE
      None
      
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/
  void qmi_nas_set_mcc_resp(qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err)
  {
    dsm_item_type *response = NULL;
    qmi_error_e_type          errval;
    qmi_result_e_type         result;
    boolean                   retval;
    qmi_mmode_qcsi_transaction_type          *cmd_buf_p;
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    errval = QMI_ERR_NONE;
    cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) p_cmd_buf;
  
    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
    {
      QM_MSG_HIGH("Received NULL cmd_buf in SET_MCC callback");
      return;
    }
  
    switch (ph_cmd_err)
    {
      case CM_PH_CMD_ERR_NOERR:
        errval = QMI_ERR_NONE;
        break;
  
      default:
        errval = QMI_ERR_INTERNAL;
        break;
    }
  
    result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS 
                                     : QMI_RESULT_FAILURE);
    retval = qmi_svc_put_result_tlv(&response, result, errval);
    if (FALSE == retval)
    {
      dsm_free_packet(&response);
    }
    else 
    {
      qmi_nasi_send_response( cmd_buf_p, response);
      /*Unable to send qmi_nas_set_drx_resp response*/
    }
  }
 /*=======================
 ====================================================
   FUNCTION QMI_NAS_EDRX_CHANGE_INFO_IND()
 
   DESCRIPTION
     generate QMI_NAS_EDRX_CHANGE_INFO_IND
 
   PARAMETERS
     pointer to new CM PH event
 ===========================================================================*/
  static void qmi_nasi_edrx_change_info_ind(qmi_cm_ph_info_s_type *p_info)
 {
   nas_edrx_change_info_ind_v01    *ind_msg;
   dsm_item_type                         *ind;
   qmi_nasi_client_state_type            *cl_sp;
 
   ind_msg = (nas_edrx_change_info_ind_v01 *) modem_mem_alloc( sizeof( nas_edrx_change_info_ind_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

   /*updating in global variable for sys_info_ind*/
   if(p_info->edrx_enabled)
   {
   qmi_nasi_global.cm_ph_info.edrx_enabled = TRUE;
   }
   if(ind_msg != NULL)
   {
     memset( ind_msg, 0x00, sizeof(nas_edrx_change_info_ind_v01) );
     cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
     while ( cl_sp != NULL )
     {
 
       if ( 
            #ifdef FEATURE_DUAL_SIM
            cl_sp->report_status.bound_subs == p_info->asubs_id &&
            #else
            cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY &&
            #endif
            cl_sp->report_status.report_edrx_change_info_ind ) 
       {
            ind_msg->edrx_enabled_valid = TRUE;
            ind_msg->edrx_enabled = p_info->edrx_enabled;
            
            ind_msg->edrx_ptw_valid = TRUE;
            ind_msg->edrx_ptw = p_info->edrx_ptw;
            
            ind_msg->edrx_cycle_length_valid = TRUE;
            ind_msg->edrx_cycle_length = p_info->edrx_cycle_length;

            ind_msg->edrx_rat_type_valid = TRUE;
            ind_msg->edrx_rat_type = (nas_radio_if_enum_v01)qmi_nas_sys_radio_access_2_radio_if_ciot(p_info->rat_type_edrx,
                                        &ind_msg->edrx_ciot_lte_mode);
            
            if (ind_msg->edrx_rat_type == NAS_RADIO_IF_LTE_V01)
            {
              ind_msg->edrx_ciot_lte_mode_valid = TRUE;
            }

            if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                              QMI_IDL_INDICATION,
                                              (uint16_t)QMI_NAS_EDRX_CHANGE_INFO_IND_V01,
                                              (void *) ind_msg,
                                              (uint32_t) sizeof( nas_edrx_change_info_ind_v01 ),
                                              &ind ) )
           {
             qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_EDRX_CHANGE_INFO_IND, ind );
           }
          /*else, Encoding has failed*/
       }

       cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
     }
   }
   else
   {
     qmi_voice_mem_error();
   }
 
   if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 }/*qmi_nasi_edrx_change_info_ind*/   

 /*===========================================================================
    FUNCTION qmi_nas_get_next_sfn_resp() 
  
    DESCRIPTION
      Get the SFN response from LTE and pass to clients
          
    PARAMETERS
      p_cmd_buf   : user data
      err         : error type
      
    RETURN VALUE
      None
      
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/
  void qmi_nas_get_next_sfn_resp(lte_cphy_get_next_sfn_rsp_s *p_info)
  {
    nas_get_next_sfn_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.get_next_sfn_buf_p;
    qmi_nasi_global.get_next_sfn_buf_p = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_GET_NEXT_SFN_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_get_next_sfn_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_next_sfn_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_get_next_sfn_resp");
      return;
    }
    
    memset ( rsp_msg, 0x00, sizeof(nas_get_next_sfn_resp_msg_v01) ); 
    rsp_msg->hsfn_sfn_nbr_valid = TRUE;
    rsp_msg->hsfn_sfn_nbr = p_info->hsfn_sfn_nbr;
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_GET_NEXT_SFN_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_get_next_sfn_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_GET_NEXT_SFN_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }

 /*===========================================================================
    FUNCTION qmi_nas_set_sfn_config_resp() 
  
    DESCRIPTION
      Get the response from LTE and pass to clients
          
    PARAMETERS
      p_cmd_buf   : user data
      err         : error type
      
    RETURN VALUE
      None
      
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/
  void qmi_nas_set_sfn_config_resp(lte_cphy_set_sfn_config_rsp_s *p_info)
  {
    nas_set_sfn_config_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.set_sfn_config_buf_p;
    qmi_nasi_global.set_sfn_config_buf_p = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_SET_SFN_CONFIG_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_set_sfn_config_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_sfn_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_set_sfn_config_resp");
      return;
    }

    memset ( rsp_msg, 0x00, sizeof(nas_set_sfn_config_resp_msg_v01) ); 
    if(p_info->req_accepted ==  TRUE)
    {
      rsp_msg->resp.error = QMI_ERR_NONE_V01;
    }
    else
    {
      rsp_msg->resp.error = QMI_ERR_ECONNREFUSED_V01;
    }
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_SET_SFN_CONFIG_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_set_sfn_config_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_SET_SFN_CONFIG_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }

   /*===========================================================================
    FUNCTION qmi_nas_sfn_threshold_reached_ind() 
  
    DESCRIPTION
      Get the indication from LTE when SFN is reached and pass to clients
          
    PARAMETERS
      p_cmd_buf   : user data
      err         : error type
      
    RETURN VALUE
      None
      
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/
  void qmi_nas_sfn_threshold_reached_ind(lte_cphy_sfn_threshold_reached_ind_s *p_info)
  {
 
   qmi_nasi_client_state_type            *cl_sp;
   nas_sfn_threshold_reached_ind_msg_v01    *ind_msg;
   dsm_item_type                         *indication;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   ind_msg = (nas_sfn_threshold_reached_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_sfn_threshold_reached_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

   QM_MSG_HIGH("qmi_nas_sfn_threshold_reached_ind() started");

   if ( ind_msg == NULL)
   {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_sfn_threshold_reached_ind");
      return;
   }

   memset ( ind_msg, 0x00, sizeof(nas_sfn_threshold_reached_ind_msg_v01) );

   ind_msg->hsfn_sfn_nbr = p_info->hsfn_sfn_nbr;
 
   cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
   while ( cl_sp != NULL )
   {
      if(cl_sp->report_status.reg_sfn_threshold_ind )
      {
   if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_SFN_THRESHOLD_REACHED_IND_MSG_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_sfn_threshold_reached_ind_msg_v01 ),
                                             &indication
                                            ) )
   {       
                   qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_SET_SFN_CONFIG_REQ, indication );
                 }  
   else
   {
       QM_MSG_HIGH("qmi_nas_sfn_threshold_reached_ind() idl_message_encode failed, no indication sent");
   }
       }
       cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
   }

   if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  }

  /*===========================================================================
     FUNCTION qmi_nas_set_true_srv_status() 
   
     DESCRIPTION
       Set True srv staus in qmi nas global based on raw_3gpp_status
           
     PARAMETERS
       p_cmd_buf   : user data
       err         : error type
       
     RETURN VALUE
       None
       
     DEPENDENCIES
       None
   
     SIDE EFFECTS
       None
   ===========================================================================*/
   
  void qmi_nas_set_true_srv_status(cm_3gpp_service_status_s_type *p_info )
   {
    QM_MSG_HIGH_2("qmi_nas_set_true_srv_status rat=%d, srv_status=%d",p_info->rat, p_info->srv_status);
    qmi_nasi_global.true_service_status.rat = p_info->rat;
    qmi_nasi_global.true_service_status.srv_domain = p_info->srv_domain;
    qmi_nasi_global.true_service_status.srv_status = p_info->srv_status;
    qmi_nasi_global.true_service_status.ciot_lte_mode = p_info->ciot_lte_mode;
   }
/*===========================================================================
   FUNCTION qmi_nas_send_jamming_status() 
 
   DESCRIPTION
     Set jamming status for the RAT and send notification
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_send_jamming_status(qmi_nas_jamming_status_msg_s_type *p_info)
 {
   qmi_nasi_client_state_type            *cl_sp;
   nas_jamming_status_ind_msg_v01    *ind_msg;
   dsm_item_type                         *indication = NULL;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   ind_msg = (nas_jamming_status_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_jamming_status_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

   if(ind_msg == NULL)
   {
     qmi_voice_mem_error();
     return;
   }
   memset ( ind_msg, 0x00, sizeof(nas_jamming_status_ind_msg_v01) );

   switch(p_info->rat)
   {
     case SYS_RAT_LTE_M1_RADIO_ACCESS:
     {
       qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_M1].jammer_status = p_info->jammer_status ;
       qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_M1].soft_jammer_flag = p_info->soft_jammer_flag ;
       ind_msg->radio_access_technology = NAS_RADIO_IF_LTE_V01;
       ind_msg->ciot_lte_op_mode_valid = TRUE;
       ind_msg->ciot_lte_op_mode = NAS_CIOT_SYS_MODE_LTE_M1_V01;
	     ind_msg->jammer_status_valid = TRUE;
       ind_msg->jammer_status = p_info->jammer_status;
       ind_msg->soft_jammer_flag_valid = TRUE;
       ind_msg->soft_jammer_flag = p_info->soft_jammer_flag;
       break;
	   } 
	   case SYS_RAT_LTE_NB1_RADIO_ACCESS:
	   {
	     qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_NB1].jammer_status = p_info->jammer_status ;
       qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_NB1].soft_jammer_flag = p_info->soft_jammer_flag ;
       ind_msg->radio_access_technology = NAS_RADIO_IF_LTE_V01;
       ind_msg->ciot_lte_op_mode_valid = TRUE;
       ind_msg->ciot_lte_op_mode = NAS_CIOT_SYS_MODE_LTE_NB1_V01;
	     ind_msg->jammer_status_valid = TRUE;
       ind_msg->jammer_status = p_info->jammer_status;
       ind_msg->soft_jammer_flag_valid = TRUE;
       ind_msg->soft_jammer_flag = p_info->soft_jammer_flag;
       break;
	   }
     case SYS_RAT_GSM_RADIO_ACCESS:
     {
	     qmi_nasi_global.jamming_status_info[IOT_RAT_GSM].jammer_status = p_info->jammer_status ;
       qmi_nasi_global.jamming_status_info[IOT_RAT_GSM].soft_jammer_flag = p_info->soft_jammer_flag ;
       ind_msg->radio_access_technology = NAS_RADIO_IF_GSM_V01;
       ind_msg->ciot_lte_op_mode_valid = FALSE;
       ind_msg->jammer_status_valid = TRUE;
       ind_msg->jammer_status = p_info->jammer_status;
       ind_msg->soft_jammer_flag_valid = FALSE;
       break;
	   }
     default:
     {
       QM_MSG_ERROR_1("Invalid radio_access_technology %d",p_info->rat);
     }
  }  
   
  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {
      if(cl_sp->report_status.reg_jamming_status_ind )
      {
        indication = NULL;
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                   QMI_IDL_INDICATION,
                                                   (uint16_t) QMI_NAS_JAMMING_STATUS_IND_MSG_V01,
                                                   (void *) ind_msg,
                                                   (uint32_t) sizeof( nas_jamming_status_ind_msg_v01 ),
                                                   &indication
                                                  ) )
        {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_GET_JAMMING_STATUS, indication );
        }
        else
        {
          QM_MSG_HIGH_1("qmi_nas_send_jamming_status() idl_message_encode failed, no indication sent %p.", cl_sp->clnt);
        }
      }
      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
   }
  
   if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 }

 /*===========================================================================
   FUNCTION qmi_nas_get_level_info_resp
 
   DESCRIPTION
     Send qmi_nas_ce_level resp
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_get_ce_level_info_resp(lte_cphy_ce_level_rpt_rsp_s *p_info)
 {
   nas_ce_level_info_resp_msg_v01         *rsp_msg;
   dsm_item_type                         *response;
   qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.get_ce_level_info_buf_p;
   qmi_nasi_global.get_ce_level_info_buf_p = NULL;

   if(p_info == NULL)
   {
     QM_MSG_ERROR("Can't find any inforation from LTE ");
     return;
   }
   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_GET_CE_LEVEL_INFO_REQ ");
     return;
   }
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  rsp_msg = (nas_ce_level_info_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_ce_level_info_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
   
   if ( rsp_msg == NULL)
   {
     QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_get_ce_level_info_resp");
     return;
   }
   
  memset ( rsp_msg, 0x00, sizeof(nas_ce_level_info_resp_msg_v01) );
  
  /* Process the response fro LTE only if the valid report from LTE is TRUE */ 
  if(p_info->valid_report == TRUE )
  {
    rsp_msg->resp.error = QMI_ERR_NONE_V01;
	rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
    rsp_msg->ce_level_valid = TRUE;
	rsp_msg->ce_level = (nas_ce_level_enum_v01)p_info->ce_level;
	
    switch(p_info->active_rat)
    {
      case SYS_SYS_MODE_LTE_M1:
     { 
       rsp_msg->active_rat_valid = TRUE;
       rsp_msg->ciot_lte_op_mode_valid = TRUE;
       rsp_msg->active_rat = NAS_RADIO_IF_LTE_V01;
	   rsp_msg->ciot_lte_op_mode = NAS_CIOT_SYS_MODE_LTE_M1_V01;
	   break;
	 } 

	 case SYS_SYS_MODE_LTE_NB1:
	 { 
	   rsp_msg->active_rat_valid = TRUE;
       rsp_msg->ciot_lte_op_mode_valid = TRUE;
	   rsp_msg->active_rat = NAS_RADIO_IF_LTE_V01;
	   rsp_msg->ciot_lte_op_mode = NAS_CIOT_SYS_MODE_LTE_NB1_V01;
       break;
	 }
	 
     default:
     { 
       rsp_msg->ce_level_valid = FALSE;
       rsp_msg->active_rat_valid = FALSE;
       rsp_msg->resp.error = QMI_ERR_INCOMPATIBLE_STATE_V01;
	   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
       QM_MSG_ERROR_1("Invalid radio_access_technology %d",p_info->active_rat);
     }
    }  
  }
  else
  {
    rsp_msg->resp.error = QMI_ERR_INTERNAL_V01;
	rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    rsp_msg->ce_level_valid = FALSE;
	 
  }
  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_RESPONSE,
                                             (uint16_t) QMI_NAS_GET_CE_LEVEL_INFO_RESP_MSG_V01,
                                             (void *) rsp_msg,
                                             (uint32_t) sizeof( nas_ce_level_info_resp_msg_v01 ),
                                             &response) )
  {
           
    if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
      QM_MSG_ERROR("Unable to send QMI_NAS_GET_CE_LEVEL_INFO_RESP");
      qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }

  }
  else
  {
     dsm_free_packet(&response);
     qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }   

  if ( rsp_msg != NULL ) 
  { 
    modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
  }

  /* Taking care of Dangling Pointer */
  rsp_msg = NULL;
  
 }
#ifdef FEATURE_FSK_TX
/*===========================================================================
   FUNCTION qmi_nas_fsk_data_resp() 
 
   DESCRIPTION
     Send qmi_nas_fsk_data_resp
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_fsk_data_resp(geran_fsk_data_rsp_type *p_info)
 {
    nas_fsk_data_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_data_buf_p;
    qmi_nasi_global.fsk_data_buf_p = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_FSK_DATA_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_fsk_data_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_fsk_data_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_fsk_data_resp");
      return;
    }
    QM_MSG_HIGH("qmi_nasi_fsk_data_resp processing started");

    memset ( rsp_msg, 0x00, sizeof(nas_fsk_data_resp_msg_v01) ); 
    if(p_info->status ==  TRUE)
    {
      rsp_msg->resp.error = QMI_ERR_NONE_V01;
    }
    else
    {
      rsp_msg->resp.error = QMI_ERR_DEVICE_NOT_READY_V01;
    }
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_FSK_DATA_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_fsk_data_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_FSK_DATA_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }
 
 /*===========================================================================
   FUNCTION qmi_nas_set_fsk_hop_table_resp() 
 
   DESCRIPTION
     Send qmi_nas_fsk_hop_table_resp
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_set_fsk_hop_table_resp(geran_fsk_hop_table_rsp_type *p_info)
 {
    nas_set_fsk_hop_table_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_set_hop_table_buf_p;
    qmi_nasi_global.fsk_set_hop_table_buf_p = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_SET_FSK_HOP_TABLE_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_set_fsk_hop_table_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_fsk_hop_table_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_set_fsk_hop_table_resp");
      return;
    }
    QM_MSG_HIGH("qmi_nasi_fsk_set_hop_table_resp processing started");

    memset ( rsp_msg, 0x00, sizeof(nas_set_fsk_hop_table_resp_msg_v01) ); 
    if(p_info->status ==  TRUE)
    {
      rsp_msg->resp.error = QMI_ERR_NONE_V01;
    }
    else
    {
      rsp_msg->resp.error = QMI_ERR_DEVICE_NOT_READY_V01;
    }
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_SET_FSK_HOP_TABLE_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_set_fsk_hop_table_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_SET_FSK_HOP_TABLE_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }

  /*===========================================================================
   FUNCTION qmi_nas_get_fsk_hop_table_resp() 
 
   DESCRIPTION
     Send qmi_nas_fsk_hop_table_resp
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_get_fsk_hop_table_resp(geran_fsk_hop_table_query_rsp_type *p_info)
 {
    nas_get_fsk_hop_table_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    uint8 i;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_get_hop_table_buf_p;
    qmi_nasi_global.fsk_get_hop_table_buf_p = NULL;


   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_GET_FSK_HOP_TABLE_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_get_fsk_hop_table_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_fsk_hop_table_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_get_fsk_hop_table_resp");
      return;
    }
    QM_MSG_HIGH("qmi_nasi_fsk_get_hop_table_resp processing started");

    memset ( rsp_msg, 0x00, sizeof(nas_get_fsk_hop_table_resp_msg_v01) ); 
    if(p_info->status)
    {  
       rsp_msg->fsk_hop_table_valid = TRUE;
       rsp_msg->resp.error = QMI_ERR_NONE_V01;
       rsp_msg->fsk_hop_table_len = FSK_MAX_FREQ_INDEX < NAS_FSK_MAX_HOP_TABLE_LENGTH_V01 ? FSK_MAX_FREQ_INDEX : NAS_FSK_MAX_HOP_TABLE_LENGTH_V01;
       for(i = 0; i < rsp_msg->fsk_hop_table_len; i++)
       {
         rsp_msg->fsk_hop_table[i].freq_len = p_info->hop_table[i].num_freq;
         rsp_msg->fsk_hop_table[i].delta = p_info->hop_table[i].delta;
         if(p_info->hop_table[i].num_freq > 0)
         {           
           memscpy( &rsp_msg->fsk_hop_table[i].freq, NAS_FSK_MAX_FREQS_V01 * sizeof(uint32), p_info->hop_table[i].freq, p_info->hop_table[i].num_freq * sizeof(uint32) );
         }         
       }
     }
    else
    {
      rsp_msg->resp.error = QMI_ERR_NOT_PROVISIONED_V01;
    }
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_GET_FSK_HOP_TABLE_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_get_fsk_hop_table_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_GET_FSK_HOP_TABLE_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }
 /*===========================================================================
   FUNCTION qmi_nas_fsk_start_resp() 
 
   DESCRIPTION
     Send qmi_nas_fsk_data_resp
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_fsk_start_resp(geran_fsk_start_rsp_type *p_info)
 {
    nas_fsk_start_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_start_buf_p;
    qmi_nasi_global.fsk_start_buf_p = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_FSK_START_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_fsk_start_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_fsk_start_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_fsk_start_resp");
      return;
    }
    QM_MSG_HIGH("qmi_nasi_fsk_start_resp processing started");

    memset ( rsp_msg, 0x00, sizeof(nas_fsk_start_resp_msg_v01) ); 
    if(p_info->status ==  TRUE)
    {
      rsp_msg->resp.error = QMI_ERR_NONE_V01;
    }
    else
    {
      rsp_msg->resp.error = QMI_ERR_DEVICE_NOT_READY_V01;
    }
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_FSK_START_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_fsk_start_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_FSK_START_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }
 /*===========================================================================
   FUNCTION qmi_nas_set_fsk_debug_resp() 
 
   DESCRIPTION
     Send qmi_nas_fsk_data_resp
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_set_fsk_debug_resp(geran_fsk_debug_rsp_type *p_info)
 {
    nas_set_fsk_debug_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_set_debug_buf_p;
    qmi_nasi_global.fsk_set_debug_buf_p = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_SET_FSK_DEBUG_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_set_fsk_debug_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_fsk_debug_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_set_fsk_debug_resp");
      return;
    }
    QM_MSG_HIGH("qmi_nasi_fsk_set_debug_resp processing started");

    memset ( rsp_msg, 0x00, sizeof(nas_set_fsk_debug_resp_msg_v01) ); 
    if(p_info->status ==  TRUE)
    {
      rsp_msg->resp.error = QMI_ERR_NONE_V01;
    }
    else
    {
      rsp_msg->resp.error = QMI_ERR_DEVICE_NOT_READY_V01;
    }
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_SET_FSK_DEBUG_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_set_fsk_debug_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_SET_FSK_DEBUG_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }
 /*===========================================================================
   FUNCTION qmi_nas_get_fsk_debug_resp() 
 
   DESCRIPTION
     Send qmi_nas_fsk_data_resp
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_get_fsk_debug_resp(geran_fsk_debug_query_rsp_type *p_info)
 {
    nas_get_fsk_debug_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_get_debug_buf_p;
    qmi_nasi_global.fsk_get_debug_buf_p = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_GET_FSK_DEBUG_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_get_fsk_debug_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_fsk_debug_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_get_fsk_debug_resp");
      return;
    }
    QM_MSG_HIGH("qmi_nasi_fsk_get_debug_resp processing started");

    memset ( rsp_msg, 0x00, sizeof(nas_get_fsk_debug_resp_msg_v01) );
    if(p_info->status)
    {
       rsp_msg->resp.error = QMI_ERR_NONE_V01;
       rsp_msg->baudrate_valid = TRUE;
       rsp_msg->baudrate = p_info->baudrate; 
       rsp_msg->delta_valid = TRUE;
       rsp_msg->delta = p_info->delta; 
       rsp_msg->freq_valid = TRUE;
       rsp_msg->freq = p_info->freq; 
    }
    else
    {
       rsp_msg->resp.error = QMI_ERR_NOT_PROVISIONED_V01;
    }
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_GET_FSK_DEBUG_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_get_fsk_debug_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_GET_FSK_DEBUG_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }
 /*===========================================================================
   FUNCTION qmi_nas_fsk_stop_resp() 
 
   DESCRIPTION
     Send qmi_nas_fsk_data_resp
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_fsk_stop_resp(geran_fsk_stop_rsp_type *p_info)
 {
    nas_fsk_stop_resp_msg_v01    *rsp_msg;
    dsm_item_type                         *response;
    qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_stop_buf_p;
    qmi_nasi_global.fsk_stop_buf_p = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_FSK_STOP_REQ ");
     return;
   }
    /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    rsp_msg = (nas_fsk_stop_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_fsk_stop_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   
    if ( rsp_msg == NULL)
    {
      QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_fsk_stop_resp");
      return;
    }
    QM_MSG_HIGH("qmi_nasi_fsk_stop_resp processing started");

    memset ( rsp_msg, 0x00, sizeof(nas_fsk_stop_resp_msg_v01) ); 
    if(p_info->status ==  TRUE)
    {
      rsp_msg->resp.error = QMI_ERR_NONE_V01;
    }
    else
    {
      rsp_msg->resp.error = QMI_ERR_DEVICE_NOT_READY_V01;
    }
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_RESPONSE,
                                                    (uint16_t) QMI_NAS_FSK_STOP_RESP_MSG_V01,
                                                    (void *) rsp_msg,
                                                    (uint32_t) sizeof( nas_fsk_stop_resp_msg_v01 ),
                                                    &response) )
    {
           
              if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
              {
                  QM_MSG_ERROR("Unable to send QMI_NAS_FSK_STOP_RESP");         
                  qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
              }
    }
    else
    {
              dsm_free_packet(&response);
              qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }   
    
 
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  }
 
 /*===========================================================================
    FUNCTION qmi_nas_set_fsk_pcl_resp() 
  
    DESCRIPTION
      Send qmi_nas_fsk_data_resp
          
    PARAMETERS
      p_cmd_buf   : user data
      err         : error type
      
    RETURN VALUE
      None
      
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/
  void qmi_nas_set_fsk_pcl_resp(geran_fsk_pcl_rsp_type *p_info)
  {
     nas_set_fsk_pcl_resp_msg_v01    *rsp_msg;
     dsm_item_type                         *response;
     qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_set_pcl_buf_p;
     qmi_nasi_global.fsk_set_pcl_buf_p = NULL;
 
    if(cmd_buf_p == NULL)
    {
      QM_MSG_ERROR("Cant find client for QMI_NASI_FSK_PCL_REQ ");
      return;
    }
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     rsp_msg = (nas_set_fsk_pcl_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_fsk_pcl_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    
     if ( rsp_msg == NULL)
     {
       QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_set_fsk_pcl_resp");
       return;
     }
     QM_MSG_HIGH("qmi_nasi_fsk_set_pcl_resp processing started");
     memset ( rsp_msg, 0x00, sizeof(nas_set_fsk_pcl_resp_msg_v01) ); 
     if(p_info->status ==  TRUE)
     {
       rsp_msg->resp.error = QMI_ERR_NONE_V01;
     }
     else
     {
       rsp_msg->resp.error = QMI_ERR_DEVICE_NOT_READY_V01;
     }
     if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                     QMI_IDL_RESPONSE,
                                                     (uint16_t) QMI_NAS_SET_FSK_PCL_RESP_MSG_V01,
                                                     (void *) rsp_msg,
                                                     (uint32_t) sizeof( nas_set_fsk_pcl_resp_msg_v01 ),
                                                     &response) )
     {
            
               if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
               {
                   QM_MSG_ERROR("Unable to send QMI_NAS_SET_FSK_PCL_RESP");         
                   qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
               }
     }
     else
     {
               dsm_free_packet(&response);
               qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
     }   
     
  
     if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
   }
  /*===========================================================================
    FUNCTION qmi_nas_get_fsk_pcl_resp() 
  
    DESCRIPTION
      Send qmi_nas_fsk_data_resp
          
    PARAMETERS
      p_cmd_buf   : user data
      err         : error type
      
    RETURN VALUE
      None
      
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/
  void qmi_nas_get_fsk_pcl_resp(geran_fsk_pcl_query_rsp_type *p_info)
  {
     nas_get_fsk_pcl_resp_msg_v01    *rsp_msg;
     dsm_item_type                         *response;
     qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.fsk_get_pcl_buf_p;
     qmi_nasi_global.fsk_get_pcl_buf_p = NULL;
 
    if(cmd_buf_p == NULL)
    {
      QM_MSG_ERROR("Cant find client for QMI_NASI_GET_FSK_PCL_REQ ");
      return;
    }
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     rsp_msg = (nas_get_fsk_pcl_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_fsk_pcl_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    
     if ( rsp_msg == NULL)
     {
       QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_get_fsk_pcl_resp");
       return;
     }
     QM_MSG_HIGH("qmi_nasi_fsk_get_pcl_resp processing started");
     memset ( rsp_msg, 0x00, sizeof(nas_get_fsk_pcl_resp_msg_v01) ); 

     if(p_info->status)
     {
       rsp_msg->resp.error = QMI_ERR_NONE_V01;
       rsp_msg->pcl_gsm_valid = TRUE;
       rsp_msg->pcl_gsm = p_info->pcl_gsm; 
       rsp_msg->pcl_dcs_valid = TRUE;
       rsp_msg->pcl_dcs = p_info->pcl_dcs; 
       rsp_msg->pcl_pcs_valid = TRUE;
       rsp_msg->pcl_pcs = p_info->pcl_pcs; 
     }
     else
     {
      rsp_msg->resp.error = QMI_ERR_NOT_PROVISIONED_V01;
     }
     if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                     QMI_IDL_RESPONSE,
                                                     (uint16_t) QMI_NAS_GET_FSK_PCL_RESP_MSG_V01,
                                                     (void *) rsp_msg,
                                                     (uint32_t) sizeof( nas_get_fsk_pcl_resp_msg_v01 ),
                                                     &response) )
     {
            
               if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
               {
                   QM_MSG_ERROR("Unable to send QMI_NAS_GET_FSK_PCL_RESP");         
                   qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
               }
     }
     else
     {
               dsm_free_packet(&response);
               qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
     }   
     
  
     if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
   }
#endif
 

 /*===========================================================================
    FUNCTION qmi_nas_get_cell_select_info_resp() 
  
    DESCRIPTION
      Send qmi_nas_get_cell_select_info_resp
          
    PARAMETERS
      p_cmd_buf   : user data
      err         : error type
      
    RETURN VALUE
      None
      
    DEPENDENCIES
      None
  
    SIDE EFFECTS
      None
  ===========================================================================*/

 void qmi_nas_get_cell_select_info_resp(qmi_nasi_cell_select_info_type *p_info)
  {
     nas_get_cell_select_info_resp_msg_v01    *rsp_msg;
     dsm_item_type                         *response;
     qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.get_cell_select_info_buf_p;
     qmi_nasi_global.get_cell_select_info_buf_p = NULL;
 
    if(cmd_buf_p == NULL)
    {
      QM_MSG_ERROR("Cant find client for QMI_NASI_GET_CELL_SELECT_INFO_REQ ");
      return;
    }
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     rsp_msg = (nas_get_cell_select_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_cell_select_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    
     if ( rsp_msg == NULL)
     {
       QM_MSG_ERROR("Not enough memory to allocate for qmi_nas_get_cell_select_info_resp");
       qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
       return;
     }
     QM_MSG_HIGH("qmi_nas_get_cell_select_info_resp processing started");
     memset ( rsp_msg, 0x00, sizeof(nas_get_cell_select_info_resp_msg_v01) ); 

     if(p_info->is_ue_camped)
     {
       rsp_msg->resp.error = QMI_ERR_NONE_V01;

       rsp_msg->radio_access_technology_valid = TRUE;
       
       rsp_msg->radio_access_technology = (nas_radio_if_enum_v01)qmi_nas_sys_mode_2_radio_if_ciot(p_info->rat,
                                       &rsp_msg->ciot_lte_op_mode);

       if (rsp_msg->radio_access_technology == NAS_RADIO_IF_LTE_V01)
       {
        rsp_msg->ciot_lte_op_mode_valid = TRUE;

		rsp_msg->q_rxlevmin_valid = TRUE ;
        rsp_msg->q_rxlevmin = p_info->qrxlevmin;			

		if(rsp_msg->ciot_lte_op_mode == NAS_CIOT_SYS_MODE_LTE_M1_V01)
        {
          rsp_msg->q_hyst_valid = TRUE;
          rsp_msg->q_hyst = p_info->q_hyst;
          rsp_msg->q_qualmin_valid = TRUE;
          rsp_msg->q_qualmin = p_info->q_qualmin;
          rsp_msg->qrxlevmin_ce_valid  = TRUE ;
          rsp_msg->qrxlevmin_ce = p_info->qrxlevmin_ce;
          rsp_msg->qrxlevmin_ce1_valid = TRUE ;
          rsp_msg->qrxlevmin_ce1 = p_info->qrxlevmin_ce1; 		
        } 
       }
       else if (rsp_msg->radio_access_technology == NAS_RADIO_IF_GSM_V01)
       {
        rsp_msg->rxlev_access_min_valid = TRUE;
        rsp_msg->rxlev_access_min = p_info->rxlev_access_min; 
       }
     }
     else
     {
      rsp_msg->resp.error = QMI_ERR_NO_NETWORK_FOUND_V01;
     }
     
     if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                     QMI_IDL_RESPONSE,
                                                     (uint16_t) QMI_NAS_GET_CELL_SELECT_INFO_RESP_MSG_V01,
                                                     (void *) rsp_msg,
                                                     (uint32_t) sizeof( nas_get_cell_select_info_resp_msg_v01 ),
                                                     &response) )
     {
            
               if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
               {
                   QM_MSG_ERROR("Unable to send QMI_NAS_GET_CELL_SELECT_INFO_RESP_MSG_V01");         
               }
     }
     else
     {
               dsm_free_packet(&response);
               qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
     }   
     
  
     if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); rsp_msg = NULL;}
   }



 #ifdef FEATURE_ENABLE_QMI_DMS
 /*===========================================================================
   FUNCTION QMI_NASI_SET_OPERATING_MODE()
 
   DESCRIPTION
     Message to set operating mode of modem
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in    : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static dsm_item_type* qmi_nasi_set_operating_mode
 (
   qmi_mmode_svc_info_type *sp,
   qmi_mmode_qcsi_transaction_type *cmd_buf_p,
   void * cl_sp,
   dsm_item_type ** sdu_in
 )
 {
   nas_set_operating_mode_req_msg_v01   *req_msg=NULL;
   nas_set_operating_mode_resp_msg_v01  *resp_msg=NULL;
   dsm_item_type       *response = NULL;
   qmi_error_type_v01     errval  = QMI_ERR_NONE_V01;
 
   if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
   {
     QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
     errval = QMI_ERR_INTERNAL_V01;
   }
   if ( errval == QMI_ERR_NONE_V01)
   {
     req_msg = (nas_set_operating_mode_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_operating_mode_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( req_msg == NULL )
     {
       QM_MSG_HIGH_1("Not enough memory to allocate for QMI_NAS_SET_OPRT_MODE request. %p ", req_msg);
       return response;
     }
   }
   if ( errval == QMI_ERR_NONE_V01)
   {
     memset ( req_msg, 0x00, sizeof(nas_set_operating_mode_req_msg_v01) );
     
     // extract information from REQ message
     errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                            (uint16_t)QMI_NAS_SET_OPERATING_MODE_REQ_MSG_V01,
                                            sdu_in,
                                            (void *) req_msg,
                                            (uint32_t) sizeof(nas_set_operating_mode_req_msg_v01)
                                          );
   }

   if ( errval == QMI_ERR_NONE_V01)
   {
     if(!req_msg->oprt_mode_valid)
     {
       errval = QMI_ERR_MISSING_ARG_V01;
     }
     else if( (req_msg->oprt_mode<NAS_OPRT_MODE_PWROFF_V01) || (req_msg->oprt_mode>NAS_OPRT_MODE_PSM_V01))
     {
       errval = QMI_ERR_INVALID_ARG_V01;
     }
   }

   if ( errval == QMI_ERR_NONE_V01)
   {
     if( !cm_ph_cmd_oprt_mode( qmi_nas_cmph_cmd_cb, cmd_buf_p, qmi_nasi_global.cm_clnt_id, (sys_oprt_mode_e_type)req_msg->oprt_mode) )
     {
       errval = QMI_ERR_INTERNAL_V01;
     }
   }
   // take care of result

   if (errval == QMI_ERR_NONE_V01)
   {
     QM_MSG_HIGH("qmi_nasi_set_operating_mode() returning QMI_SVC_RESPONSE_PENDING");
     response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
   }

   else if( cmd_buf_p != NULL )
   {
     resp_msg = (nas_set_operating_mode_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_operating_mode_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( resp_msg != NULL )
     {
       memset( resp_msg, 0x00, sizeof(nas_set_operating_mode_resp_msg_v01) );

       resp_msg->resp.error  = errval;
       resp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

       qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t)cmd_buf_p->msg_id,
                                     (void *) resp_msg,
                                     (uint32_t) sizeof(nas_set_operating_mode_resp_msg_v01),
                                     &response
                                   );
     }
     else
     {
       QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_SET_OPERATING_MODE resp. %p", resp_msg);
     }
   }
 
   if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
   if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
   return response;
 }

   /*===========================================================================
   FUNCTION QMI_NAS_SET_OPERATING_MODE_RESP() 
 
   DESCRIPTION
     Send response for SET_EDRX_PARAMS
         
   PARAMETERS
     p_cmd_buf     : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_set_operating_mode_resp(qmi_mmode_qcsi_transaction_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err)
 {
   dsm_item_type      *response = NULL;
   qmi_error_type_v01   errval = QMI_ERR_NONE_V01;
   qmi_result_e_type  result = QMI_RESULT_FAILURE;
   boolean            retval = FALSE;
   qmi_mmode_qcsi_transaction_type   *cmd_buf_p;
   nas_set_operating_mode_resp_msg_v01 *rsp_msg=NULL;
   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   cmd_buf_p = (qmi_mmode_qcsi_transaction_type *) p_cmd_buf;
 
   if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL )
   {
     QM_MSG_HIGH("Received NULL cmd_buf in SET_OPERATING_MODE callback");
     return;
   }
   QM_MSG_HIGH_1("Sending  Resp for SET OPRT MODE with ph_cmd_err %d", ph_cmd_err);
 
   switch (ph_cmd_err)
   {
     case CM_PH_CMD_ERR_NOERR:
       errval = QMI_ERR_NONE_V01;
       break;
 
     default:
       errval = QMI_ERR_INTERNAL_V01;
       break;
   }

 rsp_msg = (nas_set_operating_mode_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_operating_mode_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 
 if ( rsp_msg == NULL)
 {
   return;
 }
 
 memset (rsp_msg, 0x00, sizeof(nas_set_operating_mode_resp_msg_v01));
 
 rsp_msg->resp.error  = errval;
 rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

 if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t) QMI_NAS_SET_OPERATING_MODE_RESP_MSG_V01,
                                           (void *) rsp_msg,
                                           (uint32_t) sizeof( nas_set_operating_mode_resp_msg_v01 ),
                                           &response
                                          ) )
 {
   if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
   {
     QM_MSG_ERROR("Unable to send QMI_NAS_SET_OPERATING_MODE_RESP");
     qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
   }
 }
 else
 {
   dsm_free_packet(&response);
   qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
 }
 
 if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 }

  /*===========================================================================
   FUNCTION QMI_NASI_GET_OPERATING_MODE()
 
   DESCRIPTION
     Message to set operating mode of modem
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in    : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static dsm_item_type* qmi_nasi_get_operating_mode
 (
   qmi_mmode_svc_info_type *sp,
   qmi_mmode_qcsi_transaction_type *cmd_buf_p,
   void * cl_sp,
   dsm_item_type ** sdu_in
 )
 {
   nas_get_operating_mode_resp_msg_v01  *resp_msg=NULL;
   qmi_cm_ph_info_s_type      *p_ph_info = &qmi_nasi_global.cm_ph_info;
   dsm_item_type       *response = NULL;
   qmi_error_type_v01     errval  = QMI_ERR_NONE_V01;
 
   if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
   {
     QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
     errval = QMI_ERR_INTERNAL_V01;
   }
   
   // take care of result
   {
     resp_msg = (nas_get_operating_mode_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_operating_mode_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( resp_msg != NULL )
     {
       memset( resp_msg, 0x00, sizeof(nas_get_operating_mode_resp_msg_v01) );
       resp_msg->oprt_mode_valid = TRUE;
       resp_msg->oprt_mode       = (oprt_mode_e_type_v01)p_ph_info->oprt_mode;
       resp_msg->resp.error      = errval;
       resp_msg->resp.result     = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

       qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t)cmd_buf_p->msg_id,
                                     (void *) resp_msg,
                                     (uint32_t) sizeof(nas_get_operating_mode_resp_msg_v01),
                                     &response
                                   );
     }
     else
     {
       QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_GET_OPERATING_MODE resp. %p", resp_msg);
     }
   }
   if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
   return response;
 }

  /*===========================================================================
   FUNCTION QMI_NASI_GET_BAND_CAPABILITY()
 
   DESCRIPTION
     Message to set operating mode of modem
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in    : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static dsm_item_type* qmi_nasi_get_band_capability
 (
   qmi_mmode_svc_info_type *sp,
   qmi_mmode_qcsi_transaction_type *cmd_buf_p,
   void * cl_sp,
   dsm_item_type ** sdu_in
 )
 {
   nas_get_band_capability_resp_msg_v01  *resp_msg=NULL;
   qmi_cm_ph_info_s_type      *p_ph_info = &qmi_nasi_global.cm_ph_info;
   dsm_item_type       *response = NULL;
   qmi_error_type_v01     errval  = QMI_ERR_NONE_V01;
 
   if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
   {
     QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
     errval = QMI_ERR_INTERNAL_V01;
   }
   
   // take care of result
   {
     resp_msg = (nas_get_band_capability_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_band_capability_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( resp_msg != NULL )
     {
       memset( resp_msg, 0x00, sizeof(nas_get_band_capability_resp_msg_v01) );
       #ifndef FEATURE_MMODE_QMI_LTE_ONLY
       resp_msg->band_capability_valid = TRUE;
       memscpy(&resp_msg->band_capability, sizeof(uint64), &p_ph_info->band_capability, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
       #endif
       resp_msg->lte_band_capability_valid = TRUE;
       memscpy(&resp_msg->lte_band_capability, sizeof(sys_lte_band_mask_e_type), &p_ph_info->lte_band_capability, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV

       resp_msg->resp.error      = errval;
       resp_msg->resp.result     = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

       qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t)cmd_buf_p->msg_id,
                                     (void *) resp_msg,
                                     (uint32_t) sizeof(nas_get_band_capability_resp_msg_v01),
                                     &response
                                   );
     }
     else
     {
       QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_GET_BAND_CAP resp. %p", resp_msg);
     }
   }
   if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
   return response;
 }

 /*===========================================================================
   FUNCTION QMI_NASI_GET_PSM_CONFIG_PARAMS()
 
   DESCRIPTION
     Message to set the lte band priority list
     
   PARAMETERS
     sp            : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp          : client state pointer
     sdu_in       : incoming request
 
   RETURN VALUE
     ptr to response
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static dsm_item_type* qmi_nasi_get_psm_config_params
 ( 
   qmi_mmode_svc_info_type *sp,
   qmi_mmode_qcsi_transaction_type *cmd_buf_p,
   void *            cl_sp,
   dsm_item_type ** sdu_in
 )
 {
   dsm_item_type *       response = NULL;
   qmi_error_type_v01       errval    = QMI_ERR_NONE_V01;
   errno_enum_type           msgr_err = E_SUCCESS;
   uint8       b_cnt = 0;
   cm_psm_get_cfg_params_req_s_type msg;
   nas_get_psm_config_params_resp_msg_v01 *rsp_msg = NULL;
 
   if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
   {
     QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
     errval = QMI_ERR_INTERNAL_V01;
   }
   
   if ( (errval == QMI_ERR_NONE_V01) && qmi_nasi_global.get_psm_cfg_params!= NULL )
   {
     QM_MSG_ERROR("Already processing a QMI_NASI_GET_PSM_CONFIG request");
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }
 
   if( errval == QMI_ERR_NONE_V01 )
   {
     memset(&msg, 0x00, sizeof(cm_psm_get_cfg_params_req_s_type) );
 
     msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_CM_PSM_GET_CFG_PARAMS_REQ );
 
     msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
 
     if ( msgr_err != E_SUCCESS )
     {
       errval = QMI_ERR_INTERNAL_V01;
       QM_MSG_ERROR_1("GET PSM CFG PARAMS send fail %d", msgr_err);
     }
     else
     {
       qmi_nasi_global.get_psm_cfg_params = cmd_buf_p;
       response = QMI_SVC_RESPONSE_PENDING;
     }
   }
 
   if ( errval != QMI_ERR_NONE_V01 )
   {
     rsp_msg = (nas_get_psm_config_params_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_psm_config_params_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 
     if( rsp_msg != NULL )
     {
       memset(rsp_msg, 0x00, sizeof(nas_get_psm_config_params_resp_msg_v01) );
 
       rsp_msg->resp.error    = errval;
       rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
 
       qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     QMI_NAS_GET_PSM_CONFIG_PARAMS_RESP_MSG_V01,
                                     (void *)rsp_msg,
                                     (uint32_t)sizeof(nas_get_psm_config_params_resp_msg_v01),
                                     &response
                                   );
     }
     else
     {
       qmi_voice_mem_error();
     }
   }
 
   if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
 
   return response;
 }

 
 /*===========================================================================
   FUNCTION qmi_nasi_get_psm_config_params_resp()
 
   DESCRIPTION
     Returns status of set cell lock config request.
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in  : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static void qmi_nasi_get_psm_config_params_resp 
 (
   cm_psm_get_cfg_params_rsp_s_type psm_cfg_params_rsp
 )
 {
   dsm_item_type *response = NULL;
   nas_get_psm_config_params_resp_msg_v01 *rsp_msg;
   qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.get_psm_cfg_params;
   qmi_nasi_global.get_psm_cfg_params = NULL;

   if(cmd_buf_p == NULL)
   {
     QM_MSG_ERROR("Cant find client for QMI_NASI_GET_PSM_CONFIG_PARAMS_RESP ");
     return;
   }
   
   rsp_msg = (nas_get_psm_config_params_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_psm_config_params_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 
   if ( rsp_msg == NULL)
   {
     return;
   }
   
   memset (rsp_msg, 0x00, sizeof(nas_get_psm_config_params_resp_msg_v01));

   rsp_msg->resp.error  = QMI_ERR_NONE_V01;
   rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
   rsp_msg->psm_config_params_valid = TRUE;
   rsp_msg->psm_config_params.active_timer_value       = psm_cfg_params_rsp.active_timer_value;
   rsp_msg->psm_config_params.early_wakeup_time        = psm_cfg_params_rsp.early_wakeup_time;
   rsp_msg->psm_config_params.psm_enabled              = psm_cfg_params_rsp.enabled;
   rsp_msg->psm_config_params.gprs_ready_timer_value   = psm_cfg_params_rsp.gprs_ready_timer_value;
   rsp_msg->psm_config_params.periodic_rau_timer_value = psm_cfg_params_rsp.periodic_rau_timer_value;
   rsp_msg->psm_config_params.periodic_tau_timer_value = psm_cfg_params_rsp.periodic_tau_timer_value;
   rsp_msg->psm_config_params.psm_duration_due_to_oos  = psm_cfg_params_rsp.psm_duration_due_to_oos;
   rsp_msg->psm_config_params.psm_randomization_window = psm_cfg_params_rsp.psm_randomization_window;
   rsp_msg->psm_config_params.threshold                = psm_cfg_params_rsp.threshold;
   
   if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_RESPONSE,
                                             (uint16_t) QMI_NAS_GET_PSM_CONFIG_PARAMS_RESP_MSG_V01,
                                             (void *) rsp_msg,
                                             (uint32_t) sizeof( nas_get_psm_config_params_resp_msg_v01 ),
                                             &response
                                            ) )
   {
     if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
     {
       QM_MSG_ERROR("Unable to send QMI_NAS_GET_PSM_CONFIG_PARAMS_RESP");
       qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
     }
   }
   else
   {
     dsm_free_packet(&response);
     qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
   }
   
   if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
 } /* qmi_nasi_set_cell_lock_config_resp() */

 /*===========================================================================
   FUNCTION QMI_NASI_SET_PSM_CONFIG_PARAMS()
 
   DESCRIPTION
     Message to set configuration parameters of PSM MODE
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in    : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static dsm_item_type* qmi_nasi_set_psm_config_params
 (
   qmi_mmode_svc_info_type *sp,
   qmi_mmode_qcsi_transaction_type *cmd_buf_p,
   void * cl_sp,
   dsm_item_type ** sdu_in
 )
 {
   nas_set_psm_config_params_req_msg_v01   *req_msg=NULL;
   nas_set_psm_config_params_resp_msg_v01  *resp_msg=NULL;
   dsm_item_type       *response = NULL;
   qmi_error_type_v01     errval  = QMI_ERR_NONE_V01;
   cm_mm_psm_set_cfg_params_req_s_type msg;
   errno_enum_type           msgr_err = E_SUCCESS;

   if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
   {
     QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
     errval = QMI_ERR_INTERNAL_V01;
   }
   if ( errval == QMI_ERR_NONE_V01)
   {
     req_msg = (nas_set_psm_config_params_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_psm_config_params_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( req_msg == NULL )
     {
       return response;
     }
   }
   if ( errval == QMI_ERR_NONE_V01)
   {
     memset ( req_msg, 0x00, sizeof(nas_set_psm_config_params_req_msg_v01) );
     
     // extract information from REQ message
     errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                            (uint16_t)QMI_NAS_SET_PSM_CONFIG_PARAMS_REQ_MSG_V01,
                                            sdu_in,
                                            (void *) req_msg,
                                            (uint32_t) sizeof(nas_set_psm_config_params_req_msg_v01)
                                          );
   }

   if ( errval == QMI_ERR_NONE_V01)
   {
     if(!(req_msg->psm_enabled_valid ||
          req_msg->active_timer_value_valid ||
          req_msg->periodic_tau_timer_value_valid ||
          req_msg->periodic_rau_timer_value_valid ||
          req_msg->gprs_ready_timer_value_valid   ))
     {
       errval = QMI_ERR_MISSING_ARG_V01;
     }
   }

   if ( errval == QMI_ERR_NONE_V01)
   {
     memset(&msg, 0x00, sizeof(cm_mm_psm_set_cfg_params_req_s_type) );
 
     msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_CM_PSM_SET_CFG_PARAMS_REQ );

     msg.psm_enabled        = req_msg->psm_enabled;
     msg.active_timer_value = req_msg->active_timer_value;
     msg.periodic_tau_timer_value = req_msg->periodic_tau_timer_value;
     msg.periodic_rau_timer_value = req_msg->periodic_rau_timer_value;
     msg.gprs_ready_timer_value   = req_msg->gprs_ready_timer_value;

     msg.change_mask = CM_PSM_CONFIG_INFO_MASK_NONE;

     if(req_msg->psm_enabled_valid){msg.change_mask |= CM_PSM_CONFIG_INFO_MASK_PSM_ENABLED;}
     if(req_msg->active_timer_value_valid){msg.change_mask |= CM_PSM_CONFIG_INFO_MASK_ACTIVE_TIMER;}
     if(req_msg->periodic_tau_timer_value_valid){msg.change_mask |= CM_PSM_CONFIG_INFO_MASK_PERIODIC_UPDATE_TIMER;}
     if(req_msg->periodic_rau_timer_value_valid){msg.change_mask |= CM_PSM_CONFIG_INFO_MASK_PERIODIC_RAU_TIMER;}
     if(req_msg->gprs_ready_timer_value_valid){msg.change_mask |= CM_PSM_CONFIG_INFO_MASK_GPRS_READY_TIMER;}
 
     msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
 
     if ( msgr_err != E_SUCCESS )
     {
       errval = QMI_ERR_INTERNAL_V01;
       QM_MSG_ERROR_1("PSM CFG PARAMS send fail %d", msgr_err);
     }
   }
   // take care of result

   {
     resp_msg = (nas_set_psm_config_params_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_psm_config_params_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( resp_msg != NULL )
     {
       memset( resp_msg, 0x00, sizeof(nas_set_psm_config_params_resp_msg_v01) );

       resp_msg->resp.error  = errval;
       resp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

       qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t)cmd_buf_p->msg_id,
                                     (void *) resp_msg,
                                     (uint32_t) sizeof(nas_set_psm_config_params_resp_msg_v01),
                                     &response
                                   );
     }
     else
     {
       QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_SET_PSM_CFG resp. %p", resp_msg);
     }
   }
 
   if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
   if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
   return response;
 }

 
 /*===========================================================================
   FUNCTION qmi_nasi_psm_config_params_change_ind()
 
   DESCRIPTION
     Returns changes in config parameters of PSM MODE
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in  : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static void qmi_nasi_psm_config_params_change_ind 
 (
   cm_mm_psm_cfg_change_ind_s_type psm_cfg_params_change_ind
 )
 {
   dsm_item_type *indication = NULL;
   nas_psm_config_params_change_ind_msg_v01 *ind_msg;
   qmi_nasi_client_state_type *cl_sp;
   
   ind_msg = (nas_psm_config_params_change_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_psm_config_params_change_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 
   if ( ind_msg == NULL)
   {
     return;
   }
   
   memset (ind_msg, 0x00, sizeof(nas_psm_config_params_change_ind_msg_v01));

   ind_msg->active_rat_valid = TRUE;
   ind_msg->active_rat       = (nas_radio_if_enum_v01)qmi_nas_sys_radio_access_2_radio_if(psm_cfg_params_change_ind.active_rat);

   if(psm_cfg_params_change_ind.change_mask & CM_PSM_CONFIG_INFO_MASK_PSM_ENABLED)
   {
     ind_msg->psm_enabled_valid = TRUE;
     ind_msg->psm_enabled       = psm_cfg_params_change_ind.psm_enabled;
   }
   if(psm_cfg_params_change_ind.change_mask & CM_PSM_CONFIG_INFO_MASK_ACTIVE_TIMER)
   {
     ind_msg->active_timer_value_valid = TRUE;
     ind_msg->active_timer_value       = psm_cfg_params_change_ind.active_timer_value;
   }
   if(psm_cfg_params_change_ind.change_mask & CM_PSM_CONFIG_INFO_MASK_PERIODIC_UPDATE_TIMER)
   {
     ind_msg->periodic_update_timer_value_valid = TRUE;
     ind_msg->periodic_update_timer_value       = psm_cfg_params_change_ind.periodic_update_timer_value;
   }
   if(psm_cfg_params_change_ind.change_mask & CM_PSM_CONFIG_INFO_MASK_GPRS_READY_TIMER)
   {
     ind_msg->gprs_ready_timer_value_valid = TRUE;
     ind_msg->gprs_ready_timer_value       = psm_cfg_params_change_ind.gprs_ready_timer_value;
   }

   cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
   while ( cl_sp != NULL )
   {
        // Check to see if the client exists, AND it wants to receive updates, AND that
        // if it is a registration rejection event, that the client doesn't wish to suppress sys info notification
      if ( cl_sp->report_status.report_psm_config_params_change_ind)
      {
   if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_PSM_CONFIG_PARAMS_CHANGE_IND_MSG_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_psm_config_params_change_ind_msg_v01 ),
                                             &indication
                                            ) )
   {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_PSM_CONFIG_PARAMS_CHANGE_IND, indication );
        }
   else
   {
     QM_MSG_HIGH("qmi_nasi_psm_config_params_change_ind() idl_message_encode failed, no indication sent");
   }
       } 

        cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
   }
   
   if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
 } 

 
 /*===========================================================================
   FUNCTION qmi_nasi_psm_status_ind()
 
   DESCRIPTION
     Returns status of PSM MODE
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in  : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static void qmi_nasi_psm_status_ind 
 (
   cm_psm_status_ind_s_type   psm_status_ind
 )
 {
   dsm_item_type *indication = NULL;
   nas_psm_status_ind_msg_v01 *ind_msg;
   qmi_nasi_client_state_type *cl_sp;
   
   ind_msg = (nas_psm_status_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_psm_status_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 
   if ( ind_msg == NULL)
   {
     return;
   }
   
   memset (ind_msg, 0x00, sizeof(nas_psm_status_ind_msg_v01));

   ind_msg->status_valid = TRUE;
   ind_msg->status       = (nas_psm_status_type_v01)psm_status_ind.status;

   ind_msg->reject_reason_valid = TRUE;
   ind_msg->reject_reason       = (nas_psm_reject_reason_type_v01)psm_status_ind.reject_reason;

   ind_msg->periodic_update_timer_value_valid = TRUE;
   ind_msg->periodic_update_timer_value       = psm_status_ind.periodic_update_timer_value;

   cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
   while ( cl_sp != NULL )
   {
      // Check to see if the client exists, AND it wants to receive updates, AND that
      // if it is a registration rejection event, that the client doesn't wish to suppress sys info notification
      if ( cl_sp->report_status.report_psm_status_ind)
      {
   if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_PSM_STATUS_IND_MSG_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_psm_status_ind_msg_v01 ),
                                             &indication
                                            ) )
   {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_PSM_STATUS_IND, indication );
        }
   else
   {
     QM_MSG_HIGH("qmi_nasi_psm_status_ind() idl_message_encode failed, no indication sent");
        }    
      }
      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
   }
   
   if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
 } 

 /*===========================================================================
   FUNCTION QMI_NASI_PSM_ENTER()
 
   DESCRIPTION
     Message to enter PSM mode
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in    : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static dsm_item_type* qmi_nasi_psm_enter
 (
   qmi_mmode_svc_info_type *sp,
   qmi_mmode_qcsi_transaction_type *cmd_buf_p,
   void * cl_sp,
   dsm_item_type ** sdu_in
 )
 {
   nas_psm_enter_req_msg_v01   *req_msg=NULL;
   nas_psm_enter_resp_msg_v01  *resp_msg=NULL;
   dsm_item_type       *response = NULL;
   qmi_error_type_v01     errval  = QMI_ERR_NONE_V01;
   cm_psm_enter_req_s_type msg;
   errno_enum_type           msgr_err = E_SUCCESS;

   if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
   {
     QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
     errval = QMI_ERR_INTERNAL_V01;
   }
   if ( errval == QMI_ERR_NONE_V01)
   {
     req_msg = (nas_psm_enter_req_msg_v01  *) modem_mem_alloc( sizeof(nas_psm_enter_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( req_msg == NULL )
     {
       return response;
     }
   }
   if ( errval == QMI_ERR_NONE_V01)
   {
     memset ( req_msg, 0x00, sizeof(nas_psm_enter_req_msg_v01) );
     
     // extract information from REQ message
     errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                            (uint16_t)QMI_NAS_PSM_ENTER_REQ_MSG_V01,
                                            sdu_in,
                                            (void *) req_msg,
                                            (uint32_t) sizeof(nas_psm_enter_req_msg_v01)
                                          );
   }

   if ( errval == QMI_ERR_NONE_V01)
   {
     if(!req_msg->apps_time_valid)
     {
       errval = QMI_ERR_MISSING_ARG_V01;
     }
   }

   if ( errval == QMI_ERR_NONE_V01)
   {
     memset(&msg, 0x00, sizeof(cm_psm_enter_req_s_type) );
 
     msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_CM_PSM_ENTER_REQ );

     msg.apps_time = req_msg->apps_time;

     msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
 
     if ( msgr_err != E_SUCCESS )
     {
       errval = QMI_ERR_INTERNAL_V01;
       QM_MSG_ERROR_1("PSM ENTER send fail %d", msgr_err);
     }
   }
   // take care of result

   {
     resp_msg = (nas_psm_enter_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_psm_enter_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( resp_msg != NULL )
     {
       memset( resp_msg, 0x00, sizeof(nas_psm_enter_resp_msg_v01) );

       resp_msg->resp.error  = errval;
       resp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

       qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t)cmd_buf_p->msg_id,
                                     (void *) resp_msg,
                                     (uint32_t) sizeof(nas_psm_enter_resp_msg_v01),
                                     &response
                                   );
     }
   }
 
   if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
   if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
   return response;
 }
 
 /*===========================================================================
   FUNCTION qmi_nasi_operating_mode_ind()
 
   DESCRIPTION
     Returns operating mode of MODEM
 
   PARAMETERS
     sp        : service provided state pointer
     cmd_buf_p : ptr to cmd buffer
     cl_sp       : client state pointer
     sdu_in  : incoming request
 
   RETURN VALUE
     ptr to response
 
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static void qmi_nasi_operating_mode_ind 
 (
   sys_oprt_mode_e_type   oprt_mode
 )
 {
   dsm_item_type *indication = NULL;
   nas_operating_mode_ind_msg_v01 *ind_msg;
   qmi_nasi_client_state_type *cl_sp;
   
   ind_msg = (nas_operating_mode_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_operating_mode_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 
   if ( ind_msg == NULL)
   {
     return;
   }
   
   memset (ind_msg, 0x00, sizeof(nas_operating_mode_ind_msg_v01));

   ind_msg->oprt_mode_valid = TRUE;
   ind_msg->oprt_mode = (oprt_mode_e_type_v01)oprt_mode;

    cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
    while ( cl_sp != NULL )
    {
      // Check to see if the client exists, AND it wants to receive updates, AND that
      // if it is a registration rejection event, that the client doesn't wish to suppress sys info notification
      if ( cl_sp->report_status.report_operating_mode_ind)
      {
   if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_OPERATING_MODE_IND_MSG_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_operating_mode_ind_msg_v01 ),
                                             &indication
                                            ) )
   {
          qmi_nasi_send_ind( cl_sp, QMI_NAS_OPERATING_MODE_IND_MSG_V01, indication );
        }
   else
   {
     QM_MSG_HIGH("qmi_nasi_psm_status_ind() idl_message_encode failed, no indication sent");
   }
       }
       cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
   }
   
   if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
 
 } 
 #endif

 #ifndef FEATURE_MMODE_DISABLE_MISC_FEATURES
 /*===========================================================================
   FUNCTION QMI_NASI_SET_APP_PRIORITY()
 
   DESCRIPTION
	 Message to set the app priority
	 
   PARAMETERS
	 sp 		   : service provided state pointer
	 cmd_buf_p : ptr to cmd buffer
	 cl_sp		  : client state pointer
	 sdu_in 	  : incoming request
 
   RETURN VALUE
	 ptr to response
	 
   DEPENDENCIES
	 None
 
   SIDE EFFECTS
	 None
 ===========================================================================*/
 static dsm_item_type* qmi_nasi_set_app_priority
 ( 
   qmi_mmode_svc_info_type *sp,
   qmi_mmode_qcsi_transaction_type *cmd_buf_p,
   void *			cl_sp,
   dsm_item_type ** sdu_in
 )
 {
   dsm_item_type *			   response = NULL;
   qmi_error_type_v01		   errval	= QMI_ERR_NONE_V01;
   errno_enum_type			   msgr_err = E_SUCCESS;
   uint8					   b_cnt = 0;
 
   nas_set_app_priority_req_msg_v01  *req_msg = NULL;
   nas_set_app_priority_resp_msg_v01 *rsp_msg = NULL;
 
   if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
   {
     QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
     errval = QMI_ERR_INTERNAL_V01;
   }
 
   if ( errval == QMI_ERR_NONE_V01 )
   {
     req_msg = (nas_set_app_priority_req_msg_v01 *) modem_mem_alloc( sizeof(nas_set_app_priority_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 
     if( req_msg == NULL )
     {
       qmi_voice_mem_error();
       errval = QMI_ERR_NO_MEMORY_V01;
     }
   }
 
   if(errval == QMI_ERR_NONE_V01)
   {
	 memset(req_msg, 0x00, sizeof(nas_set_app_priority_req_msg_v01) );
 
	 
	 errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
											QMI_NAS_SET_APP_PRIORITY_REQ_MSG_V01,
											sdu_in,
											(void *)req_msg,
											(uint32_t)sizeof(nas_set_app_priority_req_msg_v01)
										  );
   }
   
   
   if (errval == QMI_ERR_NONE_V01)
   {
     if(!(req_msg->app_priority ==NAS_MARB_CLI_GROUP_GNSS_V01 ||
            req_msg->app_priority ==NAS_MARB_CLI_GROUP_WWAN_V01))
     {
       errval = QMI_ERR_INVALID_ARG_V01;
     }
   }
 
   if( errval == QMI_ERR_NONE_V01 )
   {
     QM_MSG_HIGH_1("APP PRIORITY = %d", req_msg->app_priority);
 
     if ( marb_update_app_priority(req_msg->app_priority) != MARB_RESULT_ACCEPT )
	 {
	   errval = QMI_ERR_INTERNAL_V01;
	 }
   }
   /*Construct rsp message*/
   {
	 rsp_msg = (nas_set_app_priority_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_app_priority_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 
	 if( rsp_msg != NULL )
	 {
	   memset(rsp_msg, 0x00, sizeof(nas_set_app_priority_resp_msg_v01) );
 
	   rsp_msg->resp.error	= errval;
	   rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
 
	   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
									 QMI_IDL_RESPONSE,
									 QMI_NAS_SET_APP_PRIORITY_RESP_MSG_V01,
									 (void *)rsp_msg,
									 (uint32_t)sizeof(nas_set_app_priority_resp_msg_v01),
									 &response
								   );
	 }
	 else
	 {
	   qmi_voice_mem_error();
	 }
   }
 
   if ( req_msg != NULL ) { modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
   if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
 
   return response;
 }
 #endif
/*===========================================================================
  FUNCTION QMI_NASI_SET_CELL_CONFIG ()

  DESCRIPTION
    Set the cell list to limit the service acquisition.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *qmi_nasi_set_cell_config
(
  void             *sp,
  qmi_mmode_qcsi_transaction_type  *cmd_buf_p,
  void             *cl_sp,
  dsm_item_type   **sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  nas_set_cell_config_resp_msg_v01 *rsp_msg = NULL;
  nas_set_cell_config_req_msg_v01 *req_msg = NULL;
  errno_enum_type      msgr_err = E_SUCCESS;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_set_cell_config_req_msg_v01 *) modem_mem_alloc(sizeof(nas_set_cell_config_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);
  rsp_msg = (nas_set_cell_config_resp_msg_v01 *) modem_mem_alloc(sizeof(nas_set_cell_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if( req_msg == NULL || rsp_msg == NULL)
  {
    QM_MSG_ERROR("Not enough memory to allocate ");
    errval = QMI_ERR_NO_MEMORY;
  }

  if((errval == QMI_ERR_NONE) &&
     (qmi_nasi_global.set_cell_config_req_buf_p != NULL ||
      qmi_nasi_global.set_cell_lock_config_req_buf_p != NULL))
  {
    QM_MSG_ERROR("Already processing a QMI_NASI_SET_CELL_CONFIG request");
    errval = QMI_ERR_DEVICE_NOT_READY;
  }

  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_cell_config_req_msg_v01)
                                         );

    if (errval != QMI_ERR_NONE)
    {
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_CELL_CONFIG request: %d", errval);
    }
    else if(req_msg->cell_list_len > LTE_RRC_MAX_NUM_CELL_LOCK)
    {
      QM_MSG_ERROR_2("More cell entries than expected, cell_list_len: %d, max: %d", req_msg->cell_list_len, LTE_RRC_MAX_NUM_CELL_LOCK);
      errval = QMI_ERR_ARG_TOO_LONG;
    }
  }

  if(errval == QMI_ERR_NONE)
  {
    lte_rrc_cell_lock_req_s msg;
    int cell_list_index = 0;

    msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, LTE_RRC_CELL_LOCK_REQ);

    msg.num_cell_id = (uint8)req_msg->cell_list_len;
    for (cell_list_index = 0; cell_list_index < msg.num_cell_id; cell_list_index++)
    {
      msg.cell_id_list[cell_list_index].phy_cell_id = req_msg->cell_list[cell_list_index].pci;
      msg.cell_id_list[cell_list_index].freq = req_msg->cell_list[cell_list_index].freq;
    }

    msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
    QM_MSG_HIGH_1("SET_CELL_CONFIG request msgr_err:%d ", msgr_err);

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      qmi_nasi_global.set_cell_config_req_buf_p = cmd_buf_p;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type *)QMI_SVC_RESPONSE_PENDING;
  }
  else if(rsp_msg)
  {
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_cell_config_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nasi_set_cell_config_resp()

  DESCRIPTION
    Returns status of set cell lock config request.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_set_cell_config_resp
(
  lte_rrc_cell_lock_status_e status
)
{
  qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.set_cell_config_req_buf_p;
  dsm_item_type   *response = NULL;
  nas_set_cell_config_resp_msg_v01 *rsp_msg;

  qmi_nasi_global.set_cell_config_req_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NASI_SET_CELL_CONFIG_RESP ");
    return;
  }

  rsp_msg = (nas_set_cell_config_resp_msg_v01 *) modem_mem_alloc(sizeof(nas_set_cell_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( rsp_msg == NULL)
  {
    QM_MSG_ERROR("Not enough memory to allocate for QMI_NASI_SET_CELL_CONFIG_RESP");
    return;
  }

  if( status == LTE_RRC_CELL_LOCK_STATUS_SUCCESS)
  {
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  }
  else
  {
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    switch(status)
    {
      case LTE_RRC_CELL_LOCK_STATUS_FAIL_LTE_ACTIVE:
        rsp_msg->resp.error  = QMI_ERR_INCOMPATIBLE_STATE_V01;
        break;
      case LTE_RRC_CELL_LOCK_STATUS_FAIL_OTHER:
      default:
        rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        break;
    }
  }

  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
      QMI_IDL_RESPONSE,
      (uint16_t) QMI_NAS_SET_CELL_CONFIG_RESP_MSG_V01,
      (void *) rsp_msg,
      (uint32_t) sizeof( nas_set_cell_config_resp_msg_v01 ),
      &response) )
  {
    if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
      QM_MSG_ERROR("Unable to send QMI_NAS_SET_CELL_CONFIG_RESP");
      qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

}

/*===========================================================================
  FUNCTION QMI_NASI_GET_RPM_PARAMETERS ()

  DESCRIPTION
    Retrieves Radio Policy Manager details if it is active

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *qmi_nasi_get_rpm_parameters
(
  qmi_mmode_svc_info_type             *sp,
  qmi_mmode_qcsi_transaction_type             *cmd_buf_p,
  void             *cl_sp,
  dsm_item_type   **sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_type_v01     errval = QMI_ERR_NONE_V01;
  cm_rpm_ret_e_type               rpm_rsp;
  
  cm_mm_lte_rpm_parameters_s_type lte_rpm_params;
  nas_get_rpm_parameters_req_msg_v01  *req_msg;
  nas_get_rpm_parameters_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_get_rpm_parameters_req_msg_v01 *) modem_mem_alloc( sizeof( nas_get_rpm_parameters_req_msg_v01 )
             , MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_GET_RPM_PARAMETERS request*/
    return response;
  }

  rsp_msg =  (nas_get_rpm_parameters_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_rpm_parameters_resp_msg_v01)
              , MODEM_MEM_CLIENT_QMI_MMODE );
  
  if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    /*Not enough memory to allocate for QMI_NASI_GET_RPM_PARAMETERS response*/
    return response;
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                          (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_get_rpm_parameters_req_msg_v01)
                                         );
    if (errval != QMI_ERR_NONE_V01)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_GET_RPM_PARAMETERS request: %d", errval);
  }

 

  if(errval == QMI_ERR_NONE_V01)
  {
     rpm_rsp = cmrpm_lte_send_get_rpm_parameters_rsp(&lte_rpm_params);

    if( rpm_rsp == CM_RPM_SUCCESS_RPM_ENABLED)
    {
    
      if (lte_rpm_params.max_event_counter < 1 || lte_rpm_params.max_event_counter > 16)
  	{
        QM_MSG_ERROR_1("received invalid max_event_counter value (must be a value between 1 and 16): %d", lte_rpm_params.max_event_counter);
  	  rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
  	}
      else if (lte_rpm_params.max_event_timer > 360)
  	{
        QM_MSG_ERROR_1("received invalid max_event_timer value (must be a value between 1 and 360 seconds): %d", lte_rpm_params.max_event_timer);
  	  rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
  	}
  	else
  	{
        rsp_msg->max_event_counter_valid= TRUE;
        rsp_msg->max_event_counter = lte_rpm_params.max_event_counter;
        rsp_msg->max_event_time_valid = TRUE;
        rsp_msg->max_event_time = lte_rpm_params.max_event_timer;
        rsp_msg->rpm_state_valid = TRUE;
        rsp_msg->rpm_state = TRUE;
        rsp_msg->resp.error  = QMI_ERR_NONE_V01;
        rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  	}
    } 
    else
    {
      QM_MSG_HIGH("radio policy manager not enabled");
      rsp_msg->rpm_state_valid = TRUE;
      rsp_msg->rpm_state = FALSE;
      rsp_msg->resp.error  = QMI_ERR_NONE_V01;
      rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
    }
  }
  else
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
  }

  

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)cmd_buf_p->msg_id,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_rpm_parameters_resp_msg_v01),
                                  &response
                                );
  
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
   }


/*===========================================================================
  FUNCTION QMI_NASI_SET_RPM_PARAMETERS_2 ()

  DESCRIPTION
    Changes Radio Policy Manager details if it is active

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type  *qmi_nasi_set_rpm_parameters_2
(
  qmi_mmode_svc_info_type                *sp,
  qmi_mmode_qcsi_transaction_type                *cmd_buf_p,
  void                *cl_sp,
  dsm_item_type       **sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_type_v01     errval = QMI_ERR_NONE_V01; 
  cm_mm_lte_rpm_parameters_s_type lte_rpm_params;
  cm_rpm_ret_e_type               rpm_rsp;
 
  
  nas_set_rpm_parameters_2_req_msg_v01  *req_msg;
  nas_set_rpm_parameters_2_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_set_rpm_parameters_2_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_rpm_parameters_2_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if ( req_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_PARAMETERS_2 request*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  rsp_msg = (nas_set_rpm_parameters_2_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_rpm_parameters_2_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  
   if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_PARAMETERS_2 response*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  
  memset(req_msg, 0, sizeof(nas_set_rpm_parameters_2_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_set_rpm_parameters_2_resp_msg_v01));
  
  if(errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_rpm_parameters_2_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE_V01)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_RPM_PARAMETERS_2 request: %d", errval);
  }
  
  if(errval == QMI_ERR_NONE_V01 && (req_msg->max_event_counter < 1 || req_msg->max_event_counter > 16))
  {
    QM_MSG_ERROR_1("max event counter must be a value between 1 and 16: %d", req_msg->max_event_counter);
    errval = QMI_ERR_INVALID_ARG_V01;
  }

  if(errval == QMI_ERR_NONE_V01 && (req_msg->max_event_time < 1 || req_msg->max_event_time > 360))
  {
    QM_MSG_ERROR_1("max event time must be a value between 0 and 360 seconds: %d", req_msg->max_event_time);
    errval = QMI_ERR_INVALID_ARG_V01;
  }
  
  
  
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_2("QMI_NASI_SET_RPM_PARAMETERS_2 request - max_event_counter: %d, max_event_time: %d", req_msg->max_event_counter, req_msg->max_event_time);

    lte_rpm_params.max_event_counter = req_msg->max_event_counter;
    lte_rpm_params.max_event_timer = req_msg->max_event_time;

    
    rpm_rsp = cmrpm_lte_set_rpm_parameters_req(lte_rpm_params);

    if(rpm_rsp == CM_RPM_SUCCESS_RPM_ENABLED)
    {
      rsp_msg->resp.error  = QMI_ERR_NONE_V01;
      rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
    }
    else
    {
      rsp_msg->resp.error  = QMI_ERR_INCOMPATIBLE_STATE_V01;
      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    }
  }
  else
  {
  
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
  }

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t)cmd_buf_p->msg_id,
                                (void *) rsp_msg,
                                (uint32_t) sizeof(nas_set_rpm_parameters_2_resp_msg_v01),
                                &response
                              );
    
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
  
} /* qmi_nasi_set_rpm_parameters_2() */


/*===========================================================================
  FUNCTION QMI_NASI_SET_RPM_STATE ()

  DESCRIPTION
    Enables or disables Radio Policy Manager

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_rpm_state
(
  qmi_mmode_svc_info_type              *sp,
  qmi_mmode_qcsi_transaction_type             *cmd_buf_p,
  void             *cl_sp,
  dsm_item_type     **sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_type_v01     errval = QMI_ERR_NONE_V01;
 
  
  nas_set_rpm_state_req_msg_v01  *req_msg;
  nas_set_rpm_state_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_set_rpm_state_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_rpm_state_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if ( req_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_STATE request*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  rsp_msg = (nas_set_rpm_state_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_rpm_state_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  
   if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_STATE response*/
    return response;
  }
  
  memset(req_msg, 0, sizeof(nas_set_rpm_state_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_set_rpm_state_resp_msg_v01));
  
  if(errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)cmd_buf_p->msg_id,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_rpm_state_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE_V01)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_RPM_STATE request: %d", errval);
  }
  
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_1("QMI_NASI_SET_RPM_STATE request - %d", req_msg->rpm_state);

    cmrpm_lte_set_rpm_config_req(req_msg->rpm_state);
  
  }
  
  
  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
							    QMI_IDL_RESPONSE,
							    (uint16_t)cmd_buf_p->msg_id,
							    (void *) rsp_msg,
							    (uint32_t) sizeof(nas_set_rpm_state_resp_msg_v01),
							    &response
							  );
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
  
} /* qmi_nasi_set_rpm_state() */

/*===========================================================================
  FUNCTION QMI_NASI_ABORT_SCAN()

  DESCRIPTION
    If any network scan(normal/incremental) is going on, this will tell the lower layers to abort it..

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_abort_scan
(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in)
{
  dsm_item_type             * response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  boolean                     retval   = TRUE;
  nas_abort_scan_resp_msg_v01 * rsp_msg = NULL;
  //int                         i;
  cm_mode_pref_e_type         mode_pref = CM_MODE_PREF_GWL;
  //sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  cm_network_list_type_e_type list_type = CM_NETWORK_LIST_AVAILABLE;
  cm_band_pref_e_type         band_pref     = CM_BAND_PREF_ANY,
                              lte_band_pref = CM_BAND_PREF_LTE_ANY,
                              tds_band_pref = CM_BAND_PREF_TDS_ANY;

  uint8                       filtered_network_type = 0;
  qmi_mmode_qcsi_transaction_type *  aborted_cmd_buf_p=NULL;
  dsm_item_type      *aborted_cmd_response = NULL;
  #ifdef FEATURE_DUAL_SIM
  enum qmi_nas_subs_e subs = QMI_NAS_SUBS_NONE;
  #endif
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  #ifdef FEATURE_DUAL_SIM
  subs = ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs;
  #endif
  
  QM_MSG_HIGH( " qmi_nasi_abort_scan");

  rsp_msg = (nas_abort_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_abort_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#endif
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    asubs_id = SYS_MODEM_AS_ID_3;
  }
#endif

  //Checking if any network scan is going on or not in the current sub.
  if ( qmi_nasi_global.net_scan_started )
  {
    #ifdef FEATURE_DUAL_SIM
    if ( asubs_id == qmi_nasi_global.net_scan_asubs_id )
    #endif
    {
      /* extract cmd_buf_p under queue function (mutexed) to ensure that
      CM task concurrent cm_network_scan_cb doesn't mess things up.
      -------------------------------------------------------------------------*/
      QM_MSG_HIGH_1("Before abort scan get : QM_CBPQ_QTYPE_NW_SCAN %d",qm_cbpq_count( QM_CBPQ_QTYPE_NW_SCAN ) );

      while( (aborted_cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
      {
        QM_MSG_HIGH_1("After abort scan : QM_CBPQ_QTYPE_NW_SCAN %d",qm_cbpq_count( QM_CBPQ_QTYPE_NW_SCAN ) );

        /*Send abort to pending NW Scans*/
        retval = qmi_svc_put_result_tlv(&aborted_cmd_response,
                                  QMI_RESULT_FAILURE,
                                  QMI_ERR_ABORTED);
        if(FALSE == retval)
        {
          dsm_free_packet(&aborted_cmd_response);
          qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &aborted_cmd_buf_p );
        }
        else
        {
          QM_MSG_HIGH("Send NW_SCAN aborted");
          qmi_nasi_send_response( aborted_cmd_buf_p, aborted_cmd_response);
        }
      }

      /*Terminate ongoing scan*/
      if(qm_cbpq_count( QM_CBPQ_QTYPE_NW_SCAN ) == 0)
      {
        /*-----------------------------------------------------------------------
        Issue terminate req to CM, Don't bother about success of terminate
        req irrespective send ABORT SUCCESS to client and ignore any
        network scan result that comes (AVALIABLE_CONF event)
        -----------------------------------------------------------------------*/
        #ifdef FEATURE_DUAL_SIM
        {
          QM_MSG_HIGH("send abort scan to CM" );
          (void) cm_ph_cmd_terminate_get_networks_per_subs(NULL,
									   NULL,
									   qmi_nasi_global.cm_clnt_id,
									   (sys_modem_as_id_e_type)subs  );
        }
        #else
        QM_MSG_HIGH("send abort scan to CM" );
        (void) cm_ph_cmd_terminate_get_networks(NULL,
									 NULL,
									 qmi_nasi_global.cm_clnt_id);
        #endif
        qmi_nasi_global.net_scan_started = FALSE;
      }
    }
    #ifdef FEATURE_DUAL_SIM
    else
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_HIGH_2("net scan ongoing on other subscription. Net scan on:%d Request received on: %d", qmi_nasi_global.net_scan_asubs_id, asubs_id);
    }
    #endif
  }
  else
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    QM_MSG_HIGH("No Network Scan is under progress");
  }


  if ( rsp_msg == NULL )
  {
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_STATE request*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_abort_scan_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

	QM_MSG_HIGH_1("Abort Scan returned with error = %d", (uint16)errval);
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_ABORT_SCAN_RESP_V01,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_abort_scan_resp_msg_v01),
                                  &response
                                );
  }

  QM_MSG_HIGH("Abort Scan is done. Encoding is done. Final mem clearing happening");
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_abort_scan() */

/*===========================================================================
  FUNCTION qmi_nasi_get_next_sfn_req()

  DESCRIPTION
  QMI API to request SFN value from LTE  

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_next_sfn_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_get_next_sfn_req_msg_v01  * req_msg;
  nas_get_next_sfn_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;

  if ( qmi_nasi_global.get_next_sfn_buf_p == NULL )
   {
     qmi_nasi_global.get_next_sfn_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }


  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_get_next_sfn_req processing started");
  
  req_msg = (nas_get_next_sfn_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_next_sfn_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_next_sfn_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_next_sfn_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH("Not enough memory to allocate for LTE_CPHY_GET_NEXT_SFN_REQ request.");
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH("Not enough memory to allocate for LTE_CPHY_GET_NEXT_SFN_REQ response.");
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_next_sfn_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_next_sfn_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if(req_msg->radio_access_technology != NAS_RADIO_IF_LTE_V01)
    {
       errval = QMI_ERR_OP_NETWORK_UNSUPPORTED_V01;
    }
    else if((qmi_nasi_global.true_service_status.srv_status != SYS_SRV_STATUS_SRV && 
           qmi_nasi_global.true_service_status.srv_status != SYS_SRV_STATUS_LIMITED &&
           qmi_nasi_global.true_service_status.srv_status != SYS_SRV_STATUS_LIMITED_REGIONAL) ||
          qmi_nasi_global.true_service_status.rat != SYS_SYS_MODE_LTE)
          {
            errval = QMI_ERR_OP_NETWORK_UNSUPPORTED_V01;
          }
 }  
  if (errval == QMI_ERR_NONE_V01)
  {
     lte_cphy_get_next_sfn_req_s msg;
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, LTE_CPHY_GET_NEXT_SFN_REQ);

     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("LTE_CPHY_GET_NEXT_SFN_REQ request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_next_sfn_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg)
  {
   memset( rsp_msg, 0x00, sizeof(nas_get_next_sfn_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_NEXT_SFN_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_next_sfn_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.get_next_sfn_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }

/*===========================================================================
  FUNCTION qmi_nasi_set_sfn_config_req()

  DESCRIPTION
  QMI API to send SFN config parameters to LTE 

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_sfn_config_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  dsm_item_type     *response = NULL;
  nas_set_sfn_config_req_msg_v01  * req_msg;
  nas_set_sfn_config_resp_msg_v01  * resp_msg;

  if ( qmi_nasi_global.set_sfn_config_buf_p == NULL )
  {
     qmi_nasi_global.set_sfn_config_buf_p = cmd_buf_p;
  }
  else
  {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_set_sfn_config_req processing started");
  
  req_msg = (nas_set_sfn_config_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_sfn_config_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  resp_msg = (nas_set_sfn_config_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_sfn_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH("Not enough memory to allocate for QMI_NAS_SET_SFN_CONFIG_REQ request");
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  
  if( resp_msg == NULL)
  {
   QM_MSG_HIGH("Not enough memory to allocate for QMI_NAS_SET_SFN_CONFIG_REQ response.");
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_sfn_config_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_sfn_config_req_msg_v01)
                                         );
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if(req_msg->radio_access_technology != NAS_RADIO_IF_LTE_V01)
    {
      errval = QMI_ERR_OP_NETWORK_UNSUPPORTED_V01;
    }
    else if((qmi_nasi_global.true_service_status.srv_status != SYS_SRV_STATUS_SRV && 
            qmi_nasi_global.true_service_status.srv_status != SYS_SRV_STATUS_LIMITED &&
            qmi_nasi_global.true_service_status.srv_status != SYS_SRV_STATUS_LIMITED_REGIONAL) ||
           qmi_nasi_global.true_service_status.rat != SYS_SYS_MODE_LTE)
           {
             errval = QMI_ERR_OP_NETWORK_UNSUPPORTED_V01;
           }
  }
  if (errval == QMI_ERR_NONE_V01)
  {
     lte_cphy_set_sfn_config_req_s msg;
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, LTE_CPHY_SET_SFN_CONFIG_REQ);

     msg.hsfn_sfn_nbr = req_msg->hsfn_sfn_nbr;
     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("LTE_CPHY_SET_SFN_CONFIG_REQ request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_sfn_config_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && resp_msg)
  {
    memset( resp_msg, 0x00, sizeof(nas_set_sfn_config_resp_msg_v01) );
  
   resp_msg->resp.error  = errval;
   resp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_SET_SFN_CONFIG_RESP_MSG_V01,
                                     (void *) resp_msg,
                                     (uint32_t) sizeof(nas_set_sfn_config_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.set_sfn_config_buf_p = NULL;
 }
 if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
 if ( resp_msg  != NULL ) { modem_mem_free( (void *) resp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

 return response;
}
  
/*===========================================================================
  FUNCTION QMI_NASI_GET_JAMMING_STATUS()

  DESCRIPTION
    	QMI will give the jamming status for requested RAT

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_jamming_status(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  dsm_item_type    *response = NULL;
  boolean           retval = FALSE;
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;

  nas_jamming_status_req_msg_v01  * req_msg;
  nas_jamming_status_resp_msg_v01 * rsp_msg;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_get_jamming_status processing started");
  
  req_msg = (nas_jamming_status_req_msg_v01  *) modem_mem_alloc( sizeof(nas_jamming_status_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_jamming_status_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_jamming_status_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
 

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH("Not enough memory to allocate for QMI_NAS_JAMMING_STATUS_REQ_MSG request.");
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  
  if ( rsp_msg == NULL )
  {
    QM_MSG_HIGH("Not enough memory to allocate for QMI_NAS_JAMMING_STATUS_REQ_MSG request");
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_jamming_status_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_jamming_status_req_msg_v01)
                                         );
  }
  

  if (errval == QMI_ERR_NONE_V01)
  { 
   memset( rsp_msg, 0x00, sizeof(nas_jamming_status_resp_msg_v01) );
   rsp_msg->radio_access_technology = req_msg->radio_access_technology;
   rsp_msg->jammer_status_valid = TRUE;
   switch (req_msg->radio_access_technology)
   {
     case NAS_RADIO_IF_LTE_V01:
      if(req_msg->ciot_lte_op_mode_valid)
       {
        rsp_msg->ciot_lte_op_mode_valid = TRUE;
        rsp_msg->ciot_lte_op_mode = req_msg->ciot_lte_op_mode;
        rsp_msg->soft_jammer_flag_valid = TRUE;
        if(req_msg->ciot_lte_op_mode == NAS_CIOT_SYS_MODE_LTE_M1_V01)
         { 
           rsp_msg->jammer_status = qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_M1].jammer_status;
           rsp_msg->soft_jammer_flag = qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_M1].soft_jammer_flag;
         }
        else if(req_msg->ciot_lte_op_mode == NAS_CIOT_SYS_MODE_LTE_NB1_V01)
          {
           rsp_msg->jammer_status = qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_NB1].jammer_status;
           rsp_msg->soft_jammer_flag = qmi_nasi_global.jamming_status_info[IOT_RAT_LTE_NB1].soft_jammer_flag;
          }
        else
          {
           QM_MSG_HIGH_1("Invalid CIOT LTE OP MODE = %d", req_msg->ciot_lte_op_mode);
           errval = QMI_ERR_INVALID_ARG_V01;
          }
       }
     else
       {  
          QM_MSG_HIGH("Missing CIOT LTE OP MODE");
          errval = QMI_ERR_MISSING_ARG_V01;
       }
     break;
     case NAS_RADIO_IF_GSM_V01: 
      rsp_msg->ciot_lte_op_mode_valid = FALSE;
      rsp_msg->soft_jammer_flag_valid = FALSE;
      rsp_msg->jammer_status = qmi_nasi_global.jamming_status_info[IOT_RAT_GSM].jammer_status;
      rsp_msg->soft_jammer_flag = FALSE;
      break;
     default:
      QM_MSG_HIGH_1("Invalid RAT = %d", req_msg->radio_access_technology);
      errval = QMI_ERR_INVALID_ARG_V01;
    }
   }
  
  if(cmd_buf_p != NULL && rsp_msg)
  {
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_JAMMING_STATUS_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_jamming_status_resp_msg_v01),
                                     &response
                                   );
  }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

#ifdef CM_DEBUG
#error code not present
#endif
#ifdef FEATURE_FSK_TX
/*===========================================================================
  FUNCTION qmi_nasi_fsk_data_req()

  DESCRIPTION
    	QMI will send fsk_data to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_fsk_data_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_fsk_data_req_msg_v01  * req_msg;
  nas_fsk_data_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;

  if ( qmi_nasi_global.fsk_data_buf_p == NULL )
   {
     qmi_nasi_global.fsk_data_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_fsk_data_req processing started");
  
  req_msg = (nas_fsk_data_req_msg_v01  *) modem_mem_alloc( sizeof(nas_fsk_data_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_fsk_data_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_fsk_data_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for FSK_DATA_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for FSK_DATA_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_fsk_data_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_fsk_data_req_msg_v01)
                                         );
  }
   
  if (errval == QMI_ERR_NONE_V01 && rsp_msg)
  {
   if(req_msg->data_len > 0 && req_msg->data_len <= 200)
   {
     geran_fsk_data_req_type msg;
     memset( &msg, 0x00, sizeof(geran_fsk_data_req_type) );
     
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_DATA_REQ );
     msg.bytestosend = (uint8)req_msg->data_len;
     memscpy( &msg.data, FSK_MAX_BYTES_TO_SEND * sizeof(uint8), &req_msg->data, req_msg->data_len * sizeof(uint8) );

     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("GERAN_GL1_FSK_DATA_REQ  request msgr_err:%d ", msgr_err);
  
    if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
   else
   {
     QM_MSG_HIGH_1("Data Length should be between 1 - 200 , data_len = : %d ", req_msg->data_len);
     errval = QMI_ERR_INVALID_ARG_V01;
   }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_fsk_data_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL)
  {
   memset( rsp_msg, 0x00, sizeof(nas_fsk_data_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_FSK_DATA_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_fsk_data_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_data_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }


/*===========================================================================
  FUNCTION qmi_nasi_set_fsk_hop_table_req()

  DESCRIPTION
    	QMI will send fsk_hop_table_req to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_fsk_hop_table_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_set_fsk_hop_table_req_msg_v01  * req_msg;
  nas_set_fsk_hop_table_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;
 
  if ( qmi_nasi_global.fsk_set_hop_table_buf_p == NULL )
   {
     qmi_nasi_global.fsk_set_hop_table_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_set_fsk_hop_table_req processing started");
  
  req_msg = (nas_set_fsk_hop_table_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_fsk_hop_table_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_fsk_hop_table_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_fsk_hop_table_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for SET_FSK_HOP_TABLE_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for SET_FSK_HOP_TABLE_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_fsk_hop_table_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_fsk_hop_table_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
     geran_fsk_hop_table_req_type msg;
     memset( &msg, 0x00, sizeof(geran_fsk_hop_table_req_type) );

     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_HOP_TABLE_REQ );
     msg.hop_table.index = req_msg->index;
     msg.hop_table.num_freq = (uint8)req_msg->fsk_hop_table.freq_len;
     msg.hop_table.delta = req_msg->fsk_hop_table.delta; 
     memscpy( &msg.hop_table.freq, FSK_MAX_FREQ_ARRAY_LENGTH_PER_INDEX * sizeof(uint32), req_msg->fsk_hop_table.freq, req_msg->fsk_hop_table.freq_len * sizeof(uint32) );

     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("GERAN_GL1_FSK_HOP_TABLE_REQ  request msgr_err:%d ", msgr_err);
  
     if ( msgr_err != E_SUCCESS )
     {
         errval = QMI_ERR_INTERNAL_V01;
     }
  }
  
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_fsk_hop_table_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL )
  {
   memset( rsp_msg, 0x00, sizeof(nas_set_fsk_hop_table_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_SET_FSK_HOP_TABLE_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_set_fsk_hop_table_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_set_hop_table_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }

/*===========================================================================
  FUNCTION qmi_nasi_get_fsk_hop_table_req()

  DESCRIPTION
    	QMI will send fsk_data to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_fsk_hop_table_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_get_fsk_hop_table_req_msg_v01  * req_msg;
  nas_get_fsk_hop_table_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;

  if ( qmi_nasi_global.fsk_get_hop_table_buf_p == NULL )
   {
     qmi_nasi_global.fsk_get_hop_table_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_get_fsk_hop_table_req processing started");
  
  req_msg = (nas_get_fsk_hop_table_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_fsk_hop_table_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_fsk_hop_table_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_fsk_hop_table_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for GET_FSK_HOP_TABLE_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for GET_FSK_HOP_TABLE_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_fsk_hop_table_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_fsk_hop_table_req_msg_v01)
                                         );
  }
   
  if (errval == QMI_ERR_NONE_V01)
  {
     geran_fsk_hop_table_query_req_type msg;
     memset( &msg, 0x00, sizeof(geran_fsk_hop_table_query_req_type) );
     
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_HOP_TABLE_QUERY_REQ );
     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("GERAN_GL1_FSK_HOP_TABLE_QUERY_REQ  request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_fsk_hop_table_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL )
  {
   memset( rsp_msg, 0x00, sizeof(nas_get_fsk_hop_table_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_FSK_HOP_TABLE_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_fsk_hop_table_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_get_hop_table_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }

/*===========================================================================
  FUNCTION qmi_nasi_fsk_start_req()

  DESCRIPTION
    	QMI will send fsk_data to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_fsk_start_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_fsk_start_req_msg_v01  * req_msg;
  nas_fsk_start_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;

  if ( qmi_nasi_global.fsk_start_buf_p == NULL )
   {
     qmi_nasi_global.fsk_start_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_fsk_start_req processing started");
  
  req_msg = (nas_fsk_start_req_msg_v01  *) modem_mem_alloc( sizeof(nas_fsk_start_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_fsk_start_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_fsk_start_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for FSK_START_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for FSK_START_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_fsk_start_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_fsk_start_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
     geran_fsk_start_req_type msg;
     memset( &msg, 0x00, sizeof(geran_fsk_start_req_type) );
     
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_START_REQ );
     if(req_msg->baudrate_valid)
     {
       msg.baudrate = req_msg->baudrate;
     }
     else
     {
       msg.baudrate = FSK_DEFAULT_FREQ_BAUDRATE;
     }
     if(req_msg->gaptime_valid)
     {
       msg.gaptime = req_msg->gaptime;
     }
     else
     {
       msg.gaptime = FSK_DEFAULT_FREQ_GAPTIME;
     }
     if(req_msg->restart_mode_valid)
     {
       msg.restart_mode = req_msg->restart_mode;
     }
     else
     {
       msg.restart_mode = FSK_DEFAULT_RESTART_MODE;
     }

     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("GERAN_GL1_FSK_START_REQ  request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_fsk_start_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL )
  {
   memset( rsp_msg, 0x00, sizeof(nas_fsk_start_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_FSK_START_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_fsk_start_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_start_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }

/*===========================================================================
  FUNCTION qmi_nasi_set_fsk_debug_req()

  DESCRIPTION
    	QMI will send fsk_data to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_fsk_debug_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_set_fsk_debug_req_msg_v01  * req_msg;
  nas_set_fsk_debug_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;

  if ( qmi_nasi_global.fsk_set_debug_buf_p == NULL )
   {
     qmi_nasi_global.fsk_set_debug_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_set_fsk_debug_req processing started");
  
  req_msg = (nas_set_fsk_debug_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_fsk_debug_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_fsk_debug_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_fsk_debug_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for SET_FSK_DEBUG_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for SET_FSK_DEBUG_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_fsk_debug_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_fsk_debug_req_msg_v01)
                                         );
  }
 
  if(req_msg != NULL && !req_msg->freq)
  {
    errval = QMI_ERR_MISSING_ARG_V01;
  }
  if (errval == QMI_ERR_NONE_V01)
  {
     geran_fsk_debug_req_type msg;
     memset ( &msg, 0x00, sizeof(geran_fsk_debug_req_type) ); 

     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_DEBUG_REQ );
     msg.freq =  req_msg->freq;
     if(req_msg->baudrate_valid)
     {
       msg.baudrate = req_msg->baudrate;
     }  
     else 
     {
       msg.baudrate = FSK_DEFAULT_FREQ_BAUDRATE;
     }
     if(req_msg->delta_valid)
     {
       msg.delta = req_msg->delta;
     }
     else
     {
       msg.delta = FSK_DEFAULT_FREQ_DELTA;
     }
     
     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("GERAN_GL1_FSK_DEBUG_REQ  request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_fsk_debug_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL)
  {
   memset( rsp_msg, 0x00, sizeof(nas_set_fsk_debug_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_SET_FSK_DEBUG_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_set_fsk_debug_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_set_debug_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }


/*===========================================================================
  FUNCTION qmi_nasi_get_fsk_debug_req()

  DESCRIPTION
    	QMI will send fsk_data to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_fsk_debug_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_get_fsk_debug_req_msg_v01  * req_msg;
  nas_get_fsk_debug_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;

  if ( qmi_nasi_global.fsk_get_debug_buf_p == NULL )
   {
     qmi_nasi_global.fsk_get_debug_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_get_fsk_debug_req processing started");
  
  req_msg = (nas_get_fsk_debug_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_fsk_debug_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_fsk_debug_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_fsk_debug_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for FSK_GET_DEBUG_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for FSK_GET_DEBUG_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_fsk_debug_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_fsk_debug_req_msg_v01)
                                         );
  }
   
  if (errval == QMI_ERR_NONE_V01)
  {
     geran_fsk_debug_query_req_type msg;
     memset ( &msg, 0x00, sizeof(geran_fsk_debug_query_req_type) );
     
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_DEBUG_QUERY_REQ );
          
     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("GERAN_GL1_FSK_DEBUG_QUERY_REQ  request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_fsk_debug_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL)
  {
   memset( rsp_msg, 0x00, sizeof(nas_get_fsk_debug_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_FSK_DEBUG_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_fsk_debug_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_get_debug_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }

/*===========================================================================
  FUNCTION qmi_nasi_fsk_stop_req()

  DESCRIPTION
    	QMI will send fsk_data to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_fsk_stop_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_fsk_stop_req_msg_v01  * req_msg;
  nas_fsk_stop_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;

  if ( qmi_nasi_global.fsk_stop_buf_p == NULL )
   {
     qmi_nasi_global.fsk_stop_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_fsk_stop_req processing started");
  
  req_msg = (nas_fsk_stop_req_msg_v01  *) modem_mem_alloc( sizeof(nas_fsk_stop_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_fsk_stop_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_fsk_stop_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for FSK_STOP_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for FSK_STOP_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_fsk_stop_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_fsk_stop_req_msg_v01)
                                         );
  }
   
  if (errval == QMI_ERR_NONE_V01)
  {
     geran_fsk_stop_req_type msg;
     memset ( &msg, 0x00, sizeof(geran_fsk_stop_req_type) );
     
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_STOP_REQ );
     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg)) ;
     QM_MSG_HIGH_1("GERAN_GL1_FSK_STOP_REQ  request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_fsk_stop_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL)
  {
   memset( rsp_msg, 0x00, sizeof(nas_fsk_stop_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_FSK_STOP_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_fsk_stop_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_stop_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }

/*===========================================================================
  FUNCTION qmi_nasi_set_fsk_pcl_req()

  DESCRIPTION
    	QMI will send fsk_data to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_fsk_pcl_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_set_fsk_pcl_req_msg_v01  * req_msg;
  nas_set_fsk_pcl_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;
  boolean send_req = FALSE;

  if ( qmi_nasi_global.fsk_set_pcl_buf_p == NULL )
   {
     qmi_nasi_global.fsk_set_pcl_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_set_fsk_pcl_req processing started");
  
  req_msg = (nas_set_fsk_pcl_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_fsk_pcl_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_fsk_pcl_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_fsk_pcl_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for SET_FSK_PCL_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for SET_FSK_PCL_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_fsk_pcl_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_fsk_pcl_req_msg_v01)
                                         );
  }

   if (errval == QMI_ERR_NONE_V01)
  {
     geran_fsk_pcl_req_type msg;
     memset ( &msg, 0x00, sizeof(geran_fsk_pcl_req_type) );
     
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_PCL_REQ );
     if(req_msg->pcl_gsm_valid)
     {
       msg.pcl_gsm = req_msg->pcl_gsm;
       send_req = TRUE;
     } 
     else
     {
       msg.pcl_gsm = FSK_DEFAULT_PCL;
     }
     if(req_msg->pcl_dcs_valid)
     {
       msg.pcl_dcs = req_msg->pcl_dcs;
       send_req = TRUE;
     }
     else
     {
       msg.pcl_dcs = FSK_DEFAULT_PCL;
     }
     if(req_msg->pcl_pcs_valid)
     {
      msg.pcl_pcs = req_msg->pcl_pcs;
      send_req = TRUE;
     }
     else
     {
       msg.pcl_pcs = FSK_DEFAULT_PCL;
     }

     if(send_req == TRUE)
     {
      msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
      QM_MSG_HIGH_1("GERAN_GL1_FSK_PCL_REQ  request msgr_err:%d ", msgr_err);
   
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
     }
     else
      {
      errval = QMI_ERR_MISSING_ARG_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_fsk_pcl_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL)
  {
   memset( rsp_msg, 0x00, sizeof(nas_set_fsk_pcl_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_SET_FSK_PCL_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_set_fsk_pcl_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_set_pcl_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
  }

/*===========================================================================
  FUNCTION qmi_nasi_get_fsk_pcl_req()

  DESCRIPTION
    	QMI will send fsk_data to GERAN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_fsk_pcl_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_get_fsk_pcl_req_msg_v01  * req_msg;
  nas_get_fsk_pcl_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;

  if ( qmi_nasi_global.fsk_get_pcl_buf_p == NULL )
   {
     qmi_nasi_global.fsk_get_pcl_buf_p = cmd_buf_p;
   }
   else
   {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
   }

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_get_fsk_pcl_req processing started");
  
  req_msg = (nas_get_fsk_pcl_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_fsk_pcl_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_fsk_pcl_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_fsk_pcl_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for GET_FSK_PCL_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for GET_FSK_PCL_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_fsk_pcl_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_fsk_pcl_req_msg_v01)
                                         );
  }
   
  if (errval == QMI_ERR_NONE_V01)
  {
     geran_fsk_pcl_query_req_type msg;
     memset ( &msg, 0x00, sizeof(geran_fsk_pcl_query_req_type) );
     
     msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, GERAN_GL1_FSK_PCL_QUERY_REQ );
          
     msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
     QM_MSG_HIGH_1("GERAN_GL1_FSK_PCL_QUERY_REQ  request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_fsk_pcl_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(cmd_buf_p != NULL && rsp_msg != NULL)
  {
   memset( rsp_msg, 0x00, sizeof(nas_get_fsk_pcl_resp_msg_v01) );
  
   rsp_msg->resp.error  = errval;
   rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
   qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_FSK_PCL_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_fsk_pcl_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.fsk_get_pcl_buf_p = NULL;
 }

  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}
#endif

/*===========================================================================
  FUNCTION QMI_NASI_GET_CE_LEVEL_INFO()

  DESCRIPTION
    	QMI will give the Converage Enhancement Level Information
    
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_ce_level_info_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_ce_level_info_req_msg_v01  * req_msg;
  nas_ce_level_info_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;
  
  if ( qmi_nasi_global.get_ce_level_info_buf_p == NULL )
  {
	   qmi_nasi_global.get_ce_level_info_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }


  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("nas_ce_level_info_req processing started");
  
  req_msg = (nas_ce_level_info_req_msg_v01  *) modem_mem_alloc( sizeof(nas_ce_level_info_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_ce_level_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_ce_level_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for get_ce_level_info request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for get_ce_level_info response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_ce_level_info_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_ce_level_info_req_msg_v01)
                                         );
  }
   
  if (errval == QMI_ERR_NONE_V01)
  {
    lte_cphy_ce_level_rpt_req_s msg;
    memset( &msg, 0x00, sizeof(lte_cphy_ce_level_rpt_req_s) );
     
    msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, LTE_CPHY_CE_LEVEL_REPORT_REQ );
    msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
    QM_MSG_HIGH_1("LTE_CPHY_CE_LEVEL_INFO_REQ  request msgr_err:%d ", msgr_err);
  
    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
    }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_ce_level_info_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
 else if(cmd_buf_p != NULL && rsp_msg != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_ce_level_info_resp_msg_v01) );
   
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_CE_LEVEL_INFO_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_ce_level_info_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.get_ce_level_info_buf_p = NULL;
 }

  if ( req_msg  != NULL ) 
  { 
    modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); 
  }
  if ( rsp_msg  != NULL ) 
  { 
    modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE );
  }

  /* Taking care of Dangling Pointers */
  req_msg = NULL;
  rsp_msg = NULL;


  return response;
  }

  /*===========================================================================
   FUNCTION qmi_nas_wwan_sleep_info_ind() 
 
   DESCRIPTION
     Get the sleep duration indication from the lower layer and passed to the APP
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 void qmi_nas_wwan_sleep_info_ind( uint32 sleep_duration )
 {
   qmi_nasi_client_state_type            *cl_sp;
   nas_wwan_sleep_info_ind_msg_v01       *ind_msg;
   dsm_item_type                         *indication = NULL;

   /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   ind_msg = (nas_wwan_sleep_info_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_wwan_sleep_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

   if(ind_msg == NULL)
   {
      QM_MSG_ERROR("Can not able to  allocate memory for wwan_sleep_indication");
      return;
   }
   memset ( ind_msg, 0x00, sizeof(nas_wwan_sleep_info_ind_msg_v01) );

   if(qmi_nasi_global.cm_ss_info->lte_rrc_tx_info.lte_tx_is_active == TRUE )
   {
      
      QM_MSG_HIGH("Discarding the sleep indication as AS is in connected mode");
	  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); ind_msg = NULL;}
      return;
   }

   if(qmi_nasi_global.wwan_sleep_theshold > sleep_duration )
   {

      QM_MSG_HIGH_2("Discarding the sleep indication as sleep duration from the lower layer = %d is smaller than threshold = %d",sleep_duration,qmi_nasi_global.wwan_sleep_theshold);
	  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); ind_msg = NULL;}
      return;
   }

   ind_msg->sleep_duration = sleep_duration;

  cl_sp = (qmi_nasi_client_state_type *)q_check(&(qmi_nas_state.client_q));
  while ( cl_sp != NULL )
  {
      if(cl_sp->report_status.reg_wwan_sleep_info_ind)
      {
        indication = NULL;
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                   QMI_IDL_INDICATION,
                                                   (uint16_t) QMI_NAS_WWAN_SLEEP_INFO_IND_MSG_V01,
                                                   (void *) ind_msg,
                                                   (uint32_t) sizeof( nas_wwan_sleep_info_ind_msg_v01 ),
                                                   &indication
                                                  ) )
        {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_WWAN_SLEEP_INFO_IND, indication );
        }
        else
        {
          QM_MSG_HIGH_1("qmi_nas_wwan_sleep_info_ind() idl_message_encode failed, no indication sent %p.", cl_sp->clnt);
        }
      }
      cl_sp = q_next(&(qmi_nas_state.client_q), &(cl_sp->link));
   }
  
   if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); ind_msg = NULL;}
 }

 /*===========================================================================
   FUNCTION qmi_nas_get_wwan_sleep_threshold() 
 
   DESCRIPTION
     Get the sleep threshold
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/
 static dsm_item_type * qmi_nasi_get_wwan_sleep_threshold(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                          errval                 = QMI_ERR_NONE_V01;
  nas_get_wwan_sleep_threshold_resp_msg_v01 * rsp_msg;
  nas_get_wwan_sleep_threshold_req_msg_v01  * req_msg;
  dsm_item_type                             * response = NULL;
  boolean                                     retval;


  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_get_wwan_sleep_duration_req processing started");
  
  req_msg = (nas_get_wwan_sleep_threshold_req_msg_v01 *) modem_mem_alloc( sizeof(nas_get_wwan_sleep_threshold_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_wwan_sleep_threshold_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_wwan_sleep_threshold_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   


  if( req_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for WWAN_SLEEP_DURATION_THRESHOLD_REQ request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  
  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for WWAN_SLEEP_DURATION_THRESHOLD_RESP response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_wwan_sleep_threshold_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_wwan_sleep_threshold_req_msg_v01)
                                         );
    QM_MSG_HIGH_1("Error after decoding req message is %d", errval);
  }
 
  if (errval == QMI_ERR_NONE_V01 )
  {
    
   memset( rsp_msg, 0x00, sizeof(nas_get_wwan_sleep_threshold_resp_msg_v01) );

   rsp_msg->resp.error  = QMI_ERR_NONE_V01;;
   rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
   rsp_msg->sleep_duration_threshold_valid = TRUE;
   rsp_msg->sleep_duration_threshold = qmi_nasi_global.wwan_sleep_theshold;
    
   retval= qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_WWAN_SLEEP_THRESHOLD_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_wwan_sleep_threshold_resp_msg_v01),
                                     &response
                                   );
   QM_MSG_HIGH_1("Return value after encoding is %d", retval);
   
  
  if ( !retval )
  {
    dsm_free_packet(&response);
  }
  }
  
  if ( rsp_msg  != NULL ) { modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE );rsp_msg = NULL; }
  if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE );req_msg = NULL; }

  return response;
  }

/*===========================================================================
   FUNCTION qmi_nas_set_wwan_sleep_threshold() 
 
   DESCRIPTION
     Set the sleep threshold
         
   PARAMETERS
     p_cmd_buf   : user data
     err         : error type
     
   RETURN VALUE
     None
     
   DEPENDENCIES
     None
 
   SIDE EFFECTS
     None
 ===========================================================================*/

static dsm_item_type * qmi_nasi_set_wwan_sleep_threshold(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                          errval                 = QMI_ERR_NONE_V01;
  dsm_item_type                             * response               = NULL;
  nas_set_wwan_sleep_threshold_req_msg_v01  * req_msg;
  nas_set_wwan_sleep_threshold_resp_msg_v01 * resp_msg;
  boolean                                     retval;

  

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("qmi_nasi_wwan_sleep_threshold_req processing started");
  
  req_msg = (nas_set_wwan_sleep_threshold_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_wwan_sleep_threshold_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  resp_msg = (nas_set_wwan_sleep_threshold_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_wwan_sleep_threshold_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH("Not enough memory to allocate for QMI_NAS_SET_WWAN_SLEEP_THRESHOLD_REQ request");
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  
  if( resp_msg == NULL)
  {
   QM_MSG_HIGH("Not enough memory to allocate for QMI_NAS_SET_WWAN_SLEEP_THRESHOLD_REQ response.");
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_wwan_sleep_threshold_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_wwan_sleep_threshold_req_msg_v01)
                                         );
    QM_MSG_HIGH_1("Error after decoding req message is %d", errval);
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    qmi_nasi_global.wwan_sleep_theshold = req_msg->sleep_duration_threshold;
    
    memset( resp_msg, 0x00, sizeof(nas_set_wwan_sleep_threshold_resp_msg_v01) );
  
   resp_msg->resp.error  = errval;
   resp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    
   retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_SET_WWAN_SLEEP_THRESHOLD_RESP_MSG_V01,
                                     (void *) resp_msg,
                                     (uint32_t) sizeof(nas_set_wwan_sleep_threshold_resp_msg_v01),
                                     &response
                                   );
  QM_MSG_HIGH_1("Return value after encoding is %d", retval);
  
  
  if ( !retval )
  {
    dsm_free_packet(&response);
  }
  }
 if ( req_msg  != NULL ) { modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); req_msg = NULL;}
 if ( resp_msg  != NULL ) { modem_mem_free( (void *) resp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); resp_msg = NULL;}

 return response;
}

/*===========================================================================
  FUNCTION qmi_nasi_get_cell_select_info_req()

  DESCRIPTION
    	QMI req for cell_select_info
    
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_cell_select_info_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_get_cell_select_info_req_msg_v01  * req_msg;
  nas_get_cell_select_info_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;
  
  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  if ( qmi_nasi_global.get_cell_select_info_buf_p == NULL )
  {
     qmi_nasi_global.get_cell_select_info_buf_p = cmd_buf_p;
  }
  else
  {
     errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  QM_MSG_HIGH("qmi_nasi_get_cell_select_info_req processing started");
  
  req_msg = (nas_get_cell_select_info_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_cell_select_info_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_cell_select_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_cell_select_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for nas_get_cell_select_info request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for nas_get_cell_select_info response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_cell_select_info_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_cell_select_info_req_msg_v01)
                                         );
  }
   
  if (errval == QMI_ERR_NONE_V01)
  { 
    if(qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].sys_mode == SYS_SYS_MODE_GSM)
    {       
       geran_grr_cell_select_info_req_t msg;
       memset( &msg, 0x00, sizeof(geran_grr_cell_select_info_req_t) );

       msgr_err = qmi_mmode_msgr_send(
                  GERAN_GRR_CELL_SELECT_INFO_REQ,
                  MSGR_QMI_NAS,
                  (msgr_hdr_struct_type *)&msg,
                  sizeof(geran_grr_cell_select_info_req_t));      

       QM_MSG_HIGH_1("GERAN_GRR_CELL_SELECT_INFO_REQ  request msgr_err:%d ", msgr_err);
  
       if ( msgr_err != E_SUCCESS )
       {
           errval = QMI_ERR_INTERNAL_V01;
       }
    }
    else if(qmi_nasi_global.cm_ss_info[QMI_NAS_SUBS_PRIMARY].sys_mode == SYS_SYS_MODE_LTE)
    {
      lte_rrc_cell_select_info_req_s msg;
      memset( &msg, 0x00, sizeof(lte_rrc_cell_select_info_req_s) );

      msgr_err = qmi_mmode_msgr_send(
                 LTE_RRC_CELL_SELECT_INFO_REQ,
                 MSGR_QMI_NAS,
                 (msgr_hdr_struct_type *)&msg,
                 sizeof(lte_rrc_cell_select_info_req_s)); 

      QM_MSG_HIGH_1("LTE_RRC_CELL_SELECT_INFO_REQ  request msgr_err:%d ", msgr_err);
  
      if ( msgr_err != E_SUCCESS )
      {
           errval = QMI_ERR_INTERNAL_V01;
      }
    }
    else
    {
      errval = QMI_ERR_NO_NETWORK_FOUND_V01;
    }
  }
  
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_ce_level_info_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if(rsp_msg != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_ce_level_info_resp_msg_v01) );
   
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_CE_LEVEL_INFO_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_ce_level_info_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.get_cell_select_info_buf_p = NULL;
  }

  if ( req_msg  != NULL ) 
  { 
    modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); req_msg = NULL;
  }
  if ( rsp_msg  != NULL ) 
  { 
    modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); rsp_msg = NULL;
  }

  return response;
 }
  #ifdef FEATURE_FMD_SPEED_INFO
/*===========================================================================
  FUNCTION QMI_NASI_GET_FMD_SPEED_INFO()

  DESCRIPTION
    	QMI will give the Converage Enhancement Level Information
    
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_fmd_speed_info_req(
  qmi_mmode_svc_info_type *sp,
  qmi_mmode_qcsi_transaction_type *cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)

{
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_get_fmd_speed_info_req_msg_v01  * req_msg;
  nas_get_fmd_speed_info_resp_msg_v01  * rsp_msg;
  dsm_item_type     *response = NULL;
  
  if ( qmi_nasi_global.get_fmd_speed_info_buf_p == NULL )
  {
	   qmi_nasi_global.get_fmd_speed_info_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }


  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_HIGH_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  QM_MSG_HIGH("nas_fmd_speed_info_req processing started");
  
  req_msg = (nas_get_fmd_speed_info_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_fmd_speed_info_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_fmd_speed_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_fmd_speed_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );   

  if ( req_msg == NULL )
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for get_ce_level_info request. %p", req_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( rsp_msg == NULL)
  {
    QM_MSG_HIGH_1("Not enough memory to allocate for get_ce_level_info response. %p", rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }
 
  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_fmd_speed_info_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)cmd_buf_p->msg_id,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_fmd_speed_info_req_msg_v01)
                                         );
  }
   
  if (errval == QMI_ERR_NONE_V01)
  {
    lte_rrc_fmd_speed_info_req_s msg;
    memset( &msg, 0x00, sizeof(lte_rrc_fmd_speed_info_req_s) );
     
    msgr_init_hdr( (msgr_hdr_struct_type *)&msg, MSGR_QMI_NAS, LTE_RRC_FMD_SPEED_INFO_REQ );
    msgr_err = msgr_send( (msgr_hdr_struct_type *)&msg, sizeof(msg) );
 
    QM_MSG_HIGH_1("LTE_RRC_FMD_SPPED_INFO_REQ  request msgr_err:%d ", msgr_err);
  
    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
    }
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_fmd_speed_info_req() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
 else if(cmd_buf_p != NULL && rsp_msg != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_fmd_speed_info_resp_msg_v01) );
   
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_FMD_SPEED_INFO_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_fmd_speed_info_resp_msg_v01),
                                     &response
                                   );
    qmi_nasi_global.get_fmd_speed_info_buf_p = NULL;
 }

  if ( req_msg  != NULL ) 
  { 
    modem_mem_free( (void *) req_msg,  MODEM_MEM_CLIENT_QMI_MMODE ); 
  }
  if ( rsp_msg  != NULL ) 
  { 
    modem_mem_free( (void *) rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE );
  }

  /* Taking care of Dangling Pointers */
  req_msg = NULL;
  rsp_msg = NULL;


  return response;
  }

/*===========================================================================
  FUNCTION qmi_nas_get_fmd_speed_info_resp

  DESCRIPTION
	Send qmi_nas_ce_level resp
		
  PARAMETERS
	p_cmd_buf	: user data
	err 		: error type
	
  RETURN VALUE
	None
	
  DEPENDENCIES
	None

  SIDE EFFECTS
	None
===========================================================================*/
void qmi_nas_get_fmd_speed_info_resp(lte_rrc_fmd_speed_info_rsp_s *p_info)
{
  nas_get_fmd_speed_info_resp_msg_v01		 *rsp_msg;
  dsm_item_type 						*response;
  qmi_mmode_qcsi_transaction_type *cmd_buf_p = qmi_nasi_global.get_fmd_speed_info_buf_p;
  qmi_nasi_global.get_fmd_speed_info_buf_p = NULL;

  if(p_info == NULL)
  {
	QM_MSG_ERROR("Can't find any inforation from LTE ");
	return;
  }
  if(cmd_buf_p == NULL)
  {
	QM_MSG_ERROR("Cant find client for QMI_NASI_GET_FMD_SPEED_INFO_REQ ");
	return;
  }
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
 rsp_msg = (nas_get_fmd_speed_info_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_fmd_speed_info_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( rsp_msg == NULL)
  {
	QM_MSG_ERROR("Not enough memory to allocate for qnas_get_fmd_speed_resp");
	return;
  }
  
 memset ( rsp_msg, 0x00, sizeof(nas_get_fmd_speed_info_resp_msg_v01) );

  rsp_msg->resp.error = QMI_ERR_NONE_V01;
  rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  rsp_msg->speed_valid = TRUE;
  rsp_msg->speed = p_info->speed;
  rsp_msg->abs_time_sec_valid = TRUE;
  rsp_msg->abs_time_sec = p_info->abs_time_sec;
 
 if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
											QMI_IDL_RESPONSE,
											(uint16_t) QMI_NAS_GET_FMD_SPEED_INFO_RESP_MSG_V01,
											(void *) rsp_msg,
											(uint32_t) sizeof( nas_get_fmd_speed_info_resp_msg_v01 ),
											&response) )
 {
		  
   if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
   {
	 QM_MSG_ERROR("Unable to send QMI_NAS_GET_FMD_SPEED_RESP_MSG");
	 qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
   }

 }
 else
 {
	dsm_free_packet(&response);
	qmi_mmode_svc_free_pending_transaction( &qmi_nas_state, &cmd_buf_p );
 }	 

 if ( rsp_msg != NULL ) 
 { 
   modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
 }

 /* Taking care of Dangling Pointer */
 rsp_msg = NULL;
 
}

#endif

  


