/*=============================================================================
  @file sns_fw_log.c

  Log packets generated by the Framework, Client Manager, and other misc.
  entities that found their way in here.

  Copyright (c) 2016-2019 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
  ===========================================================================*/

/*=============================================================================
  Include Files
  ===========================================================================*/

#include "sns_assert.h"
#include "sns_fw_attribute_service.h"
#include "sns_fw_data_stream.h"
#include "sns_fw_log.h"
#include "sns_fw_request.h"
#include "sns_fw_sensor.h"
#include "sns_fw_sensor_instance.h"
#include "sns_rc.h"
#include "sns_sensor_event.h"
#include "sns_sensor_uid.h"

#include "pb_encode.h"
#include "sns_diag.pb.h"
#include "sns_fw_diag_service.h"
#include "sns_fw_diag_types.h"
#include "sns_mem_util.h"
#include "sns_pb_util.h"

#include "sns_client.pb.h"
#include "sns_printf_int.h"
#include "sns_std.pb.h"

#include "sns_island.h"
#include "sns_types.h"

/*=============================================================================
  Macro and Preprocessor Definitions
  ===========================================================================*/

#define SNS_FW_LOG_INST_MAP_MAX_INST (20)

/*=============================================================================
  Type Definitions
  ===========================================================================*/

typedef struct
{
  uint64_t timestamp;
  uint64_t stream_id;
  uint32_t message_id;
  size_t payload_len;
  sns_fw_diag_service_log_id log_id;
  uint8_t payload[];
} sensor_api_log_info;

typedef struct
{
  char src_sensor_type[SNS_SENSOR_DATATYPE_NAME_LEN];
  uint64_t client_id;
  size_t type_len;
  size_t payload_len;
  sns_fw_diag_service_log_id log_id;
  uint8_t payload[];
} client_api_log_info;

typedef struct
{
  uint64_t src_instance_id;
  uint64_t dest_instance_id[SNS_FW_LOG_INST_MAP_MAX_INST];
  uint64_t stream_id[SNS_FW_LOG_INST_MAP_MAX_INST];
  uint8_t num_dest_id;
} inst_map_log_info;

/*=============================================================================
  Public Function Definitions
  ===========================================================================*/

DIAG_ISLAND_TEXT sns_rc
sns_fw_log_encode_sensor_api_cb(void *log, size_t log_size,
    size_t encoded_log_size, void *encoded_log, size_t *bytes_written)
{
  sns_rc rc = SNS_RC_SUCCESS;

  if(NULL == log || 0 == log_size || NULL == encoded_log ||
     0 == encoded_log_size || NULL == bytes_written)
  {
    return SNS_RC_FAILED;
  }

  sensor_api_log_info *log_info = (sensor_api_log_info *)log;
  sns_diag_sensor_api_log hdr = sns_diag_sensor_api_log_init_default;
  sns_diag_sensor_api_log *sensor_api_log = &hdr;
  pb_ostream_t stream = pb_ostream_from_buffer(encoded_log, encoded_log_size);

  hdr.message_id = log_info->message_id;
  hdr.timestamp = log_info->timestamp;
  hdr.has_stream_id = true;
  hdr.stream_id = log_info->stream_id;

  if(!pb_encode(&stream, sns_diag_sensor_api_log_fields,
                sensor_api_log))
  {
    SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding sensor api log header : %s",
        PB_GET_ERROR(&stream));
    rc = SNS_RC_FAILED;
  }
  else
  {
    switch(log_info->log_id)
    {
      case SNS_LOG_SENSOR_API_REQUEST:
      {
        if(!pb_encode_tag(&stream, PB_WT_STRING,
                          sns_diag_sensor_api_log_request_payload_tag))
        {
          rc = SNS_RC_FAILED;
          SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding sensor api req payload"
              "field tag: %s", PB_GET_ERROR(&stream));
        }
        else if(!pb_encode_string(&stream,(pb_byte_t*)log_info->payload,
              log_info->payload_len))
        {
          rc = SNS_RC_FAILED;
          SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding sensor api req payload"
              "string: %s", PB_GET_ERROR(&stream));
        }
        break;
      }
      default:
      {
        uint64_t tag_size = sizeof(uint8_t);
        uint64_t payload_len = log_info->payload_len;
        uint8_t length_size = 0;
        /* length_size should be based on log_info->payload_len */
        do
        {
          payload_len >>= 7;
          length_size++;
        } while(payload_len);

        if(!pb_encode_tag(&stream, PB_WT_STRING,
                          sns_diag_sensor_api_log_opaque_payload_tag))
        {
          rc = SNS_RC_FAILED;
          SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding sensor api event "
              "payload field tag: %s", PB_GET_ERROR(&stream));
        }
        else if(!pb_encode_varint(&stream, (log_info->payload_len +
                                            tag_size + length_size)))
        {
          rc = SNS_RC_FAILED;
          SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding sensor api event payload"
                               "string: %s", PB_GET_ERROR(&stream));
        }
        else if(!pb_encode_tag(&stream, PB_WT_STRING,
                               sns_diag_opaque_payload_payload_tag))
        {
          rc = SNS_RC_FAILED;
          SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding sensor api event log"
                               "payload field tag: %s", PB_GET_ERROR(&stream));
        }
        else if(!pb_encode_string(&stream,
             (pb_byte_t*)log_info->payload, log_info->payload_len))
        {
          rc = SNS_RC_FAILED;
          SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding sensor api event log"
                               "string: %s", PB_GET_ERROR(&stream));
        }
        break;
      }
    }
  }

  if(SNS_RC_SUCCESS == rc)
    *bytes_written = stream.bytes_written;

  return rc;
}

DIAG_ISLAND_TEXT static sns_rc
sns_fw_log_sensor_inst_api_msg(sns_fw_sensor_instance *instance,
  sns_sensor_uid const *sensor_uid, sns_fw_diag_service_log_id log_id,
  uint32_t message_id, uint64_t timestamp, void *payload, size_t payload_len)
{
  sns_rc rc = SNS_RC_SUCCESS;
  sns_diag_src_config *diag_config =
    sns_diag_find_diag_config(instance, sensor_uid);
  sensor_api_log_info *log_info = NULL;
  size_t log_info_size = sizeof(sensor_api_log_info) + payload_len;
  size_t encoded_sensor_api_hdr_size =
    sns_diag_get_preencoded_size(SNS_DIAG_ENC_SIZE_SENSOR_API_HDR);

  if(!sns_island_is_island_ptr((intptr_t)diag_config->config))
    SNS_ISLAND_EXIT();

  // PEND: The following is unsafe without acquiring
  // diag_service_internal.data_type_list_lock
  if(!diag_config->config->enabled)
  {
    return SNS_RC_NOT_SUPPORTED;
  }

  log_info = (sensor_api_log_info*)sns_diag_log_alloc(
    log_info_size, log_id);

  if(NULL != log_info)
  {
    log_info->log_id = log_id;

    log_info->message_id = message_id;
    log_info->timestamp = timestamp;

    log_info->payload_len = payload_len;
    sns_memscpy(log_info->payload, payload_len,
                payload, payload_len);
  }

  if(!sns_island_is_island_ptr((intptr_t)diag_config->config))
    SNS_ISLAND_EXIT();

  rc = sns_diag_publish_sensor_log(
    (uintptr_t)instance, sensor_uid, (char const *)diag_config->config->datatype,
    log_id, log_info_size, log_info, encoded_sensor_api_hdr_size + payload_len,
    sns_fw_log_encode_sensor_api_cb);

  return rc;
}

SNS_SECTION(".text.sns") sns_rc
sns_fw_log_sensor_inst_api_event(sns_sensor_instance *instance,
  sns_sensor_uid const *sensor_uid, sns_sensor_event *event)
{
  sns_rc rc = SNS_RC_FAILED;
  SNS_NON_ISLAND_DIAG_CHECK(if(SNS_ISLAND_STATE_IN_ISLAND != sns_island_get_island_state()))
  {
    sns_fw_sensor_instance *fw_instance = (sns_fw_sensor_instance*)instance;
    sns_diag_src_config *diag_config =
      sns_diag_find_diag_config(fw_instance, sensor_uid);
    SNS_ASSERT(NULL != event);

    if(!sns_island_is_island_ptr((intptr_t)diag_config->config))
      SNS_ISLAND_EXIT();

    rc = sns_fw_log_sensor_inst_api_msg(
      fw_instance, sensor_uid, SNS_LOG_SENSOR_API_EVENT,
      event->message_id, event->timestamp, event->event, event->event_len);
  }
  return rc;
}

DIAG_ISLAND_TEXT static sns_rc
sns_fw_log_sensor_api_msg(sns_fw_sensor *sensor,
  sns_sensor_uid const *sensor_uid, sns_fw_diag_service_log_id log_id,
  uint32_t message_id, uint64_t timestamp, uint64_t stream_id,
  void *payload, size_t payload_len)
{
  sns_rc rc = SNS_RC_SUCCESS;
  sns_diag_src_config *diag_config = &sensor->diag_config;
  sensor_api_log_info *log_info = NULL;
  size_t log_info_size = sizeof(sensor_api_log_info) + payload_len;
  size_t encoded_sensor_api_hdr_size =
    sns_diag_get_preencoded_size(SNS_DIAG_ENC_SIZE_SENSOR_API_HDR);

  if(!sns_island_is_island_ptr((intptr_t)diag_config->config))
    SNS_ISLAND_EXIT();

  // PEND: The following is unsafe without acquiring
  // diag_service_internal.data_type_list_lock
  if(!diag_config->config->enabled)
  {
    return SNS_RC_NOT_SUPPORTED;
  }

  log_info = (sensor_api_log_info*)sns_diag_log_alloc(
    log_info_size, log_id);

  if(NULL != log_info)
  {
    log_info->log_id = log_id;

    log_info->message_id = message_id;
    log_info->timestamp = timestamp;
    log_info->stream_id = stream_id;

    log_info->payload_len = payload_len;
    sns_memscpy(log_info->payload, payload_len,
                payload, payload_len);
  }

  if(!sns_island_is_island_ptr((intptr_t)diag_config->config))
    SNS_ISLAND_EXIT();

  rc = sns_diag_publish_sensor_log(
    (uintptr_t)0, sensor_uid, diag_config->config->datatype,
    log_id, log_info_size, log_info, encoded_sensor_api_hdr_size + payload_len,
    sns_fw_log_encode_sensor_api_cb);

  return rc;
}

SNS_SECTION(".text.sns") sns_rc
sns_fw_log_sensor_api_event(sns_fw_data_stream *stream, sns_sensor_event *event)
{
  sns_rc rc = SNS_RC_FAILED;
  SNS_NON_ISLAND_DIAG_CHECK(if(SNS_ISLAND_STATE_IN_ISLAND != sns_island_get_island_state()))
  {
    if(NULL != stream && NULL != event && NULL != stream->data_source)
    {
      sns_fw_sensor *fw_sensor = stream->data_source;

      if(!sns_island_is_island_ptr((intptr_t)fw_sensor->diag_config.config))
        SNS_ISLAND_EXIT();

      rc = sns_fw_log_sensor_api_msg(
        fw_sensor, fw_sensor->sensor.sensor_api->get_sensor_uid((sns_sensor *)fw_sensor),
        SNS_LOG_SENSOR_API_EVENT, event->message_id, event->timestamp, (size_t)stream,
        event->event, event->event_len);
    }
  }
  return rc;
}

SNS_SECTION(".text.sns") sns_rc
sns_fw_log_sensor_api_req(sns_sensor *sensor, sns_fw_request const *req,
    sns_time ts)
{
  sns_rc rc = SNS_RC_FAILED;
  SNS_ASSERT(NULL != req);

  SNS_NON_ISLAND_DIAG_CHECK(if(SNS_ISLAND_STATE_IN_ISLAND != sns_island_get_island_state()))
  {
    sns_fw_sensor *fw_sensor = (sns_fw_sensor*)sensor;

    if(!sns_island_is_island_ptr((intptr_t)fw_sensor->diag_config.config))
      SNS_ISLAND_EXIT();

    rc = sns_fw_log_sensor_api_msg(
      fw_sensor, sensor->sensor_api->get_sensor_uid(sensor), SNS_LOG_SENSOR_API_REQUEST,
      req->request.message_id, ts, (size_t)req->stream, req->request.request,
      req->request.request_len);
  }
  return rc;

}

DIAG_ISLAND_TEXT sns_rc
sns_fw_log_encode_inst_map_cb(void *log, size_t log_size,
    size_t encoded_log_size, void *encoded_log, size_t *bytes_written)
{
  sns_rc rc = SNS_RC_SUCCESS;
  inst_map_log_info *log_info = (inst_map_log_info*)log;

  if(NULL == log || 0 == log_size || NULL == encoded_log ||
     0 == encoded_log_size || NULL == bytes_written)
  {
    return SNS_RC_FAILED;
  }

  sns_diag_instance_map_log instance_map_log =
    sns_diag_instance_map_log_init_default;
  pb_ostream_t stream = pb_ostream_from_buffer(encoded_log, encoded_log_size);

  instance_map_log.src_instance_id = log_info->src_instance_id;

  if(!pb_encode(&stream, sns_diag_instance_map_log_fields, &instance_map_log))
  {
    SNS_SPRINTF(ERROR, sns_fw_printf,
        "Error encoding inst client api req header : %s",
        PB_GET_ERROR(&stream));
    rc = SNS_RC_FAILED;
  }

  for(int i = 0; i < log_info->num_dest_id; i++)
  {
    if(!pb_encode_tag(&stream, PB_WT_64BIT,
                      sns_diag_instance_map_log_dest_instance_id_tag))
    {
      rc = SNS_RC_FAILED;
      SNS_SPRINTF(ERROR, sns_fw_printf,
          "Error encoding sns_diag_instance_map_log_dest_instance_id_tag: %s",
          PB_GET_ERROR(&stream));
    }
    else if(!pb_encode_fixed64(&stream, (pb_byte_t*)(&log_info->dest_instance_id[i])))
    {
      SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding dest_instance_id : %s",
               PB_GET_ERROR(&stream));
      rc = SNS_RC_FAILED;
    }
  }

  for(uint_fast8_t i = 0; i < log_info->num_dest_id; i++)
  {
    if(!pb_encode_tag(&stream, PB_WT_64BIT,
                      sns_diag_instance_map_log_stream_id_tag))
    {
      rc = SNS_RC_FAILED;
      SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding sns_diag_instance_map_log_stream_id_tag: %s",
                 PB_GET_ERROR(&stream));
    }
    else if(!pb_encode_fixed64(&stream, (pb_byte_t*)(&log_info->stream_id[i])))
    {
      SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding stream_id : %s",
          PB_GET_ERROR(&stream));
      rc = SNS_RC_FAILED;
    }
  }

  if(SNS_RC_SUCCESS == rc)
    *bytes_written = stream.bytes_written;

  return rc;
}

DIAG_ISLAND_TEXT static sns_rc
sns_fw_log_inst_map_internal(sns_sensor_instance *instance)
{
  sns_rc rc = SNS_RC_SUCCESS;
  sns_diag_instance_map_log instance_map_log =
    sns_diag_instance_map_log_init_default;
  size_t encoded_inst_id_size = 0, encoded_log_size = 0;
  sns_isafe_list_iter client_iter, req_list_iter;
  sns_fw_sensor_instance *fw_instance = (sns_fw_sensor_instance*)instance;
  uint8_t i = 0;
  inst_map_log_info *log_info = (inst_map_log_info*)sns_diag_log_alloc(
    sizeof(inst_map_log_info), SNS_LOG_INSTANCE_MAP);

  if(NULL == log_info)
    return SNS_RC_FAILED;

  pb_get_encoded_size(&encoded_inst_id_size, sns_diag_instance_map_log_fields,
      &instance_map_log);

  sns_isafe_list_iter_init(&client_iter, &fw_instance->client_req_lists, true);

  log_info->src_instance_id = (size_t)instance;

  // For each client of this Sensor Instance
  for(sns_isafe_list_iter_init(&req_list_iter, &fw_instance->client_req_lists, true);
      NULL != sns_isafe_list_iter_curr(&req_list_iter);
      sns_isafe_list_iter_advance(&req_list_iter))
  {
    sns_client_req_list *req_list = (sns_client_req_list*)
      sns_isafe_list_iter_get_curr_data(&req_list_iter);
    sns_isafe_list_iter client_iter;

    for(sns_isafe_list_iter_init(&client_iter, &req_list->client_requests, true);
        NULL != sns_isafe_list_iter_curr(&client_iter);
        sns_isafe_list_iter_advance(&client_iter))
    {
      sns_fw_data_stream *fw_stream = (sns_fw_data_stream *)
        sns_isafe_list_iter_get_curr_data(&client_iter);

      if(!sns_island_is_island_ptr((intptr_t)fw_stream) ||
         SNS_ISLAND_STATE_IN_ISLAND != fw_stream->island_operation)
      {
        SNS_ISLAND_EXIT();
      }

      if(NULL != fw_stream && i < SNS_FW_LOG_INST_MAP_MAX_INST)
      {
        if(NULL != fw_stream->dst_instance)
          log_info->dest_instance_id[i] = (size_t)fw_stream->dst_instance;
        else
          log_info->dest_instance_id[i] = (size_t)fw_stream->dst_sensor;
        log_info->stream_id[i] = (size_t)fw_stream;
        i++;
      }
    }
  }

  log_info->num_dest_id = i;

  // encoded_size * (num_dest_inst + num_dest_data_stream + num_src_inst(1))
  encoded_log_size = encoded_inst_id_size * (log_info->num_dest_id * 2 + 1);

  rc = sns_diag_publish_fw_log(
    SNS_LOG_INSTANCE_MAP, sizeof(inst_map_log_info), log_info,
    encoded_log_size, sns_fw_log_encode_inst_map_cb);

  return rc;
}

SNS_SECTION(".text.sns") sns_rc
sns_fw_log_inst_map(sns_sensor_instance *instance)
{
  sns_rc rc = SNS_RC_FAILED;
  SNS_NON_ISLAND_DIAG_CHECK(if(SNS_ISLAND_STATE_IN_ISLAND != sns_island_get_island_state()))
  {
    rc = sns_fw_log_inst_map_internal(instance);
  }
  return rc;
}

DIAG_ISLAND_TEXT sns_rc
sns_fw_log_encode_client_api_cb(void *log, size_t log_size,
    size_t encoded_log_size, void *encoded_log, size_t *bytes_written)
{
  UNUSED_VAR(log_size);
  sns_rc rc = SNS_RC_SUCCESS;
  client_api_log_info *log_info = (client_api_log_info*)log;
  pb_buffer_arg sensor_type_args;
  sns_diag_client_api_log *client_api_log = NULL;

  if(NULL == log || 0 == log_size || NULL == encoded_log ||
     0 == encoded_log_size || NULL == bytes_written)
  {
    return SNS_RC_FAILED;
  }

  sns_diag_client_api_log hdr = sns_diag_client_api_log_init_default;
  client_api_log = &hdr;

  sensor_type_args = (pb_buffer_arg){ .buf = log_info->src_sensor_type,
    .buf_len = log_info->type_len};

  hdr.client_id = log_info->client_id;

  client_api_log->src_sensor_type.funcs.encode = &pb_encode_string_cb;
  client_api_log->src_sensor_type.arg = &sensor_type_args;

  pb_ostream_t stream = pb_ostream_from_buffer(encoded_log, encoded_log_size);

  if(!pb_encode(&stream, sns_diag_client_api_log_fields, client_api_log))
  {
    SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding client api req header : %s",
               PB_GET_ERROR(&stream));
    rc = SNS_RC_FAILED;
  }
  else
  {
    uint32_t field_tag = 0;
    switch(log_info->log_id)
    {
      case SNS_LOG_CLIENT_API_REQUEST:
      {
        field_tag = sns_diag_client_api_log_request_payload_tag;
        break;
      }
      case SNS_LOG_CLIENT_API_RESPONSE:
      {
        field_tag = sns_diag_client_api_log_resp_payload_tag;
        break;
      }
      case SNS_LOG_CLIENT_API_EVENT:
      {
        field_tag = sns_diag_client_api_log_event_payload_tag;
        break;
      }
      default:
      {
        break;
      }
    }

    if(!pb_encode_tag(&stream, PB_WT_STRING, field_tag))
    {
      rc = SNS_RC_FAILED;
      SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding client api payload"
          "field tag: %s",PB_GET_ERROR(&stream));
    }
    else if(!pb_encode_string(&stream,
                              (pb_byte_t*)log_info->payload,
                              log_info->payload_len))
    {
      rc = SNS_RC_FAILED;
      SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding client api payload"
          "string: %s",PB_GET_ERROR(&stream));
    }
  }

  if(SNS_RC_SUCCESS == rc)
    *bytes_written = stream.bytes_written;

  return rc;
}

DIAG_ISLAND_TEXT static sns_rc
sns_fw_log_client_api_msg(intptr_t instance, sns_sensor_uid const *sensor_uid,
    sns_fw_diag_service_log_id log_id, uint64_t client_id,
    sns_fw_sensor const *sensor, void const *payload, size_t payload_len)
{
  sns_rc rc = SNS_RC_SUCCESS;
  client_api_log_info *log_info = NULL;
  size_t log_info_size = sizeof(client_api_log_info) + payload_len;
  size_t encoded_client_api_hdr_size =
    sns_diag_get_preencoded_size(SNS_DIAG_ENC_SIZE_CLIENT_API_HDR);
  char data_type[] = "client_manager";

  if(!sns_island_is_island_ptr((intptr_t)sensor->diag_config.config))
    SNS_ISLAND_EXIT();

  // PEND: Accessing an arbitrary sensor is incredibly dangerous, and might
  // cause the system to crash.  An alternative solution is likely preferred.
  if(!sensor->diag_config.config->enabled)
  {
    return SNS_RC_NOT_SUPPORTED;
  }

  log_info = (client_api_log_info*)sns_diag_log_alloc(log_info_size, log_id);

  if(NULL != log_info)
  {
    if(sns_island_is_island_ptr((intptr_t)sensor->diag_config.config))
      SNS_ISLAND_EXIT();

    char const *data_type = sensor->diag_config.config->datatype;

    log_info->log_id = log_id;

    log_info->type_len = strlen(data_type) + 1;
    log_info->type_len = log_info->type_len > SNS_SENSOR_DATATYPE_NAME_LEN ?
        SNS_SENSOR_DATATYPE_NAME_LEN : log_info->type_len;

    sns_strlcpy(log_info->src_sensor_type, data_type, log_info->type_len);

    log_info->client_id = client_id;

    log_info->payload_len = payload_len;
    sns_memscpy(log_info->payload, payload_len,
                payload, payload_len);
  }

  rc = sns_diag_publish_sensor_log(
      (uintptr_t)instance, sensor_uid, data_type,
      log_id, log_info_size, log_info,
      encoded_client_api_hdr_size + payload_len,
      sns_fw_log_encode_client_api_cb);

  return rc;
}

SNS_SECTION(".text.sns") sns_rc
sns_fw_log_client_api_req(sns_sensor_instance *instance,
  sns_sensor const *src_sensor, sns_sensor_uid const *sensor_uid, uint64_t client_id,
  void *payload, size_t payload_len)
{
  sns_rc rc = SNS_RC_FAILED;
  sns_fw_sensor *fw_src_sensor = (sns_fw_sensor*)src_sensor;
  SNS_ASSERT(NULL != payload);

  SNS_NON_ISLAND_DIAG_CHECK(if(SNS_ISLAND_STATE_IN_ISLAND != sns_island_get_island_state()))
  {
    rc = sns_fw_log_client_api_msg((intptr_t)instance, sensor_uid,
        SNS_LOG_CLIENT_API_REQUEST , client_id, fw_src_sensor,
        payload, payload_len);
  }

  return rc;
}

SNS_SECTION(".text.sns") sns_rc
sns_fw_log_client_api_resp(sns_sensor_instance *instance,
  sns_sensor const *src_sensor, sns_sensor_uid const *sensor_uid,
  uint64_t client_id, uint64_t error)
{
  sns_rc rc = SNS_RC_FAILED;
  SNS_NON_ISLAND_DIAG_CHECK(if(SNS_ISLAND_STATE_IN_ISLAND != sns_island_get_island_state()))
  {
    sns_fw_sensor *fw_src_sensor = (sns_fw_sensor*)src_sensor;
    sns_diag_client_resp_msg resp_msg = sns_diag_client_resp_msg_init_default;
    uint64_t buffer[2];
    pb_ostream_t stream =
      pb_ostream_from_buffer((pb_byte_t*)buffer, sizeof(buffer));

    sns_memzero(buffer, sizeof(buffer));

    resp_msg.error = error;

    if(!pb_encode(&stream, sns_diag_client_resp_msg_fields, &resp_msg))
    {
      rc = SNS_RC_FAILED;
      SNS_SPRINTF(ERROR, sns_fw_printf, "Error encoding client resp msg log: %s",
          PB_GET_ERROR(&stream));
    }
    else
    {
      rc = sns_fw_log_client_api_msg((intptr_t)instance, sensor_uid,
        SNS_LOG_CLIENT_API_RESPONSE , client_id, fw_src_sensor,
        buffer, stream.bytes_written);
    }
  }
  return rc;
}

SNS_SECTION(".text.sns") sns_rc
sns_fw_log_client_api_ind(sns_sensor_instance *instance,
  sns_sensor const *src_sensor, sns_sensor_uid const *sensor_uid, uint64_t client_id,
  void *payload, size_t payload_len)
{
  sns_rc rc = SNS_RC_FAILED;
  sns_fw_sensor *fw_src_sensor = (sns_fw_sensor*)src_sensor;

  SNS_ASSERT(NULL != payload);

  SNS_NON_ISLAND_DIAG_CHECK(if(SNS_ISLAND_STATE_IN_ISLAND != sns_island_get_island_state()))
  {
    rc = sns_fw_log_client_api_msg((intptr_t)instance, sensor_uid,
      SNS_LOG_CLIENT_API_EVENT, client_id, fw_src_sensor,
      payload, payload_len);
  }
  return rc;
}
