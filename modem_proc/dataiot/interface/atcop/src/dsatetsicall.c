/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                D A T A   S E R V I C E S

                U M T S

                C A L L   C O N T R O L
                                
                A T   C O M M A N D   P R O C E S S I N G

GENERAL DESCRIPTION
  This module executes AT commands. It executes UMTS specific call control 
  AT commands.

  
EXTERNALIZED FUNCTIONS
  dsat_send_cr_result
    Sends intermediate service reporting result code to TE or PS protocol
    stack based on response routing provided by response router.
    

EXTERNALIZED FUNCTIONS INTERNAL TO DSAT UNIT
  dsatetsicall_init_call
    This function intializes ETSI call handling.

  dsatetsicall_exec_cdip_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CDIP command, which enables/disables the display of 
    called line identification.
  
  dsatetsicall_exec_ctfr_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CTFR command, which controls the call deflection (call Transfer)
    supplementary service acording to 3GPP TS 22.072 [30]
      
  dsatetsicall_set_crc_result
    Produces unformatted incoming call indication or GPRS network request
    for PDP context activation result and returns in DSM item.

  dsatetsicall_exec_cbst_cmd
    This function takes the result from the command line parser
    and executes it. It executes +CBST command.It is used to select
    bearer services to be used when data calls are originated. 

  dsatetsicall_voice_dial_cmd
    Handle atd voice dial commands.  This function is called by 
    dsatact_exec_atd_cmd when dial string has ;.

  dsatetsicall_exec_chup_cmd
    This is the command handler function for +CHUP.

  dsatetsicall_exec_clck_cmd
    This function controls the facility lock supplementary service.

  dsatetsicall_report_clck
    This function reports the facility lock supplementary service status
    received from Call Manager.

  dsatetsicall_exec_cpwd_cmd
    This function sets new passwords for facility lock supplementary service.

  dsatetsicall_exec_cusd_cmd
    This function control of Unstructured Supplementary Service Data (USSD).

  dsatetsicall_exec_chld_cmd
    This function controls the call hold supplementary service. 

  dsatetsicall_update_call_state
    Maintains call state, held/active, for voice and CS data calls. 
    
  dsatetsicall_sups_cmd_cb_handler
    Handles error responses for CM Supplementary Service commands generated by
    +CHLD command

  dsatetsicall_call_event_connect
    Handles CM_CALL_EVENT_CONNECT events, keeping call state info up to 
    date.

  dsatetsicall_call_event_end
    Handles CM_CALL_EVENT_END events, keeping call state info up to 
    date.

  dsatetsicall_call_event_incom
    Handles CM_CALL_EVENT_INCOM events, keeping call state info up to 
    date.

  dsatetsicall_exec_es_cmd
    This function executes +ES command, which set parameters for entering 
    or exiting synchronous access mode.

  dsatetsicall_exec_esa_cmd
    This function executes +ESA command, which set parameters for synchronous 
    access mode configuration.

  dsatetsicall_es_export
    This function export the +ES's value to other subsystem.

  dsatetsicall_esa_export
    This function export the +ESA's value to other subsystem.

  dsatetsicall_exec_crlp_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CRLP command, which processes parameters for
    non-transparnet/asynchronous circuit-switched data calls.

  dsatetsicall_crlp_response_fmt
    This function generates the response for the +CRLP read & test
    commands.  The &V command respose is handled as well.  Data is
    extracted from data structure and formatted according to
    parameter flag.

  dsatetsicall_init_crlp_export
    This function intializes the +CRLP multidimensional value list.

  dsatetsicall_exec_caoc_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CAOC command, which enables/disables
    unsolitited result codes for advice of charge supplementary service.

  dsatetsicall_caoc_timer_expired_handler 
    This function is the handler function for the +CAOC command
    reporting timer expired event.

  dsatetsicall_exec_cacm_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CACM command, which reports the
    accumulated call meteter from the SIM/USIM.
    
  dsatetsicall_exec_camm_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CAMM command, which reports or resets the 
    accumulated call meter maximum from the SIM/USIM.

  dsatetsicall_aoc_verify_pin_handler
    This function is the handler function for the +CACM/+CAMM commands
    PIN2 verification.

  dsatetsicall_exec_cpuc_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CPUC command, which reports or sets the 
    Price per Unit and Currency table from the SIM/USIM.

  dsatetsicall_exec_cops_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +COPS command, which list available networks and sets
    automatic/manual registration.

  dsatetsicall_cops_abort_cmd_handler
  dsatetsicall_cops_abort_event_handler
    This function handles an abort command to terminate asynchronous
    processing for +COPS registration operation.
    
  dsatetsicall_cops_asynch_handler
    This function manages the asynchronous processing of the +COPS
    command. 

  dsatetsicall_exec_ceer_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CEER command, which report the reason
    for the last call failure to setup or release.

  dsatetsicall_exec_cqi_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CQI command, which report the GW Channel 
    Quality Indicator.
    
   Copyright (c) 2001 - 2023 by Qualcomm Technologies Incorporated.
   All Rights Reserved.
   Qualcomm Confidential and Proprietary.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $PVCSPath:  L:/src/asw/MSM5200/data/vcs/dsatetsicall.c_v   1.7   12 Jul 2002 10:05:08   randrew  $
   $Header: //components/rel/dataiot.mpss/2.0/interface/atcop/src/dsatetsicall.c#11 $ $DateTime: 2023/06/15 05:54:52 $ $Author: pwbldsvc $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
06/15/23   gk      Changes made to give ERROR response in +COPS command 
                   when UE is in offline/LPM state.
05/15/23   ks      Enhancing +COPS, +CEREG commands to support NTN RAT.
04/05/23   ks      $QCCELLSCAN command enhancement to support NTN RAT.
03/02/21   ks      Made changes to properly update PSM URC values when "Name only" 
                   commands are given.
11/09/20   ks      Added support for preserving URC indices across PSM cycles.
07/27/20   ks      Changes made to align with latest specs for +CEREG command.
04/17/20   ks      Fixed issue with +COPS displaying SPN appended with long/short 
                   PLMN name in the result.
02/14/18   rk      Fixed issue related to COPS cmd.
01/24/18   skc     Fixed issue with CEREG urc.
01/11/18   rk      Added support of URC for CGREG=4.
11/27/17   rk      Fixed issue with CEREG urc.
05/01/17   skc     Featurizing PBM Code. 
04/20/17   rk      Added support of URC for CEREG=4.
04/17/17   skc     Enabled requested AT Commands for IOE Build.
04/13/17   rg      Added rau and gprs ready timer for CPSMS
04/07/17   skc     Fixed CEREG Display issue.
03/27/17   skc     Fixed KW issue.
01/19/17   skc     Added enhancement on CHLD and CLCC for VoLTE MPTY Call.
12/16/16   skc     Added support for AT+VTS before connect event.
10/05/16   skc     Fixed KW issues.
09/23/16   skc     Added support for AT+CPSMS.
08/18/16   skc     Fixed issue with at+chld=2 during MPTY calls
06/21/16   skc     Fixed abort issue related to CPOL command.
06/21/16   skc     Fixed issue with chld=0 where call id of active call was sent
                   if there is any active call 
06/01/16   skc     Fixed PLMN display issue.
12/16/15   skc     Fixed issue where wrong call id is stored during one 
                   active call and one held call and at+chld=2 is issued.
12/10/15   skc     Fixed +COPN issue in MNC display logic.
04/15/15   sc      Fixed issue in event handling to use subs_id provided in 
                   event info.
02/19/15   tk      Fixed issue in subscription not available event handling.
10/24/14   tk      ATCoP changes for dynamic memory optimizations.
09/26/14   pg      Fixed skiping of zeros in MNC display.
08/27/14   pg      Fixed CLCK query issue.
08/01/14   sc      Added support for linked MO and MT USSD sessions.
07/08/14   sc      Fixed SGLTE+G issue on SUB2.
06/27/14   tk/sc   Added support for Dynamic ATCoP.
06/12/14   pg      Depricated mmgsdi_session_perso APIs.
06/11/14   sc      Fixed PLMN name issue having '@'.
02/15/14   pg      Added support for SGLTE+G.
05/23/14   pg      Fixed LLVM warnings.
04/29/14   sc      Added csg_list_cat support to $QCCSGCOPS command.
04/17/14   sc      Fixed ATCoP KW errors.
04/07/14   pg      Fixed CREG cmd issue on sub2.
03/27/14   pg      Fixed NOCARRIER response for command issue.
03/14/14   tk/sc   Optimized debug macros usage in ATCoP.
02/20/14   pg      Fixed last character missing issue in cops response.
01/22/14   pg      Fixed incorrect CREG status in Limited service.
12/30/13   sc      Fixed static code bugs.
12/30/13   sc      Used cm_user* api instead of sys_sel* api
12/23/13   sc      Fixed PLMN name encoding/decoding issue.
12/17/13   ab      Fixed at+cops=? truncated response issue.
11/22/13   sc      Fixed Bolt MOB3.0 compiler warnings.
11/18/13   sc      Fixed ATCoP KW errors.
11/13/13   sc      Added support for $QCCSGCOPS command.
10/28/13   pg      Fixed CPOL issue on DSDS.
10/15/13   sc      Fixed +CACM issue with SIM PIN2 enabled on SUB2.
10/11/13   sc      Added support for $QCNSP, $QCSIMT, $QCRCIND commands and
                   REMOTE CALL END, REMOTE RING, REMOTE ANSWER
                   unsolicited result codes.
09/13/13   sc      Fixed KW errors.
08/01/13   sc      Fixed KW errors.
07/24/13   sc      Migrated Extended MMGSDI api to disaply RPLMN name always.
07/05/13   tk      Fixed +CUSD issue when no USSD command pending to abort.
07/02/13   pg      Migrated to MMGSDI API to find PLMN info in SE13 table
06/05/13   tk      ATCoP changes for SGLTE support on Dime Plus.
05/24/13   tk      Fixed +CVMOD issue causing crash due to exception.
05/22/13   sk      updated cm api for bcd to ascii conversion.
05/16/13   sk      $QCCOPS command for Extension of network search.
05/03/13   tk      Fixed +CEREG issue when CS domain registration denied.
04/19/13   tk      Fixed issue in DSDS device mode.
03/27/13   tk      Fixed issues in dual stack commands.
03/01/13   tk      Fixed CEER issue with network ended CS calls.
02/22/13   tk      ATCoP - CM interface changes for Triton DSDA.
02/15/13   tk      Fixed KW error.
01/08/12   sk      Encoding type MMGSDI_EONS_ENC_UCS2_PACKED added.
01/23/13   tk      Fixed ATA issue.
01/23/13   sk      DS command buffer memory reduction.
01/17/13   tk      Fixed KW errors.
01/04/13   tk      Fixed +CPAS and +CEER issues.
01/04/13   tk      ATCoP changes for DSDX C/G+G with True World Mode Support.
11/30/12   tk      ATCoP changes for Triton DSDA.
10/12/12   tk      Fixed COPS dereg issue.
10/12/12   sk      Support to add "No Change" when  value is not given in +COPS.
10/10/12   sk      Fixed COPS short name Display Issue.
08/29/12   sb      Fix for No unsolicited codes returned for CGREG.
08/22/12   sk      Mainlining Nikel Changes.
07/31/12   sk      C-EONS Feature Support.
07/26/12   sb      Fixed KW Errors.
07/16/12   tk      Added RAT input to lookup SE13 table.
06/15/12   sk      Fixed CEER issue.
06/07/12   sk      fixed COPS issue in LTE mode.
05/18/12   tk      Migrated to MSG 2.0 macros
05/11/12   sk      Fixed CLCC MT calls reporting in CDMA mode.
05/04/12   sk      Fixed PDP deactivation issue when CHUP issued.
04/20/12   sk      DSAT_NIKEL featurization changes.
03/07/12   sk      Made CLCC common for all modes.
02/20/12   sb      Fixed Compiler Warnings.
02/17/12   sk      Migrating Data related AT commands interface to unified MH.
02/06/12   ad      Added CSTF/CEN/CGPIAF/CVMOD command support.
02/06/12   nc      Added support for ^SPN and URC Queue.
12/26/11   ad      Added Support the New Call Control Interface in Call Manager.
01/19/12   sk      Feature cleanup.
01/04/12   sb      Fixed KW Warnings.
11/03/11   sb      Fixed KW Warnings.
10/17/11   ad      Added +CECALL support.
10/04/11   ht      Included dsut header to support offtarget stubs.
10/03/11   nc      Fixed the short name display for COPS command.
09/14/11   ua      Extending uiutils network type to LTE. 
09/07/11   ad      Fixed +CRLP command.
07/05/11   nc      Added support for ^MODE,^CARDMODE,^SYSCONFIG,^SYSINFO,^DSCI.
04/13/11   ua      Extneding EONS for DSDS.
04/06/11   nc      Fixed the <act> parameter display for LTE in COPS.
03/29/11   nc      Fixed +VTS command.
03/18/11   bs      Fixed CLIP num type reporting.
03/11/11   bs      Fixed SUBSCRIPTION issue.
02/24/11   bs      Fixed Klocwork errors.
02/10/11   ad      Fixed CM realted commands .
01/11/11   ad      Removed pending variable .
01/11/11   ad      Remove extern usage.used get/set API for command associated  
                   value pointers.
10/25/10   ad      Init Changes for DSDS. 
10/06/10   ad      Added Error msg before Assert(0).
10/12/10   bs      Fixed mode pref change during active voice call.
10/04/10   ua      Additional messages for the COPS network name.
09/30/10   ad      Fixed Compilation warnings. 
08/30/10   ad      Fixed cops act issue.
08/17/10   ad      Fixed +CEREG for LTE.
07/09/10   bs      Fixed +CGACT for LTE.
07/01/10   nc      Corrected the check for CEREG and CGREG command execution.
06/04/10   bs      MMGSDI SESSION Migration.
05/19/10   bs      Added <act> support for CREG.
05/17/10   ad      Added Support for $CEREG for LTE.
05/10/10   kk      Mainlining pending GOBI changes.
03/15/10   bs      Added +CQI support.
01/15/10   sa      Added support for +CPIN,^CPIN and +CLCK for RUIM cards.
                   correcting COPS response. 
12/15/09   nc      Featurisation changes for LTE.
12/8/09    vg      Fixed network operator name issue.
12/08/09   nc      Added support to display an incoming call as +CCWA when a held 
                   held call is present.
11/30/09   bs      Added +COPS support for LTE.
12/07/09   nc      Added support for <E-UTRAN_AcT> parameter for +CPOL in LTE.
10/05/09   ua\bs   Fixed +COPS issue.
11/02/09   sa      Replacing snprintf with std_snprintf.
10/30/09   nc      Limiting argument size to 1 and Returning OK after 
                   STOP_CONT_DTMF_CONF from CM for +VTS.
09/09/09   bs      Fixed Klocwork criticals.
09/22/09   vrk	   Merged LTE changes.
09/09/09   ua      Added support for EONS (spec 22.101).
08/21/09   bs      Fixed +CHLD corner case issue.
08/05/09   nc      Fixed the Input length of Passwords for +CPWD.
07/14/09   bs      Added support for $CREG command.
06/11/09   nc      Modified the waiting call end using +CHUP to 
                   reflect the correct cause code.
06/04/09   bs      Fixed +CPWD test command.
06/29/09   vg	   Replacing MSG_XXX with MSG_SPRINTF_X.
04/29/09   ua      Fixed compiler warnings. 
04/20/09   ua      Fixed lint errors.
04/16/09   sa      Removed CLIR val updation as per S65 phone's behavior.
03/20/09   ss      Fixed lac id display for creg.
01/19/09   bs      Fixed +COPS issue associated with DSAT_CFUN_CARD_POWER_CTL enabled.
01/20/09   nc      Fixed CPUC Response for Floating point output.
01/12/09   bs      Fixed +CCFC number type issue.
12/29/08   nc      Added support for +VTS Command
12/12/08   ua      Fixed Off target lint errors.
11/28/08   bs      Changed DSM LARGE item to SMALL.
11/28/08   ss      Off target Lint fix.
10/23/08   bs      Added support for 1X AT Phonebook commands.
10/18/08   bs      Fixing Featurization issues.
10/13/08   bs      Fixing 6800 compilation issues.
09/03/08   bs      Fixed Alignment issues with MDM8200.
09/08/08   bs      Fixed +COPS command for manual mode.
09/05/08   nc      Fixed +CR result reporting issue when auto answer is OFF.
07/21/08   bs      Added support for +CREG=2 command.
04/25/08   bs      Fixed +CLCK query command for personalization facilities. 
03/24/08   bs      Fixed Klocwork criticals.
03/21/08   sa      Set network access technology to automatic if not given by +COPS.
01/25/08   bs      Fixing COPS test command behaviour on SMS arrival scenario.
01/22/08   sa      Fixed +CLCK and +CPIN issues related with SIM PIN2.
11/04/07   pp      Lint low - fixes.
10/12/07   sa      Correcting COPS issues.
09/27/07   sa      Modified dsat_send_cr_result not to change ds3g_siolib_active_port.
09/25/07   ss      Fixed lint high errors.
09/21/07   sa      Fixed +CLCC reporting when call is in set-up indication phase.
08/24/07   ar      Fix feature wrapping for non-GCSD builds.
07/27/07   ar      Added support for UCSD API updating RLP parameters.
07/18/07   sa      Fixed feature wrap errors for GSM 1x builds.
06/22/07   sa      Added dsat_bsg_extra_conversion_table for conversion of basic service 
                   codes to class parameter which are not present in bsg_conversion_table.
06/14/07   sa      Corrected +CHLD not to send multiple result codes 
                   in ERROR scenarios.
05/25/07   ua      Verify the password when provided, irrespective of the 
                   SIM PIN2 status for +CPUC command. 
05/24/07   ss      +CPUC now allows only quoted strings as arguments.
05/23/07   ua      Call RAB release stack only when SMD is established.
05/18/07   sa      Corrected abort handlers to send response to TE only when
                   it is not in the NOT_ABORTABLE state.
05/17/07   ss      Moved to MMGSDI APIs for pin status operations. 
04/23/07   pp      Lint Medium fixes.
04/19/07   pp      Corrected setting of dsat_cli_presence flag in 
                   dsatetsicall_report_clip[colp]_result functions.
04/12/07   ua      Corrected CR result code to send it to answerport
                   when auto answer is choosen.
04/05/07   ua      Added support for COPS=2 (deregistration )
04/04/07   sa      Correcting COPS abort handling.
03/28/07   sa      Correcting +CHLD for 2x send.
03/21/07   sa      Add support for BS code not being sent in case of class 255 
                   to map to All tele and bearerservices of MMI code and lint 
                   fix corrections.
03/02/07   sa      Added outgoing voice call support when there is an active call  
                   for ATD command.
01/29/06   ua      Added support for GSM 7bit '@' character (0x00).
02/13/07   sa      Fixed issues related to MULTIPORT support.
02/15/07   ua      Added new phone book "FD" support.
02/15/07   ss      Fixed lint high errors
02/14/07   ph      dsatutil_reset_password() now requires total buffer size
02/13/07   sa      Correcting +CHLD command.
02/13/07   pkp     Fixed RVCT compiler warnings.
01/30/07   ss      Replaced banned string API calls.
12/14/06   sa      Fixed +CLIP <CLI validity>.
11/29/06   ua      CLCK deactivation procedure is called for deactication instead of
                   permanent disable for network personalization 
11/03/06   snb     Dual processor changes.
08/01/06   snb     Clear query_mode on failure.
07/11/06   ua      CACM/CAMM modifications according to the new CM API's.
                   PIN2 verification made mandatory for CACM/CAMM commands 
04/07/06   snb     Use dsatvoice_go_to_connecting_cmd_ext() interface.
02/27/06   snb     Allow for 2 or 3 digit MNC in PLMN.
02/21/06   sa      Merged from Sirius Branch
                   -Correct +CPOL display.
                   -Added +CLIR support
01/19/06   ua      Add support for +CTFR command
01/16/06   ua      Add support for +CDIP command
01/06/06   snb     Check for SIM PIN2 on slot selected by $QCSLOT command.
05/12/06   ua      Function dsatetsicall_display_pref_networks wrapped
                   under FEATURE_MMGSDI
05/08/06   ua      Eliminating the use of gsdi interface for CPOL command. 
                   dsatetsime_get_num_pplmn_rec is removed.
02/27/06   snb     Allow for 2 or 3 digit MNC in PLMN 
12/17/05   snb     Correct call history entry and Lint issues.
12/09/05   ar      Permit +CUSD to send empty USSD data string.
12/08/05   snb     Minor correction during addition of IPV6 support.
11/30/05   snb     Add support for +CGCMOD command.
11/11/05   ar      Return immediately to command mode for voice calls.
11/09/05   snb     Correct FEATURE_ETSI_PBM wrapping.
11/08/05   ar      Add use of BREW serving system query callbacks.  Handle 
                   async responses better.
09/23/05   snb     Add call ID to CM in-call supplementary service calls 
                   in +CHLD command handler, correct +CCFC response.
09/14/05   tkk     Corrected basic services code for +CLIP & +COLP commands.
09/07/05   ar      Added dsatetsicall_init_call().
08/15/05   snb     Fix multiple response problem when RAB reestablished.
08/03/05   hap     Modified dsatetsime_ld_save to avoid making duplicate 
                   entries in call history
07/25/05   snb     Add external RAB event handler function to support 
                   WCDMA-mode $QCDGEN.
06/14/05   ar      Return error on if +CPUC missing first two params.
05/05/05   iv      Added call id to sequence number mapping for +CLCC
04/29/05   ar      Add support for +CEER command.
04/27/05   ar      Add support for +CV120 command.
04/22/05   snb     Changes to track call sequence number as described in 3GPP 
                   TS 22.030 section 6.5.5.1 and required by +CHLD command.
04/19/05   tkk     Removed resetting of CMUT status.
04/19/05   dvp     Added a global to capture the AT cmd in execution.
04/12/05   ar      Add support for +COPS access technology selection.
04/06/05   hap     Corrections for +CSSN command
04/05/05   ar      Add support for +CIND indicators.
04/05/05   iv      Modified +CLCC to support CS data calls.
04/01/05   ar      Remove FEATURE_DSAT_COPS_ALWAYS_REPORT_HOME code.
03/30/05   tkk     Removed extra comma during number reporting.
03/30/05   iv      Fixed bugs in +CPOL.
03/29/05   ar      Minor adjustments for +COPS command handler.
03/15/05   dvp     Fixed bugs in +CLCK(personalization).
03/11/05   snb     Redo voice call LD entry fix and lint corrections.
02/28/05   hap     Added support for +CSSN command
02/21/05   dvp     Added support for Personalization facility in +CLCK
02/14/05   dvp     Removed compilation warning.
02/10/05   sb      Accessories related changes.
02/02/05   tkk     Added support for +CLIR command and generalized abort 
                   handler to include (+CLIR, +COLP and +CLIP).
02/03/05   iv      Added support for +CPOL command.
01/31/05   iv      Added support for +COPN command.
01/27/05   pdv     Merge from Sirius-ATCoP development.
01/27/05   pdv     Rebase from Mainline.
01/20/05   tkk     Incorporated +CLIP abort handling.
01/05/05   ar      Code review action items.
01/05/05   iv      Added support for +CLCC command
01/05/05   snb     Correct search for waiting and connecting voice calls,
                   make LD entry for voice calls as OEM_ no longer does.
12/30/04   tkk     Added support for +CLIP, +COLP commands.
12/29/04   snb     Further changes for new character sets, +CGACT response fix.
12/15/04   snb     Add +CHUP to hangup UI voice calls and make some variables
                   external.
12/08/04   snb     Correct number_type setting.
12/07/04   ar      Add support for +COPS command.
12/06/04   snb     Initialize number_plan on +CCFC write command.
11/19/04   tkk     Reseting voice muting after the call is done in 
                   "dsatetsicall_call_event_end".
11/18/04   snb     Add +CSCS character set support and lint corrections.
10/04/04   snb     Fix +CGACT response problem.
11/09/04   ar      Add support for +CPUC.
10/15/04   ar      Add Advice of Charge support.
09/03/04   snb     Add +CHLD support.
05/12/04   snb     Fix +CGACT response when deactivating contexts activated via
                   embedded sockets.
04/07/04   ar      Add support for setting default RLP version from NV.
03/19/04   snb     Added support for +CCWA command.
11/07/03   snb     Fix out of order responses due to local formatted response
                   buffers.
10/23/03   ar      Use CSData +CBST parameter validation routine.
10/07/03   ar      Add +CREG and +CGREG support
09/30/03   ar      Validate parameter count in +CRLP command handler.
09/04/03   ar      Adjust interface for SupS event repoting routines.
07/29/03   ar      Added command handler and response generator for +CRLP
06/26/03   sb      Moved dsatetsicall_voice_cmd_orig_cb_handler() to common
                   files. Now it is dsatvoice_cmd_orig_cb_handler().
06/09/03   ar      Fix +ES to use validated numeric parameters on test cmd.
06/03/03   ar      +CCFC response number decoding changed to BCD.
05/21/03   snb     Verify chars of +CCFC number parm in set [0-9*#abc] per
                   GSM 04.08 and correctly verify type & satype parms.
05/06/03   snb     Correct +CLCK/+CCFC response on error condition.
04/03/03   ar      Accomodate restructuring of SupS event info.
03/26/03   sb      Allow +CUSD no value default command.
03/25/03   ar      Enforce spec PIN constraints on +CPWD new password.
03/17/03   ar      Move VALID_TOKEN macro to common header file.
                   Fix +CUSD dcs parameter range test. Lint correction.
03/07/03   ar      Remove FEATURE_DATA_ETSI_SUPSERV wrappers
02/25/03   wx      Use mixed_param to implement +ES's parameters
02/25/03   ar      Removed mode switching behavior in +CBST handler
02/20/03   wx      Get rid of spaces for +ES's query result
02/06/03   ar      Fix +CLCK response for SIM action.
01/16/03   ar      Corrections to +CCFC response generation
01/08/03   wx      Added support for +ES and +ESA command
12/09/02   ar      Added support for +CUSD command
12/02/02   ar      Added support for +CPWD command
11/21/02   ar      Added support for +CCUG and +CLCK commands
10/31/02   ar      Added support for +CCFC command
10/28/02   sb      Opened Voice call related handlers (moved to a common file)
09/04/02   ar      Wrap multimode build API changes under FEATURE_DATA_MM
05/07/02   wx      Call ds3g_sio_ri_assert, ds3g_sio_ri_deassert to alert TE
01/28/02   ar      Export +CBST integer values
10/17/01   sb      Created module.

===========================================================================*/


/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"

#include <stringl/stringl.h>


/* This file should be included only in GSM or WCDMA mode */
#ifdef FEATURE_DSAT_ETSI_MODE

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "rex.h"
#include "amssassert.h"
#include "err.h"
#include "msg.h"
#include "cmutil.h"

#if defined(T_WINNT)
#error code not present
#endif /* WINNT */

#include "dsati.h"
#include "dsatact.h"
#include "dsatctab.h"
#include "dsatetsicall.h"
#include "dsatetsictab.h"
#include "dsatetsime.h"
#include "dsatetsicmif.h"
#include "dsatcmif.h"
#include "dsatparm.h"
#include "dsatvoice.h"
#include "ds_cap.h" /* ITC_SPEECH */
#include "mn_cm_exp.h"

#ifdef FEATURE_DSAT_ETSI_DATA
#include "dsatetsipkt.h"
#endif /* FEATURE_DSAT_ETSI_DATA */

#include "ds3gsiolib.h"


#ifdef FEATURE_DATA_WCDMA_PS
#include "dsatvend.h"
#endif /* FEATURE_DATA_WCDMA_PS */

#include "sys_v.h"
#include "dsmsgr.h"
#include "cm_msgr_msg.h"
#include "ds_system_heap.h"

/*===========================================================================

            PUBLIC DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains public definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
#define CREG_DISP_LAC_CELL_ID (2)
#define CGREG_DISP_LAC_CELL_ID (2)
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
#define CGREG_DISP_GPRS_READY_PER_RAU (4)
#ifdef FEATURE_DSAT_LTE
#define CEREG_DISP_TAC_CI (2)
#define CEREG_DISP_TAC_CI_ACTIVE_TIME_PER_TAU (4)
#endif /* FEATURE_DSAT_LTE */
#define MAX_COPN_ALPHA_LEN  128

/*-------------------------------------------------------------------------
    External Variables:
-------------------------------------------------------------------------*/

extern const bsg_conversion_s_type dsat_bsg_conversion_table[];
extern const bsg_conversion_s_type dsat_bsg_extra_conversion_table[];

extern const uint32 dsat_clck_allowed_classes;
extern const dsat_string_item_type dsat_clck_fac_valstr[][8];
extern const dsat_string_item_type dsat_clck_fac_tststr[];
extern const dsat_string_item_type dsat_cpwd_fac_valstr[][8];
extern const mixed_def_s_type * dsat_cops_mixed_dfl[];

#ifdef FEATURE_MMGSDI
#define MAX_CPOL_BUFF_LEN  128
#endif /* FEATURE_MMGSDI */

#ifdef FEATURE_DSAT_EXTENDED_SMS
extern boolean dsat_unicode_response;
#endif /* FEATURE_DSAT_EXTENDED_SMS */

creg_cmd_type creg_cmd_pending;


/*===========================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains local definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/

/*-------------------------------------------------------------------------
    Local variables:
-------------------------------------------------------------------------*/
/* CM serving system state information */
typedef enum net_state_e
{
  DSAT_NET_STAT_UNKNOWN    = 0,   /* Network state unknown */
  DSAT_NET_STAT_AVAILABLE  = 1,   /* Network is available for registration */
  DSAT_NET_STAT_CURRENT    = 2,   /* Network currently registered */
  DSAT_NET_STAT_FORBIDDEN  = 3,   /* Network forbidden registraiton */
  DSAT_NET_STAT_MAX          /* Internal use only */
} dsat_net_state_e_type;
#define MAX_NETWORK_REPORT_LEN 92

#define CPUC_CURCODE_SIM_CSET ALPHA_GSM
#define CPUC_CURCODE_STR_LEN 3
#define CPUC_MAX_PARAM_STR_LEN 20   /* Currency 3 or PPU 18 */ 
#define CPUC_MAX_PPU_ACCUM 4095     /* Largest accumulator supported */ 
#define CPUC_MAX_PPU_EXPN 7         /* Largest exponent supported */ 
#define DSAT_SIM_PADDING          0xFF  /* padding byte used by the sim       */

/* PLMN list stored on ME need to be aborted(TRUE) or not(FALSE) */
LOCAL boolean dsat_abort_plmn_listing = FALSE;

/*-------------------------------------------------------------------------
    Prototypes for local functions:
-------------------------------------------------------------------------*/
LOCAL void etsicall_convert_chrset_todefault
(
  mmgsdi_eons_encoding_enum_type enc_type,
  const byte  *src_data,
  size_t      src_size,
  byte        *dst_data,
  size_t      dst_size,
  size_t      *num_unpacked
);
LOCAL void etsicall_cops_generate_network_response
(
  ds_at_plmn_info        *plmn_info_ptr,
  boolean                 eons_available,
  dsm_item_type          *res_buff_ptr           /*  Place to put response       */
);

LOCAL dsat_net_state_e_type etsicall_find_net_state
(
  const dsat_sys_detailed_plmn_list_info_s_type * plmn_info_ptr,
  dsat_cops_act_e_type * act_ptr
);

LOCAL boolean etsicall_convert_mminfo_oper_name
(
  const uint8  * name_ptr,
  sys_network_name_coding_scheme_type_e_type  in_scheme,
  char         * out_ptr,
  uint8          max_len,
  uint8          encoded_len
);

LOCAL void etsicall_lineid_buf_copy
(
  const uint8            *line_num_buf,
  uint8                   line_num_len
);

LOCAL void etsicall_lineid_subaddr_buf_copy
(
  const uint8            *line_num_buf,
  uint8                   line_num_len
);


LOCAL dsat_result_enum_type etsicall_copn_reenter_handler
(
  ds_command_type* cmd_ptr
);

LOCAL dsat_result_enum_type etsicall_setup_network_selection
(
  const dsati_cmd_type *parse_table,
  const tokens_struct_type *tok_ptr,
  dsm_item_type *res_buff_ptr,
  dsat_num_item_type  prev_mode,
  dsatetsicall_network_pref_s_type * net_pref_ptr
);

LOCAL void etsicall_called_lineid_buf_copy
(
  const uint8            *line_num_buf,
  uint8                   line_num_len
);

LOCAL void dsat_cops_copy_all_categories
(
  dsat_sys_detailed_plmn_list_s_type *plmn_list,
  mmgsdi_plmn_id_type                *plmn_id_list,
  dsat_cops_cmd_idx_e_type            cmd_idx
);

/*-------------------------------------------------------------------------
    Function Definitions:
-------------------------------------------------------------------------*/

/*===========================================================================

FUNCTION  DSATETSICALL_SEND_CR_RESULT

DESCRIPTION
  Sends intermediate service reporting result code to TE or PS protocol
  stack based on response routing provided by response router.

  Should be called from mode specific protocol stack at time during
  connection negotiation that speed and quality of service is determined 
  and before compression and connect result code are sent.
 
DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsatetsicall_send_cr_result
(
  dsat_cr_service_e_type service
)
{
  /* The table of serv_text is according to
     3GPP Table_Size 27.007 Section 6.9
     Service reporting control +CR */
  dsat_num_item_type cr_val ;
  static const struct {
    dsat_cr_service_e_type serv_code;
    char * serv_text;
  } serv_table[] = {
    { DSAT_CR_SERVICE_ASYNC,     "ASYNC"     },
    { DSAT_CR_SERVICE_SYNC,      "SYNC"      },
    { DSAT_CR_SERVICE_REL_ASYNC, "REL ASYNC" },
    { DSAT_CR_SERVICE_REL_SYNC,  "REL SYNC"  },
    { DSAT_CR_SERVICE_GPRS,      "GPRS"      },
    { DSAT_CR_SERVICE_MAX,        NULL       }
  };
  cr_val =(dsat_num_item_type)dsatutil_get_val(
                                             DSATETSI_EXT_CR_IDX,0,NUM_TYPE);
  /* the service reporting is done only when +CR set to be 1 */
  if(cr_val == 1)
  {
    int index = 0;
    char * serv_string;

    dsm_item_type *raw_rsp_ptr, *formatted_rsp_ptr;
    char * buff_ptr;

    /* search through the serv_table for serv_text */
    do
    {
      serv_string = serv_table[index].serv_text;
    } while (serv_table[index++].serv_code != service &&
             serv_string != NULL);
  
    if(serv_string == NULL)
    {
      DS_AT_MSG1_ERROR("Incorrect service type %d", service);
      return;
    }

    /* use dsm buffer to output results */
    raw_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if (NULL != raw_rsp_ptr)
    {
      buff_ptr = (char *) raw_rsp_ptr->data_ptr;
      raw_rsp_ptr->used = (word)snprintf(buff_ptr,raw_rsp_ptr->size,
                                               "+CR: %s", serv_string);

      formatted_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);

      if (NULL != formatted_rsp_ptr)
      {
        /* format the result code and send response */
        dsat_fmt_response( &raw_rsp_ptr, DSAT_COMPLETE_RSP, TRUE,
                           &formatted_rsp_ptr );

        if (NULL != formatted_rsp_ptr)
        {
          /* If auto answer is set and CR is enabled, then there wont be 
             a valid active port to send the CR result, get the port 
             from the auto answer port */
          if ( ds3g_siolib_get_active_port() == DS3G_SIOLIB_PORT_NONE )
          {
            /* If the accessory feature is enabled, inform SIOLIB which port 
             this should go to */
            ds3g_siolib_port_e_type port = ds3g_siolib_get_answer_port();
            if( port == DS3G_SIOLIB_PORT_NONE )
            {
              /* If there is no auto answer port send */
              /* the response to all data ports       */
              port = DS3G_SIOLIB_DATA_PORT;
            }
            ds3g_siolib_set_tx_type( DS3G_SIOLIB_UNSOLICTED_DS_RESULT_CODE, 
                                     port); 
          }
    
          dsatrsp_send_response( formatted_rsp_ptr, FALSE );
        }
      }
    }
  }
} /* dsatetsicall_send_cr_result( ) */

/*===========================================================================

FUNCTION  DSATETSICALL_SEND_CR_RESULT_EX

DESCRIPTION
  Sends intermediate service reporting result code to TE or PS protocol
  stack based on response routing provided by response router.

  Should be called from mode specific protocol stack at time during
  connection negotiation that speed and quality of service is determined 
  and before compression and connect result code are sent.
 
DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsatetsicall_send_cr_result_ex
(
  dsat_cr_service_e_type service,
  ds3g_siolib_port_e_type port 
)
{
  /* The table of serv_text is according to
     3GPP Table_Size 27.007 Section 6.9
     Service reporting control +CR */
  dsat_num_item_type cr_val ;
  static const struct {
    dsat_cr_service_e_type serv_code;
    char * serv_text;
  } serv_table[] = {
    { DSAT_CR_SERVICE_ASYNC,     "ASYNC"     },
    { DSAT_CR_SERVICE_SYNC,      "SYNC"      },
    { DSAT_CR_SERVICE_REL_ASYNC, "REL ASYNC" },
    { DSAT_CR_SERVICE_REL_SYNC,  "REL SYNC"  },
    { DSAT_CR_SERVICE_GPRS,      "GPRS"      },
    { DSAT_CR_SERVICE_MAX,        NULL       }
  };
  cr_val =(dsat_num_item_type)dsatutil_get_val(
                                             DSATETSI_EXT_CR_IDX,0,NUM_TYPE);
  /* the service reporting is done only when +CR set to be 1 */
  if(cr_val == 1)
  {
    int index = 0;
    char * serv_string;

    dsm_item_type *raw_rsp_ptr, *formatted_rsp_ptr;
    char * buff_ptr;

    /* search through the serv_table for serv_text */
    do
    {
      serv_string = serv_table[index].serv_text;
    } while (serv_table[index++].serv_code != service &&
             serv_string != NULL);
  
    if(serv_string == NULL)
    {
      DS_AT_MSG1_ERROR("Incorrect service type %d", service);
      return;
    }
  
    /* use dsm buffer to output results */
    raw_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if ( raw_rsp_ptr == NULL )
    {
      return;
    }

    buff_ptr = (char *) raw_rsp_ptr->data_ptr;
    raw_rsp_ptr->used = (word)snprintf(buff_ptr,raw_rsp_ptr->size,
                                             "+CR: %s", serv_string);

    formatted_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if ( formatted_rsp_ptr == NULL )
    {
      (void)dsm_free_buffer(raw_rsp_ptr);
      return;
    }

    /* format the result code and send response */
    dsat_fmt_response( &raw_rsp_ptr, DSAT_COMPLETE_RSP, TRUE,
                       &formatted_rsp_ptr );


    ds3g_siolib_set_tx_type( DS3G_SIOLIB_UNSOLICTED_DS_RESULT_CODE, 
                               port); 

    dsatrsp_send_response( formatted_rsp_ptr, FALSE );
  }
} /* dsatetsicall_send_cr_result_ex( ) */

/*===========================================================================

FUNCTION  DSATETSICALL_SET_CRC_RESULT

DESCRIPTION
  Produces unformatted incoming call indication or GPRS network request
  for PDP context activation result and returns in DSM item.

  If AT+CRC is 0, only RING is returned.
  If AT+CRC is 1, the extendted format RING <type> is returned.
                  <type> is defined in Section 6.11 of 3GPP TS 27.007

DEPENDENCIES
  None
  
RETURN VALUE
  Pointer to DSM item containing unformatted CRC result.
  
SIDE EFFECTS
  None
===========================================================================*/
dsm_item_type *dsatetsicall_set_crc_result
(
  dsat_result_enum_type crc_code
)
{
  dsm_item_type *raw_rsp_ptr;
  dsat_num_item_type temp_val; 
  dsat_num_item_type crc_val ;
  
  /* +CRING <type> table according to Section 6.11 of 3GPP TS 27.007 */
  static const struct
  {
    dsat_result_enum_type crc_code;
    char * crc_type;
  } crc_table[] =
  {
    { DSAT_CRC_CODE_ASYNC,               "ASYNC"  },
    { DSAT_CRC_CODE_SYNC,                "SYNC"  },
    { DSAT_CRC_CODE_REL_ASYNC,           "REL ASYNC"  },
    { DSAT_CRC_CODE_REL_SYNC,            "REL SYNC"  },
    { DSAT_CRC_CODE_FAX,                 "FAX"  },
    { DSAT_CRC_CODE_VOICE,               "VOICE"  },
    { DSAT_CRC_CODE_VOICE_ASYNC,         "VOICE/ASYNC"  },
    { DSAT_CRC_CODE_VOICE_SYNC,          "VOICE/SYNC"  },
    { DSAT_CRC_CODE_VOICE_REL_ASYNC,     "VOICE/REL ASYNC"  },
    { DSAT_CRC_CODE_VOICE_REL_SYNC,      "VOICE/REL SYNC"  },
    { DSAT_CRC_CODE_ALT_VOICE_ASYNC,     "ALT VOICE/ASYNC"  },
    { DSAT_CRC_CODE_ALT_VOICE_SYNC,      "ALT VOICE/SYNC"  },
    { DSAT_CRC_CODE_ALT_VOICE_REL_ASYNC, "ALT VOICE/REL ASYNC"  },
    { DSAT_CRC_CODE_ALT_VOICE_REL_SYNC,  "ALT VOICE/REL SYNC"  },
    { DSAT_CRC_CODE_ALT_ASYNC_VOICE,     "ALT ASYNC/VOICE"  },
    { DSAT_CRC_CODE_ALT_SYNC_VOICE,      "ALT SYNC/VOICE"  },
    { DSAT_CRC_CODE_ALT_REL_ASYNC_VOICE, "ALT REL ASYNC/VOICE"  },
    { DSAT_CRC_CODE_ALT_REL_SYNC_VOICE,  "ALT REL SYNC/VOICE"  },
    { DSAT_CRC_CODE_ALT_VOICE_FAX,       "ALT VOICE/FAX"  },
    { DSAT_CRC_CODE_ALT_FAX_VOICE,       "ALT FAX/VOICE"  },
    { DSAT_CRC_CODE_GPRS,                "GPRS"  },
    { DSAT_CRC_CODE_MAX,                 NULL }
  };
  crc_val =(dsat_num_item_type)dsatutil_get_val(
                                             DSATETSI_EXT_CRC_IDX,0,NUM_TYPE);
  /* crc extended format is enabled */
  if(crc_val == 1)
  {
    int index = 0;
    char *crc_type_string = NULL;
    
    /* search the crc type table for the extended format 
       type field */
    do
    {
      crc_type_string = crc_table[index].crc_type;
    } while ( crc_table[index++].crc_code != crc_code &&
              crc_type_string != NULL );

    if( crc_type_string == NULL )
    {
      DS_AT_MSG1_ERROR("Incorrect crc result code %d", crc_code);
      return NULL;
    }

    /* produce the extended format for incoming call indication 
       or GPRS network request for PDP context activation */
    raw_rsp_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
    if (NULL != raw_rsp_ptr)
    {
      raw_rsp_ptr->used = (word) snprintf( (char *) raw_rsp_ptr->data_ptr,
                                                  raw_rsp_ptr->size,
                                                  "+CRING: %s",
                                                  crc_type_string );
    }
  }
  else /* crc extended format is disabled */
  {
    temp_val = (dsat_num_item_type) dsatutil_get_val(DSAT_BASIC_V_IDX,0,NUM_TYPE);
    raw_rsp_ptr = dsatrsp_set_basic_result_code( DSAT_RING,(boolean)temp_val);
  }

  return raw_rsp_ptr;
  
} /* dsatetsicall_set_crc_result( ) */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CHUP_CMD

DESCRIPTION
  This is the command handler function for +CHUP.

  This function sends request to CM to end current ETSI voice calls for
  action command.

  Return OK for test command.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_ASYNC_CMD : if the action command succeeds.
  DSAT_OK        : if there is no active voice call or if this
                   is a test command.
  DSAT_ERROR     : if the action command fails.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_chup_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result;
  dsatetsicall_call_state_info  *call_val = NULL;

  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  /*---------------------------------------------  
    There is no argument. Assume default value  
  ----------------------------------------------*/
  if (tok_ptr->op == NA)
  {
    uint8 num_calls = 0;
    cm_call_id_type call_ids[CM_CALL_ID_MAX];
    uint8 index;
	
    memset ((void*)call_ids, CM_CALL_ID_INVALID, sizeof(call_ids));
      
    /* Waiting calls need to end using call_cmd_answer with reply as false*/
    if( call_val->etsicall_wait_call_present )
    {
      etsicall_cmd_pending = CMD_CHUP;
      if( dsatcmif_answer_voice_call(call_val->etsicall_wait_call_id,
	  	                              FALSE,
	  	                              voice_state[call_val->etsicall_wait_call_id].call_mode) )
      {
        result = DSAT_ASYNC_CMD;
      }
      else
      {
        etsicall_cmd_pending = CMD_NONE;
        DS_AT_MSG0_ERROR("End call request failed");
        result = DSAT_ERROR;
        return result;
      }
    }

    /* in ETSI builds active and held call lists are maintained for +CHLD
       command but these types must be searched for */
    for ( index = 0; 
          index < CM_CALL_ID_MAX; 
          index++ )
    {
      if ( voice_state[index].state == DSAT_VOICE_STATE_CONNECTING )
      {
        call_ids[num_calls++] = index;
      }
    }

    /* If any voice calls are active or held */
    if ( num_calls > 0 ||
         call_val->etsicall_num_active_calls != 0 ||
         call_val->etsicall_num_held_calls != 0 ) 
    {
      /* 27.007 describes +CHUP command as ending "current" GSM/UMTS call.
         "current" call could be a multiparty call. Additionally
         22.030, describing MMI states "The use of END key shall release all 
         calls in progress" and in 6.5.5.6 clarifies END key should terminate
         active and held calls. This is the behavior emulated by +CHUP */

      /* Fill call_ids[] with all active & held voice calls that 
         should be ended by +CHUP */
      if ( call_val->etsicall_num_active_calls )
      {
        for ( index = 0; (index < call_val->etsicall_num_active_calls&& index < CM_CALL_ID_MAX &&
               num_calls < CM_CALL_ID_MAX); index++ )
        {
          call_ids[num_calls++] = call_val->etsicall_active_call_ids[index];
        }
      }

      if ( call_val->etsicall_num_held_calls )
      {
        for ( index = 0; (index < call_val->etsicall_num_held_calls && index < CM_CALL_ID_MAX &&
                          num_calls < CM_CALL_ID_MAX ); index++ )
        {
          call_ids[num_calls++] = call_val->etsicall_held_call_ids[index];
        }
      }

      etsicall_cmd_pending = CMD_CHUP;

      /* Make CM call to release them all */
      if ( dsatcmif_end_calls(num_calls, &call_ids[0]) )
      {
        /* the command callback function will be called */
        result = DSAT_ASYNC_CMD;
      }
      else
      {
        etsicall_cmd_pending = CMD_NONE;
        DS_AT_MSG0_ERROR("End call request failed");
        result = DSAT_ERROR;
      }
    }
    else
    {
      /* +CHUP is used to hangup voice call.  If there is no
         active call or current call type is not voice call,
         return ok. 
         Spec does not specify what to retrun if
         the ph is not connected.
         This implementation follows ATH's behavior. */
      result = DSAT_OK;
    }
  }

  /*----------------------------------------------------------------
   Test command.
  -----------------------------------------------------------------*/
  else if ( tok_ptr->op == (NA|EQ|QU) )
  {
    /* we support this command */
    result = DSAT_OK;
  }

  /* other commands are illegal */
  else
  {
    result = DSAT_ERROR;
  }

  return result;
} /* dsatetsicall_exec_chup_cmd */

/*===========================================================================

FUNCTION DSATETSICALL_VOICE_DIAL_CMD

DESCRIPTION
  Handle atd voice dial commands.  This function is called by 
  dsatact_exec_atd_cmd and me_dd_dial when dial string has ;.

  This function initiates a voice call and goes to DIALING state.

DEPENDENCIES

RETURN VALUE
  DSAT_ASYNC_CMD : If the command succeeds.  CM will call the cmd cb 
                   function later to report status.
  DSAT_ERROR:      If the command fails.

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_voice_dial_cmd
(
  const dsati_dial_str_type * dial_str        /* containing dial string 
                                                 and its attribs*/
)
{
  dsat_result_enum_type result;
  dsatetsicall_call_state_info  *call_val = NULL;

  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  /* allow ATD<str>; only when no incoming call is present */
  if ( !call_val->etsicall_wait_call_present )
  {
    cm_call_id_type call_id = 0;

    if ( dsatetsicmif_initiate_voice_call(dial_str, &call_id) )
    {
      dsatvoice_go_to_connecting_cmd_ext( call_id, VOICE_CMD_ATD );

      /* the command callback function will be called */
      result = DSAT_ASYNC_CMD;
    }
    else
    {
      /* fail it, release atcop cmd processor */
      call_val->etsicall_was_call_active = FALSE;
      result = DSAT_ERROR;
    }
  }
  else
  {
    result = DSAT_ERROR;
  }
  
  return result;

} /* dsatetsicall_voice_dial_cmd */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CREG_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CREG and +CGREG commands, which manage the parameters
  for network registration reporting.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_creg_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  void               *base_add = NULL;

#if defined(FEATURE_DSAT_LTE) || defined(FEATURE_GSM_RR_CELL_CALLBACK)
  char fmt_string[70];
  dsat_cops_act_e_type current_act;
#endif /* (FEATURE_DSAT_LTE) || (FEATURE_GSM_RR_CELL_CALLBACK) */

  dsatcmif_servs_state_info  *ph_val = NULL;

#ifdef FEATURE_DSAT_LTE
  dsati_mode_e_type  sys_mode = dsatcmdp_get_current_mode();
  dsat_num_item_type cereg_val = 0;
  dsat_num_item_type cereg_display = 0;
 #endif /*FEATURE_DSAT_LTE */

  dsat_num_item_type cgreg_val = 0;
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
  dsat_num_item_type cgreg_display = 0;
#endif /*FEATURE_GSM_RR_CELL_CALLBACK*/
  cm_psm_get_cfg_params_req_s_type cm_psm_get_cfg_params_req;
  memset(&cm_psm_get_cfg_params_req, 0, sizeof(cm_psm_get_cfg_params_req));

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
   Processing for TEST command 
  -----------------------------------------------------------*/
  if ((tok_ptr->op == (NA|EQ|AR)) ||
      (tok_ptr->op == (NA|EQ|QU)) ||
      (tok_ptr->op == (NA)))
  {
    result = dsatparm_exec_param_cmd(
                                     mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr
                                    );

    if((DSAT_OK == result) && (tok_ptr->op == (NA|EQ|AR) || tok_ptr->op == (NA)))
    {
      if(0 == dsatutil_strcmp_ig_sp_case((byte*)"+CREG", (const byte *)parse_table->name))
      {
        dsat_psm_urc_update_bit_mask(DSAT_PSM_URC_CREG, 
                                  DSATETSI_EXT_CREG_IDX, 
                                  0);
      }
      else if(0 == dsatutil_strcmp_ig_sp_case((byte*)"+CGREG", (const byte *)parse_table->name))
      {
        dsat_psm_urc_update_bit_mask(DSAT_PSM_URC_CGREG, 
                                  DSATETSI_EXT_CGREG_IDX, 
                                  0);
      }
      else if(0 == dsatutil_strcmp_ig_sp_case((byte*)"+CEREG", (const byte *)parse_table->name))
      {
        dsat_psm_urc_update_bit_mask(DSAT_PSM_URC_CEREG, 
                                  DSATETSI_EXT_CEREG_IDX, 
                                  0);
      }
    }
  }
  /*--------------------------------------
  Processing for a READ command
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|QU) )
  {
    net_reg_status_e_type reg_state;
#ifdef FEATURE_DSAT_LTE
    if((sys_mode != DSAT_MODE_LTE) &&
       (0 == dsatutil_strcmp_ig_sp_case((byte*)"+CEREG", (const byte *)parse_table->name)))
    {
        cereg_val =(dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,0,NUM_TYPE);
       /* <stat> 4 unknown (e.g. out of E-UTRAN coverage)
          In this latest case <AcT>, <tac> and <ci> are sent only if available */
      res_buff_ptr->used =
        (word)snprintf((char*)res_buff_ptr->data_ptr,
                                res_buff_ptr->size,
                                "+CEREG: %d,4",cereg_val);
      return result;
    }
#endif /* FEATURE_DSAT_LTE*/

    if((sys_mode != DSAT_MODE_GSM) &&
       (0 == dsatutil_strcmp_ig_sp_case((byte*)"+CGREG", (const byte *)parse_table->name)))
    {
          cgreg_val =(dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGREG_IDX,0,NUM_TYPE);
       /* <stat> 4 unknown (e.g. out of UTRAN coverage)  */
      res_buff_ptr->used =
        (word)snprintf((char*)res_buff_ptr->data_ptr,
                                res_buff_ptr->size,
                                "+CGREG: %d,4",cgreg_val);
      return result;
    }

    /* Determine domain to report based on command name */

    reg_state =
      ((0 == dsatutil_strcmp_ig_sp_case((byte*)"+CGREG", (const byte *)parse_table->name)) || 
       (0 == dsatutil_strcmp_ig_sp_case((byte*)"+CEREG", (const byte *)parse_table->name)))?
      ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] :
      ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS];

    base_add = (void*)dsatutil_get_val(parse_table->cmd_id,0,STR_TYPE);

    if(base_add !=NULL)
    {
    res_buff_ptr->used =
      (word)snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                            "%s: %d,%d",
                            parse_table->name,
                            *(dsat_num_item_type*)base_add,
                            reg_state);
    }
#if defined(FEATURE_DSAT_LTE) || defined(FEATURE_GSM_RR_CELL_CALLBACK)
    current_act = ph_val->dsat_net_reg_state.act;
#endif /* (FEATURE_DSAT_LTE) || (FEATURE_GSM_RR_CELL_CALLBACK) */

#ifdef FEATURE_GSM_RR_CELL_CALLBACK
    if(0 == dsatutil_strcmp_ig_sp_case((byte*)"+CREG", (const byte *)parse_table->name))
    {
    
      /* location id, cell id is required only when CREG = 2*/
      /* Cell ID should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called
         for +CREG */
      /* Display Cell id and location id only when camped */
      if ((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CREG_IDX,
                         0,NUM_TYPE) == CREG_DISP_LAC_CELL_ID)
      {
        /* +CREG requires only lac and cell_id */
        if((ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_HOME)||
            (ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_ROAMING))
        {
          if((ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
              (ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF))
          {
            (void) snprintf(fmt_string,
                            sizeof(fmt_string),
                            ",\"%X\",\"%X\",%d",
                            ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                            (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                            current_act);
            res_buff_ptr->used += 
              (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                 res_buff_ptr->size - res_buff_ptr->used,
                                 "%s",fmt_string );
          
          }
          else if((ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
              (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac != 0XFFFF))
          {
            (void) snprintf(fmt_string,
                            sizeof(fmt_string),
                            ",\"%X\",\"%X\",%d",
                            ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac,
                            (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                            current_act);
            res_buff_ptr->used += 
              (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                 res_buff_ptr->size - res_buff_ptr->used,
                                 "%s",fmt_string );
          }
        }
      }
    }
    else if(0 == dsatutil_strcmp_ig_sp_case((byte*)"+CGREG", (const byte *)parse_table->name))
    {
    
      /* location id, cell id is required only when CGREG = 2*/
      /* Cell ID should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called
         for +CGREG */
      /* Display Cell id and location id only when camped */
	  cgreg_display = (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGREG_IDX, 0,NUM_TYPE);

      if (cgreg_display == CGREG_DISP_LAC_CELL_ID || cgreg_display == CGREG_DISP_GPRS_READY_PER_RAU )
      {
      
        /* +CGREG requires only lac and cell_id */
        if(((ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
          (  ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
          ((ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF)&&
           (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code != 0xFF)))
        {
        
          if (cgreg_display == CGREG_DISP_LAC_CELL_ID)
          {
          
            (void) snprintf(fmt_string,
                                sizeof(fmt_string),
                                ",\"%X\",\"%X\",%d,\"%X\"",
                                ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                                (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                                current_act,
                                ph_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code);
            res_buff_ptr->used += 
              (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                   res_buff_ptr->size - res_buff_ptr->used,
                                   "%s",fmt_string );
          }
          else
          {

            cm_psm_get_cfg_params_req.user_config = FALSE;
            if(!ds_msgr_snd_msg_send(
                MM_CM_PSM_GET_CFG_PARAMS_REQ,
                (msgr_hdr_struct_type *)&cm_psm_get_cfg_params_req,
            	    sizeof(cm_psm_get_cfg_params_req)))
            {
              result = DSAT_ERROR;
            }
            else
            {
            
              SET_PENDING(DSATETSI_EXT_CGREG_IDX, 0, DSAT_PENDING_CGREG_READ)
              result = DSAT_ASYNC_CMD;
            } 					  
          }
        }
      }
    }
#ifdef FEATURE_DSAT_LTE
    else if((sys_mode == DSAT_MODE_LTE) && 
		    (0 == dsatutil_strcmp_ig_sp_case((byte*)"+CEREG",(const byte *) parse_table->name)))
#endif /* FEATURE_DSAT_LTE */
#else

    if((sys_mode == DSAT_MODE_LTE) &&
       (0 == dsatutil_strcmp_ig_sp_case((byte*)"+CEREG",(const byte *) parse_table->name)))
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
#ifdef FEATURE_DSAT_LTE
    {
    
      /* Routing area code, location id, cell id is required only when CGREG = 2*/
      /* Routing area code, location id and Cell ID  should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called for +CEREG */
      cereg_display = (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,
                      0,NUM_TYPE);
      if( cereg_display == CEREG_DISP_TAC_CI ||
          cereg_display == CEREG_DISP_TAC_CI_ACTIVE_TIME_PER_TAU )
      {
      
        if(((ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
          ( ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
          ((ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac != 0XFFFF)))
        {
        
          if( cereg_display == CEREG_DISP_TAC_CI)
	  {
	  
            (void) snprintf(fmt_string,
                                sizeof(fmt_string),
                                ",\"%X\",\"%X\",%d",
                                ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac,
                                (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                                current_act);
            res_buff_ptr->used += 
              (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                 res_buff_ptr->size - res_buff_ptr->used,
                                 "%s",fmt_string );
          }
          else
          {
          
            cm_psm_get_cfg_params_req.user_config = FALSE;
            if(!ds_msgr_snd_msg_send(
                MM_CM_PSM_GET_CFG_PARAMS_REQ,
                (msgr_hdr_struct_type *)&cm_psm_get_cfg_params_req,
                sizeof(cm_psm_get_cfg_params_req)))
            {
              result = DSAT_ERROR;
            }
            else
            {
            
              SET_PENDING(DSATETSI_EXT_CEREG_IDX, 0, DSAT_PENDING_CEREG_READ)
              result = DSAT_ASYNC_CMD;
            }		    		    
          }
        }
      }
    }
#endif  /* FEATURE_DSAT_LTE */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
}

/*===========================================================================

FUNCTION DSATETSICALL_GET_NET_REG

DESCRIPTION
  This function return last reported domain.

DEPENDENCIES
  None
  
RETURN VALUE
  Domain Net registation status

SIDE EFFECTS
  None
  
===========================================================================*/

net_reg_status_e_type  dsatetsicall_get_net_reg
( 
  net_reg_domain_e_type  domain
)
{

  net_reg_status_e_type net_reg_stat = DSAT_NET_REG_NONE;
  dsatcmif_servs_state_info  *ph_val = NULL;
  
  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);
  net_reg_stat = ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[domain];

  return net_reg_stat;
} /*dsatetsicall_get_net_reg*/

/*===========================================================================

FUNCTION DSATETSICALL_REPORT_CREG_RESULT

DESCRIPTION
  This function generates the unsolicited result code for registration
  commands +CREG and +CGREG.  The command parameter <n> controls whether
  results are presented or suppressed.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_report_creg_result 
(
  dsat_creg_report_e_type report_creg
)
{
  dsm_item_type * res_buff_ptr = NULL;
  dsat_num_item_type is_creg_reported = FALSE;
  const char *creg_name = "+CREG";
  dsati_mode_e_type  curr_mode = dsatcmdp_get_current_mode();

#if defined(FEATURE_GSM_RR_CELL_CALLBACK) || defined(FEATURE_DSAT_LTE)
  char fmt_string[70];
  dsat_cops_act_e_type current_act;
  cm_psm_get_cfg_params_req_s_type cm_psm_get_cfg_params_req;
#endif /* FEATURE_GSM_RR_CELL_CALLBACK || FEATURE_DSAT_LTE */

  dsatcmif_servs_state_info  *ph_val = NULL;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);
  curr_mode = dsatcmdp_calculate_curr_mode(); 
  DS_AT_MSG2_HIGH("dsatcmdp_calculate_curr_mode mode is %d report_creg %d ",curr_mode,report_creg);
#ifdef FEATURE_DSAT_LTE 
  if(report_creg & REPORT_CGREG)
  {
    report_creg |= REPORT_CEREG;
  }
#endif /* FEATURE_DSAT_LTE */

#if defined(FEATURE_GSM_RR_CELL_CALLBACK) || defined(FEATURE_DSAT_LTE)
  current_act = ph_val->dsat_net_reg_state.act;
#endif /* FEATURE_GSM_RR_CELL_CALLBACK || FEATURE_DSAT_LTE */

  /* Report CS domain (+CREG) response */
  if ( 0 < (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CREG_IDX,
                   0,NUM_TYPE)) 
  {
    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
    if (NULL == res_buff_ptr)
    {
      return;
    }
    if((report_creg & REPORT_CREG))
    {
      res_buff_ptr->used =
        (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                            "%s: %d",
                            creg_name,
                            ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]);
      is_creg_reported = TRUE;
    }
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
    /* location id, cell id is required only when CREG = 2*/
    /* Cell ID should be in  hex format*/
    /* cmd_name variable is just to differentiate if this is called
       for +CREG */
    if ((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CREG_IDX,
                                         0,NUM_TYPE) == CREG_DISP_LAC_CELL_ID)
    {
      /* +CREG displays lac and cell_id only when camped */
      if((ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_HOME)||
          (ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_ROAMING))
      {
        if(((ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
            (ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF) &&
            (current_act != DSAT_COPS_ACT_MAX)) &&
            (report_creg & ( REPORT_CREG | REPORT_CREG_LAC | REPORT_CREG_CELL_ID)))
        {
          if((report_creg & REPORT_CREG) != REPORT_CREG)
          {
            res_buff_ptr->used =
             (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                              "%s: %d",
                              creg_name,
                              ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]);
          }
          (void) snprintf(fmt_string,
                            sizeof(fmt_string),
                            ",\"%X\",\"%X\",%d",
                            ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                            (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                            current_act);
          res_buff_ptr->used += 
            (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                               res_buff_ptr->size - res_buff_ptr->used,
                               "%s",fmt_string );
          is_creg_reported = TRUE;
        }
        else if(((ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
             (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac != 0XFFFF) &&
             (current_act != DSAT_COPS_ACT_MAX)) &&
               (report_creg & ( REPORT_CREG | REPORT_CREG_LAC | REPORT_CREG_CELL_ID)))
        {
          if((report_creg & REPORT_CREG) != REPORT_CREG)
          {
            res_buff_ptr->used =
             (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                                "%s: %d",
                                creg_name,
                                ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]);
          }
          (void) snprintf(fmt_string,
                              sizeof(fmt_string),
                                ",\"%X\",\"%X\",%d",
                                ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac,
                                (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                                current_act);
          res_buff_ptr->used += 
            (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                 res_buff_ptr->size - res_buff_ptr->used,
                                 "%s",fmt_string );
          is_creg_reported = TRUE;
        }
      }
    }
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
  }

  /* Report PS domain (+CGREG) response */
  if (0 < (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGREG_IDX,
               0,NUM_TYPE))
  {
    if(curr_mode == DSAT_MODE_GSM)
    {
      if((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGREG_IDX,
			  0, NUM_TYPE)== CGREG_DISP_GPRS_READY_PER_RAU)
      {
        if(!(CHECK_PENDING(DSATETSI_EXT_CGREG_IDX, 0, DSAT_PENDING_CGREG_READ)))
        {
          cm_psm_get_cfg_params_req.user_config = FALSE;
          if (!ds_msgr_snd_msg_send(MM_CM_PSM_GET_CFG_PARAMS_REQ,
				  (msgr_hdr_struct_type *)&cm_psm_get_cfg_params_req,
				  sizeof(cm_psm_get_cfg_params_req)))
          {
            DS_AT_MSG0_HIGH("DSAT_ERROR result");
          }
          else
          {
            if(!(creg_cmd_pending & CMD_CGREG_4_URC))
            {
              creg_cmd_pending |= CMD_CGREG_4_URC;
            }
          }
        }
      }
      else
      {
        if ( NULL == res_buff_ptr )
        {
          res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
          if (NULL == res_buff_ptr)
          {
            return;
          }
        }
        else if(is_creg_reported == TRUE)
        {
          res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
          res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
        }

        res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';
        if(report_creg & REPORT_CGREG)
        {
          res_buff_ptr->used =
            (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                             "%s+CGREG: %d",
                             res_buff_ptr->data_ptr,
                             ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]);
          is_creg_reported = TRUE;
        }
#ifdef FEATURE_GSM_RR_CELL_CALLBACK
        /* location id, cell id is required only when CGREG = 2*/
        /* Cell ID should be in  hex format*/
        /* cmd_name variable is just to differentiate if this is called
           for +CGREG */
        if ((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CGREG_IDX,
                                        0,NUM_TYPE) == CGREG_DISP_LAC_CELL_ID)
        {
          /* +CGREG displays lac and cell_id only when camped */
          if(((ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
              (ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
              ((ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
               (ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac != 0XFFFF)&&
               (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code != 0xFF))&&
               (current_act != DSAT_COPS_ACT_MAX)&&
                ((report_creg &( REPORT_CGREG | REPORT_CREG_LAC | REPORT_CREG_CELL_ID))))
          {
            if((report_creg & REPORT_CGREG) != REPORT_CGREG)
            {
              res_buff_ptr->used =
                (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                              "%s+CGREG: %d",
                              res_buff_ptr->data_ptr,
                              ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]);
            }

            (void) snprintf(fmt_string,
                            sizeof(fmt_string),
                            ",\"%X\",\"%X\",%d,\"%X\"",
                            (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
                            (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                            (unsigned int)current_act,
                            ph_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code);
            res_buff_ptr->used += 
              (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                               res_buff_ptr->size - res_buff_ptr->used,
                               "%s",fmt_string );
            is_creg_reported = TRUE;
          }
        }
#endif /* FEATURE_GSM_RR_CELL_CALLBACK */
      }
    }
  }
#ifdef FEATURE_DSAT_LTE
    /* Report PS domain (+CEREG) response */
  
  memset(&cm_psm_get_cfg_params_req, 0, sizeof(cm_psm_get_cfg_params_req));
  if ( 0 < (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,
            0,NUM_TYPE) )
  {
    if(curr_mode == DSAT_MODE_LTE)            
    {
      if((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,
			 0, NUM_TYPE)== CEREG_DISP_TAC_CI_ACTIVE_TIME_PER_TAU)
      {
        if(report_creg &(REPORT_CEREG ) ||
           (((ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
           (ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
           (ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac != 0XFFFF)&&
           (current_act != DSAT_COPS_ACT_MAX)&& 
           (report_creg &( REPORT_CREG_LTE_TAC | REPORT_CREG_CELL_ID))))
         {
          if(!(CHECK_PENDING(DSATETSI_EXT_CEREG_IDX, 0, DSAT_PENDING_CEREG_READ)))
          {
            cm_psm_get_cfg_params_req.user_config = FALSE;
            if (!ds_msgr_snd_msg_send(MM_CM_PSM_GET_CFG_PARAMS_REQ,
				  (msgr_hdr_struct_type *)&cm_psm_get_cfg_params_req,
				  sizeof(cm_psm_get_cfg_params_req)))
            {
              DS_AT_MSG0_HIGH("DSAT_ERROR result");
            }
            else
            {
              if(!(creg_cmd_pending & CMD_CEREG_4_URC))
              {
                creg_cmd_pending |= CMD_CEREG_4_URC;
              }
            }
          }
        }
      }
      else
      {
        if ( NULL == res_buff_ptr )
        {
          res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, TRUE);
          if (NULL == res_buff_ptr)
          {
            return;
          }
        }
        else if(is_creg_reported == TRUE)
        {
          res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
          res_buff_ptr->data_ptr[res_buff_ptr->used++] = '\n';
        }
        
        res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';
        if(report_creg & REPORT_CEREG)
        {
          res_buff_ptr->used =
          (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                               "%s+CEREG: %d",
                               res_buff_ptr->data_ptr,
                                ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]);
        is_creg_reported = TRUE;
      }
      /* Routing area code, location id, cell id is required only when CEREG = 2*/
      /* Routing area code, location id and Cell ID  should be in  hex format*/
      /* cmd_name variable is just to differentiate if this is called for +CEREG */
      if((dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CEREG_IDX,
                  0,NUM_TYPE)== CEREG_DISP_TAC_CI)
      {
      /* +CEREG displays tac and cell_id only when camped */
        if(((ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_HOME)||
          (ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_ROAMING))&&
          ((ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id != 0xFFFFFFFF)&&
           (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac != 0XFFFF)&&
           (current_act != DSAT_COPS_ACT_MAX))&&
            ((report_creg &(REPORT_CEREG | REPORT_CREG_LTE_TAC | REPORT_CREG_CELL_ID))))
        {
          if((report_creg & REPORT_CEREG)!= REPORT_CEREG)
          {
            res_buff_ptr->used =
             (word) snprintf((char*)res_buff_ptr->data_ptr,res_buff_ptr->size,
                                "%s+CEREG: %d",
                                 res_buff_ptr->data_ptr,
                                 ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]);
          }

          (void) snprintf(fmt_string,
                                sizeof(fmt_string),
                                ",\"%X\",\"%X\",%d",
                                ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac,
                                (unsigned int)ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
                                current_act);
           res_buff_ptr->used += 
            (word) snprintf((char*)&res_buff_ptr->data_ptr[res_buff_ptr->used],
                                   res_buff_ptr->size - res_buff_ptr->used,
                                   "%s",fmt_string );
           is_creg_reported = TRUE;
	 }
       }
      }
    }
  }
#endif /* FEATURE_DSAT_LTE */

  /* Ensure a response was generated */
  if (NULL != res_buff_ptr)
  { 
   if(is_creg_reported == TRUE)
   {
    /* Send response to TE */
      dsatcmdp_send_urc(res_buff_ptr, DSAT_COMPLETE_RSP);
    }
   else
    {
     /*CREG status not changed*/
      DS_AT_MSG1_HIGH(" Is creg reported:- %d",is_creg_reported);
     (void)dsm_free_buffer(res_buff_ptr);
    }
  }
} /* dsatetsicall_report_creg_result */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CLCK_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CLCK command, which controls the facility lock
  supplementary service acording to 3GPP TS 22.088

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was an problem in executing the command
    DSAT_CMD_ERR_RSP : if there was a problem during aynchronous execution
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_clck_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type            result = DSAT_ASYNC_EVENT;
  mmgsdi_return_enum_type          mmgsdi_status;
  mmgsdi_data_type                 pin_data;
  dsatetsicmif_sups_state_info     *sups_val = NULL;
  dsat_apps_id_e_type              apps_id = dsat_get_current_gw_apps_id(FALSE);
  mmgsdi_session_id_type           session_id = dsat_get_current_gw_session_id(FALSE);
  simlock_set_lock_ck_msg_req_type req_data;
  dsat_perso_user_type             user_data;

  sups_val = dsat_get_base_addr(DSAT_SUPS_VALS, TRUE);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR))
  {
    ss_fl_user_s_type * ssfl_ptr = &sups_val->dsat_ss_cm_data.user_data.opdata.fac_lock;
    dsat_num_item_type temp;
    byte  max_pw_len = 0;
    mixed_def_s_type ** mixed_def_list = 
      (mixed_def_s_type **) parse_table->def_lim_ptr;

    /* Define list of facilities which are restriced to unlock mode, */
    /* as listed in dsat_clck_fac_valstr[] */
    const dsat_string_item_type unlock_only_facs[4][8] =
          { "\"AB\"", "\"AG\"", "\"AC\"", "" };
    
#ifdef FEATURE_DATA_ETSI_PIN
    /* Define list of PIN oriented facilities, as listed in */
    /* dsat_clck_fac_valstr[] */
    const dsat_string_item_type pin_facs[3][8] = { "\"SC\"", "\"FD\"", "" };
    boolean isFDN = FALSE; /* If the request is for FD phone book" */
#ifdef FEATURE_MMGSDI_PERSONALIZATION
    /* Personalization facilities. */
    const dsat_string_item_type
      perso_facs[6][8] = { "\"PN\"", "\"PU\"", "\"PP\"", "\"PC\"", "\"PF\"",
                          "" };
#endif /* FEATURE_MMGSDI_PERSONALIZATION */
    enum { REST_FAC = 0, PIN_FAC, PERSO_FAC } pin_fac = REST_FAC;
#endif /* FEATURE_DATA_ETSI_PIN */
    
    /* Initialize data structure */
    memset (&sups_val->dsat_ss_cm_data.user_data, 0, sizeof(ss_user_data_s_type));
    sups_val->dsat_ss_cm_data.user_data.operation = DSAT_SSOP_FACILITY;
    memset (&req_data, 0, sizeof(simlock_set_lock_ck_msg_req_type));
      
    /* Validate MODE parameter  (no default) */
    if (VALID_TOKEN(1))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[1], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert MODE parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((dsat_num_item_type)DSAT_CLCK_MODE_MAX <= temp)
      {
        DS_AT_MSG0_HIGH("MODE parameter outside range");
        return DSAT_ERROR;
      }
      ssfl_ptr->mode = (clck_mode_e_type)temp;
    }
    else
    {
      DS_AT_MSG0_HIGH("+CLCK MODE parameter mandatory");
      return DSAT_ERROR;
    }

    /* Validate FACILITY parameter  (no default) */
    if (VALID_TOKEN(0))
    {
      /* Search for token in valid list */
      if (PARAM_HIT != dsatutil_srch_list (
                         &temp, 
                         dsat_clck_fac_valstr,
                         tok_ptr->arg[0],
                         tok_ptr->arg_length[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        DS_AT_MSG0_HIGH("Token not in FACILITY list");
        return DSAT_ERROR;
      }
      /* Store position in list */ 
      ssfl_ptr->facility = (ss_fac_e_type)temp;

      /* Ensure ALL facilities used only in unlock mode */
      if ((DSAT_CLCK_MODE_UNLOCK != ssfl_ptr->mode) &&
          (PARAM_HIT == dsatutil_srch_list (
                         &temp,
                         unlock_only_facs,
                         tok_ptr->arg[0],
                         tok_ptr->arg_length[0],
                         ACTION_QUOTE_NO_QUOTE )))
      {
        DS_AT_MSG0_HIGH("FACILITY not allowed in specified mode");
        return DSAT_ERROR;
      }

#ifdef FEATURE_DATA_ETSI_PIN
      /* Search for token in PIN list and set flag */
      if (PARAM_HIT == dsatutil_srch_list (
                         &temp, 
                         pin_facs,
                         tok_ptr->arg[0],
                         tok_ptr->arg_length[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        pin_fac = PIN_FAC;
        max_pw_len =  MMGSDI_PIN_MAX_LEN;
      }
#ifdef FEATURE_MMGSDI_PERSONALIZATION
      else if (PARAM_HIT == dsatutil_srch_list (
                         &temp, 
                         perso_facs,
                         tok_ptr->arg[0],
                         tok_ptr->arg_length[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        pin_fac = PERSO_FAC;
        max_pw_len =  SIMLOCK_CK_MAX;
        ssfl_ptr->facility = (ss_fac_e_type)temp;
      }
#endif /* FEATURE_MMGSDI_PERSONALIZATION */
      else {
        /* Network PIN */
        max_pw_len = MAX_PWD_CHAR;
      }
#endif /* FEATURE_DATA_ETSI_PIN */

    }

    /* Validate PASSWORD parameter  (no default) */
    if (VALID_TOKEN(2))
    {
      /* Test string length */
      temp = (dsat_num_item_type)strlen((char*)tok_ptr->arg[2]);
      if ((dsat_num_item_type)(max_pw_len+2) < temp)
      {
        DS_AT_MSG0_HIGH("Password string too long");
        return DSAT_ERROR;
      }
      /* Strip quotes */
      if (!dsatutil_strip_quotes_out(tok_ptr->arg[2],
                                     ssfl_ptr->passwd,
                                     (word)temp))
      {
        DS_AT_MSG0_HIGH("Problem stripping quotes");
        return DSAT_ERROR;
      }
      /* Clear password */
      dsatutil_reset_password (tok_ptr->arg[2], (word)temp+1);
    }
    
    /* Validate CLASS parameter  (default available) */
    if (VALID_TOKEN(3))
    {
      /* Convert to number */
      if (ATOI_OK != dsatutil_atoi(&temp, tok_ptr->arg[3], 10))
      {
        DS_AT_MSG0_HIGH("Cannot convert CLASS parameter");
        return DSAT_ERROR;
      }
      /* Test for in-range */
      if ((mixed_def_list[3]->def->dflm.upper <  temp) &&
          (mixed_def_list[3]->def->dflm.lower >  temp))
      {
        DS_AT_MSG0_HIGH("MODE parameter outside range");
        return DSAT_ERROR;
      }

      /* See if class in Basice Service Group lookup table */
      if ((dsat_clck_allowed_classes != (dsat_clck_allowed_classes | temp)) &&
          ((dsat_num_item_type)DSAT_SS_CLASS_ALL != temp))
      {
        DS_AT_MSG0_HIGH("Class not mapped to Basic Service Group");
        return DSAT_ERROR;
      }
      
      sups_val->dsat_ss_cm_data.user_data.class = (uint8)temp;
    }
    else
    {
      /* Default */
      sups_val->dsat_ss_cm_data.user_data.class =
        (uint8)mixed_def_list[3]->def->dflm.default_v;
    }

    pin_data.data_ptr = (uint8 *)(char *)ssfl_ptr->passwd;
    pin_data.data_len = (mmgsdi_len_type)strlen((char *)ssfl_ptr->passwd);

#ifdef FEATURE_DATA_ETSI_PIN
    switch (pin_fac)
    {
      case PIN_FAC:
        isFDN = ( (0 == strcmp((char *)tok_ptr->arg[0], "\"FD\""))||
                  (0 == strcmp((char *)tok_ptr->arg[0], "\"fd\"")) );

        /* Initiate GSDI call */
        switch (ssfl_ptr->mode)
        {
          case DSAT_CLCK_MODE_LOCK:
            if (isFDN) 
            { /* Operation is for FD phone book */
              VERIFY_PIN( session_id,
                      MMGSDI_PIN2, 
                      pin_data, 
                      CLCK_MMGSDI_FDN_LOCK );
              if(MMGSDI_SUCCESS == mmgsdi_status)
              {
                result = DSAT_ASYNC_CMD; 
              }
              else 
              { 
                result = DSAT_ERROR; 
              }
            }
            else 
            { /* Operation is for SC */
#ifdef FEATURE_MMGSDI
              result = dsatetsime_set_pin_status(MMGSDI_PIN1, TRUE,
                                                 ssfl_ptr->passwd, apps_id);
#else 
              #error code not present
#endif /* FEATURE_MMGSDI */
            }
            break;
          case DSAT_CLCK_MODE_UNLOCK:
            if (isFDN) 
            { /* Operation is for FD phone book */
              VERIFY_PIN( session_id,
                      MMGSDI_PIN2, 
                      pin_data, 
                      CLCK_MMGSDI_FDN_UNLOCK );

              if(MMGSDI_SUCCESS == mmgsdi_status) 
              {
                result = DSAT_ASYNC_CMD; 
              }
              else 
              { 
                result = DSAT_ERROR; 
              }
            }
            else 
            { /* Operation is for SC */
              result = dsatetsime_set_pin_status(MMGSDI_PIN1, FALSE,
                                                 ssfl_ptr->passwd, apps_id);
            }
            break;
          case DSAT_CLCK_MODE_QUERY:
            if (isFDN) 
            { /* Operation is for FD phone book */
              if (MMGSDI_SUCCESS == mmgsdi_session_get_app_capabilities(
                                            session_id,
                                            dsatme_mmgsdi_perso_req_cb,
                                            (uint32)CLCK_MMGSDI_FDN_QUERY))
              {
                result = DSAT_ASYNC_CMD;
              }
              else 
              {
                DS_AT_MSG0_ERROR("SIM capabilities returned failure ");
                dsatme_set_cme_error(DSAT_CME_SIM_FAILURE, res_buff_ptr);
                return DSAT_CMD_ERR_RSP;
              }
            }
            else 
            { /* Operation is for SC */
              result = dsatetsime_get_pin_status(MMGSDI_PIN1);
            }
            break;
          default:
            DS_AT_MSG0_ERROR("Unsupported MODE parameter");
            return DSAT_ERROR;
        }

        /* Clear password */
        dsatutil_reset_password (ssfl_ptr->passwd,
            sizeof(ssfl_ptr->passwd));

        break;

#ifndef FEATURE_DSAT_LEGACY_GCF_SUPPORT
#ifdef FEATURE_MMGSDI_PERSONALIZATION
      case PERSO_FAC:
        {
          if((DSAT_CLCK_MODE_LOCK == ssfl_ptr->mode) ||
             (DSAT_CLCK_MODE_UNLOCK == ssfl_ptr->mode))
          {
            req_data.ck.simlock_ck_length=
              (uint8)strlen((char*)ssfl_ptr->passwd);
            dsatutil_memscpy(req_data.ck.simlock_ck_data,SIMLOCK_CK_MAX,
                  ssfl_ptr->passwd,req_data.ck.simlock_ck_length);
          }

          req_data.slot = SIMLOCK_SLOT_1;
           
          user_data.slot = req_data.slot;
          
          switch((clck_perso_fac_e_type)ssfl_ptr->facility)
          {
            case DSAT_MMGSDI_PERSO_FAC_PN:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_NW;
              break;
            case DSAT_MMGSDI_PERSO_FAC_PU:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_NS;
              break;
            case DSAT_MMGSDI_PERSO_FAC_PP:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_SP;
              break;
            case DSAT_MMGSDI_PERSO_FAC_PC:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_CP;
              break;
            case DSAT_MMGSDI_PERSO_FAC_PF:
              req_data.category.category_type = SIMLOCK_CATEGORY_3GPP_SIM;
              break;
            default:
              DS_AT_MSG0_HIGH("Invalid facility");
              return DSAT_ERROR;
              break;
          }
          req_data.auto_lock = TRUE; /* Indicates the lock codes are taken from the first SIM card that is inserted */
          req_data.blacklist = FALSE; /* Should be false when autolock is true */
          req_data.num_retries_max = 10;
          req_data.iteration_cnt = 10000;
          
          if( DSAT_CLCK_MODE_LOCK == ssfl_ptr->mode)
          {
            user_data.session_id = session_id;
            user_data.perso_cmd = CPIN_MMGSDI_PERSO_ACT;
            if(SIMLOCK_SUCCESS != simlock_ck_lock(req_data,dsatme_sim_mmgsdi_perso_req_cb,&user_data))
            {
              result = DSAT_ERROR;
            } else {
              /* Flag that the PIN state is being changed */
              dsatme_pending_mmgsdi_command[apps_id] = TRUE;
              result = DSAT_ASYNC_CMD;
            }
          } else if(DSAT_CLCK_MODE_UNLOCK == ssfl_ptr->mode)
          {
            simlock_unlock_device_msg_req_type req_data_unlock;
            memset (&req_data_unlock, 0, sizeof(simlock_unlock_device_msg_req_type));
            req_data_unlock.slot = req_data.slot;

            req_data_unlock.category = req_data.category.category_type;
            req_data_unlock.ck.simlock_ck_length=
              (uint8)strlen((char*)ssfl_ptr->passwd);
            dsatutil_memscpy(req_data_unlock.ck.simlock_ck_data,SIMLOCK_CK_MAX,
                  ssfl_ptr->passwd,req_data_unlock.ck.simlock_ck_length);
            user_data.session_id = session_id;
            user_data.perso_cmd = CPIN_MMGSDI_PERSO_DEACT;
            if(SIMLOCK_SUCCESS != simlock_unlock(req_data_unlock,dsatme_sim_mmgsdi_perso_req_cb,&user_data))
            {
              result = DSAT_ERROR;
            } else {
                    dsatme_pending_mmgsdi_command[apps_id] = TRUE;
                    result = DSAT_ASYNC_CMD;
            }
          } else if(DSAT_CLCK_MODE_QUERY == ssfl_ptr->mode)
          {
            clck_perso_fac = (clck_perso_fac_e_type)ssfl_ptr->facility;
            user_data.session_id = session_id;
            user_data.perso_cmd = CPIN_MMGSDI_PERSO_GET_IND_RSP;
            if(SIMLOCK_SUCCESS != simlock_get_status(dsatme_sim_mmgsdi_perso_req_cb,&user_data))
            {
              result = DSAT_ERROR;
            } else {
              dsatme_pending_mmgsdi_command[apps_id] = TRUE;
              result = DSAT_ASYNC_CMD;
            }
          } else {
              DS_AT_MSG0_ERROR("Unsupported MODE parameter");
              return DSAT_ERROR;
          }
        }
        break;
#endif /* FEATURE_MMGSDI_PERSONALIZATION */
#endif /* FEATURE_DSAT_LEGACY_GCF_SUPPORT */

      default:
#endif /* FEATURE_DATA_ETSI_PIN */
        {
          /* Initiate CM command */
 
#ifdef FEATURE_ATCOP_CM_SUPP
          result = dsatetsicmif_sups_class_action (TRUE);
#endif
        }
#ifdef FEATURE_DATA_ETSI_PIN
    }
#endif /* FEATURE_DATA_ETSI_PIN */
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                res_buff_ptr->size,
                                                "%s: %s",
                                                parse_table->name, 
                                                dsat_clck_fac_tststr);
    result = DSAT_OK;
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_clck_cmd */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CPWD_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CPWD command, which sets new passwords for facility lock
  supplementary service.

  Facility PIN values are restricted to four digits in range 0-9 per 
  3GPP TS 22.004 section 5.2.  SIM PIN values may be 4 to 8 digits in 
  range 0-9 per 3GPP TS 11.11 section 9.3.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cpwd_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_ERROR;
  dsatetsicmif_sups_state_info  *sups_val = NULL;

  sups_val = dsat_get_base_addr(DSAT_SUPS_VALS, TRUE);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR))
  {
    ss_fl_user_s_type * ssfl_ptr = &sups_val->dsat_ss_cm_data.user_data.opdata.fac_lock;
    dsat_num_item_type temp = 0;
    byte  min_pw_len = 0;
    byte  max_pw_len = 0;

#ifdef FEATURE_DATA_ETSI_PIN
    /* Define list of PIN oriented facilities, as listed in */
    /* dsat_cpwd_fac_valstr[] */
    const dsat_string_item_type pin_facs[3][8] = { "\"SC\"", "\"P2\"", "" };
    /* MMGSDI PIN identifiers in same order as above */
    const mmgsdi_pin_enum_type pin_ids[] = {MMGSDI_PIN1, MMGSDI_PIN2};
    mmgsdi_pin_enum_type  pin_id = MMGSDI_MAX_PIN_ENUM;
    boolean pin_fac = FALSE;
#endif /* FEATURE_DATA_ETSI_PIN */
    
    /* WRITE command should have 3 Mandatory Arguments */
    if( tok_ptr->args_found != 3 )
    {
      DS_AT_MSG0_ERROR("Invalid no of Arguments in +CPWD Command");
      return DSAT_ERROR;
    }
    /* Initialize data structure */
    memset (&sups_val->dsat_ss_cm_data.user_data, 0, sizeof(ss_user_data_s_type));
    sups_val->dsat_ss_cm_data.user_data.operation = DSAT_SSOP_FACILITY;
      
    /* Validate FACILITY parameter  (no default) */
    if (VALID_TOKEN(0))
    {
      /* Search for token in valid list */
      if (PARAM_HIT != dsatutil_srch_list (
                         &temp, 
                         dsat_cpwd_fac_valstr,
                         tok_ptr->arg[0],
                         tok_ptr->arg_length[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        DS_AT_MSG0_HIGH("Token not in FACILITY list");
        return DSAT_ERROR;
      }
      /* Store position in list */ 
      ssfl_ptr->facility = (ss_fac_e_type)temp;

#ifdef FEATURE_DATA_ETSI_PIN
      /* Search for token in PIN list and set flag */
      if (PARAM_HIT == dsatutil_srch_list (
                         &temp, 
                         pin_facs,
                         tok_ptr->arg[0],
                         tok_ptr->arg_length[0],
                         ACTION_QUOTE_NO_QUOTE ))
      {
        pin_fac = TRUE;
        pin_id = pin_ids[temp];
        min_pw_len =  MMGSDI_PIN_MIN_LEN;
        max_pw_len =  MMGSDI_PIN_MAX_LEN;
      }
      else
#endif /* FEATURE_DATA_ETSI_PIN */
      {
        /* Network Facility PIN */
        min_pw_len = MAX_PWD_CHAR;
        max_pw_len = MAX_PWD_CHAR;
      }
    }

    /* Validate old PASSWORD parameter  (no default) */
    if (VALID_TOKEN(1))
    {
      /* Strip quotes */
      if ('"' == tok_ptr->arg[1][0])
      {
        if (!dsatutil_strip_quotes_out(tok_ptr->arg[1],
                                       tok_ptr->arg[1],
                                       (word)strlen((char*)tok_ptr->arg[1])))
        {
          DS_AT_MSG0_HIGH("Problem stripping quotes");
          return DSAT_ERROR;
        }
      }
      
      /* Test string length */
      temp = (dsat_num_item_type)strlen((char*)tok_ptr->arg[1]);
      if ( (max_pw_len < temp) || (temp < min_pw_len) )
      {
        DS_AT_MSG1_ERROR("Incorrect OLD Password Length %d",temp);
        return DSAT_ERROR;
      }
      else
      {
        (void)strlcpy ((char*)ssfl_ptr->passwd,
                       (char*)tok_ptr->arg[1], max_pw_len+1);
      }

      /* Clear password */
      dsatutil_reset_password (tok_ptr->arg[1],
                               (word)strlen((char*)tok_ptr->arg[1])+1);
    }
    
    /* Validate new PASSWORD parameter  (no default) */
    if (VALID_TOKEN(2))
    {
      byte * c_ptr;
        
      /* Strip quotes */
      if ('"' == tok_ptr->arg[2][0])
      {
        if (!dsatutil_strip_quotes_out(tok_ptr->arg[2],
                                       tok_ptr->arg[2],
                                       (word)strlen((char*)tok_ptr->arg[2])))
        {
          DS_AT_MSG0_HIGH("Problem stripping quotes");
          return DSAT_ERROR;
        }
      }
      
      temp = (dsat_num_item_type)strlen((char*)tok_ptr->arg[2]);
      if ( (max_pw_len < temp) || (temp < min_pw_len) )
      {
        DS_AT_MSG1_ERROR("Incorrect NEW Password Length %d",temp);
        return DSAT_ERROR;
      }
      else
      {
        (void)strlcpy ((char*)ssfl_ptr->new_passwd,
                           (char*)tok_ptr->arg[2], max_pw_len+1);
      }

      /* Clear password */
      dsatutil_reset_password (tok_ptr->arg[2],
                               (word)strlen((char*)tok_ptr->arg[2])+1);

      
      /* Test string length */
      temp = (dsat_num_item_type)strlen((char*)ssfl_ptr->new_passwd);
      if ((max_pw_len < temp) || (min_pw_len > temp))
      {
        DS_AT_MSG3_HIGH("PIN string outside length bounds [%d-%d]: %d",
                  min_pw_len, max_pw_len, temp);
        return DSAT_ERROR;
      }
      
      /* Verify allowed digits */
      c_ptr = ssfl_ptr->new_passwd;
      while ( '\0' != *c_ptr )
      {
        /* Report error if char not numeric */
        if (!(('0' <= *c_ptr) && ('9' >= *c_ptr)))
        { 
          DS_AT_MSG1_HIGH("PIN char outside range [0-9]: %c",*c_ptr);
          return DSAT_ERROR;
        }
        c_ptr++;
      }
    }

#ifdef FEATURE_DATA_ETSI_PIN
    if (pin_fac)
    {
      /* Prevent null passwords */
      if ('\0' == *ssfl_ptr->new_passwd)
      {
        DS_AT_MSG0_MED("Null PIN password prohibited");
        dsatme_set_cme_error(DSAT_CME_INCORRECT_PASSWORD, res_buff_ptr);
        return DSAT_CMD_ERR_RSP;
      }
      
      /* Initiate GSDI PIN change */
      result = dsatetsime_change_pin (pin_id,
                                      ssfl_ptr->passwd,
                                      ssfl_ptr->new_passwd);
      /* Clear passwords */
      dsatutil_reset_password (ssfl_ptr->passwd,
                               sizeof(ssfl_ptr->passwd));
      dsatutil_reset_password (ssfl_ptr->new_passwd,
                               sizeof(ssfl_ptr->new_passwd));
    }
    else
#endif /* FEATURE_DATA_ETSI_PIN */
    {
      /* Initiate CM command */
    
#ifdef FEATURE_ATCOP_CM_SUPP
      result = dsatetsicmif_sups_change_password();
#endif
    }
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    const struct cpwd_tst_entry
    {
      dsat_string_item_type fac[5];
      dsat_num_item_type len;
    } cpwd_tst_table[] =
    {
      { "\"AB\"",  MAX_PWD_CHAR},
      { "\"AC\"",  MAX_PWD_CHAR},
      { "\"AG\"",  MAX_PWD_CHAR},
      { "\"AI\"",  MAX_PWD_CHAR},
      { "\"AO\"",  MAX_PWD_CHAR},
      { "\"IR\"",  MAX_PWD_CHAR},
      { "\"OI\"",  MAX_PWD_CHAR},
      { "\"OX\"",  MAX_PWD_CHAR},
#ifdef FEATURE_DATA_ETSI_PIN
      { "\"SC\"",  MMGSDI_PIN_MAX_LEN},
      { "\"P2\"",  MMGSDI_PIN_MAX_LEN},
#endif /* FEATURE_DATA_ETSI_PIN */
      { "",        0}
    };
    byte i = 0;

    res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                res_buff_ptr->size,
                                                "%s: ",
                                                parse_table->name);

    while ('\0' != cpwd_tst_table[i].fac[0])
    {
      res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                  res_buff_ptr->size,
                                                  "%s(%s,%d),",
                                                  res_buff_ptr->data_ptr,
                                                  cpwd_tst_table[i].fac,
                                                  cpwd_tst_table[i].len);
      i++;
    }
    /* Overwrite last comma */
    res_buff_ptr->data_ptr[--res_buff_ptr->used] = '\0';
    result = DSAT_OK;
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cpwd_cmd */

/*===========================================================================

FUNCTION DSATETSICALL_EXEC_CUSD_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +CUSD command, which allows control of Unstructured
  Supplementary Service Data (USSD).

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cusd_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
#define MAX_DCS_LIMIT 255
  dsat_result_enum_type result = DSAT_OK;
  dsat_num_item_type cscs_val ;
  dsatetsicmif_sups_state_info  *sups_val = NULL;
  
  sups_val = dsat_get_base_addr(DSAT_SUPS_VALS, TRUE);

  /*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  if (tok_ptr->op == (NA|EQ|AR) ||
      tok_ptr->op == NA)
  {
    ss_us_user_s_type * ssus_ptr = &sups_val->dsat_ss_cm_data.user_data.opdata.ussd;
    dsat_num_item_type temp;
    dsat_num_item_type initial_n;
    dsat_mixed_param_val_type * mixed_val_list = 
      (dsat_mixed_param_val_type *) dsatutil_get_val(parse_table->cmd_id,0,STR_TYPE);
    if(mixed_val_list ==NULL)
    {
      return DSAT_ERROR;
    }

    /* Capture initial <n> setting */
    initial_n = mixed_val_list[0].num_item;

    result = dsatparm_exec_param_cmd(
                                     mode,
                                     parse_table,
                                     tok_ptr,
                                     res_buff_ptr
                                    );
    if (DSAT_OK == result)
    {
      boolean network_op = FALSE;

      /* Initialize SS data structure */
      sups_val->dsat_ss_cm_data.user_data.operation = DSAT_SSOP_USSD;

      switch (mixed_val_list[0].num_item)
      {
        case 0:
        case 1:
          /* Check for USSD string present */
          if (VALID_TOKEN(1))
          {
            /* Process data string (may be empty string) */
	    if ('\0' != mixed_val_list[1].string_item[0])
	    {
	      /* Convert from TE character set, per +CSCA setting, to ME's 
		 internal chset, IRA T.50, fail on inconvertible character */
		 cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,NUM_TYPE);
	      if ( dsatutil_convert_chset( 
		     (const char *)&mixed_val_list[1].string_item[0], 
		     (dsati_chset_type)cscs_val,
		     (const char *)&mixed_val_list[1].string_item[0], 
		     ALPHA_IRA, 
		     MAX_USS_CHAR_ASCII + 1,
		     FALSE ) == NULL )
	      {
		DS_AT_MSG0_HIGH("Inconvertible chars in USSD");
		return DSAT_ERROR;
	      }
            }

            /* Preserve USSD string */
            (void)strlcpy ((char*)ssus_ptr->string,
                               (char*)mixed_val_list[1].string_item,
                               MAX_USS_CHAR_ASCII+1);
            mixed_val_list[1].string_item[0] = '\0';

            /* Determine DCS value (default 0) */
            ssus_ptr->dcs = 0;
            if (VALID_TOKEN(2))
            {
              /* Convert DCS to number */
              if (ATOI_OK !=
                  dsatutil_atoi(&temp, mixed_val_list[2].string_item, 10))
              {
                DS_AT_MSG0_HIGH("Cannot convert DCS parameter");
                return DSAT_ERROR;
              }
              /* Test for in-range */
              if (MAX_DCS_LIMIT < temp)
              {
                DS_AT_MSG0_HIGH("DCS parameter outside range");
                return DSAT_ERROR;
              }
              ssus_ptr->dcs = (uint8)temp;
            }
            mixed_val_list[2].string_item[0] = '\0';

            /* Update state machine if in NULL state */
            if (DSAT_CUSD_STATE_NULL == sups_val->dsat_ss_cm_data.ussd_state)
            {
              dsatetsicmif_set_cusd_state(&(sups_val->dsat_ss_cm_data), DSAT_CUSD_STATE_MS_SEND, 0);
            }
            network_op = TRUE;
          }
          break;
          
        case 2:
          /* For <n>=2, restore intial <n> */
          mixed_val_list[0].num_item = initial_n;

          /* Check to see if there is pending USSD command to abort */
          if (TRUE != sups_val->dsat_ss_cm_data.pending_msg)
          {
            DS_AT_MSG0_HIGH("No USSD command pending; abort rejected");
            result = DSAT_ERROR;
          }
          else
          {
            /* Set state machine to ABORT */
            dsatetsicmif_set_cusd_state( &(sups_val->dsat_ss_cm_data),DSAT_CUSD_STATE_MS_ABORT, 0);
            network_op = TRUE;
          }
          break;

        default:
          DS_AT_MSG1_ERROR("Unsupported CUSD <n> parameter: %d",
                     mixed_val_list[0].num_item);
      }

      /* Check for error condition */
      if (network_op && (DSAT_ERROR != result))
      {
        /* Start network interaction */
        result = dsatetsicmif_sups_process_ussd();
      }
    }
    else
    {
      result = DSAT_ERROR;
    }
  }

  /*--------------------------------------
  Processing for a READ command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|QU) )
  {
    if (0 == dsatetsicall_cusd_response_fmt (parse_table,
                                             &res_buff_ptr,
                                             MULTI_INDEX_READ))
    {
      DS_AT_MSG0_HIGH("Problem generating query response");
      result = DSAT_ERROR;
    }
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    if (0 == dsatetsicall_cusd_response_fmt (parse_table,
                                             &res_buff_ptr,
                                             MULTI_INDEX_TEST))
    {
      DS_AT_MSG0_HIGH("Problem generating query response");
      result = DSAT_ERROR;
    }
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cusd_cmd */
/*===========================================================================

FUNCTION DSATETSICALL_CUSD_RESPONSE_FMT

DESCRIPTION
  This function generates the response for the +CUSD read & test
  commands.  The &V command respose is handled as well.  Data is
  extracted from data structure and formatted according to parameter flag.

DEPENDENCIES
  None

RETURN VALUE
  Returns number of characters in response buffer.

SIDE EFFECTS
  None

===========================================================================*/
dsat_num_item_type dsatetsicall_cusd_response_fmt
(
  const dsati_cmd_type   *parse_table,    /*  Ptr to cmd in parse table   */
  dsm_item_type * const  *out_buff_ptr,   /*  Place to put response       */
  multi_index_fmt_e_type  format          /*  Flag for format type        */
)
{
  int size = 0;
  int result = 0;
  dsm_item_type * res_buff_ptr = *out_buff_ptr;
  mixed_def_s_type ** mixed_def_list = 
    (mixed_def_s_type **) parse_table->def_lim_ptr;
  dsat_mixed_param_val_type * mixed_val_list = 
    (dsat_mixed_param_val_type *) dsatutil_get_val(parse_table->cmd_id,0,STR_TYPE);
  if(!mixed_val_list)
     return 0;

  switch (format)
  {
    case MULTI_INDEX_TEST:
      res_buff_ptr->used =
        (word) snprintf ((char*)res_buff_ptr->data_ptr,
                        res_buff_ptr->size,
                        "%s: (%d-%d)",
                        parse_table->name,
                        mixed_def_list[0]->def->dflm.lower,
                        mixed_def_list[0]->def->dflm.upper);
      result = res_buff_ptr->used;
      break;

    case MULTI_INDEX_READ:
      res_buff_ptr->used = (word) snprintf ((char*)res_buff_ptr->data_ptr,
                                                  res_buff_ptr->size,
                                                  "%s: %d",
                                                  parse_table->name,
                                                  mixed_val_list[0].num_item);
      result = res_buff_ptr->used;
      break;

    case MULTI_INDEX_AMPV:
      size = res_buff_ptr->used;
      res_buff_ptr->data_ptr[res_buff_ptr->used] = '\0';
      result = snprintf ((char*)res_buff_ptr->data_ptr,
                               res_buff_ptr->size,
                               "%s%s: %d",
                               res_buff_ptr->data_ptr,
                               parse_table->name,
                               mixed_val_list[0].num_item);
      result = (result - size);
      break;

    default:
      DS_AT_MSG0_HIGH("Unsupported format type");
  }
  return (dsat_num_item_type)result;
}  /* dsatetsicall_cusd_response_fmt */

/*===========================================================================

FUNCTION DSATETSICALL_SUPS_CMD_CB_HANDLER

DESCRIPTION
  This function is the handler function for the CM SupS call commands

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR :      if there was any problem in execution.
    DSAT_ASYNC_CMD :  if it is a success and asynch cmd continues.
    DSAT_OK :         if it is a success and asynch cmd done. 

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_sups_cmd_cb_handler
(
  ds_at_cm_call_cmd_type *call_cmd /* Call command pointer */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_CMD;

  DS_AT_MSG1_MED("In sups_cmd_cb_handler: %d", call_cmd->cmd_err);

  /* Check for error condition */
  if (CM_CALL_CMD_ERR_NOERR != call_cmd->cmd_err)
  {
    dsat_cme_error_e_type error_code;

    etsicall_cmd_pending = CMD_NONE;

    switch (call_cmd->cmd_err)
    {
      case CM_CALL_CMD_ERR_SRV_STATE_S:
        error_code = DSAT_CME_NO_NETWORK_SERVICE;
        break;

      default:
        error_code = DSAT_CME_UNKNOWN;
        DS_AT_MSG1_HIGH("Unmapped CM SupS cmd error type: %d", call_cmd->cmd_err);
        break;
    }

    /* Report +CME error */
    result = dsat_send_cme_error(error_code);
  }
  
  return result;
} /* dsatetsicall_sups_cmd_cb_handler */



/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_CONNECT

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_CONNECT event. It adds the call id connected to the active
  calls list of our state info and if a +CHLD command is pending and no 
  further events are expected gives result code.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_OK :          if +CHLD command processing complete.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_connect
(
  ds_at_cm_call_event_type*  call_event,     /* call event pointer         */
  dsat_result_enum_type      result
)
{
  dsatetsicall_call_state_info  *call_val = NULL;

  call_val = dsat_get_base_addr(DSAT_CALL_VALS, TRUE);
  if (NULL == call_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  if ( etsicall_cmd_pending != CMD_NONE )
  {
    /* Maintain dsatvoice state machine state */
    voice_state[call_event->event_info.call_id].state = DSAT_VOICE_STATE_ACTIVE;
  }

  return result;
} /* dsatetsicall_call_event_connect */


/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_END

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_MNG_CALLS_CONF event and removes the call id ended from 
  our call state info.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_end
(
  ds_at_cm_call_event_type *call_event /* Call event pointer */
)
{
  dsat_result_enum_type            result = DSAT_ASYNC_EVENT;
  boolean                          clr_pending = FALSE;
  cm_call_id_type                  call_id;
  dsatetsicall_call_state_info *call_val = NULL;

  call_val = dsat_get_base_addr(DSAT_CALL_VALS, TRUE);
  if (NULL == call_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  call_id = call_event->event_info.call_id;
  
    if ( etsicall_cmd_pending != CMD_NONE )
    {
      DS_AT_MSG1_MED("Command = %d",(uint8)etsicall_cmd_pending);
      switch ( etsicall_cmd_pending )
      {
        case CMD_CHUP:
        case CMD_ATH:
          if ( call_val->etsicall_num_active_calls == 0 &&
               call_val->etsicall_num_held_calls == 0 ) 
          {
            clr_pending = TRUE;
          }
          break;
  
        default:
          break;
      }

      /* Maintain dsatvoice state machine state */
      dsatvoice_go_to_idle_state( call_id );

      if ( clr_pending )
      {
        etsicall_cmd_pending = CMD_NONE;
        result = DSAT_OK;
      }
    }
    else
    {
      if ( ( VOICE_CMD_ATD == voice_state[call_id].cmd_active ) &&
           ( call_val->etsicall_was_call_active) )
      {
        /* clear the call active flag */
        call_val->etsicall_was_call_active = FALSE;
      }
      result = dsatvoice_call_event_end(&call_event->event_info);
    }
  return result;
} /* dsatetsicall_call_event_end */

#ifdef FEATURE_DATA_ETSI_PIN

/*===========================================================================

FUNCTION DSATETSICALL_CPUC_GSDI_WRITE

DESCRIPTION
  This function write the Price per Unit and Currency table
  to the SIM/USIM.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP:  if there was any problem in executing the command 
  DSAT_ASYNC_CMD :   if it is a success.

SIDE EFFECTS
  None.

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type  dsatetsicall_cpuc_mmgsdi_write
(
  ds_at_cmd_status_type *cmd_ptr
)
{
  dsat_result_enum_type result = DSAT_ASYNC_CMD;
  dsatetsicall_call_state_info  *call_val = NULL;
  
  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  /* Write PUCT to GSDI after PIN2 verified */
  if ( DSAT_ERROR ==
       dsatetsime_sim_write( CPUC_MMGSDI_SIM_WRITE,
                             call_val->dsatetsicall_cpuc_mmgsdi_data,
                             DSAT_PUCT_LEN) )
  {
    dsm_item_type *res_buff_ptr;

    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);
    dsatme_set_cme_error(DSAT_CME_SIM_FAILURE, res_buff_ptr);
    DSAT_SEND_RESPONSE( res_buff_ptr, DSAT_COMPLETE_RSP );
    result = DSAT_CMD_ERR_RSP;
  }
  
  return result;
} /* dsatetsicall_cpuc_gsdi_write() */


/*===========================================================================

FUNCTION DSATETSICALL_REPORT_CPUC

DESCRIPTION
  This function reports the Price per Unit and Currency table
  stored in the SIM/USIM.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP:  if there was any problem in executing the command 
  DSAT_OK :          if it is a success.

SIDE EFFECTS
  None.

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_report_cpuc
(
  ds_at_mmgsdi_sim_info_type *sim_info_ptr /* MMGSDI SIM info pointer */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsm_item_type * res_buff_ptr = NULL;
  uint8  mmgsdi_status;

  char curcode[CPUC_CURCODE_STR_LEN+1];
  char cscurcode[(4*CPUC_CURCODE_STR_LEN)+1];
  char * cur_ptr = NULL;
  byte * buf_ptr = NULL;
  dsat_num_item_type cscs_val ;

  mmgsdi_status = sim_info_ptr->cmd_status;
  
  if (mmgsdi_status != (uint8)MMGSDI_SUCCESS)
  {
    result = dsat_send_cme_error(DSAT_CME_SIM_FAILURE);
    return DSAT_CMD_ERR_RSP;
  }

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);

  /* Check for undefined +CPUC */
  buf_ptr = sim_info_ptr->data;
  if( DSAT_SIM_PADDING == *buf_ptr )
  {
    /* +CPUC not specified in SIM, send empty response */
    res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                               res_buff_ptr->size, 
                                               "+CPUC: "); 
  }
  else
  {
    /* Convert SIM/USIM format to display format */
    /* Bytes 0-2: currency code */
    memset((void*)curcode, 0x0, sizeof(curcode));

    /* Adjust for character set */

    /* Data is comming from GSDI module in GSM character set;
       This should be converted to replace GSM @ (0x00) characters if any */
    if (! dsatutil_convert_alpha_gsm_with_at_to_alpha_gsm ( 
                        (const char *)buf_ptr , curcode, CPUC_CURCODE_STR_LEN ) )
    {
      DS_AT_MSG0_ERROR(" Invalid string received from GSDI");
      /* Report CME error */
      dsatme_set_cme_error ( DSAT_CME_INVALID_CHAR_IN_TEXT,
                                res_buff_ptr );
      result = DSAT_CMD_ERR_RSP;
    }
    else if ( (dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_CSCS_IDX,
                   0,NUM_TYPE) != (dsat_num_item_type)CPUC_CURCODE_SIM_CSET )
    {
      memset((void*)cscurcode, 0x0, sizeof(cscurcode));
      cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,NUM_TYPE);
      if (NULL == dsatutil_convert_chset( curcode, 
                                          CPUC_CURCODE_SIM_CSET,
                                          cscurcode,
                                          (dsati_chset_type)cscs_val,
                                          sizeof(cscurcode),
                                          FALSE ))
      {
        /* Report CME error */
        dsatme_set_cme_error ( DSAT_CME_INVALID_CHAR_IN_TEXT,
                                   res_buff_ptr );
        result = DSAT_CMD_ERR_RSP;
      }
      else
      {
        cur_ptr = cscurcode;
      }
    }
    else
    {
      cur_ptr = curcode;
    }

    if ( DSAT_OK == result )
    {
      int32 i;
      uint8 expn;
      int8 sign;
      uint16 eppu;
      float factor = 1;
    
      /* Bytes 3-4: encoded  price per unit */
      sign = (buf_ptr[4] & 0x10) >> 4;      /* exponent sign: 0=positive,
                                               1=negative  */
      expn = (buf_ptr[4] >> 5);             /* exponent */
      eppu = (buf_ptr[3] << 4) + (buf_ptr[4] & 0x0F);

      for (i=expn; i>0; i--)
      {
        factor *= 10.0;
      }
      /* Format the response */
        if(sign)
        {
           res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                                 res_buff_ptr->size,
                                                 "+CPUC: \"%s\",\"%.4g\"", 
                                                  cur_ptr, eppu/factor);   
        }
        else
        {
           res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                                 res_buff_ptr->size,
                                                 "+CPUC: \"%s\",\"%.12g\"", 
                                                 cur_ptr, eppu*factor);   
        }
    }
  }
  
  DSAT_SEND_RESPONSE( res_buff_ptr, DSAT_COMPLETE_RSP );
  return result;
} /* dsatetsicall_report_cpuc */

#endif /* FEATURE_DATA_ETSI_PIN */


/*===========================================================================

FUNCTION DSATETSICALL_EXEC_COPS_CMD

DESCRIPTION
  This function takes the result from the command line parser and executes 
  it. It executes +COPS command, which list available networks and sets
  automatic/manual registration.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_CMD_ERR_RSP: if there was a problem in lower layers
    DSAT_ASYNC_CMD : if aynchronous command continues successfully
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_exec_cops_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{
  dsat_result_enum_type         result   = DSAT_OK;
  dsatcmif_servs_state_info *ph_val = NULL;
  cm_network_list_type_e_type   network_list_type = CM_NETWORK_LIST_AVAILABLE;
  dsat_cops_cmd_idx_e_type      temp_cmd_idx;
  byte                          temp_cmd_name[DSAT_COPS_CMD_NAME_SIZE];

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);

/*---------------------------------------------------------
   Processing for a command with an argument (WRITE command)
  -----------------------------------------------------------*/
  memset ((void*)&(ph_val->dsatetsicall_network_list), 0x0,
            sizeof(ph_val->dsatetsicall_network_list));
  ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_COPS;

  dsatutil_memscpy(&ph_val->dsatetsicall_network_list.cmd_name[0],
                   DSAT_COPS_CMD_NAME_SIZE,
                   tok_ptr->name,
                   strlen((const char*)tok_ptr->name)+1);

  if (tok_ptr->op == (NA|EQ|AR) )
  {
    dsat_num_item_type prev_mode = (dsat_num_item_type)dsatutil_get_val(
               DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE); /* list index */
      
    result = dsatparm_exec_param_cmd(mode, parse_table, tok_ptr, res_buff_ptr);

    if ( DSAT_OK == result )
    {
      /* Preserve the current PLMN and network selection preference
       * incase of user abort */
      ph_val->dsatetsicall_network_list.previous_pref.plmn =
      ph_val->dsat_net_reg_state.net_id_info.plmn;
      ph_val->dsatetsicall_network_list.previous_pref.mode = 
       (dsat_cops_mode_e_type)prev_mode;
   
      if(TRUE != dsatetsicmif_lookup_cm_rat_pref
      ( FALSE,
      &(ph_val->dsatetsicall_network_list.previous_pref.act),
      &(ph_val->dsat_net_reg_state.cmph_pref.network_rat_mode_pref))
      )
      {
        /* Assume auto rat selection */
        ph_val->dsatetsicall_network_list.previous_pref.act =
                                                          DSAT_COPS_ACT_AUTO;
      }
      /* Save previous pref act for CIOT */
      DSATETSICALL_GET_CIOT_LTE_COPS_PREF(ph_val->dsatetsicall_network_list.previous_pref.act,
                                       DSAT_COPS_ACT_AUTO)

      /* Setup network selection operation */
      result =etsicall_setup_network_selection( parse_table, tok_ptr,
                                                res_buff_ptr, prev_mode,
                                                &ph_val->net_pref );
    }
    if ( ( DSAT_ERROR == result ) || ( DSAT_CMD_ERR_RSP == result ) )
    {
      /* Restore previous COPS value in case of ERROR */
      DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,
                     0,0,(dsat_num_item_type)prev_mode,MIX_NUM_TYPE)
    }
    return result;
  }

  /*--------------------------------------
  Processing for a READ command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|QU) )
  {
    dsat_num_item_type mode_val = (dsat_num_item_type)dsatutil_get_val(
                       DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE);

    dsat_cops_fmt_e_type fmt = (dsat_num_item_type)dsatutil_get_val(
                       DSATETSI_EXT_ACT_COPS_ETSI_IDX,1,MIX_NUM_TYPE);
      
    if ( FALSE == ph_val->dsat_net_reg_state.net_id_info.present || 
         ph_val->dsat_net_reg_state.act == DSAT_COPS_ACT_MAX )
    {
        res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                             res_buff_ptr->size, 
                                             "%s: %d",
                                              parse_table->name,
                                              mode_val );
    }
    else if( fmt == DSAT_COPS_FMT_PLMN )
    {
      dsat_cops_act_e_type net_act = ph_val->dsat_net_reg_state.act;
      boolean plmn_undefined = FALSE;
      sys_mcc_type mcc = 0;
      sys_mnc_type mnc = 0;
      boolean pcs_flag = FALSE;

          sys_plmn_get_mcc_mnc( ph_val->dsat_net_reg_state.net_id_info.plmn,
                                &plmn_undefined,
                                &pcs_flag,
                                &mcc,
                                &mnc );

          /* PLMN may be undefined */
          if (TRUE == plmn_undefined)
          {
       res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                         res_buff_ptr->size,
                                         "%s: %d,%d,\"\",%d",
                                         &ph_val->dsatetsicall_network_list.cmd_name[0],
                                         mode_val,
                                   fmt,
                                   net_act );
          }
          else
          {
            if ( pcs_flag )
            {
              /* Print MNC as 3 digits */
          res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                         res_buff_ptr->size,
                                          "%s: %d,%d,\"%03lu%03lu\",%d",
                                          &ph_val->dsatetsicall_network_list.cmd_name[0],
                                          mode_val,
                                          fmt,
                                          mcc,mnc,
                                          net_act );
            }
            else
            {
          res_buff_ptr->used = (word)snprintf ((char*)res_buff_ptr->data_ptr,
                                            res_buff_ptr->size,
                                            "%s: %d,%d,\"%03lu%02lu\",%d",
                                           &ph_val->dsatetsicall_network_list.cmd_name[0],
                                            mode_val,
                                     fmt,
                                     mcc,mnc,
                                     net_act );
            }
          } 
        }
    else
    {
#ifdef FEATURE_MMGSDI
      mmgsdi_plmn_id_list_type plmn_id_list;
      mmgsdi_session_get_operator_name_info_type              operator_name_info_ptr;
      mmgsdi_plmn_id_type plmn_id;
      mmgsdi_plmn_info_static_type                      *plmn_info_ptr =NULL;
      sys_sys_mode_e_type sys_act = ph_val->dsat_net_reg_state.sys_mode;
      memset(&operator_name_info_ptr,0,sizeof(mmgsdi_session_get_operator_name_info_type));
      plmn_id_list.num_of_plmn_ids = 1;

      (void) dsatutil_memscpy((void*)&plmn_id.plmn_id_val[0], MMGSDI_PLMN_ID_SIZE,
                      (void *)&ph_val->dsat_net_reg_state.net_id_info.plmn.identity[0],
                      MMGSDI_PLMN_ID_SIZE);

      plmn_id.csg_id = SYS_CSG_ID_INVALID;

     switch(sys_act)
     {
       case SYS_SYS_MODE_WCDMA:
         plmn_id.rat = MMGSDI_RAT_UMTS;
         break;
#ifdef FEATURE_TDSCDMA
       case SYS_SYS_MODE_TDS:
#endif /* FEATURE_TDSCDMA */
         plmn_id.rat = MMGSDI_RAT_TDS;
         break;

       case SYS_SYS_MODE_LTE:
         plmn_id.rat = MMGSDI_RAT_LTE;
         break;

       case SYS_SYS_MODE_GSM:
         plmn_id.rat = MMGSDI_RAT_GSM;
         break;

       default:
         plmn_id.rat = MMGSDI_RAT_NONE;
         break;
     }

      plmn_id_list.plmn_list_ptr = &plmn_id;
     
      DS_SYSTEM_HEAP_MEM_ALLOC(plmn_info_ptr, (sizeof(mmgsdi_plmn_info_static_type)* plmn_id_list.num_of_plmn_ids),
                               mmgsdi_plmn_info_static_type     *);
      if(plmn_info_ptr ==NULL)
      {
          ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
          ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
          DS_AT_MSG0_ERROR("mmgsdi_session_get_operator_name API memory failed");
          dsatme_set_cme_error(DSAT_CME_PHONE_FAILURE, res_buff_ptr);
          result = DSAT_CMD_ERR_RSP;
      }

      operator_name_info_ptr.plmn_info_ptr = plmn_info_ptr;
      ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_GET_NAME;
      
      if( MMGSDI_SUCCESS == mmgsdi_session_get_operator_name_ext_sync(
                dsat_get_current_gw_session_id(FALSE),
                plmn_id_list,
                MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND,
                &operator_name_info_ptr
                ) )
      {
        result =  dsatme_mmgsdi_get_operator_name_cb(DSAT_MMGSDI_GET_CURR_OPER_NAME         ,
                                                               plmn_id_list.num_of_plmn_ids,
                                                               &operator_name_info_ptr);
        
         DS_AT_MSG0_ERROR("mmgsdi_session_get_operator_name API call failed");         
         ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;         
         DS_SYSTEM_HEAP_MEM_FREE(plmn_info_ptr);         
         ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
    }
    else
    {
        ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
        ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
        DS_AT_MSG0_ERROR("mmgsdi_session_get_operator_name API call failed");
        dsatme_set_cme_error(DSAT_CME_PHONE_FAILURE, res_buff_ptr);		
        DS_SYSTEM_HEAP_MEM_FREE(plmn_info_ptr);
        result = DSAT_CMD_ERR_RSP;
    }
#endif /* FEATURE_MMGSDI */
    }
  }

  /*--------------------------------------
  Processing for a TEST command:
  ----------------------------------------*/
  else if (tok_ptr->op == (NA|EQ|QU) )
  {
    /* Allocate command memory pointer for +COPS=? command */
    (void) dsat_alloc_cmd_mem_ptr(sizeof(dsat_sys_detailed_plmn_list_s_type),
                                  DSATETSI_EXT_ACT_COPS_ETSI_IDX);

    temp_cmd_idx = ph_val->dsatetsicall_network_list.cmd_idx;
    dsatutil_memscpy(&temp_cmd_name[0], DSAT_COPS_CMD_NAME_SIZE,
                     &ph_val->dsatetsicall_network_list.cmd_name[0],
                     DSAT_COPS_CMD_NAME_SIZE);
    
    memset ((void*)&ph_val->dsatetsicall_network_list, 0x0,
            sizeof(dsatetsicall_network_list_s_type));

    ph_val->dsatetsicall_network_list.cmd_idx = temp_cmd_idx;
    dsatutil_memscpy(&ph_val->dsatetsicall_network_list.cmd_name[0],
                       DSAT_COPS_CMD_NAME_SIZE,
                       &temp_cmd_name[0], DSAT_COPS_CMD_NAME_SIZE);

    /* Preserve the current PLMN and network selection preference
     * to determine current provider */
    ph_val->dsatetsicall_network_list.previous_pref.plmn =
      ph_val->dsat_net_reg_state.net_id_info.plmn;
    ph_val->dsatetsicall_network_list.previous_pref.mode = 
      (dsat_cops_mode_e_type)(dsat_num_item_type)dsatutil_get_val(DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE);

    /* Invoke network query from CM API; remaining processing done
     * asynchronously. */
    ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_ANETS;
    
    if ( DSAT_ERROR == dsatetsicmif_query_networks(network_list_type) )
    {
      ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
      ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
      dsatme_set_cme_error(DSAT_CME_NO_NETWORK_SERVICE, res_buff_ptr);
      return DSAT_CMD_ERR_RSP;
    }
    result = DSAT_ASYNC_CMD;
  }
  else if (tok_ptr->op == (NA) )
  {
    /* Do nothing */
  }
  else
  {
    /* wrong operation */
    result = DSAT_ERROR;
  }
  
  return result;
} /* dsatetsicall_exec_cops_cmd */



/*===========================================================================

FUNCTION DSATETSICALL_COPS_ABORT_CMD_HANDLER

DESCRIPTION
  This function handles an abort command to terminate asynchronous
  processing for +COPS registration operation.  The network
  registration preferences before the last +COPS comamnd handler
  execution are restored.

DEPENDENCIES
  None

RETURN VALUE
  Value indicating whether or not command should be aborted:
      TRUE if call should be aborted, FALSE otherwise.

SIDE EFFECTS
  Allocates and submits command buffer to DS task

===========================================================================*/
/* ARGSUSED */
boolean dsatetsicall_cops_abort_cmd_handler
(
  const dsati_cmd_type *cmd_table_entry_ptr  /* Ptr to cmd entry in table. */
)
{
  boolean result = FALSE;
  dsatcmif_servs_state_info  *ph_val = NULL;
  ds_at_cmd_status_type         *status_cmd_ptr = NULL;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);

  /* Abort operation only if network preference change underway */
  if( (DSAT_COPS_ASTATE_PREF == ph_val->dsatetsicall_network_list.cmd_state) ||
      (DSAT_COPS_ASTATE_WAIT == ph_val->dsatetsicall_network_list.cmd_state) || 
      (DSAT_COPS_ASTATE_WAIT_2 == ph_val->dsatetsicall_network_list.cmd_state) )
  {
    ds_command_type *cmd_ptr;

    DS_AT_MSG1_HIGH("COPS abort handler invoked: %d",
              ph_val->dsatetsicall_network_list.cmd_state);
    /* storing the mode,plmn and act value for further processing */
    ph_val->net_pref.mode = ph_val->dsatetsicall_network_list.previous_pref.mode;
    ph_val->net_pref.plmn = ph_val->dsatetsicall_network_list.previous_pref.plmn;
    ph_val->net_pref.act  = ph_val->dsatetsicall_network_list.previous_pref.act;
    /* Make best effort to restore old COPS mode */
    switch(ph_val->net_pref.mode)
    {
      case DSAT_COPS_MODE_DEREG:
        if (!ph_val->net_pref.last_dereg_success)
        {
          /* An ABORT is received after 
             CM_PH_EVENT_SUBSCRIPTION_AVAILABLE. Restore de-registration. */
          (void)dsatetsicmif_change_network_registration (ph_val->net_pref.mode,
                                                          NULL,
                                                          ph_val->net_pref.act);
        }
        break;
      case DSAT_COPS_MODE_AUTO:
      case DSAT_COPS_MODE_MANAUTO:
      case DSAT_COPS_MODE_MANUAL:
        /* Restore network select preferences to state before +COPS started 
           If aborted during COPS =2 and current de-registration is success,
           send subscription available and restore back the previous state. */
           
        if (!ph_val->net_pref.last_dereg_success)
        {
          (void)dsatetsicmif_change_network_registration(ph_val->net_pref.mode,
                                                         &ph_val->net_pref.plmn,
                                                         ph_val->net_pref.act);
        }
        else  /* current de-registration was successful. */
        {
          ph_val->net_pref.subscription_invoked = TRUE;
          (void) cm_ph_cmd_subscription_available3 ( dsatcmif_ph_cmd_cb_func,
                                   NULL,
                                   dsatcm_client_id,
                                   CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                   CM_SUBSCRIPTION_STATUS_CHANGE,
                                   CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                   CM_SUBSCRIPTION_STATUS_NO_CHANGE);

          }
        break;
      default:
        DS_AT_MSG0_ERROR("Unsupported COPS mode ");
        break;
    }
    ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_ABORT;
    cmd_ptr = dsat_get_cmd_buf(sizeof(ds_at_cmd_status_type), FALSE);
    status_cmd_ptr = cmd_ptr->cmd_payload_ptr;

    /* Send abort event to restore normal command processing */
    cmd_ptr->hdr.cmd_id    = DS_CMD_ATCOP_STATUS_CMD;
    status_cmd_ptr->cmd_id     = (uint16)COPS_CM_CMD_ABORT;
    status_cmd_ptr->cmd_status = MMGSDI_SUCCESS;
    status_cmd_ptr->cmd_data   = 0;
    ds_put_cmd (cmd_ptr);
  }
  
  /* Signal command processor */
  return result;
} /* dsatetsicall_cops_abort_cmd_handler */


/*===========================================================================

FUNCTION DSATETSICALL_COPS_ABORT_EVENT_HANDLER

DESCRIPTION
  This function handles teh +COPS abort event handling. Most of the
  processing is done in the abort command handler.  This routine just
  ensures the AT command processor returns to normal processing.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_cops_abort_event_handler
(
   ds_at_cmd_status_type *cmd_info_ptr
)
{
  dsatcmif_servs_state_info  *ph_val = NULL;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, TRUE);

  if(dsatcmdp_abortable_state != NOT_ABORTABLE)
  {
    ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
    ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
    DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,0,
        (dsat_num_item_type)ph_val->dsatetsicall_network_list.previous_pref.mode,MIX_NUM_TYPE)
    return DSAT_OK;
  }
  else
  {
    return DSAT_ASYNC_EVENT ;
  }
}


/*===========================================================================

FUNCTION DSATETSICALL_COPS_ASYNCH_HANDLER

DESCRIPTION
  This function manages the asynchronous processing of the +COPS
  command. Numerous acynch queries are required depnding on the +COPS
  syntax.  For test syntax, its is necessary to get available and
  poreferred networks from CM.  The home PLMN is determined from the
  GSDI IMSI query if necessary.  For read syntax, current state of
  phone is requried from CM.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_CMD_ERR_RSP: if there was a problem in lower layers
    DSAT_ASYNC_CMD : if aynchronous command continues successfully

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_cops_async_handler
(
  dsat_cops_async_state_e_type  cmd_state,    /* Processing state    */
  ds_at_cm_ph_event_type       *ph_event      /* PH event pointer */
)
{
  uint8 i = 0;
#ifdef FEATURE_MMGSDI
  mmgsdi_plmn_id_list_type plmn_id_list;
  mmgsdi_plmn_id_type *plmn_id = NULL;
  mmgsdi_plmn_id_type *plmn_id_temp = NULL;
  mmgsdi_session_get_operator_name_info_type         operator_name_info_ptr;  
  mmgsdi_plmn_info_static_type                      *plmn_info_ptr =NULL;
  memset(&operator_name_info_ptr,0,sizeof(mmgsdi_session_get_operator_name_info_type));
#endif /* FEATURE_MMGSDI */
  dsatcmif_servs_state_info  *ph_val = NULL;
  dsat_sys_detailed_plmn_list_s_type *alist        = NULL;
  dsat_result_enum_type          result = DSAT_ASYNC_CMD;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);
  
  DS_AT_MSG1_MED("In dsatetsicall_cops_async_handler: cmd_state=%d",cmd_state);
  
  switch (cmd_state)
  {
  case DSAT_COPS_ASTATE_NULL:
  case DSAT_COPS_ASTATE_WAIT:
    /* No processing in these states */
    break;
#ifdef FEATURE_MMGSDI
  case DSAT_COPS_ASTATE_ANETS:
    {

      alist = dsat_get_cmd_mem_ptr();

      /* Save results from event info */
      dsatutil_memscpy(alist,
                       sizeof(dsat_sys_detailed_plmn_list_s_type),
                       &ph_event->event_info.available_networks,
                       sizeof(dsat_sys_detailed_plmn_list_s_type));

      DS_AT_MSG1_HIGH("Available networks list received: length=%d", alist->length);

      plmn_id_list.num_of_plmn_ids = alist->length;

      if(plmn_id_list.num_of_plmn_ids < 1 )
      {
        ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
        ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
        DS_AT_MSG0_ERROR("Invalid List length");
        dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
        return DSAT_CMD_ERR_RSP;
    }

      DS_SYSTEM_HEAP_MEM_ALLOC(plmn_info_ptr, (sizeof(mmgsdi_plmn_info_static_type)* plmn_id_list.num_of_plmn_ids),
                               mmgsdi_plmn_info_static_type     *);
      if(plmn_info_ptr ==NULL)
      {
          ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
          ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
          DS_AT_MSG0_ERROR("mmgsdi_session_get_operator_name API memory failed");
          dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
          result = DSAT_CMD_ERR_RSP;
      }
      operator_name_info_ptr.plmn_info_ptr = plmn_info_ptr;

      plmn_id = (mmgsdi_plmn_id_type *)dsat_alloc_memory((plmn_id_list.num_of_plmn_ids)*
                                                                 sizeof(mmgsdi_plmn_id_type ), FALSE);
      plmn_id_temp = plmn_id;
      i = 0;
      plmn_id_list.plmn_list_ptr = &plmn_id[0];

      (void)dsat_cops_copy_all_categories(alist,plmn_id,ph_val->dsatetsicall_network_list.cmd_idx);

      ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_GET_NAME;

      if( MMGSDI_SUCCESS == mmgsdi_session_get_operator_name_ext_sync(
                dsat_get_current_gw_session_id(FALSE),
                plmn_id_list,
                MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND,
                &operator_name_info_ptr ) )
      {
        result =  dsatme_mmgsdi_get_operator_name_cb(DSAT_MMGSDI_GET_OPER_NAME_LIST         ,
                                                               plmn_id_list.num_of_plmn_ids,
                                                               &operator_name_info_ptr);
        DS_AT_MSG0_HIGH( "Query EONS for Long and short names");        
        ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;        
        ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
        DS_SYSTEM_HEAP_MEM_FREE(plmn_info_ptr);
                                                  
      }      
      else
      {
        ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
        ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
        DS_AT_MSG0_HIGH("mmgsdi_session_get_operator_name API call failed");
        dsat_send_cme_error(DSAT_CME_PHONE_FAILURE);		
        DS_SYSTEM_HEAP_MEM_FREE(plmn_info_ptr);
        result = DSAT_CMD_ERR_RSP;
      }
      if(plmn_id_temp != NULL)
      {
        DS_AT_MSG1_LOW("Memory free for %x",plmn_id_temp);
        dsatutil_free_memory(plmn_id_temp);
        plmn_id_temp = NULL;
      }
    }
    break;
#endif /* FEATURE_MMGSDI */
  case DSAT_COPS_ASTATE_PREF:
  case DSAT_COPS_ASTATE_PREF_ONLY:
    if( DSAT_COPS_ASTATE_PREF == ph_val->dsatetsicall_network_list.cmd_state )
    {
      /* If ATCOP originated preference change action, and we got here
       * there was no error so wait for service preference change. */
      ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_WAIT;
    }
    else if( DSAT_COPS_ASTATE_PREF_ONLY == ph_val->dsatetsicall_network_list.cmd_state )
    {
      /* Preferences changed so return to command mode */
      ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
      ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;

      if( DSAT_COPS_MODE_MANAUTO ==
             ph_val->dsatetsicall_network_list.requested_pref.mode )
      { 
            /* Update COPS state based on the current network state.*/ 
        dsat_cops_mode_e_type curr_cops_mode = (dsat_cops_mode_e_type)
              ph_val->dsat_net_reg_state.cmph_pref.network_sel_mode_pref;
        DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,0,
                               (dsat_num_item_type)curr_cops_mode,MIX_NUM_TYPE)
      }
      result = DSAT_OK;
    }
    break;
    
  case DSAT_COPS_ASTATE_ABORT:
    /* Async command processing is done */
    ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_NULL;
    ph_val->dsatetsicall_network_list.cmd_idx = CMD_IDX_NONE;
    /* Abort handler responsible for sending result code */
    result = DSAT_ASYNC_EVENT;
    break;
    
  default:
    DS_AT_MSG1_ERROR("Unsupported COPS state: %d", cmd_state);
    break;
  }


   return result;      
} /* dsatetsicall_cops_asynch_handler */

#ifdef FEATURE_DSAT_ATCOP_VEND
/*===========================================================================

FUNCTION DSATETSICALL_QCCELLSCAN_ASYNCH_HANDLER

DESCRIPTION
  This function manages the asnychronous processing of the $QCCELLSCAN
  command.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_CMD_ERR_RSP: if there was a problem in lower layers
    DSAT_ASYNC_CMD : if aynchronous command continues successfully

SIDE EFFECTS
  None
  
===========================================================================*/

dsat_result_enum_type dsatetsicall_qccellscan_async_handler
(
  ds_at_cm_ph_event_type       *ph_event      /* PH event pointer */
)
{
  dsatcmif_servs_state_info           *ph_val = NULL;
  sys_cell_search_list_s_type         *dsat_cell_serach_info = NULL;
  dsm_item_type                       *res_buff_ptr = NULL; 
  int                                 *rat;
  boolean                              plmn_undefined = FALSE;
  sys_mcc_type                         mcc = 0;
  sys_mnc_type                         mnc = 0;
  boolean                              pcs_flag = FALSE;
  int                                  i =0;
  int                                  k =0;
  boolean                              last_indication = FALSE;
  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);
  if(ph_val == NULL)
  {
    DS_AT_MSG0_ERROR("ph_val not been defined for this command ");    
    DSATUTIL_SET_VAL(DSAT_VENDOR_QCCELLSCAN_IDX,0,0,(dsat_num_item_type)0,NUM_TYPE)
    return DSAT_ASYNC_EVENT;
  }  
  DS_AT_MSG1_HIGH("cell scan conf state from the CM  %d", ph_event->event_info.cell_cnf);
  
  dsat_cell_serach_info = &ph_event->event_info.dsat_cell_serach_info;
  if(ph_event->event_info.cell_cnf == SYS_PLMN_LIST_SUCCESS)
  {
     last_indication = TRUE;
     DSATUTIL_SET_VAL(DSAT_VENDOR_QCCELLSCAN_IDX,0,0,(dsat_num_item_type)0,NUM_TYPE)
  }
  else if (ph_event->event_info.cell_cnf != SYS_PLMN_LIST_PARTIAL)
  {
    DSATUTIL_SET_VAL(DSAT_VENDOR_QCCELLSCAN_IDX,0,0,(dsat_num_item_type)0,NUM_TYPE)
    return DSAT_ASYNC_EVENT;
  }
    
    /*----------------------------------------------------------------------- 
      Stores the cell scan info into the buffer. 
      -----------------------------------------------------------------------*/ 
  rat = dsatvend_get_rat_state();

  if( (*rat == DSAT_QCCELLSCAN_RAT_LTE_M1 ) 
   || (*rat == DSAT_QCCELLSCAN_RAT_LTE_NB1) 
#ifdef FEATURE_NBIOT_NTN
   || (*rat == DSAT_QCCELLSCAN_RAT_LTE_NB1_NTN)
#endif /* FEATURE_NBIOT_NTN */
  )
  {
     #define LTE_COMMAND     dsat_cell_serach_info->lte_cell_list
     
      for(i = 0;i<LTE_COMMAND.num_cell ;i++)
      {
         for(k =0;k < LTE_COMMAND.lte_cell_info[i].num_plmn ;k++)
         {
            res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
            if (NULL != res_buff_ptr)
            {
              plmn_undefined = FALSE;
              mcc = 0;
              mnc = 0;
              pcs_flag = FALSE;
              sys_plmn_get_mcc_mnc( LTE_COMMAND.lte_cell_info[i].plmn[k],
                                  &plmn_undefined,
                                  &pcs_flag,
                                  &mcc,
                                  &mnc );
             DS_AT_MSG9_HIGH("cell scan info from the CM for LTE rat  %d , %d ,%d ,%d ,%d %d, %d, %d ,%d,",
                              LTE_COMMAND.lte_cell_info[i].earfcn,
                              LTE_COMMAND.lte_cell_info[i].phy_cell_id,
                              mcc,
                              mnc,
                              LTE_COMMAND.lte_cell_info[i].tac, 
                              LTE_COMMAND.lte_cell_info[i].global_cell_id,
                              LTE_COMMAND.lte_cell_info[i].rsrp,
                              LTE_COMMAND.lte_cell_info[i].rsrq,
                              LTE_COMMAND.lte_cell_info[i].dl_bandwidth
                              );  
             DS_AT_MSG2_HIGH("cell rssi %d %d ",
                              LTE_COMMAND.lte_cell_info[i].rat,
                             last_indication );
             res_buff_ptr->used = snprintf((char *)res_buff_ptr->data_ptr,
                                    res_buff_ptr->size,
                                    "QCCELLSCAN:(%ld),(%d),(%ld),(%ld),(%d),(%ld),"
                                              "(%d),(%d),(%d),(%d),(%d),(%d)",
                                    LTE_COMMAND.lte_cell_info[i].earfcn,
                                    LTE_COMMAND.lte_cell_info[i].phy_cell_id,
                                    mcc,
                                    mnc,
                                    LTE_COMMAND.lte_cell_info[i].tac,
                                    LTE_COMMAND.lte_cell_info[i].global_cell_id,
                                    LTE_COMMAND.lte_cell_info[i].cell_barred,
                                    LTE_COMMAND.lte_cell_info[i].rsrp,
                                    LTE_COMMAND.lte_cell_info[i].rsrq,
                                    LTE_COMMAND.lte_cell_info[i].dl_bandwidth,
                                    LTE_COMMAND.lte_cell_info[i].rssi,
                                    last_indication);
          
              dsatcmdp_send_urc(res_buff_ptr, DSAT_COMPLETE_RSP);
            }
         }
      }
  }
  else if(*rat == DSAT_QCCELLSCAN_RAT_GSM)
  { 
     #define GERAN_STR     dsat_cell_serach_info->geran_cell_list
     for(i = 0;i <SYS_PCI_SCAN_MAX_NUM_PCI ;i++)
     {
        res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
        if (NULL != res_buff_ptr)
        {
           plmn_undefined = FALSE;
           mcc = 0;
           mnc = 0;
           pcs_flag = FALSE;
           sys_plmn_get_mcc_mnc( GERAN_STR.geran_cell_info[i].PLMN,
                                &plmn_undefined,
                                &pcs_flag,
                                &mcc,
                                &mnc );
           DS_AT_MSG9_HIGH("cell scan info from the CM for GSM rat  %d , %d ,%d ,%d ,%d %d, %d, %d ,%d,",
                             GERAN_STR.geran_cell_info[i].ARFCN.num,
                             GERAN_STR.geran_cell_info[i].ARFCN.band,                       
                             GERAN_STR.geran_cell_info[i].BSIC,
                             mcc,
                             mnc,
                             GERAN_STR.geran_cell_info[i].LAC,
                             GERAN_STR.geran_cell_info[i].cell_identity,
                             GERAN_STR.geran_cell_info[i].cell_barred,
                             GERAN_STR.geran_cell_info[i].gprs_supported
                             );
            DS_AT_MSG2_HIGH("cell rssi %d %d ",GERAN_STR.geran_cell_info[i].RxLev,last_indication);
            res_buff_ptr->used = snprintf((char *)res_buff_ptr->data_ptr,
                                          res_buff_ptr->size,
                                          "QCCELLSCAN:(%d),(%d),(%d),(%ld),(%ld),(%d),(%d),"
                                                    "(%d),(%d),(%d),(%d)",
                                          GERAN_STR.geran_cell_info[i].ARFCN.num,
                                          GERAN_STR.geran_cell_info[i].ARFCN.band,
                                          GERAN_STR.geran_cell_info[i].BSIC,
                                          mcc,
                                          mnc,
                                          GERAN_STR.geran_cell_info[i].LAC,
                                          GERAN_STR.geran_cell_info[i].cell_identity,
                                          GERAN_STR.geran_cell_info[i].cell_barred,
                                          GERAN_STR.geran_cell_info[i].RxLev,
                                          GERAN_STR.geran_cell_info[i].gprs_supported,
                                          last_indication);                
            
              dsatcmdp_send_urc(res_buff_ptr, DSAT_COMPLETE_RSP);
           }
       }
  }
  else
  {
    DS_AT_MSG1_ERROR("Rat type is not supported %d ",*rat);
  }
  return DSAT_ASYNC_EVENT;
}

#endif


#ifndef FEATURE_DSAT_CUST 
/*===========================================================================

FUNCTION DSATETSICALL_EXEC_COPN_CMD

DESCRIPTION
  This function takes the result from the command line parser and
  executes it. It executes +COPN command, which displays list of 
  operator names from the ME. This command is implemented as 
  asynchronous command to make it abortable

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_exec_copn_cmd
(
  dsat_mode_enum_type       mode,         /*  AT command mode:            */
  const dsati_cmd_type     *parse_table,  /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,      /*  Command tokens from parser  */
  dsm_item_type            *res_buff_ptr  /*  Place to put response       */
)
{
  dsat_result_enum_type result = DSAT_OK;
  dsatetsicall_call_state_info  *call_val = NULL;

  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  /* Reset abort flag */
  dsat_abort_plmn_listing = FALSE;
  if(tok_ptr->op == (NA|EQ|QU))
  {
    /* Test command is valid - we support this command */
    result = DSAT_OK;
  }
  else if (tok_ptr->op == NA)
  {
    call_val->dsatetsicall_copn_plmn_index = 0;
    (void)strlcpy(call_val->etsicall_copn_display_name,
                     ((char *)(parse_table->name)),MAX_COPN_LEN);
    result =  dsatetsime_get_next_netwk_plmn();
  }
  else
  {
    /* other commands are illegal */
    result = DSAT_ERROR;
  }

  return result;

} /* dsatetsicall_exec_copn_cmd() */

#endif /* FEATURE_DSAT_CUST */


/*===========================================================================

FUNCTION DSATETSICALL_DISPLAY_PLMN_LIST

DESCRIPTION
  This function displays list of operator names from the ME.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_display_plmn_list
(
  void
)
{
  dsm_item_type        *res_buff_ptr;
  char full_name[DSAT_MAX_FULLNAME_STR_LEN+1];
  mmgsdi_se13_network_info_type *netinfo;
  dsat_num_item_type cscs_val ;
  dsatcmif_servs_state_info  *ph_val = NULL;
  dsatetsicall_call_state_info  *call_val = NULL;
  ds3g_siolib_port_e_type          current_port;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);
  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  netinfo = &ph_val->dsatetsicall_copn_plmn_info;
  
  if (TRUE == dsat_abort_plmn_listing)
  {
    /* user has aborted the PLMN listing */
    dsat_abort_plmn_listing = FALSE;

    /* Abort handler responsible for sending error */
    return DSAT_ASYNC_EVENT;
  }

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);

  memset ((void*)full_name, 0x0, sizeof(full_name));

  (void)strlcpy(full_name,
                    netinfo->long_name,
                    DSAT_MAX_FULLNAME_STR_LEN+1);
  cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,NUM_TYPE);
  if((dsati_chset_type)cscs_val != ALPHA_GSM)
  {
    char alpha_buff[MAX_COPN_ALPHA_LEN] = "\0";
    if(dsatutil_convert_chset(
                  full_name,
                  ALPHA_GSM,
                  alpha_buff,
                  (dsati_chset_type)cscs_val,
                  MAX_COPN_ALPHA_LEN,
                  TRUE) == NULL)

    {
      return dsat_send_cme_error(DSAT_CME_UNKNOWN);
    }

    if ((netinfo->mnc > 99) || (MMGSDI_PLMN_NETWK_TYPE_PCS_1900_MASK & netinfo->network_type_mask))
    {
      /* Print MNC as 3 digits */
      res_buff_ptr->used = (word)snprintf(
                      (char*)res_buff_ptr->data_ptr,
                      res_buff_ptr->size,
                      "%s: \"%03lu%03lu\",\"%s\"\n", 
                      call_val->etsicall_copn_display_name,
                      (long unsigned int)netinfo->mcc, 
                      (long unsigned int)netinfo->mnc, alpha_buff);
    }
    else
    {
      /* Print MNC as 2 digits */
      res_buff_ptr->used = (word)snprintf(
                      (char*)res_buff_ptr->data_ptr,
                      res_buff_ptr->size,
                      "%s: \"%03lu%02lu\",\"%s\"\n", 
                      call_val->etsicall_copn_display_name, 
                      (long unsigned int)netinfo->mcc, 
                      (long unsigned int)netinfo->mnc, alpha_buff);
    }
  }
  else
  {
    if ((netinfo->mnc > 99) || (MMGSDI_PLMN_NETWK_TYPE_PCS_1900_MASK & netinfo->network_type_mask))
    {
      /* Print MNC as 3 digits */
      res_buff_ptr->used = (word)snprintf(
                      (char*)res_buff_ptr->data_ptr,
                      res_buff_ptr->size,
                      "%s: \"%03lu%03lu\",\"%s\"\n", 
                      call_val->etsicall_copn_display_name, 
                      (long unsigned int)netinfo->mcc, 
                      (long unsigned int)netinfo->mnc, full_name);
    }
    else
    {
      /* Print MNC as 2 digits */
      res_buff_ptr->used = (word)snprintf(
                      (char*)res_buff_ptr->data_ptr,
                      res_buff_ptr->size,
                      "%s: \"%03lu%02lu\",\"%s\"\n", 
                      call_val->etsicall_copn_display_name, 
                      (long unsigned int)netinfo->mcc,
                      (long unsigned int)netinfo->mnc, full_name);
    }
  }

  if (call_val->dsatetsicall_copn_plmn_index == 0)
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_START_OF_RSP);
  }
  else
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_INTERMEDIATE_RSP);
  }

  /* Disable the flow if low RTS signal received and 
     if flow is already not disabled due to High TX WM */
  current_port = ds3g_siolib_get_active_port();
  if (current_port > DS3G_SIOLIB_PORT_NONE && 
     current_port < DS3G_SIOLIB_PORT_MAX)
  {
    if(dsati_sio_get_rts_changed_cb(current_port))
    {
      /* Update to latest RTS value */
      ds3g_siolib_ex_is_rts_asserted ( &dsati_sio_rts_change[current_port].is_rts_asserted, current_port );
      dsati_sio_set_rts_changed_cb(current_port, FALSE);
    }
    if (dsati_to_sio_low_handler == NULL &&
       (!dsati_sio_rts_change[current_port].is_rts_asserted))
    {
      /* RTS is low. Host has disabled the flow: 
         set up handler to re-enter COPN entry reading once RTS is high i.e. host enabled the flow */
      dsati_sio_rts_change[current_port].rts_high_handler = etsicall_copn_reenter_handler;
      DS_AT_MSG2_HIGH("Flow disabled as per low RTS, current_port %d plmn_index %d",
                      current_port, call_val->dsatetsicall_copn_plmn_index);
      return DSAT_ASYNC_CMD;
    }
  }

  /* Disable the flow if there is High TX WM */
  if ( dsati_tx_wm_high )
  {
    /* High watermark has been hit on dsat to sio queue: 
       set up handler to re-enter COPN entry reading once queue hits low
       watermark */
    dsati_to_sio_low_handler = etsicall_copn_reenter_handler;
    DS_AT_MSG2_HIGH("Flow disabled as per high TX WM, current_port %d plmn_index %d",
                    current_port, call_val->dsatetsicall_copn_plmn_index);
    return DSAT_ASYNC_CMD;
  }

  call_val->dsatetsicall_copn_plmn_index++;
  
  if (dsatetsime_get_next_netwk_plmn() == DSAT_ERROR)
  {
    return DSAT_OK;
  }
  else
  {
    return DSAT_ASYNC_CMD;
  }

}/* dsatetsicall_display_plmn_list */

#ifdef FEATURE_MMGSDI

/*===========================================================================

FUNCTION  DSATETSICALL_DISPLAY_PREF_NETWORKS

DESCRIPTION
  This function displays valid preffered PLMNs in the given index range.
  
DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_ERROR :    if there was any problem in executing the command
    DSAT_OK :       if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_display_pref_networks
(
  ds_at_mmgsdi_oper_name_type *oper_name_ptr /* Operator name pointer */
)
{
  int index;
  dsm_item_type        *res_buff_ptr;
  dsat_num_item_type cscs_val ;
  boolean hit                                             = FALSE;
  dsatme_mmgsdi_state_info    *me_val               = NULL;
  sys_user_pref_plmn_list_s_type *user_pref_plmn_list_ptr = NULL;
  dsat_me_cpol_read_param_s_type *read_params_ptr         = NULL;

  /*  If user aborted the listing */
  if (TRUE == dsat_abort_plmn_listing)
  {
    dsat_abort_plmn_listing = FALSE;

    /* Abort handler responsible for sending error */
    return DSAT_ASYNC_EVENT;
  }

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);

  me_val = dsat_get_base_addr(DSAT_MMGSDI_VALS, TRUE);

  read_params_ptr         = dsat_get_cmd_mem_ptr();
  user_pref_plmn_list_ptr = &read_params_ptr->user_pref_networks;

  for (index = read_params_ptr->start_index -1; 
    index < read_params_ptr->end_index && 
    index <= ( user_pref_plmn_list_ptr->length - 1) &&
    index < SYS_USER_PPLMN_LIST_MAX_LENGTH; index++)
  {
    /* Check whether the PLMN is valid or not */
    if ((FALSE == dsat_abort_plmn_listing) && 
      (!sys_plmn_id_is_undefined(user_pref_plmn_list_ptr->info[index].plmn)))
    {
      char full_name[DSAT_MAX_FULLNAME_STR_LEN + 1] = "\0";
      char short_name[DSAT_MAX_SHORTNAME_STR_LEN + 1] = "\0";
      char buffer[MAX_CPOL_BUFF_LEN] = "\0";
      char format_str[40] = "%s: %d,%d";
      char alpha_buff[MAX_CPOL_BUFF_LEN] = "\0";
      uint8 size = 0;
      sys_access_tech_e_type act1 =0;
      sys_access_tech_e_type act2 =0;
      sys_access_tech_e_type act3 =0;
#ifdef FEATURE_DSAT_LTE
      sys_access_tech_e_type act4 =0;
#endif /* FEATURE_DSAT_LTE */
      sys_mcc_type mcc = 0;
      sys_mnc_type mnc = 0;
      boolean plmn_undefined = FALSE;
      boolean pcs_flag = FALSE;
      uinetwk_network_info_s_type  netinfo;
      ds_at_plmn_info * plmn_info_ptr = NULL;
      uint8 j=0;
      uint32 name_len = 0;

      for(j = 0; j < oper_name_ptr->num_of_plmn_ids; j++)
      {
        if( memcmp((byte *)&user_pref_plmn_list_ptr->info[index].plmn,
            &oper_name_ptr->plmn_info_ptr[j]->plmn_id.plmn_id_val,3) == 0 )
        {
          plmn_info_ptr = oper_name_ptr->plmn_info_ptr[j];
          hit = TRUE;
          break;
        }
      }
    
      if(!hit)
      { 
        continue;
      }
      memset ((void*)&netinfo, 0x0, sizeof(netinfo));
      /* Convert PLMN to MCC/MNC */
      sys_plmn_get_mcc_mnc( user_pref_plmn_list_ptr->info[index].plmn,
                            &plmn_undefined,
                            &pcs_flag,
                            &mcc,
                            &mnc );
      memset ((void*)full_name, 0x0, sizeof(full_name));
      memset ((void*)short_name, 0x0, sizeof(short_name));
      DS_AT_MSG0_HIGH(" EONS available");
      if(plmn_info_ptr == NULL)
      {
        return DSAT_ERROR;
      }
      /*UCS2 encoding have 2 byte long char. e.g. 5 UCS2 character fit in 10 byte long array.*/
      if(MMGSDI_EONS_ENC_UCS2 == plmn_info_ptr->long_name_encoding)
      {
        plmn_info_ptr->long_name_len = (plmn_info_ptr->long_name_len)/2;
      }
      name_len = MIN(plmn_info_ptr->long_name_len,DSAT_MAX_FULLNAME_STR_LEN);
      if(name_len > 0)
      {
        etsicall_convert_chrset_todefault(plmn_info_ptr->long_name_encoding,(const byte *)plmn_info_ptr->long_name,
                                           (size_t)name_len,(byte *)full_name,
                                           DSAT_MAX_FULLNAME_STR_LEN,NULL);
      }
      if(MMGSDI_EONS_ENC_UCS2 == plmn_info_ptr->short_name_encoding)
      {
        plmn_info_ptr->short_name_len = (plmn_info_ptr->short_name_len)/2;
      }
      name_len = MIN(plmn_info_ptr->short_name_len,DSAT_MAX_SHORTNAME_STR_LEN);
      if(name_len > 0)
      {
        etsicall_convert_chrset_todefault(plmn_info_ptr->short_name_encoding,(const byte *)plmn_info_ptr->short_name,
                                           (size_t)name_len,(byte *)short_name,
                                           DSAT_MAX_SHORTNAME_STR_LEN,NULL);
      }
      /* Setting Access Technologies to 1 */
      if ( user_pref_plmn_list_ptr->info[index].access_tech & SYS_ACT_GSM_MASK )
      {
        act1 = 1;
      }
      if ( user_pref_plmn_list_ptr->info[index].access_tech & SYS_ACT_GSM_COMPACT_MASK )
      {
        act2 = 1;
      }
      if ( user_pref_plmn_list_ptr->info[index].access_tech & SYS_ACT_UMTS_MASK )
      {
        act3 = 1;
      }
#ifdef FEATURE_DSAT_LTE
      if ( user_pref_plmn_list_ptr->info[index].access_tech & SYS_ACT_LTE_MASK )
      {
        act4 = 1;
      }
#endif /* FEATURE_DSAT_LTE */
      /* Display preffered PLMNs in the user configured format */
      switch (read_params_ptr->format)
      {
      case DSAT_CPOL_LONG_ALPHA_NUMERIC:
      case DSAT_CPOL_SHORT_ALPHA_NUMERIC:
        /* If name exists in requested format... */
        if ( ( DSAT_CPOL_LONG_ALPHA_NUMERIC == read_params_ptr->format &&
               strlen(full_name) > 0 ) ||
             ( DSAT_CPOL_SHORT_ALPHA_NUMERIC == read_params_ptr->format &&
               strlen(short_name) > 0 ) )
        {
          /* If TE character set is not GSM 7bit alphabet, convert name into
             this character set... */
          cscs_val =(dsat_num_item_type)dsatutil_get_val(
                                           DSATETSI_EXT_CSCS_IDX,0,NUM_TYPE);
          if((dsati_chset_type)cscs_val != ALPHA_GSM)
          {
            if (dsatutil_convert_chset(
                          ( DSAT_CPOL_LONG_ALPHA_NUMERIC == 
                              read_params_ptr->format ? 
                              full_name : short_name ),
                          ALPHA_GSM,
                          alpha_buff,
                          (dsati_chset_type)cscs_val,
                          MAX_CPOL_BUFF_LEN,
                          TRUE) == NULL)

            {
              (void)dsm_free_buffer(res_buff_ptr);
              return dsat_send_cme_error(DSAT_CME_UNKNOWN);
            }
          }
          /* Else just copy name into buffer. */
          else
          {
            (void)strlcpy( alpha_buff, 
                           ( DSAT_CPOL_LONG_ALPHA_NUMERIC == 
                           read_params_ptr->format ? 
                           full_name : short_name ),
                           MAX_CPOL_BUFF_LEN );
          }

          if (me_val->dsat_plmn_wact_supported)
          {
            /* Display ACT indicators */
#ifdef FEATURE_DSAT_LTE
            (void)strlcat(format_str,",\"%s\",%d,%d,%d,%d\n",sizeof(format_str));
#else 
            (void)strlcat(format_str,",\"%s\",%d,%d,%d\n",sizeof(format_str));
#endif /* FEATURE_DSAT_LTE */
          }
          else
          {
            /* Don't display 3 ACT indicators */
            (void)strlcat( format_str, ",\"%s\"\n",sizeof(format_str));
          }
#ifdef FEATURE_DSAT_LTE
          size += (uint8)snprintf(
                        buffer + size,
                        sizeof(buffer),
                        format_str, 
                        read_params_ptr->display_str,
                        index + 1, read_params_ptr->format, alpha_buff,
                        act1, act2, act3,act4 ); 
#else 
          size += (uint8)snprintf(
                        buffer + size,
                        sizeof(buffer),
                        format_str, 
                        read_params_ptr->display_str,
                        index + 1, read_params_ptr->format, alpha_buff,
                        act1, act2, act3 ); 
#endif /* FEATURE_DSAT_LTE */
        }
        else
        {
          /* If full name not available */

          if ( pcs_flag || UI_NETWK_TYPE_PCS_1900 == netinfo.network_type )
          {
            /* Display MNC of PLMN as 3 digits */
            (void)strlcat( format_str, ",\"%03lu%03lu\"",sizeof(format_str) );
          }
          else
          {
            /* Display MNC of PLMN as 2 digits */
            (void)strlcat( format_str, ",\"%03lu%02lu\"",sizeof(format_str) );
          }

          if (me_val->dsat_plmn_wact_supported)
          {
            /* Display ACT indicators */
#ifdef FEATURE_DSAT_LTE
            (void)strlcat( format_str, ",%d,%d,%d,%d\n",sizeof(format_str) );
#else 
            (void)strlcat( format_str, ",%d,%d,%d\n",sizeof(format_str) );
#endif /* FEATURE_DSAT_LTE */
          }
          else
          {
            /* Don't display 3 ACT indicators */
            (void)strlcat( format_str, "\n",sizeof(format_str));
          }
#ifdef FEATURE_DSAT_LTE          
          size += (uint8)snprintf( buffer + size,
                                   sizeof(buffer),
                                   format_str,
                                   read_params_ptr->display_str,
                                   (index + 1), 
                                   DSAT_CPOL_NUMERIC, mcc, mnc, 
                                   act1, act2, act3, act4 );       
#else
          size += (uint8)snprintf( buffer + size,
                                   sizeof(buffer),
                                   format_str,
                                   read_params_ptr->display_str,
                                   (index + 1), 
                                   DSAT_CPOL_NUMERIC, mcc, mnc, 
                                   act1, act2, act3 );            
#endif /* FEATURE_DSAT_LTE */     
        }
        break;      

      case DSAT_CPOL_NUMERIC:
        if ( pcs_flag || UI_NETWK_TYPE_PCS_1900 == netinfo.network_type )
        {
          /* Display MNC of PLMN as 3 digits */
          (void)strlcat( format_str, ",\"%03lu%03lu\"",sizeof(format_str) );
        }
        else
        {
          /* Display MNC of PLMN as 2 digits */
          (void)strlcat( format_str, ",\"%03lu%02lu\"",sizeof(format_str) );
        }

        if (me_val->dsat_plmn_wact_supported)
        {
          /* Display ACT indicators */
#ifdef FEATURE_DSAT_LTE          
          (void)strlcat( format_str, ",%d,%d,%d,%d\n",sizeof(format_str));
#else
          (void)strlcat( format_str, ",%d,%d,%d\n",sizeof(format_str));
#endif /* FEATURE_DSAT_LTE */
        }
        else
        {
          /* Don't display 3 ACT indicators */
          (void)strlcat( format_str, "\n",sizeof(format_str));
        }
#ifdef FEATURE_DSAT_LTE          
        size += (uint8)snprintf( buffer + size,
                                 sizeof(buffer),
                                 format_str,
                                 read_params_ptr->display_str, 
                                 (index + 1), 
                                 DSAT_CPOL_NUMERIC, mcc, mnc, 
                                 act1, act2, act3,act4 );
#else
        size += (uint8)snprintf( buffer + size,
                                 sizeof(buffer),
                                 format_str,
                                 read_params_ptr->display_str, 
                                 (index + 1), 
                                 DSAT_CPOL_NUMERIC, mcc, mnc, 
                                 act1, act2, act3 );            
#endif /* FEATURE_DSAT_LTE */            
        break;

      default:
        (void)dsm_free_buffer(res_buff_ptr);
        return dsat_send_cme_error(DSAT_CME_UNKNOWN);      
      }

      dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                             DSM_ITEM_POOL(res_buff_ptr), FALSE);
    }
    memset(&user_pref_plmn_list_ptr->info[index],0xFF,sizeof(sys_user_pref_plmn_list_info_s_type));
  }
  
  if ((res_buff_ptr != NULL) && (res_buff_ptr->used > 0))
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
  }
  else
  {
    (void)dsm_free_buffer(res_buff_ptr);
  }

  return DSAT_OK;
} /* dsatetsicall_display_pref_networks */
#endif /* FEATURE_MMGSDI */

/*===========================================================================

FUNCTION DSATETSICALL_PLMN_ABORT_CMD_HANDLER

DESCRIPTION
  This function handles an abort command to terminate listing of both 
  preffered PLMN and PLMN list stored on the ME.

DEPENDENCIES
  None

RETURN VALUE
  Value indicating whether or not command should be aborted:
      TRUE if call should be aborted, FALSE otherwise.

===========================================================================*/
/*ARGSUSED*/
boolean dsatetsicall_plmn_abort_cmd_handler
(
  const dsati_cmd_type *cmd_table_entry_ptr  /* Ptr to cmd entry in table. */
)
{
  ds_command_type               *cmd_ptr;
  ds_at_cmd_status_type     *status_cmd_ptr = NULL;

  dsat_abort_plmn_listing = TRUE;

  cmd_ptr = dsat_get_cmd_buf(sizeof(ds_at_cmd_status_type), FALSE);
  status_cmd_ptr = cmd_ptr->cmd_payload_ptr;

  /* Send abort event to restore normal command processing */
  cmd_ptr->hdr.cmd_id           = DS_CMD_ATCOP_STATUS_CMD;
  status_cmd_ptr->cmd_id        = (uint16)COPN_CM_CMD_ABORT;
  status_cmd_ptr->cmd_status    = MMGSDI_SUCCESS;
  status_cmd_ptr->cmd_data      = 0;
  ds_put_cmd (cmd_ptr);

  return TRUE;
}


/*===========================================================================

FUNCTION DSATETSICALL_COPN_ABORT_EVENT_HANDLER

DESCRIPTION
  This function handles teh +COPN abort event handling. Most of the
  processing is done in the abort command handler.  This routine just
  ensures the AT command processor returns to normal processing.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_ERROR : As command is aborted

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_copn_abort_event_handler
(
  ds_at_cmd_status_type *cmd_info_ptr
)
{
  if( dsatcmdp_abortable_state != NOT_ABORTABLE )
  {
    return DSAT_ERROR;
  }
  else
  {
    return DSAT_ASYNC_EVENT;
  }
}

/*===========================================================================

FUNCTION ETSICALL_COPN_REENTER_HANDLER

DESCRIPTION
  Local function that is used to reenter reading PLMN entries once DSAT to SIO
  queue has hit low watermark (or) DSM large item threshold timer expiry.

DEPENDENCIES
  none

RETURN VALUE
  DSAT_OK          : If reading of all records complete.
  DSAT_ASYNC_CMD   : Additional entries remain to be read.
  DSAT_CMD_ERR_RSP : If there is a CME ERROR.
  DSAT_ERROR       : Read action fails due to non-CME errors.

SIDE EFFECTS
  None
===========================================================================*/
/* ARGSUSED */
LOCAL dsat_result_enum_type etsicall_copn_reenter_handler
(
  ds_command_type* cmd_ptr
)
{
  dsat_result_enum_type result;
  dsatetsicall_call_state_info  *call_val = NULL;
  ds3g_siolib_port_e_type          current_port = ds3g_siolib_get_active_port();

  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  call_val->dsatetsicall_copn_plmn_index++;
  DS_AT_MSG3_HIGH("etsicall_copn_reenter_handler: reading index from %d 0x%x current_port %d",
                   call_val->dsatetsicall_copn_plmn_index,
                   dsati_to_sio_low_handler,
                   current_port);

  /* Reset handler function pointers */
  /* Handler function for low event, now not neccesary */
  if(dsati_to_sio_low_handler)
  {
    dsati_to_sio_low_handler = NULL;
  }

  if(current_port > DS3G_SIOLIB_PORT_NONE &&
     current_port < DS3G_SIOLIB_PORT_MAX &&
     dsati_sio_rts_change[current_port].rts_high_handler)
  {
    dsati_sio_rts_change[current_port].rts_high_handler = NULL;
  }

  result = dsatetsime_get_next_netwk_plmn ();

  return result;
}/* etsicall_copn_reenter_handler */

/*===========================================================================

FUNCTION CONVERT_TO_NUMERIC

DESCRIPTION
  Local function that is used to convert values to a numeric value.

DEPENDENCIES
  none

RETURN VALUE
  TRUE          : An error while converting.
  FALSE         : No error while converting.

SIDE EFFECTS
  None
===========================================================================*/

boolean convert_to_numeric
(
  const dsati_cmd_type *parse_table,
  dsat_num_item_type   *temp,
  int                   i
)
{
  const byte *param_ptr;
  mixed_def_s_type ** mixed_def_list = (mixed_def_s_type **) parse_table->def_lim_ptr;
  dsat_mixed_param_val_type *val_ptr =
  (dsat_mixed_param_val_type*)dsatutil_get_val(parse_table->cmd_id,0,STR_TYPE);
  if(val_ptr == NULL)
  {

   return FALSE;
  }
  param_ptr = mixed_def_list[i]->def->def_list.list_v[val_ptr[i].num_item]; 
  
  if ( ATOI_OK != dsatutil_atoi (temp, param_ptr, 10) ) 
    { 
       DS_AT_MSG_SPRINTF_1_ERROR("Cannot convert format param: %s",param_ptr); 
       return TRUE; 
    } 
	 
  return FALSE;
}

/*===========================================================================

FUNCTION ETSICALL_SETUP_NETWORK_SELECTION

DESCRIPTION
  This function does the necessary setup to perform network selection
  based on +COPS command parameters.

DEPENDENCIES
  None
  
RETURN VALUE
  Returns an enum that describes the result of the command execution.
  Possible values:
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_OK : if it is a success for local execution
    DSAT_CMD_ERR_RSP: if there was +CME error

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL dsat_result_enum_type etsicall_setup_network_selection
(
  const dsati_cmd_type *parse_table,
  const tokens_struct_type *tok_ptr,
  dsm_item_type *res_buff_ptr,
  dsat_num_item_type prev_mode,
  dsatetsicall_network_pref_s_type * net_pref_ptr
)
{
  dsat_num_item_type temp;
  dsat_cops_fmt_e_type fmt;
  dsat_num_item_type result = DSAT_ERROR;
  dsat_mixed_param_val_type *val_ptr =
    (dsat_mixed_param_val_type*)dsatutil_get_val(parse_table->cmd_id,0,STR_TYPE);
  byte oper[DSAT_MAX_FULLNAME_STR_LEN+1];
  dsatcmif_servs_state_info         *ph_val = NULL;
  dsatme_mmgsdi_state_info          *me_val = NULL;
  dsat_cops_cmd_idx_e_type           temp_cmd_idx;
  byte                               temp_cmd_name[DSAT_COPS_CMD_NAME_SIZE];
  uint16                             plmn_id =  0;
  mmgsdi_se13_plmn_static_info_type  *se13_plmn_info_ptr = NULL;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);
  me_val = dsat_get_base_addr(DSAT_MMGSDI_VALS, FALSE);
  if(val_ptr ==NULL)
  {
    return DSAT_ERROR;
  }
  
/* Macro to convert list index to numberic value */
  #define CONVERT_TO_NUMERIC(i, cast, val) \
     convert_to_numeric(parse_table, &temp, i); \
     val = (cast)temp;
  
  #define CONVERT_TO_PLMN( mcc, mnc, plmn, pcs_flag ) \
      if ( FALSE == \
           sys_plmn_set_mcc_mnc( (mnc > 99 || pcs_flag)? TRUE : FALSE, \
                                 mcc, mnc, &plmn ) ) \
      { \
        DS_AT_MSG2_ERROR("Error parsing MCC/MNC into PLMN: [%d,%d]", \
                   mcc,mnc); \
        dsatme_set_cme_error(DSAT_CME_PHONE_FAILURE, res_buff_ptr); \
        return DSAT_CMD_ERR_RSP; \
      }
      temp_cmd_idx = ph_val->dsatetsicall_network_list.cmd_idx;
      dsatutil_memscpy(&temp_cmd_name[0], DSAT_COPS_CMD_NAME_SIZE,
                       &ph_val->dsatetsicall_network_list.cmd_name[0],
                       DSAT_COPS_CMD_NAME_SIZE);
      
      /* Clear structures */
      memset((void*)&net_pref_ptr->plmn, 0x0, sizeof(sys_plmn_id_s_type));
      memset((void*)&(ph_val->dsatetsicall_network_list),
             0x0,
             sizeof(ph_val->dsatetsicall_network_list));

      ph_val->dsatetsicall_network_list.cmd_idx = temp_cmd_idx;
      dsatutil_memscpy(&ph_val->dsatetsicall_network_list.cmd_name[0],
                       DSAT_COPS_CMD_NAME_SIZE,
                       &temp_cmd_name[0], DSAT_COPS_CMD_NAME_SIZE);
  net_pref_ptr->no_of_args = tok_ptr->args_found;

  net_pref_ptr->is_arg0_valid = VALID_TOKEN(0);
  net_pref_ptr->is_arg2_valid = VALID_TOKEN(2);
  DS_AT_MSG1_HIGH("%d Args found in COPS command", net_pref_ptr->no_of_args);

  /* Clear the oper parameter so its not reported in &V response */
  (void)strlcpy((char*)oper,
                    (char*)val_ptr[2].string_item,
                    sizeof(oper));
  val_ptr[2].string_item[0]='\0';
      
  /* Convert list parameters to numerics */
  CONVERT_TO_NUMERIC(0, dsat_cops_mode_e_type, net_pref_ptr->mode);
  CONVERT_TO_NUMERIC(1, dsat_cops_fmt_e_type, fmt);
  CONVERT_TO_NUMERIC(3, dsat_cops_act_e_type, net_pref_ptr->act);

  if( net_pref_ptr->mode == DSAT_COPS_MODE_MANUAL || 
      net_pref_ptr->mode == DSAT_COPS_MODE_MANAUTO )
  {
    if(ph_val != NULL )
    {
      if(ph_val->dsat_oprt_mode == SYS_OPRT_MODE_OFFLINE || 
         ph_val->dsat_oprt_mode == SYS_OPRT_MODE_LPM )
      {
        DS_AT_MSG0_ERROR("Device is in offline state");
        return DSAT_ERROR;
      }
    }
    else
    {
      DS_AT_MSG0_ERROR("operating mode unknown");
      return DSAT_ERROR;
    }
  }
      
  DS_AT_MSG1_MED("cops cmd id %d",ph_val->dsatetsicall_network_list.cmd_idx);
  
  /* Process parameters if not just setting format */
  if ( DSAT_COPS_MODE_SETFMT != net_pref_ptr->mode )
  {
       /* Force to automatic AcT if parameter not specified.  This
        * allow user flexibility to select specific AcT or any */
    if( !VALID_TOKEN(3) )
    {
       net_pref_ptr->act = DSAT_COPS_ACT_AUTO;
    }
    /* network ID is valid  only in manual selection for +COPS command */
     if((DSAT_COPS_MODE_AUTO  != net_pref_ptr->mode) && (DSAT_COPS_MODE_DEREG != net_pref_ptr->mode) )
    {      
      /* Check for network ID parameter */
      if (!VALID_TOKEN(2))
      {
        DS_AT_MSG0_ERROR("Missing COPS network identifier");
        return DSAT_ERROR;
      }

      /* Convert alpha parameter to PLMN. */
      /* Force the access technology to that in operator database to
       * speed selection process.  This will change the overall
       * network mode preference; UI does the same. */
      switch (fmt)
      {
         case DSAT_COPS_FMT_LONG:
         case DSAT_COPS_FMT_SHRT:
         {
            mmgsdi_data_type   longname;
            mmgsdi_data_type   shortname;
            longname.data_ptr  = NULL;
            longname.data_len  = 0;
            shortname.data_ptr = NULL;
            shortname.data_len = 0;

            if( DSAT_COPS_FMT_LONG == fmt )
            {
               longname.data_len = strlen((const char *)oper);
               longname.data_ptr = ( uint8 *)oper;
            }
            else
            {
               shortname.data_len = strlen((const char *)oper);
               shortname.data_ptr = ( uint8 *)oper;
            }
#ifdef FEATURE_MMGSDI
             DS_SYSTEM_HEAP_MEM_ALLOC(se13_plmn_info_ptr,
                                      (sizeof(mmgsdi_plmn_info_static_type)*10),
                                       mmgsdi_se13_plmn_static_info_type *);
             if(se13_plmn_info_ptr == NULL)
             {
                DS_AT_MSG0_ERROR("Memory failed");
                return DSAT_ERROR;
             }
             plmn_id = mmgsdi_get_se13_plmn_info_by_name_sync(
                              me_val->dsat_mmgsdi_client_id,
                              longname,
                              shortname,
                              MMGSDI_RAT_NONE,
                              se13_plmn_info_ptr
                             );
             if(plmn_id)
             {
                 result = dsatetsicall_cops_cmd_cb_func(COPS_MMGSDI_PLMN_INFO ,se13_plmn_info_ptr,plmn_id);
                 DS_SYSTEM_HEAP_MEM_FREE(se13_plmn_info_ptr);
                 return result;
             }
             else
#endif /*FEATURE_MMGSDI*/
             {
               /* Name lookup failed so return error */
                 DS_AT_MSG0_ERROR("COPS network name lookup failed");
                 DS_SYSTEM_HEAP_MEM_FREE(se13_plmn_info_ptr);
                 dsatme_set_cme_error(DSAT_CME_NOT_FOUND, res_buff_ptr);
                 return DSAT_CMD_ERR_RSP;
            }
            break;
       }/* case DSAT_COPS_FMT_SHRT:*/
      case DSAT_COPS_FMT_PLMN:
         {
            byte buffer[8];
            dsat_num_item_type mcc = 0;
            dsat_num_item_type mnc = 0;

        /* Convert string to PLMN structure */
        /* MCC is first 3 characters */
        memset ((void*)buffer, 0x0, sizeof(buffer));
       (void)strlcat ((char*)buffer,
                          (char*)oper,
                          PLMN_STR_MCC_LEN+1);
        if ( ATOI_OK !=
             dsatutil_atoi (&mcc, buffer, 10) )
        {
          DS_AT_MSG0_ERROR("Cannot convert MCC value");
          return DSAT_ERROR;
        }

        /* MNC is next 2 or 3 characters */
        memset ((void*)buffer, 0x0, sizeof(buffer));
        (void)strlcat ((char*)buffer,
                           (char*)(oper+PLMN_STR_MCC_LEN),
                           PLMN_STR_MNC_LEN+1);
        if ( ATOI_OK !=
             dsatutil_atoi (&mnc, buffer, 10) )
        {
          DS_AT_MSG0_ERROR("Cannot convert MNC value");
          return DSAT_ERROR;
        }

        /* Convert MCC/MNC to PLMN, set 3rd MNC digit if MNC string
           was of 3 characters */
        CONVERT_TO_PLMN( mcc, mnc, net_pref_ptr->plmn,
                         (PLMN_STR_MNC_LEN == strlen((char*)buffer)) );
        break;
      }/*case DSAT_COPS_FMT_PLMN:*/
      default:
    {
      DS_AT_MSG1_ERROR("Error: Unsupported format: %d", fmt);
      return DSAT_ERROR;
      break;
    }
    }
    }
    result = dsatetsicall_process_plmn_info();
  }
  else
  {
    /* Restore previous mode when just setting format */
    val_ptr[0].num_item = prev_mode;
     result = DSAT_OK;
  }
  return result;
} /* etsicall_setup_network_selection */


/*===========================================================================

FUNCTION DSATETSICALL_REPORT_COPS_RESULT

DESCRIPTION
  This function generates the response for network query command +COPS
  read syntax.  The order of networks shown in the respose is dictated
  in TS27.007 section 7.3: home, SIM (preferred), other.  Only those
  networks "present" are to be reported.

DEPENDENCIES
  None
  
RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure
  DSAT_OK : if it is a success for local execution
  DSAT_ERROR : if there was any problem in executing the command
  
SIDE EFFECTS
  May append further DSM items to original result buffer.
  
===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_report_cops_result
(
  ds_at_mmgsdi_oper_name_type *oper_name /* Operator name pointer */
)
{
#define COPS_NETWORK_REPORTED 0xFF  /* control value to flag reported */

  char buffer[MAX_NETWORK_REPORT_LEN];
  uint8 j = 0;
  word size = 0;
  dsat_sys_detailed_plmn_list_s_type *alist        = NULL;
  dsm_item_type                 *res_buff_ptr = NULL;
  dsatcmif_servs_state_info  *ph_val = NULL;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);

  if(ph_val->dsatetsicall_network_list.cmd_state != DSAT_COPS_ASTATE_GET_NAME)
  {
    DS_AT_MSG0_ERROR ( "Invalid state");
    return DSAT_ERROR;
  }
  memset ((void*)buffer, 0x0, sizeof(buffer));
  if( oper_name->client_ref == DSAT_MMGSDI_GET_OPER_NAME_LIST )
  {
    alist = dsat_get_cmd_mem_ptr();

  /* Check whether the command was aborted */
  if(alist->length < 1)
  {
    DS_AT_MSG0_ERROR("+COPS command got aborted");
    /* Report +CME error asynchronously */
    return dsat_send_cme_error(DSAT_CME_OP_NOT_ALLOWED);
  }

    if(oper_name->num_of_plmn_ids != alist->length)
    {
      DS_AT_MSG2_ERROR("%d num_of_plmn_ids %d alist->length",
                   oper_name->num_of_plmn_ids,alist->length);
      return DSAT_ERROR;
    }

    /* Get a response buffer */
    res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_LARGE_ITEM_POOL, FALSE);
    /* Initialize response */
    size = (word)snprintf( buffer, sizeof(buffer), "%s: ",
           (char*) &ph_val->dsatetsicall_network_list.cmd_name[0] );
    dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                           DSM_ITEM_POOL(res_buff_ptr), FALSE);

    for(j = 0 ; (j < oper_name->num_of_plmn_ids) && (j < alist->length) ; j++)
    {
      if( oper_name->plmn_info_ptr[j] != NULL )
      {
        etsicall_cops_generate_network_response( oper_name->plmn_info_ptr[j],
                                               TRUE,
                                               res_buff_ptr ); 
      }
    }
    /* Append list of supported nodes/formats */
    size = (word)snprintf( buffer, sizeof(buffer), ",%s,%s",
                          dsat_cops_mixed_dfl[0]->def->def_list.list_t,
                          dsat_cops_mixed_dfl[1]->def->def_list.list_t );
    dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                           DSM_ITEM_POOL(res_buff_ptr), FALSE);
    /* Ensure a response was generated */
    /* Send response to TE */
    DSAT_SEND_RESPONSE( res_buff_ptr, DSAT_COMPLETE_RSP );
  }
  else if( oper_name->client_ref == DSAT_MMGSDI_GET_CURR_OPER_NAME)
  {
    uint32  name_len=0;

    dsat_cops_act_e_type net_act = ph_val->dsat_net_reg_state.act;
    boolean plmn_undefined = FALSE;
    
    dsat_num_item_type mode_val = (dsat_num_item_type)dsatutil_get_val(
                     DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE);

    dsat_cops_fmt_e_type fmt = (dsat_num_item_type)dsatutil_get_val(
                     DSATETSI_EXT_ACT_COPS_ETSI_IDX,1,MIX_NUM_TYPE);
    char *cp = buffer;

    uint32 no_of_chars = 0;
    sys_mcc_type mcc = 0;
    sys_mnc_type mnc = 0;

    if(oper_name->num_of_plmn_ids != 1)
    {
      DS_AT_MSG1_ERROR(" Incorrect MMGSDI data found - %d plmn_ids ",oper_name->num_of_plmn_ids);
      return DSAT_ERROR;
    }


    /* Report the mode and current registration info */
    switch (fmt)
    {
    case DSAT_COPS_FMT_LONG:
    case DSAT_COPS_FMT_SHRT:
    {
      size = (word)snprintf (buffer, sizeof(buffer),
                                   "%s: %d,%d,\"",
                                   &ph_val->dsatetsicall_network_list.cmd_name[0],
                                   mode_val,
                                   fmt);
      if( size < MAX_NETWORK_REPORT_LEN )
      {
        cp = buffer + size;
      }
      if((fmt == DSAT_COPS_FMT_LONG) && (oper_name->plmn_info_ptr != NULL))
      {
        /*UCS2 encoding have 2 byte long char. e.g. 5 UCS2 character fit in 10 byte long array.*/
        if(MMGSDI_EONS_ENC_UCS2 == oper_name->plmn_info_ptr[0]->long_name_encoding)
        {
          oper_name->plmn_info_ptr[0]->long_name_len = (oper_name->plmn_info_ptr[0]->long_name_len)/2;
        }
        name_len = MIN(oper_name->plmn_info_ptr[0]->long_name_len,DSAT_MAX_FULLNAME_STR_LEN);
        DS_AT_MSG1_HIGH("name_len = %d",name_len);
        etsicall_convert_chrset_todefault(oper_name->plmn_info_ptr[0]->long_name_encoding,
                                          (const byte *)oper_name->plmn_info_ptr[0]->long_name,(size_t)name_len,(byte *) cp,
                                           DSAT_MAX_FULLNAME_STR_LEN,(size_t*)&no_of_chars);
        cp += no_of_chars;
      }
      else if((fmt == DSAT_COPS_FMT_SHRT) && (oper_name->plmn_info_ptr != NULL))
      {
        /*UCS2 encoding have 2 byte long char. e.g. 5 UCS2 character fit in 10 byte long array.*/
        if(MMGSDI_EONS_ENC_UCS2 == oper_name->plmn_info_ptr[0]->short_name_encoding)
        {
          oper_name->plmn_info_ptr[0]->short_name_len = (oper_name->plmn_info_ptr[0]->short_name_len)/2;
        }

        name_len = MIN(oper_name->plmn_info_ptr[0]->short_name_len,DSAT_MAX_SHORTNAME_STR_LEN);
        DS_AT_MSG1_HIGH("name_len = %d",name_len);
        etsicall_convert_chrset_todefault(oper_name->plmn_info_ptr[0]->short_name_encoding,
                                          (const byte *)oper_name->plmn_info_ptr[0]->short_name,(size_t)name_len,(byte *) cp,
                                           DSAT_MAX_SHORTNAME_STR_LEN,(size_t*)&no_of_chars);
        cp += no_of_chars;
      }
      
      *cp++ = '"';
      *cp++ = ',';

      if(net_act <= 9)
      {
        *cp++ = '0' + net_act;
      }
      else
      {
        *cp++ = '1';
        *cp++ = '0' + (net_act % 10);
      }

      *cp++ = '\0';
      size = cp - buffer;
      break;
    }
    case DSAT_COPS_FMT_PLMN:
    {
      boolean pcs_flag = FALSE;
    
      /* Convert PLMN to MCC/MNC */
      sys_plmn_get_mcc_mnc( ph_val->dsat_net_reg_state.net_id_info.plmn,
                            &plmn_undefined,
                            &pcs_flag,
                            &mcc,
                            &mnc );

      /* PLMN may be undefined */
      if (TRUE == plmn_undefined)
      {
        size = (word)snprintf (buffer, sizeof(buffer),
                               "%s: %d,%d,\"\",%d",
                               &ph_val->dsatetsicall_network_list.cmd_name[0],
                               mode_val,
                               fmt,
                               net_act );
      }
      else
      {
        if ( pcs_flag )
        {
          /* Print MNC as 3 digits */
          size = (word)snprintf (buffer, sizeof(buffer),
                                 "%s: %d,%d,\"%03lu%03lu\",%d",
                                 &ph_val->dsatetsicall_network_list.cmd_name[0],
                                 mode_val,
                                 fmt,
                                 mcc,mnc,
                                 net_act );
        }
        else
        {
          size = (word)snprintf (buffer, sizeof(buffer),
                                 "%s: %d,%d,\"%03lu%02lu\",%d",
                                 &ph_val->dsatetsicall_network_list.cmd_name[0],
                                 mode_val,
                                 fmt,
                                 mcc,mnc,
                                 net_act );
        }
       }
    }
    break;

    case DSAT_COPS_FMT_MAX:
    default:
      DS_AT_MSG1_ERROR ( "Unsupported format code: %d",fmt);
      return DSAT_ERROR;
    }
         
    res_buff_ptr = dsat_dsm_create_packet(buffer, size, FALSE);
    if (NULL != res_buff_ptr)
    {
      dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
    }
  }


  return DSAT_OK;
} /* etsicall_report_cops_result */

/*===========================================================================

FUNCTION ETSICALL_CONVERT_CHRSET_TODEFAULT

DESCRIPTION
  This function converts alpha packed,unpacked and UCS2 to default charset.
  cm_util api's are used to acheive the same.

DEPENDENCIES
  None.
  
RETURN VALUE
  None.
  
SIDE EFFECTS
  None.
  
===========================================================================*/
LOCAL void etsicall_convert_chrset_todefault
(
  mmgsdi_eons_encoding_enum_type enc_type,
  const byte  *src_data,
  size_t      src_size,
  byte        *dst_data,
  size_t      dst_size,
  size_t      *num_unpacked
)
{
  uint32 index = 0;
  uint16 buffer[DSAT_MAX_FULLNAME_STR_LEN+1];
  boolean convert_to_cscs = TRUE;
  size_t  num_of_chars = 0;
  byte temp_src[DSAT_MAX_FULLNAME_STR_LEN*2];
  #define STRIP_UNKNOWN_CHAR(buffer, t_len)\
  {\
    index = 0;\
    while ( (buffer[index]!=0xFF) && ( index < t_len ))\
    {\
      ++index;\
    }\
    buffer[index] = NULL;\
  }

  DS_AT_MSG1_HIGH ( "Encoding Type: %d",enc_type);
  switch(enc_type)
  {
    case MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED:
       cm_util_gsm7_unpack_remove_suspected_padding( src_data, src_size,dst_data,dst_size+1,&num_of_chars);
       break;
    case MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED:
       {
         (void) dsatutil_memscpy((void*)dst_data,
                 dst_size,(void*)src_data,src_size);
         
         STRIP_UNKNOWN_CHAR(dst_data,src_size);
         num_of_chars =(size_t)index;
       }  
       break;
    case MMGSDI_EONS_ENC_UCS2:
       memscpy(temp_src, sizeof(temp_src), src_data, src_size * 2);
       /* Received 16 bits information are in big endian. Converting to little endian */
       dsatutil_convert_endianness16(temp_src, src_size * 2);
       cm_util_utf16_to_gsm7((const uint16 *)temp_src,src_size,dst_data,dst_size+1,&num_of_chars);
       break;
    case MMGSDI_EONS_ENC_UCS2_PACKED:
        memset(&buffer,0x0,sizeof(buffer));
        src_size =  dsatutil_decode_ucs2_80_81_82_encoding(( uint8 *)src_data,src_size,
                               buffer,ARR_SIZE(buffer));
        src_size = MIN(src_size, (DSAT_MAX_FULLNAME_STR_LEN + 1));
        if (src_size > 0)
        {
          cm_util_utf16_to_gsm7((const uint16 *)buffer,src_size,dst_data,dst_size+1,&num_of_chars);
        }
        else
        {
          convert_to_cscs = FALSE;
          DS_AT_MSG0_ERROR("Empty buffer returned in UCS2 decoding");
          num_of_chars = 0;
        }
       break;
    default:
      convert_to_cscs = FALSE;
       break;
  }

   if ( NULL != num_unpacked )
   {
     *num_unpacked = num_of_chars;
   }

   DS_AT_MSG1_HIGH("num_of_chars %d", num_of_chars);

  if(convert_to_cscs)
  {
    if ( TRUE == dsatutil_convert_alpha_gsm_with_at_to_alpha_gsm( (const char *) dst_data,
                                                                  (char *) dst_data, 
                                                                   num_of_chars) )
    {
      if(dsatutil_convert_chset( (const char *) dst_data,
                                 ALPHA_GSM,
                                 (const char *) dst_data,
                                 (dsati_chset_type) dsatutil_get_val
                                           (DSATETSI_EXT_CSCS_IDX,0,NUM_TYPE),
                                 dst_size+1,
                                 TRUE) == NULL)
      {
         DS_AT_MSG1_MED("GSM 7 bit to %d char set conversion failure",
	                         (dsat_num_item_type) dsatutil_get_val(DSATETSI_EXT_CSCS_IDX,0,NUM_TYPE));
      }
    }	
  }
}
  

/*===========================================================================

FUNCTION ETSICALL_COPS_GENERATE_NETWORK_RESPONSE

DESCRIPTION
  This function generates the response for a single network.  The
  passed structure is cleared after reporting to indicate its been
  processed.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  May append further DSM items to original result buffer.
  
===========================================================================*/
LOCAL void etsicall_cops_generate_network_response
(
  ds_at_plmn_info        *plmn_info_ptr,
  boolean                 eons_available,
  dsm_item_type          *res_buff_ptr           /*  Place to put response       */
)
{
  char buffer[MAX_NETWORK_REPORT_LEN];
  char full_name[DSAT_MAX_FULLNAME_STR_LEN+1];
  char short_name[DSAT_MAX_SHORTNAME_STR_LEN+1];
  dsat_net_state_e_type net_state;
  sys_mcc_type  mcc;
  sys_mnc_type  mnc;
  boolean hit = FALSE;
  boolean undef = TRUE;
  boolean pcs_flag = FALSE;
  word size;
  dsat_cops_act_e_type act;
  uint8 j=0;
  uint8 name_len = DSAT_MAX_SHORTNAME_STR_LEN;
  dsatcmif_servs_state_info  *ph_val = NULL;
  dsat_sys_detailed_plmn_list_s_type *alist  = NULL;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);

  alist = dsat_get_cmd_mem_ptr();

  DS_ASSERT(plmn_info_ptr != NULL);
  memset(buffer,0x00,sizeof(buffer));
  
  for(j = 0 ; j < alist->length ; j++)
  {
    if( memcmp((byte *)&alist->info[j].plmn.identity[0],plmn_info_ptr->plmn_id.plmn_id_val,3) == 0 )
    {
      hit = TRUE;
      break;
    }
  } 

  if(!hit)
  {
    return;
  }

  /* Get the MCC & MNC from PLMN */    
  sys_plmn_get_mcc_mnc( alist->info[j].plmn,&undef, &pcs_flag, &mcc, &mnc );
  if (TRUE == undef)
    {
    mcc = mnc = 0;
    pcs_flag = FALSE;
  }

  memset ((void*)full_name, 0x0, sizeof(full_name));
  memset ((void*)short_name, 0x0, sizeof(short_name));

  net_state = etsicall_find_net_state ( &alist->info[j], &act );

  if(MMGSDI_EONS_ENC_UCS2 == plmn_info_ptr->short_name_encoding)
  {
    plmn_info_ptr->short_name_len = (plmn_info_ptr->short_name_len)/2;
  }

  name_len = (uint8) ( MIN(plmn_info_ptr->short_name_len,DSAT_MAX_SHORTNAME_STR_LEN) );
  DS_AT_MSG0_HIGH(" EONS available");
  if(name_len != 0 && plmn_info_ptr->short_name[0] != '\0')
  {
    etsicall_convert_chrset_todefault(plmn_info_ptr->short_name_encoding,
                                            (const byte *)plmn_info_ptr->short_name,(size_t)name_len,(byte *)short_name,
                                             DSAT_MAX_SHORTNAME_STR_LEN,NULL);
  }

  if(MMGSDI_EONS_ENC_UCS2 == plmn_info_ptr->long_name_encoding)
  {
    plmn_info_ptr->long_name_len= (plmn_info_ptr->long_name_len)/2;
  }

  name_len = (uint8) ( MIN(plmn_info_ptr->long_name_len,DSAT_MAX_FULLNAME_STR_LEN) );
  if(name_len != 0 && plmn_info_ptr->long_name[0] != '\0')
  {
    etsicall_convert_chrset_todefault(plmn_info_ptr->long_name_encoding,
                                          (const byte *)plmn_info_ptr->long_name,(size_t)name_len,(byte *)full_name,
                                             DSAT_MAX_FULLNAME_STR_LEN,NULL);
  }
  if ( pcs_flag )
  {
    size = (word)snprintf( buffer, sizeof(buffer),
                           "(%d,\"%s\",\"%s\",\"%03lu%03lu\",%d",
                           net_state,
                           full_name,
                           short_name,
                           mcc, mnc,
                           act );
  }
  else
  {
    size = (word)snprintf( buffer, sizeof(buffer),
                           "(%d,\"%s\",\"%s\",\"%03lu%02lu\",%d",
                           net_state,
                           full_name,
                           short_name,
                           mcc, mnc,
                           act );
  }

  size = (word)snprintf ((char*)buffer,
                                 sizeof(buffer),
                                 "%s),",
                                 buffer);
  /* Clear the reported value to avoid duplication */
  memset((void *)&alist->info[j].plmn,0xFF, 3);

  dsat_dsm_pushdown_tail(&res_buff_ptr, buffer, size,
                         DSM_ITEM_POOL(res_buff_ptr), FALSE);

} /* etsicall_cops_generate_network_response */

/*===========================================================================

FUNCTION ETSICALL_COPS_COPY_CATEGORY

DESCRIPTION 
   Internal Function to copy PLMN ID info. Currently used for +COPS specific
   commands.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL void dsat_cops_copy_all_categories
(
  dsat_sys_detailed_plmn_list_s_type *plmn_list,
  mmgsdi_plmn_id_type                *plmn_id_list,
  dsat_cops_cmd_idx_e_type            cmd_idx
)
{
  dsat_num_item_type        i = 0;
  dsat_num_item_type        j = 0;
  dsat_num_item_type        k = 0;

  dsat_sys_detailed_plmn_list_s_type *alist        = plmn_list;
  mmgsdi_plmn_id_type                *plmn_id      = plmn_id_list;

  for(k=0; k < SYS_DETAILED_PLMN_LIST_CATEGORY_MAX; k++)
  {
    for ( j=0; (j < alist->length) && (j < SYS_PLMN_LIST_MAX_LENGTH ) && ( i < alist->length); j++ )
    {
      if(alist->info[j].list_category == k)
      {
        (void)dsatutil_memscpy(plmn_id->plmn_id_val,MMGSDI_PLMN_ID_SIZE,&alist->info[j].plmn.identity[0],MMGSDI_PLMN_ID_SIZE);
        switch(alist->info[j].rat) 
        {
          case SYS_RAT_GSM_RADIO_ACCESS: 
            plmn_id->rat = MMGSDI_RAT_GSM; 
            break;
          case SYS_RAT_UMTS_RADIO_ACCESS: 
            plmn_id->rat = MMGSDI_RAT_UMTS; 
            break; 
          case SYS_RAT_LTE_RADIO_ACCESS:
          case SYS_RAT_LTE_M1_RADIO_ACCESS:
          case SYS_RAT_LTE_NB1_RADIO_ACCESS:
#ifdef FEATURE_NBIOT_NTN
          case SYS_RAT_LTE_NB1_NTN_RADIO_ACCESS:
#endif /* FEATURE_NBIOT_NTN */
            plmn_id->rat = MMGSDI_RAT_LTE; 
            break; 
          case SYS_RAT_TDS_RADIO_ACCESS: 
            plmn_id->rat = MMGSDI_RAT_TDS; 
            break; 
          default: 
            plmn_id->rat = MMGSDI_RAT_NONE;
        }
        plmn_id->csg_id = SYS_CSG_ID_INVALID;
        plmn_id++;
        i++;
      } 
    }
  }
  DS_AT_MSG1_HIGH("etsicall_cops_copy_category() Total PLMNS Copied: [%d]",i);
} /*etsicall_cops_copy_category*/

/*===========================================================================

FUNCTION ETSICALL_FIND_NET_STATE

DESCRIPTION
  This function returns the network registraiton state for the passed
  PLMN information returned form Call Manager.  The ATCOP AcT decoded
  from the RAT is also returned by reference.

DEPENDENCIES
  None
  
RETURN VALUE
  Enum value indicating network registration state

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL dsat_net_state_e_type etsicall_find_net_state
(
  const dsat_sys_detailed_plmn_list_info_s_type * plmn_info_ptr,
  dsat_cops_act_e_type * act_ptr
)
{
  dsatcmif_servs_state_info  *ph_val = NULL;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, TRUE);

  /* Decode the access technology paramater */
  switch (plmn_info_ptr->rat)
  {
#ifdef FEATURE_DSAT_LTE
  case SYS_RAT_LTE_RADIO_ACCESS:
    *act_ptr = DSAT_COPS_ACT_EUTRAN;
    break;

  case SYS_RAT_LTE_M1_RADIO_ACCESS:
    *act_ptr = DSAT_COPS_ACT_EUTRAN;
    break;

  case SYS_RAT_LTE_NB1_RADIO_ACCESS:
    *act_ptr = DSAT_COPS_ACT_EUTRAN_NB_S1;
    break;

#ifdef FEATURE_NBIOT_NTN
  case SYS_RAT_LTE_NB1_NTN_RADIO_ACCESS:
    *act_ptr = DSAT_COPS_ACT_SATELLITE_EUTRAN_NB_S1;
    break;
#endif /* FEATURE_NBIOT_NTN */

#endif /* FEATURE_DSAT_LTE */
  case SYS_RAT_GSM_RADIO_ACCESS:
  default:
    *act_ptr = DSAT_COPS_ACT_GSM;
    break;
  }

  /* If COPS is de-registered , then the plmn_forbidden status will
     not be filled correctly by lower layers. So setting
     the state to unknown */
  if( DSAT_COPS_MODE_DEREG == (dsat_num_item_type)dsatutil_get_val(
              DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE) )
  {
    return DSAT_NET_STAT_UNKNOWN;
  }
  /* Check for forbidden state */
  if ( TRUE == plmn_info_ptr->plmn_forbidden )
    return DSAT_NET_STAT_FORBIDDEN;
  /* Check for current registration state */
  else if( ( TRUE ==
            sys_plmn_match ( ph_val->dsatetsicall_network_list.previous_pref.plmn,
                              plmn_info_ptr->plmn ) ) &&
           (ph_val->dsat_net_reg_state.act == *act_ptr) )
    return DSAT_NET_STAT_CURRENT;
  /* Otherwise set available state */
  else
    return DSAT_NET_STAT_AVAILABLE;
  
} /* etsicall_find_net_state */


/*===========================================================================

FUNCTION ETSICALL_CONVERT_MMINFO_OPER_NAME

DESCRIPTION
  This function converts the operator name received from NAS
  mobility management message into suitable format for TE
  presentation.  The IRA character set is the assumed output format.

DEPENDENCIES
  None
  
RETURN VALUE
  TRUE on successful conversion; FALSE otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL boolean etsicall_convert_mminfo_oper_name
(
  const uint8  * name_ptr,
  sys_network_name_coding_scheme_type_e_type  in_scheme,
  char         * out_ptr,
  uint8          max_len,
  uint8          encoded_len
)
{
  uint8 num_chars;

  DS_AT_MSG3_MED("etsicall_convert_mminfo_oper_name: in_scheme = %d max_len = %d "
          "encoded_len = %d", in_scheme, max_len, encoded_len);

  if (!encoded_len || !max_len)
  {
    DS_AT_MSG0_ERROR("etsicall_convert_mminfo_oper_name called on ntw name with max_len "
              "or encoded_len set to 0, returning FALSE");
    return FALSE;
  }

  /* Translate coding scheme */
  switch( in_scheme )
  {
  case SYS_NW_NAME_CODING_SCHEME_UCS2:
    /* Convert from OTA coding scheme, assuming IRA output */
    num_chars = MIN(encoded_len/2, max_len); /* UCS2 is 16 bits per char */
    if( NULL == dsatutil_convert_chset( (char*)name_ptr, ALPHA_UCS2,
                                        out_ptr, ALPHA_IRA,
                                        num_chars, TRUE ))
    {
       DS_AT_MSG0_ERROR("UCS2 decode of MM info failed");
       return FALSE;
    }
    break;
  case SYS_NW_NAME_CODING_SCHEME_CELL_BROADCAST_DEFAULT_ALPHABET:
  default:
      encoded_len = MIN(encoded_len, max_len);
      num_chars = cm_util_gsm_alphabet_to_ascii( (byte*) out_ptr,
                                                 name_ptr,
                                                 encoded_len );
      /* Spare bits will be set to '0' as documented in 3GPP TS24.008
       * Section 10.5.3.5a, but the CM util function unpacks it assuming
       * USSD packing (if 7 spare bits, pack with carriage return = 0x0D).
       * This causes it to append an '@' if there are 7 spare bits, so
       * detect and correct this case. */
      if ( !(encoded_len % 7) && !(name_ptr[encoded_len - 1] & 0xFE) &&
            (out_ptr[num_chars - 1] == '@') )
      {
        DS_AT_MSG0_HIGH("Detected 7 spare bits in network name, removing trailing @");
        out_ptr[num_chars - 1] = '\0';
      }
      break;
  }
  

  return TRUE;
} /* etsicall_convert_mminfo_oper_name */

/*===========================================================================

FUNCTION  DSATETSICALL_REPORT_SS_LINEID_STATUS

DESCRIPTION
  This function reports the COLP/CLIP/CDIP supplementary service status
  received from Call Manager.

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_OK :       if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_report_ss_lineid_status
(
  ss_operation_code_T       * op_code,    /* Interrogation operation code */
  const ie_ss_status_T      * ss_info_ptr, /* SS info pointer */
  boolean                     in_service
)
{
  dsm_item_type           *res_buff_ptr = NULL;
  uint32                   ss_status;
  dsat_result_enum_type    result = DSAT_OK;

  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, FALSE);

  if(in_service == FALSE)
  {
    ss_status = DSAT_NO_NW_SERVICE;
  }
  else if (ss_info_ptr->present)
  {
    ss_status = ss_info_ptr->cm_ss_provisioned;
  }
  else
  {
    ss_status = DSAT_NO_NW_SERVICE;
  }

  switch(*op_code)
  {//TODO:Sanjykc
      case clir:
      res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                          res_buff_ptr->size,
                                          "+CLIR: %u,%lu",
                                          (dsat_num_item_type)dsatutil_get_val(
                                          DSATETSI_EXT_ACT_CLIR_ETSI_IDX,0,NUM_TYPE),
                                          ss_status);
      break;

    default:
      /* Being defensive when opcode is not colp/clip/clir & memory 
         was allocated earlier */
      dsm_free_packet(&res_buff_ptr);
      DS_AT_MSG1_ERROR("Invalid operation code %d", *op_code);
      result = DSAT_ERROR;
  }

  *op_code = (ss_operation_code_T)DSAT_INVALID_OP_CODE;
  if(result == DSAT_OK)
  {
    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
  }
  return result;
} /* dsatetsicall_report_ss_lineid_status */


/*===========================================================================

FUNCTION  DSAT_LINEID_BUF_COPY

DESCRIPTION
  This function fills out CLIP/COLP unified lineid buffer with call subaddress.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void etsicall_lineid_buf_copy
(
  const uint8            *line_num_buf,
  uint8                   line_num_len
)
{
  dsatetsicall_call_state_info  *call_val = NULL;
  dsat_num_item_type buffer_size = 0;
  
  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  call_val->dsat_lineid_buf[call_val->dsat_lineid_buf_length] = '"';
  call_val->dsat_lineid_buf_length++;

  buffer_size = DSAT_BUF_SIZE(DSAT_MAX_LINEID_BUF,call_val->dsat_lineid_buf_length);
  
  if(line_num_len <= CM_MAX_NUMBER_CHARS && buffer_size > 0)
  {
    (void) dsatutil_memscpy((void*)&call_val->dsat_lineid_buf[call_val->dsat_lineid_buf_length],
          buffer_size,(void*)line_num_buf,line_num_len);
  }else
  {
    DS_AT_MSG1_ERROR("LineID Buffer overflow %d", call_val->dsat_lineid_buf_length);
    return;
  }
  
  call_val->dsat_lineid_buf_length += line_num_len;

  if( call_val->dsat_lineid_buf_length < DSAT_MAX_LINEID_BUF)
  {
    call_val->dsat_lineid_buf[call_val->dsat_lineid_buf_length] = '"';
    call_val->dsat_lineid_buf_length++;
  }
} /* etsicall_lineid_buf_copy */


/*===========================================================================

FUNCTION  DSAT_LINEID_SUBADDR_BUF_COPY

DESCRIPTION
  This function fills out CLIP/COLP unified lineid buffer with call subaddress.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
LOCAL void etsicall_lineid_subaddr_buf_copy
(
  const uint8            *line_num_buf,
  uint8                   line_num_len
)
{
  dsat_num_item_type buffer_size = 0;
  dsatetsicall_call_state_info  *call_val = NULL;
  
  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  call_val->dsat_lineid_buf[call_val->dsat_lineid_buf_length] = '"';
  call_val->dsat_lineid_buf_length++;

  buffer_size = DSAT_BUF_SIZE(DSAT_MAX_LINEID_BUF,call_val->dsat_lineid_buf_length);

  if(line_num_len <= CM_MAX_SUBADDRESS_DIGITS && buffer_size > 0)
  {
    (void) dsatutil_memscpy((void*)&call_val->dsat_lineid_buf[call_val->dsat_lineid_buf_length],
               buffer_size,
               (void*)line_num_buf,
               line_num_len);
  }
  else
  {
    goto lineid_buf_overflow;
  }

  call_val->dsat_lineid_buf_length += line_num_len;

  buffer_size = DSAT_BUF_SIZE(DSAT_MAX_LINEID_BUF,call_val->dsat_lineid_buf_length);

  if (0 == buffer_size)
  {
    goto lineid_buf_overflow;
  }

  call_val->dsat_lineid_buf[call_val->dsat_lineid_buf_length] = '"';
  call_val->dsat_lineid_buf_length++;
  return;

lineid_buf_overflow:

  DS_AT_MSG1_ERROR("LineID Buffer overflow %d", call_val->dsat_lineid_buf_length);
  return;
} /* etsicall_lineid_subaddr_buf_copy */

/*===========================================================================

FUNCTION  ETSICALL_CALLED_LINEID_BUF_COPY

DESCRIPTION
  This function fills out CDIP unified lineid buffer with call subaddress.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void etsicall_called_lineid_buf_copy
(
  const uint8            *line_num_buf,
  uint8                   line_num_len
)
{

  dsat_num_item_type buffer_size = 0;
  dsatetsicall_call_state_info  *call_val = NULL;
  
  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  call_val->dsat_called_lineid_buf[call_val->dsat_called_lineid_buf_length] = '"';
  call_val->dsat_called_lineid_buf_length++;

  buffer_size = DSAT_BUF_SIZE(DSAT_MAX_CALLED_LINEID_BUF,call_val->dsat_called_lineid_buf_length);
  if(buffer_size > 0)
  {
    (void) dsatutil_memscpy((void*)&call_val->dsat_called_lineid_buf[call_val->dsat_called_lineid_buf_length],
             buffer_size,
             (void*)line_num_buf,
             line_num_len);
  }else
  {
    DS_AT_MSG1_ERROR("Called LineID Buffer overflow %d", call_val->dsat_called_lineid_buf_length);
    return;
  }
  call_val->dsat_called_lineid_buf_length += line_num_len;

  call_val->dsat_called_lineid_buf[call_val->dsat_called_lineid_buf_length] = '"';
  call_val->dsat_called_lineid_buf_length++;
} /* etsicall_called_lineid_buf_copy */

/*===========================================================================

FUNCTION  DSATETSICALL_EXEC_SS_ABORT_HANDLER

DESCRIPTION
  This function is the abort handler function for the SS functionality. 
  
DEPENDENCIES
  None

RETURN VALUE
  TRUE - meaning to abort the delay execution.

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
boolean dsatetsicall_exec_ss_abort_handler
(
  const struct dsati_cmd_struct *ptr
)
{
  ds_command_type *cmd_ptr;
  dsatetsicmif_sups_state_info  *sups_val = NULL;
  ds_at_cmd_status_type            *status_cmd_ptr = NULL;
    
  sups_val = dsat_get_base_addr(DSAT_SUPS_VALS, FALSE);

  sups_val->dsat_interr_ss_service = (ss_operation_code_T)DSAT_INVALID_OP_CODE;
  sups_val->dsat_ss_abort_status = TRUE;

  cmd_ptr = dsat_get_cmd_buf(sizeof(ds_at_cmd_status_type), FALSE);
  status_cmd_ptr = cmd_ptr->cmd_payload_ptr;

  /* Send abort event to restore normal command processing */
  cmd_ptr->hdr.cmd_id = DS_CMD_ATCOP_STATUS_CMD;
  status_cmd_ptr->cmd_id     = (uint16)SS_CM_CMD_ABORT;
  status_cmd_ptr->cmd_status = MMGSDI_SUCCESS;
  status_cmd_ptr->cmd_data   = 0;
  ds_put_cmd (cmd_ptr);

  return TRUE;
} /* dsatetsicall_exec_ss_abort_handler */


/*===========================================================================

FUNCTION DSATETSICALL_SS_ABORT_EVENT_HANDLER

DESCRIPTION
  This function handles +CLIP abort event handling.We set the ss service to 
  invalid state and return. This routine just ensures the AT command processor
  returns to normal processing.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_ERROR : as the function is aborted

SIDE EFFECTS
  None

===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_ss_abort_event_handler
(
  ds_at_cmd_status_type *cmd_info_ptr
)
{
  if( dsatcmdp_abortable_state != NOT_ABORTABLE)
  {
    return DSAT_ERROR;
  }
  else
  {
    return DSAT_ASYNC_EVENT ;
  }
} /* dsatetsicall_ss_abort_event_handler */

/*===========================================================================

FUNCTION  DSATETSICALL_REPORT_CLIR_STATUS

DESCRIPTION
  This function reports the CLIR supplementary service interrogation status
  received from Call Manager.

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_OK :       if it is a success.

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_report_clir_status
(
  ds_at_cm_sups_event_type *sups_event_ptr /* SUPS event pointer */
)
{
  dsm_item_type           *res_buff_ptr = NULL;
  uint32                   clir_interrogate_status;
  dsatetsicmif_sups_state_info  *sups_val = NULL;
  

  /* Initialize CLIR interrogate status to not provisioned
     And later overwrite with the appropriate status 
     received */

  clir_interrogate_status = (uint32)DSAT_CLIR_SRV_NOT_PROVISIONED;

  sups_val = dsat_get_base_addr(DSAT_SUPS_VALS, FALSE);

  if (sups_event_ptr->event_info.cli_restriction.present == TRUE)
  {
    if (sups_event_ptr->event_info.cli_restriction.cm_cli_restriction_option.present == TRUE)
    {
      switch (sups_event_ptr->event_info.cli_restriction.cm_cli_restriction_option.option)
      {
      case CLI_DEFAULT_OPTION:
        /* This maps to Permanent CLIR provisioning */
        clir_interrogate_status = (uint32)DSAT_CLIR_SRV_PROVISIONED_PERMANENT;
        break;
      
      case CLI_RESTRICT_OPTION:
        /* This maps to default CLIR ON and can be overidden */
        clir_interrogate_status = (uint32)DSAT_CLIR_SRV_PRESENTATION_RESTRICTED;
        break;

      case CLI_OVERRIDE_OPTION:
        /* This maps to CLIR default - requires explicit CLIR status to be used
           during call setup */
        clir_interrogate_status = (uint32)DSAT_CLIR_SRV_PRESENTATION_ALLOWED;
        break;

      default:
        /* Ideally filtered by CM and should not be received */
        /* Map it to non provisioned status */
        break;
      } 
    }
  }

#if 0 

  /* We are removing this behaviour as per CR 177923.*/
  /* Update local CLIR setting in accordance with N/W settings 
     Any conflicting user CLIR setting with interrogated result is made as 
     default. This conforms to S65 phone's behavior */
  if(((dsat_clir_val == (dsat_num_item_type)DSAT_CLIR_SUPPRESSION_OPTION) && 
     ((clir_interrogate_status == (uint32)DSAT_CLIR_SRV_PRESENTATION_ALLOWED) ||  
      (clir_interrogate_status == (uint32)DSAT_CLIR_SRV_PROVISIONED_PERMANENT))) ||
     ((dsat_clir_val == (dsat_num_item_type)DSAT_CLIR_INVOCATION_OPTION) && 
      (clir_interrogate_status == (uint32)DSAT_CLIR_SRV_PRESENTATION_RESTRICTED)) ||
      (clir_interrogate_status == (uint32)DSAT_CLIR_SRV_NOT_PROVISIONED))
  {
    dsat_clir_val = (dsat_num_item_type)DSAT_CLIR_PRESENTATION_INDICATOR;
  }
#endif 
  res_buff_ptr = dsat_dsm_new_buffer(DSM_DS_SMALL_ITEM_POOL, TRUE);
  if (NULL != res_buff_ptr)
  {
    res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                              res_buff_ptr->size,
                                              "+CLIR: %u,%lu",
                                              (dsat_num_item_type)dsatutil_get_val(
                                              DSATETSI_EXT_ACT_CLIR_ETSI_IDX,0,NUM_TYPE),
                                              clir_interrogate_status);

    dsatcmdp_handle_async_cmd_rsp(res_buff_ptr, DSAT_COMPLETE_RSP);
  }
  sups_val->dsat_interr_ss_service = (ss_operation_code_T)DSAT_INVALID_OP_CODE;

  return DSAT_OK;
} /* dsatetsicall_report_clir_status */

/*===========================================================================

FUNCTION  DSATETSICALL_EXEC_VTS_CMD

DESCRIPTION
  This function generates a dtmf during an ongoing call.

DEPENDENCIES
  An active call

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_ASYNC_CMD : Intermediate Response
    DSAT_OK :       if it is a success.
SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_exec_vts_cmd
(
  dsat_mode_enum_type mode,             /*  AT command mode:            */
  const dsati_cmd_type *parse_table,    /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,    /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr           /*  Place to put response       */
)
{

  dsat_result_enum_type result = DSAT_OK;

  /*--------------------------------------------------------------------------
   Invoke the general AT parameter handler for TEST command
  ---------------------------------------------------------------------------*/
  if( tok_ptr->op == (NA|EQ|QU) )
  {
    res_buff_ptr->used = (word)snprintf((char*)res_buff_ptr->data_ptr,
                                                res_buff_ptr->size,
                                                "+VTS: (0-9,A-D,*,#)");
  }
  /*--------------------------------------------------------------------------
     Execute command
  ---------------------------------------------------------------------------*/
  else if ( tok_ptr->op == (NA|EQ|AR) )
  {
    /* Return ERROR if there are more than one args or 
     * if token is not valid.
     */
    if( ( tok_ptr->args_found != 1 ) || ( !VALID_TOKEN(0) ) )
    {
      return DSAT_ERROR;
    }
    result = dsatetsicall_start_dtmf( tok_ptr ); 
  }
  else 
  {
    result = DSAT_ERROR;
  }

  return result;
}/* dsatetsicall_exec_vts_cmd */

/*===========================================================================

FUNCTION  DSATETSICALL_START_DTMF

DESCRIPTION
  This function process the 'write' command of +vts.It process the Input DTMF
  code and Calls the CM API to generate a inband DTMF tone in a active call

DEPENDENCIES
  Command Valid if there is an active call

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_ASYNC_CMD : Intermediate Response

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_start_dtmf 
(
  const tokens_struct_type * tok_ptr 
)
{
  byte dtmf_code;
  dsat_result_enum_type result  = DSAT_ASYNC_CMD;
  dsatetsicall_call_state_info  *call_da_val = NULL;
  cm_call_id_type call_id;

  call_da_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

  DS_ASSERT(NULL != tok_ptr);
  dtmf_code = tok_ptr->arg[0][0];
  
  /* Check for an active call and change the case of DTMF code */
  /* Currently we support Inband DTMF on the primary active call */
  /* Putting check for CM_CALL_MODE_INFO_NONE as well because we 
     are receiving this info type during emergency call */
    DS_AT_MSG4_HIGH("In dsatetsicall_start_dtmf %d %d %d %d",call_da_val->etsicall_num_active_calls,
                                        call_da_val->call_info_before_connect.call_id,
                                        call_da_val->call_info_before_connect.info_type,
                                        call_da_val->etsicall_active_call_ids[0]);
  if ( call_da_val->etsicall_num_active_calls != 0 ||
      (call_da_val->call_info_before_connect.call_id != CM_CALL_ID_INVALID &&
       (call_da_val->call_info_before_connect.info_type == CM_CALL_MODE_INFO_IP ||
        call_da_val->call_info_before_connect.info_type == CM_CALL_MODE_INFO_NONE)) )
  {
    dtmf_code = UPCASE( dtmf_code );
    /* Verify DTMF code.  */
    if (  (strlen( (char *)tok_ptr->arg[0] ) == 1 ) &&
          ( IS_DIGIT( dtmf_code ) || 
            (dtmf_code == '#') || 
            (dtmf_code == '*') || 
            ( (dtmf_code >= 'A') && (dtmf_code <= 'D') ) ) )
    {
      DS_AT_MSG0_HIGH("In dsatetsicall_start_dtmf");
      SET_PENDING(DSATETSI_EXT_ACT_VTS_ETSI_IDX ,0, DSAT_PENDING_TRUE)
      /* Return value is ignored as error case is handled by callback func */
      if(call_da_val->call_info_before_connect.call_id != CM_CALL_ID_INVALID && 
         (call_da_val->call_info_before_connect.info_type == CM_CALL_MODE_INFO_IP ||
          call_da_val->call_info_before_connect.info_type == CM_CALL_MODE_INFO_NONE) )
      {
        call_id = call_da_val->call_info_before_connect.call_id;
      }
      else
      {
        call_id = call_da_val->etsicall_active_call_ids[0];
      }
      DS_AT_MSG1_HIGH("dsatetsicall_start_dtmf: call_id %d", call_id);
      (void) cm_mm_inband_cmd_start_cont_dtmf( dsatcmif_cm_inband_cmd_cb_func, 
                                               NULL,
                                               dsatcm_client_id,
                                               call_id,
                                               dtmf_code );
    }
    else
    {
      DS_AT_MSG0_HIGH("Unrecognized DTMF tone in dsatetsicall_start_dtmf()");
      result = DSAT_ERROR;
    }
  }
  else 
  {
    DS_AT_MSG0_HIGH("No Active Calls");
    result = DSAT_ERROR;
  }
  return result;

}/* dsatetsicall_start_dtmf */

/*===========================================================================

FUNCTION  dsatetsicall_inband_dtmf_timer_expired_handler

DESCRIPTION
  Handler Function for DTMF Timer.

DEPENDENCIES
  None

RETURN VALUE
  Returns an enum that describes the result of the execution.
  Possible values:
    DSAT_ERROR :    if there was any problem in execution.
    DSAT_OK :       if it is a success.
    DSAT_ASYNC_EVENT Intermediate Response

SIDE EFFECTS
  None

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
dsat_result_enum_type dsatetsicall_inband_dtmf_timer_expired_handler 
(
  ds_command_type        * cmd_ptr       /* DS Command pointer		 */
)
{
  dsat_timer_id_e_type *timer_id_ptr = dsat_get_cmd_payload_ptr(cmd_ptr);
  if((*timer_id_ptr) != DSAT_INBAND_DTMF_RING)
  {  
	DS_AT_MSG0_HIGH("In dsatetsicall_inband_dtmf_timer_expired_handler");
	return DSAT_ERROR;
  }
  cm_call_id_type call_id;
  dsatetsicall_call_state_info  *call_da_val = NULL;

  call_da_val = dsat_get_base_addr(DSAT_CALL_VALS, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  DS_AT_MSG0_HIGH("In dsatetsicall_inband_dtmf_timer_expired_handler");

  if(call_da_val->call_info_before_connect.call_id != CM_CALL_ID_INVALID && 
    (call_da_val->call_info_before_connect.info_type == CM_CALL_MODE_INFO_IP ||
    call_da_val->call_info_before_connect.info_type == CM_CALL_MODE_INFO_NONE) )
  {
    call_id = call_da_val->call_info_before_connect.call_id;
  }
  else
  {
    call_id = call_da_val->etsicall_active_call_ids[0];
  }

  if ( CHECK_PENDING(DSATETSI_EXT_ACT_VTS_ETSI_IDX,0,DSAT_PENDING_TRUE) )
  {
    (void)cm_mm_inband_cmd_stop_cont_dtmf( dsatcmif_cm_inband_cmd_cb_func,
                                           NULL,
                                           dsatcm_client_id,
                                           call_id,
                                           0 );
  }
  else 
  {
    DS_AT_MSG0_ERROR(" Wrong function invocation ");
  }
  return DSAT_ASYNC_EVENT;
}/*dsatetsicall_inband_dtmf_timer_expired_handler*/

#ifdef FEATURE_DSAT_LTE
/*===========================================================================
FUNCTION: DSATETSICALL_EXEC_CVMOD_CMD

DESCRIPTION
  This function takes the result from the command line parser
  and executes it. It executes at+cvmod command.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_OK : if the command has been successfully executed
    DSAT_ERROR : if there was any problem in executing the command

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_exec_cvmod_cmd
(
  dsat_mode_enum_type mode,               /*  AT command mode:            */
  const dsati_cmd_type *parse_table,      /*  Ptr to cmd in parse table   */
  const tokens_struct_type *tok_ptr,      /*  Command tokens from parser  */
  dsm_item_type *res_buff_ptr             /*  Place to put response       */
)
{
  #define DSAT_VOICE_MODE_MAX  4
  
  dsat_result_enum_type         result        = DSAT_OK;
  dsat_num_item_type                voice_domain_pref = DSAT_VOICE_MODE_MAX;    /* Voice domain preference */  
  cm_cmd_user_pref_update_type      user_pref;
  
  if (tok_ptr->op == (NA|EQ|AR))
  {
    if( tok_ptr->args_found == 1 && (VALID_TOKEN(0))&& 
       (ATOI_OK == dsatutil_atoi(&voice_domain_pref,tok_ptr->arg[0],10))&&
       ( voice_domain_pref < DSAT_VOICE_MODE_MAX)
      )
    {
      memset(&user_pref,0x0,sizeof(user_pref));
      if ( !cm_user_pref_init( &user_pref ) )
      {
       return DSAT_ERROR;
      }
      user_pref.client_id = dsatcm_client_id;
      user_pref.pref_term = CM_PREF_TERM_PERMANENT;
       /*Change voice domain pref*/
      user_pref.voice_domain_pref = voice_domain_pref;
      SET_PENDING(DSATETSI_EXT_ACT_CVMOD_ETSI_IDX ,0, DSAT_PENDING_TRUE)
      if(FALSE == cm_user_pref_update_req(&user_pref,dsatcmif_ph_cmd_cb_func,NULL))
      {
        SET_PENDING(DSATETSI_EXT_ACT_CVMOD_ETSI_IDX ,0, DSAT_PENDING_FALSE)
        result = DSAT_ERROR;
      }
      else
      {
        result = DSAT_ASYNC_CMD;
      }
      
    }
    else
    {
      DS_AT_MSG1_ERROR("+CVMOD: Invalid arguement value  %d", voice_domain_pref);
      return DSAT_ERROR;
    }
  }else if(tok_ptr->op == (NA|QU))
  {
    voice_domain_pref = cm_ph_get_voice_domain_pref();
    res_buff_ptr->used = (word) snprintf((char *)res_buff_ptr->data_ptr,
                                              res_buff_ptr->size,
                                              "+CVMOD: %d",(int)voice_domain_pref);
  }else if(tok_ptr->op == (NA|EQ|QU))
  {
     res_buff_ptr->used = (word) snprintf((char *)res_buff_ptr->data_ptr,
                                              res_buff_ptr->size,
                                              "+CVMOD: (0-3)");
  }else if(tok_ptr->op == (NA))
  {
     /* Do nothing: No default value mentioned in SPEC*/
      result = DSAT_OK;
  }
  else
  {
      /* wrong operation */
    result = DSAT_ERROR;
  }
  return result;
}/*dsatetsicall_exec_cvmod_cmd*/
#endif /* FEATURE_DSAT_LTE*/

/*===========================================================================
FUNCTION: DSATETSICALL_PROCESS_PLMN_INFO

DESCRIPTION
  This function processes PLMN data for at+cops command 
  and registers/deregister with the available network
  based on the Access Technology

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_OK : if the command has been successfully executed
    DSAT_ERROR : if there was any problem in executing the command
    DSAT_ASYNC_CMD : if user want to deregister

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_process_plmn_info(void)
{
   dsat_result_enum_type result = DSAT_ERROR;
   dsat_cops_act_e_type current_act_pref = DSAT_COPS_ACT_MAX;
   dsatcmif_servs_state_info  *ph_val = NULL;
   dsatetsicall_call_state_info  *call_val = NULL;
   dsat_cops_act_e_type current_act;

#ifdef FEATURE_DUAL_SIM
   cm_subscription_status_e_type status_one = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
   cm_subscription_status_e_type status_two = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
   cm_subscription_status_e_type status_three = CM_SUBSCRIPTION_STATUS_NO_CHANGE;
#endif /* FEATURE_DUAL_SIM */

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);
  call_val = dsat_get_base_addr(DSAT_CALL_VALS, FALSE);

   current_act = ph_val->dsat_net_reg_state.act;
   /* Cross-reference CM RAT preference to AcT parameter */
   if ( TRUE !=
    dsatetsicmif_lookup_cm_rat_pref( FALSE, &current_act_pref,
    &(ph_val->dsat_net_reg_state.cmph_pref.network_rat_mode_pref))
    )
   {
     current_act_pref = DSAT_COPS_ACT_MAX; /* never match */
   }
   /* Get current_act_pref for CIOT */
   DSATETSICALL_GET_CIOT_LTE_COPS_PREF(current_act_pref, DSAT_COPS_ACT_MAX)
 
   /* Check for (PLMN+AcT) same as current OR we are in automatic
       * mode.  No CM SS events are received if PLMN is not different so
       * return to command mode after PH prefernece change event
       * received.  For fully automatic mode, its somewhat non-
       * deterministic whether serving system change event will be
       * received. */
 
   /* If voice call is active, mode pref change needs to be droped 
       since lower layers dont support it */

    if((ph_val->net_pref.act != current_act_pref)&&(call_val->etsicall_num_active_calls != 0))
   {
      DS_AT_MSG0_ERROR("Droping request since voice call is active");
      return DSAT_ERROR;
   }

   if (DSAT_COPS_MODE_DEREG == ph_val->net_pref.mode)
   {
     ph_val->dsatetsicall_network_list.cmd_state = DSAT_COPS_ASTATE_DEREG;
   }
   /* Test for (PLMN + AcT) same as current */
   else if( (( TRUE ==
         sys_plmn_match (ph_val->net_pref.plmn,
         (ph_val->dsat_net_reg_state.net_id_info.plmn)) ) &&
         ((ph_val->net_pref.act == current_act_pref)||
         (ph_val->net_pref.act == DSAT_COPS_ACT_AUTO))) ||

          /* Test for certain AcT change case (ie on GSM, requesting UTRAN
           * or opposite case) */
          (( DSAT_COPS_MODE_AUTO == ph_val->net_pref.mode ) &&
           ((current_act == ph_val->net_pref.act) &&  (ph_val->net_pref.is_arg2_valid) )) ||

           /* If This is mode changes only*/
          (( DSAT_COPS_MODE_AUTO == ph_val->net_pref.mode )&&
          ((ph_val->net_pref.no_of_args == 1 && ph_val->net_pref.is_arg0_valid))))
   {
      DS_AT_MSG0_HIGH("COPS setting preference only; early return code");
      ph_val->dsatetsicall_network_list.cmd_state =
                                          DSAT_COPS_ASTATE_PREF_ONLY;
   }
   else
   {
      ph_val->dsatetsicall_network_list.cmd_state =
                                                DSAT_COPS_ASTATE_PREF;
   }

   /* If the dereg_success should be true and the requested mode should not
       be either DEREG or SETFMT */
    if ( ph_val->net_pref.last_dereg_success == TRUE )
    {
       if ( ph_val->net_pref.mode == DSAT_COPS_MODE_DEREG )
       {
          DS_AT_MSG0_HIGH("COPS is already in DEREG state, early return");
          return DSAT_OK;
       }
       else if(ph_val->net_pref.mode != DSAT_COPS_MODE_SETFMT)
       {
          /* Active flag will not be set to FALSE when ATCoP goes SUBSCRIPTION
                         UNAVAILABLE */
          if (dsat_qcsimapp_info[dsat_get_current_gw_apps_id(FALSE)].active == FALSE)
          {
             DS_AT_MSG0_ERROR("SIM is in illegal subscription state");
                  /* Restore previous COPS value in case of ERROR */
             result = dsat_send_cme_error(DSAT_CME_SIM_FAILURE);
             return result;           
          }

          if ( cm_ph_cmd_subscription_available ( dsatcmif_ph_cmd_cb_func,
                                    NULL,
                                    dsatcm_client_id,
                                    CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                    CM_SUBSCRIPTION_STATUS_CHANGE,
                                    CM_SUBSCRIPTION_STATUS_NO_CHANGE) == TRUE )
          {
             /*This boolean is used to handle the geniune event
                          of CM_PH_EVENT_SUBSCRIPTION_AVAILABLE */
             ph_val->net_pref.subscription_invoked = TRUE; 
          }
         return DSAT_ASYNC_CMD;
       }
    }/* Last de-registartion was success */
    DS_AT_MSG2_HIGH("Mode %d ACT %d", ph_val->net_pref.mode,
                                      ph_val->net_pref.act);
           /* Process paramaters based on mode */
    switch (ph_val->net_pref.mode)
    {
       case  DSAT_COPS_MODE_AUTO:
       case  DSAT_COPS_MODE_DEREG:
          result = dsatetsicmif_change_network_registration (
                                  ph_val->net_pref.mode,
                                  NULL,
                                  ph_val->net_pref.act);
          break;

       case  DSAT_COPS_MODE_MANUAL:
       case  DSAT_COPS_MODE_MANAUTO:
          result = dsatetsicmif_change_network_registration (
                                  ph_val->net_pref.mode,
                                  &(ph_val->net_pref.plmn),
                                  ph_val->net_pref.act);
          if(DSAT_OK == result)
          {
             /* This happens when CM is already registered with a PLMN 
                        and COPS mode is set to either MANUAL or MANAUTO. If MANAUTO
                        is set then CM will move to MANUAL if it was in automatic previously.*/
              DSATUTIL_SET_VAL(DSATETSI_EXT_ACT_COPS_ETSI_IDX,
                      0,
                      0,
                      (dsat_num_item_type)DSAT_COPS_MODE_MANUAL,MIX_NUM_TYPE)
          }
          break;

       case  DSAT_COPS_MODE_SETFMT:
          /* Do nothing */
          break;

       default:
          DS_AT_MSG1_ERROR("Error: Unsupported mode: %d", 
                     ph_val->net_pref.mode);
          result = DSAT_ERROR;
          break;
    }
   
    if (DSAT_ERROR == result)
    {
       result = dsat_send_cme_error(DSAT_CME_PHONE_FAILURE);
    }
  return result;
}/* dsatetsicall_process_plmn_info */

#ifdef FEATURE_MMGSDI

/*===========================================================================
FUNCTION: DSATETSICALL_COPS_MMGSDI_CMD_HANDLER

DESCRIPTION
  This function handles at+cops command.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of the command execution.
  possible values:
    DSAT_OK : if the command has been successfully executed
    DSAT_ERROR : if there was any problem in executing the command

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_cops_mmgsdi_handler
(
  ds_at_mmgsdi_plmn_info_type  *plmn_info_ptr
)
{
#define CONVERT_TO_PLMN2( mcc, mnc, plmn, pcs_flag ) \
    if ( FALSE == \
         sys_plmn_set_mcc_mnc( (mnc > 99 || pcs_flag)? TRUE : FALSE, \
                               mcc, mnc, &plmn ) ) \
     { \
       DS_AT_MSG2_ERROR("Error parsing MCC/MNC into PLMN: [%d,%d]", \
                  mcc,mnc); \
       dsat_send_cme_error(DSAT_CME_PHONE_FAILURE); \
       return DSAT_CMD_ERR_RSP; \
     }
   
  dsatcmif_servs_state_info  *ph_val = NULL;

   ph_val = dsat_get_base_addr(DSAT_PH_VALS, FALSE);
  /* Convert MCC/MNC to PLMN, set 3rd MNC digit if MNC string was of 3 characters */
  CONVERT_TO_PLMN2( plmn_info_ptr->plmn_info.mcc, 
        plmn_info_ptr->plmn_info.mnc,
        ph_val->net_pref.plmn,
        (MMGSDI_PLMN_NETWK_TYPE_PCS_1900_MASK &
               plmn_info_ptr->plmn_info.network_mask));

  /* Process PLMN data */
  return dsatetsicall_process_plmn_info();
}/* dsatetsicall_cops_mmgsdi_handler */


/*===========================================================================
FUNCTION: DSATETSICALL_COPS_CMD_CB_FUNC

DESCRIPTION
  This function handles at+cops command.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatetsicall_cops_cmd_cb_func
(
  uint32                                  client_ref,
  mmgsdi_se13_plmn_static_info_type      *se13_plmn_info_ptr,
  uint16                                  plmn_id
)
{
  ds_at_mmgsdi_plmn_info_type      plmn_info_ptr;      
  dsatme_mmgsdi_state_info  *me_val = NULL;         
  dsat_result_enum_type result = DSAT_ERROR;       
  
  DS_AT_MSG1_ERROR("dsatetsicall_cops_cmd_cb_func %d",plmn_id);       
  if(plmn_id == 0)
  {
    dsat_send_cme_error(DSAT_CME_NOT_FOUND);
    return DSAT_CMD_ERR_RSP;
  }   
  memset(&plmn_info_ptr,0,sizeof(ds_at_mmgsdi_plmn_info_type));

  dsatutil_memscpy(&plmn_info_ptr.plmn_info,
               sizeof(mmgsdi_se13_plmn_static_info_type),
               se13_plmn_info_ptr,
               sizeof(mmgsdi_se13_plmn_static_info_type));
  
   if(client_ref == COPS_MMGSDI_PLMN_INFO)
    result=  dsatetsicall_cops_mmgsdi_handler(&plmn_info_ptr);
   else if(client_ref == CPOL_MMGSDI_PLMN_INFO)
   {
      me_val = dsat_get_base_addr(DSAT_MMGSDI_VALS, TRUE);
      me_val->dsat_cpol_write_params.mcc = plmn_info_ptr.plmn_info.mcc;
      me_val->dsat_cpol_write_params.mnc = plmn_info_ptr.plmn_info.mnc;
      /* Process PLMN data */
      result = dsatetsime_process_plmn_info();
    }
  return result;
}
#endif /*FEATURE_MMGSDI*/

/*===========================================================================
FUNCTION: DSATETSICALL_GET_CIOT_LTE_COPS_PREF

DESCRIPTION
  This function maps CM CIOT LTE preference to COPS ACT value.

DEPENDENCIES
  None

RETURN VALUE
  COPS ACT value

SIDE EFFECTS
  None

===========================================================================*/
dsat_cops_act_e_type dsatetsicall_get_ciot_lte_cops_pref ( 
  cm_ciot_lte_op_mode_e_type cm_mode,
  dsat_cops_act_e_type       at_mode
)
{
  dsat_cops_act_e_type act_pref = DSAT_COPS_ACT_MAX;
/* - - - - - - - - - - - - - - - - -- - -  - - - - - - - - - - - - - - - - */

  switch(cm_mode)
  {
    case CM_LTE_IOT_OP_MODE_PREF_M1:
      act_pref = DSAT_COPS_ACT_EUTRAN;
      break;

    case CM_LTE_IOT_OP_MODE_PREF_NB1:
      act_pref = DSAT_COPS_ACT_EUTRAN_NB_S1;
      break;

#ifdef FEATURE_NBIOT_NTN
    case CM_LTE_IOT_OP_MODE_PREF_NB1_NTN:
      act_pref = DSAT_COPS_ACT_SATELLITE_EUTRAN_NB_S1;
      break;
#endif /* FEATURE_NBIOT_NTN */

    case CM_LTE_IOT_OP_MODE_PREF_WB:
      break;

    default:
      act_pref = at_mode;
      break;
  }
  return act_pref;
}

#endif /* FEATURE_DSAT_ETSI_MODE */
