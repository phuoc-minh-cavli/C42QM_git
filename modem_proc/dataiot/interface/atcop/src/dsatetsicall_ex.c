/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                D A T A   S E R V I C E S

                U M T S

                C A L L   C O N T R O L
                                
                A T   C O M M A N D   P R O C E S S I N G

GENERAL DESCRIPTION
  This module executes AT commands. It executes UMTS specific call control 
  AT commands.

  
EXTERNALIZED FUNCTIONS
  dsat_send_cr_result
    Sends intermediate service reporting result code to TE or PS protocol
    stack based on response routing provided by response router.
    

EXTERNALIZED FUNCTIONS INTERNAL TO DSAT UNIT
  dsatetsicall_init_call
    This function intializes ETSI call handling.

  dsatetsicall_exec_cdip_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CDIP command, which enables/disables the display of 
    called line identification.
  
  dsatetsicall_exec_ctfr_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CTFR command, which controls the call deflection (call Transfer)
    supplementary service acording to 3GPP TS 22.072 [30]
      
  dsatetsicall_set_crc_result
    Produces unformatted incoming call indication or GPRS network request
    for PDP context activation result and returns in DSM item.

  dsatetsicall_exec_cbst_cmd
    This function takes the result from the command line parser
    and executes it. It executes +CBST command.It is used to select
    bearer services to be used when data calls are originated. 

  dsatetsicall_voice_dial_cmd
    Handle atd voice dial commands.  This function is called by 
    dsatact_exec_atd_cmd when dial string has ;.

  dsatetsicall_exec_chup_cmd
    This is the command handler function for +CHUP.

  dsatetsicall_exec_ccfc_cmd
    This function takes the result from the command line parser and executes 
    it. 

  dsatetsicall_report_ccfc
    This function reports the call forwarding supplementary service status
    received from Call Manager.

  dsatetsicall_exec_clck_cmd
    This function controls the facility lock supplementary service.

  dsatetsicall_report_clck
    This function reports the facility lock supplementary service status
    received from Call Manager.

  dsatetsicall_exec_cpwd_cmd
    This function sets new passwords for facility lock supplementary service.

  dsatetsicall_exec_cusd_cmd
    This function control of Unstructured Supplementary Service Data (USSD).

  dsatetsicall_exec_chld_cmd
    This function controls the call hold supplementary service. 

  dsatetsicall_update_call_state
    Maintains call state, held/active, for voice and CS data calls. 
    
  dsatetsicall_sups_cmd_cb_handler
    Handles error responses for CM Supplementary Service commands generated by
    +CHLD command

  dsatetsicall_call_event_connect_ex
    Handles CM_CALL_EVENT_CONNECT events, keeping call state info up to 
    date.

  dsatetsicall_call_event_end_ex
    Handles CM_CALL_EVENT_END events, keeping call state info up to 
    date.

  dsatetsicall_call_event_incom
    Handles CM_CALL_EVENT_INCOM events, keeping call state info up to 
    date.

  dsatetsicall_exec_es_cmd
    This function executes +ES command, which set parameters for entering 
    or exiting synchronous access mode.

  dsatetsicall_exec_esa_cmd
    This function executes +ESA command, which set parameters for synchronous 
    access mode configuration.

  dsatetsicall_es_export
    This function export the +ES's value to other subsystem.

  dsatetsicall_esa_export
    This function export the +ESA's value to other subsystem.

  dsatetsicall_exec_crlp_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +CRLP command, which processes parameters for
    non-transparnet/asynchronous circuit-switched data calls.

  dsatetsicall_crlp_response_fmt
    This function generates the response for the +CRLP read & test
    commands.  The &V command respose is handled as well.  Data is
    extracted from data structure and formatted according to
    parameter flag.

  dsatetsicall_init_crlp_export
    This function intializes the +CRLP multidimensional value list.

  dsatetsicall_exec_caoc_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CAOC command, which enables/disables
    unsolitited result codes for advice of charge supplementary service.

  dsatetsicall_caoc_timer_expired_handler 
    This function is the handler function for the +CAOC command
    reporting timer expired event.

  dsatetsicall_exec_cacm_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CACM command, which reports the
    accumulated call meteter from the SIM/USIM.
    
  dsatetsicall_exec_camm_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CAMM command, which reports or resets the 
    accumulated call meter maximum from the SIM/USIM.

  dsatetsicall_aoc_verify_pin_handler
    This function is the handler function for the +CACM/+CAMM commands
    PIN2 verification.

  dsatetsicall_exec_cpuc_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CPUC command, which reports or sets the 
    Price per Unit and Currency table from the SIM/USIM.

  dsatetsicall_exec_cops_cmd
    This function takes the result from the command line parser and executes 
    it. It executes +COPS command, which list available networks and sets
    automatic/manual registration.

  dsatetsicall_cops_abort_cmd_handler
  dsatetsicall_cops_abort_event_handler
    This function handles an abort command to terminate asynchronous
    processing for +COPS registration operation.
    
  dsatetsicall_cops_asynch_handler
    This function manages the asynchronous processing of the +COPS
    command. 

  dsatetsicall_exec_ceer_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CEER command, which report the reason
    for the last call failure to setup or release.

  dsatetsicall_exec_cqi_cmd
    This function takes the result from the command line parser and
    executes it. It executes +CQI command, which report the GW Channel 
    Quality Indicator.
    
   Copyright (c) 2001 - 2022 by Qualcomm Technologies Incorporated.
   All Rights Reserved.
   Qualcomm Confidential and Proprietary.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

   $Header: //components/rel/dataiot.mpss/2.0/interface/atcop/src/dsatetsicall_ex.c#13 $ $DateTime: 2022/10/10 02:02:46 $ $Author: pwbldsvc $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
10/01/22   ks      Added CM_SS_CIOT_LTE_SYS_MODE_MASK support for properly
                   updating cell-id during NB_IOT -> CATM transition.
05/25/21   ks      Added SYS_ID mask check as part of serving state update to
                   properly update cell_id.
09/03/21   ks      Removing domain check to allow CS PS domains to properly
                   get updated when it's NO SERVICE.
07/09/20   ks      Fixed incorrect cell-id on attaching to LTE network.
07/07/20   ks      Fixed issue with CREG and CGREG URCs.
07/02/20   ks      Fixed issue with +CREG registration status does not match 
                   with +COPS return value.
07/02/20   ks      Fixed incorrect CGREG URC after UE resume service from 
                   service reject.
07/01/20   ks      Fixed issue with CREG & CEREG.
06/29/20   ks      Fixed issue with registration status after LTE detach.
06/29/20   ks      Fixed issue regarding at+cgreg? returning DSAT_NET_REG_HOME
                   even the PS attach is rejected by NW.
06/26/20   ks      Fixed +CREG displaying invalid ACT value.
01/19/17   skc     Added enhancement on CHLD and CLCC for VoLTE MPTY Call.
10/28/16   skc     Added support for AT+VTS before connect event.
05/04/15   sc      Fixed +CHLD command issue to use requesting client id
                   instead of call client id. 
04/15/15   sc      Fixed issue in event handling to use subs_id provided in 
                   event info.
06/27/14   tk/sc   Initial revision (created file for Dynamic ATCoP).
07/08/14   sc      Fixed SGLTE+G issue on SUB2.

===========================================================================*/


/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"

#include <stringl/stringl.h>


/* This file should be included only in GSM or WCDMA mode */
#ifdef FEATURE_DSAT_ETSI_MODE

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "rex.h"
#include "amssassert.h"
#include "err.h"
#include "msg.h"
#include "cmutil.h"

#if defined(T_WINNT)
#error code not present
#endif /* WINNT */

#include "dsati.h"
#include "dsatact.h"
#include "dsatctab.h"
#include "dsatdl.h"
#include "dsatetsicall.h"
#include "dsatetsictab.h"
#include "dsatetsime.h"
#include "dsatetsicmif.h"
#include "dsatcmif.h"
#include "dsatparm.h"
#include "dsatvoice.h"
#include "ds_cap.h" /* ITC_SPEECH */
#include "mn_cm_exp.h"

#ifdef FEATURE_DSAT_ETSI_DATA
#include "dsatetsipkt.h"
#endif /* FEATURE_DSAT_ETSI_DATA */

#include "ds3gsiolib.h"


#ifdef FEATURE_DATA_WCDMA_PS
#include "dsatvend.h"
#endif /* FEATURE_DATA_WCDMA_PS */

#include "sys_v.h"


/*===========================================================================

            PUBLIC DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains public definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/
rex_timer_type dsatetsicall_inband_dtmf_timer;

/*-------------------------------------------------------------------------
    External Variables:
-------------------------------------------------------------------------*/

/*===========================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains local definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/

/*-------------------------------------------------------------------------
    Local variables:
-------------------------------------------------------------------------*/
/* +CHLD command: */
/* To keep track of supplementary service command in progress */
etsicall_cmd_type etsicall_cmd_pending;

/*-------------------------------------------------------------------------
    Prototypes for local functions:
-------------------------------------------------------------------------*/

LOCAL void etsicall_show_call_lists
(
  void
);

LOCAL boolean etsicall_is_valid_cell_info
(
  const ds_at_ss_info_s_type   *event_info        /* DS event pointer */
);

/*-------------------------------------------------------------------------
    Function Definitions:
-------------------------------------------------------------------------*/

/*===========================================================================

FUNCTION  DSAT_SEND_CR_RESULT

DESCRIPTION
  Sends intermediate service reporting result code to TE or PS protocol
  stack based on response routing provided by response router.

  Should be called from mode specific protocol stack at time during
  connection negotiation that speed and quality of service is determined 
  and before compression and connect result code are sent.
 
DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsat_send_cr_result
(
  dsat_cr_service_e_type service
)
{
  DSAT_DL_CHECK_SYMBOL_ADDR(dsatdl_vtable.dsatetsicall_send_cr_result_fp);

  dsatdl_vtable.dsatetsicall_send_cr_result_fp(service);

  return;
} /* dsat_send_cr_result( ) */

/*===========================================================================

FUNCTION  DSAT_SEND_CR_RESULT_EX

DESCRIPTION
  Sends intermediate service reporting result code to TE or PS protocol
  stack based on response routing provided by response router.

  Should be called from mode specific protocol stack at time during
  connection negotiation that speed and quality of service is determined 
  and before compression and connect result code are sent.
 
DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsat_send_cr_result_ex
(
  dsat_cr_service_e_type service,
  ds3g_siolib_port_e_type port 
)
{
  DSAT_DL_CHECK_SYMBOL_ADDR(dsatdl_vtable.dsatetsicall_send_cr_result_ex_fp);

  dsatdl_vtable.dsatetsicall_send_cr_result_ex_fp(service, port);

  return;
} /* dsat_send_cr_result_ex( ) */


/*===========================================================================

FUNCTION  DSATETSICALL_INIT_CALL

DESCRIPTION
  This function intializes ETSI call handling.

DEPENDENCIES
  None
  
RETURN VALUE
  None
  
SIDE EFFECTS
  None
===========================================================================*/
void dsatetsicall_init_call ( void )
{
  etsicall_cmd_pending = CMD_NONE;
  return;
} /* dsatetsicall_init_call() */

/*===========================================================================

FUNCTION DSATETSICALL_RESET_LAST_REPORTED_CREG

DESCRIPTION
  This function reset last reported creg parameter

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_reset_last_reported_creg(dsatcmif_servs_state_info  *ph_val)
{

  ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[0] =
  ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[1] = DSAT_REG_REGISTERED_MAX;
  ph_val->dsat_net_reg_state.dsat_creg_reported.act = DSAT_COPS_ACT_MAX;
  ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id = 0xFFFFFFFF;
  ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac = 0XFFFF;
  ph_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code = 0XFF;
  ph_val->dsat_net_reg_state.dsat_creg_reported.psc = 0XFFFF;
  ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac = 0XFFFF;
  ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
  ph_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg = REPORT_NONE;
  ph_val->dsat_net_reg_state.dsat_creg_reported.pending_cell_info_update = FALSE;
}

/*===========================================================================

FUNCTION DSATETSICALL_SET_NET_REG

DESCRIPTION
  This function set last reported domain.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/

void dsatetsicall_set_net_reg
(
  net_reg_domain_e_type  domain ,
  net_reg_status_e_type  value
)
{

#define CHECK_STATE_CHANGE(prev,latest,flag)\
        if(prev != latest)\
          report_creg |= flag;\
          
#define PREV_CS_DOMAIN  ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]
#define PREV_PS_DOMAIN  ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]

  dsat_creg_report_e_type      report_creg = REPORT_NONE;
  dsatcmif_servs_state_info  *ph_val = NULL;
  
   ph_val = dsat_get_base_addr(DSAT_PH_VALS, TRUE);
   if (NULL == ph_val)
   {
     return;
   }

    /*Report Creg if change*/
    if(domain == DSAT_NET_REG_DOMAIN_CS)
    {
      CHECK_STATE_CHANGE(PREV_CS_DOMAIN,value,REPORT_CREG)
    }
    else
    {
      CHECK_STATE_CHANGE(PREV_PS_DOMAIN,value,REPORT_CGREG)
    }
    ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[domain] = value;

  if (DSAT_DL_VALIDATE_SYMBOL_ADDR(dsatdl_vtable.dsatetsicall_report_creg_result_fp))
  {
    dsatdl_vtable.dsatetsicall_report_creg_result_fp(report_creg);
  }

  return;
}/* dsatetsicall_set_net_reg */

/*===========================================================================

FUNCTION DSATETSICALL_CREG_GET_NET_REG_STATUS

DESCRIPTION
  This function return CREG network registration status based on COPS 
  and CFUN value.

DEPENDENCIES
  None
  
RETURN VALUE
  NET REG STATUS

SIDE EFFECTS
  None
  
===========================================================================*/
net_reg_status_e_type  dsatetsicall_creg_get_net_reg_status
(
  const ds_at_cm_ss_event_type * event_ptr      /* DS event pointer */
)
{
  net_reg_status_e_type        net_val = DSAT_NET_REG_NONE;
  sys_oprt_mode_e_type         oprt_mode = dsatcmif_get_oprt_mode();

  if ( NULL == event_ptr )
  {
    DS_AT_MSG0_ERROR("NULL event_ptr");
    return DSAT_NET_REG_NONE;
  }

  /*Setting Net registration status based on CFUN and COPS values*/

  if(DSAT_COPS_MODE_AUTO ==(dsat_num_item_type)dsatutil_get_val(
       DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE) && 
   ((dsat_num_item_type)dsatutil_get_val(DSAT_EXT_CFUN_IDX,0,MIX_NUM_TYPE) == DSAT_ME_FUNC_FULL))
  {
  
    net_val = DSAT_NET_REG_SEARCHING;
    
  }else if((DSAT_COPS_MODE_MANUAL ==(dsat_num_item_type)dsatutil_get_val(
       DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE) )||
    ((dsat_num_item_type)dsatutil_get_val(DSAT_EXT_CFUN_IDX,0,MIX_NUM_TYPE) != DSAT_ME_FUNC_FULL))
  {
    net_val = DSAT_NET_REG_NONE;
    
  }
  if( (event_ptr->event_info.srv_status == SYS_SRV_STATUS_NO_SRV)||
            (event_ptr->event_info.srv_status == SYS_SRV_STATUS_PWR_SAVE))
  {
    dsatcmif_servs_state_info  *ph_val = NULL;
    ph_val = dsat_get_base_addr(DSAT_PH_VALS, TRUE);
    if (NULL == ph_val)
    {
      return DSAT_NET_REG_NONE;
    }
    if( TRUE == ph_val->cm_ph_deep_sleep )
    {
      net_val =  DSAT_NET_REG_NONE;
    }        
  }
  if ( ( SYS_OPRT_MODE_LPM == oprt_mode) ||
       ( SYS_OPRT_MODE_FTM == oprt_mode) ||
       ( SYS_OPRT_MODE_OFFLINE      == oprt_mode) ||
       ( SYS_OPRT_MODE_OFFLINE_AMPS == oprt_mode) ||
       ( SYS_OPRT_MODE_OFFLINE_CDMA == oprt_mode) )
  {
      net_val = DSAT_NET_REG_NONE;
  }
   /*If cops in Deregistration state then creg must be No service */
  if ( DSAT_COPS_MODE_DEREG == (dsat_num_item_type)dsatutil_get_val(
                       DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE))
  {
    net_val = DSAT_NET_REG_NONE;
  }
  DS_AT_MSG1_HIGH(" Net val %d ",net_val);
  return net_val;

}/* dsatetsicall_creg_get_net_reg_status */


/*===========================================================================

FUNCTION ETSICALL_IS_VALID_CELL_INFO

DESCRIPTION
  This function checks if the cell info from NAS and RRC match or not.

DEPENDENCIES
  None
  
RETURN VALUE
  Boolean

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL boolean etsicall_is_valid_cell_info
(
  const ds_at_ss_info_s_type   *event_info        /* DS event pointer */
)
{
  boolean result = FALSE;

  enum dsat_mismatch_info
  {
    DSAT_NO_MISMATCH,
    DSAT_SYS_MODE_MISMATCH,
    DSAT_LAC_ID_MISMATCH,
    DSAT_PLMN_ID_MISMATCH
  };

  enum dsat_mismatch_info info = DSAT_NO_MISMATCH;
  dsatcmif_servs_state_info  *ph_val   = NULL;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, TRUE);

  if ( NULL == ph_val )
  {
    DS_AT_MSG0_ERROR("NULL ph_val");
    return FALSE;
  }

  DS_AT_MSG4_HIGH("SYS_MODE(NAS:%d, AS:%d), LAC_ID(NAS:%d, AS:%d)",
                  event_info->sys_mode,
                  event_info->cell_info.as_sys_mode,
                  event_info->sys_id.id.plmn_lac.lac,
                  event_info->cell_info.lac_id);

#ifdef FEATURE_DSAT_LTE
  DS_AT_MSG2_HIGH("lte_tac:%d, cell_info.lac_id:%d",
                  event_info->lte_tac,
                  event_info->cell_info.tac);
#endif /* FEATURE_DSAT_LTE */

  if ((event_info->sys_mode == event_info->cell_info.as_sys_mode) ||
      ((event_info->sys_mode == SYS_SYS_MODE_TDS) &&
       (event_info->cell_info.as_sys_mode == SYS_SYS_MODE_WCDMA)))
  {
    if (TRUE == sys_plmn_match(event_info->sys_id.id.plmn, event_info->cell_info.plmn_id))
    {
      if ( ( (event_info->sys_mode == SYS_SYS_MODE_WCDMA) ||
             (event_info->sys_mode == SYS_SYS_MODE_GSM) ||
             (event_info->sys_mode == SYS_SYS_MODE_TDS) ) &&
           (event_info->sys_id.id.plmn_lac.lac == event_info->cell_info.lac_id) )
      {
        result = TRUE;
      }
#ifdef FEATURE_DSAT_LTE
      else if ( (event_info->sys_mode == SYS_SYS_MODE_LTE) &&
                (event_info->lte_tac == event_info->cell_info.tac) )
      {
        result = TRUE;
      }
#endif /* FEATURE_DSAT_LTE */
      else
      {
        info = DSAT_LAC_ID_MISMATCH;
      }
    }
    else
    {
      info = DSAT_PLMN_ID_MISMATCH;
    }
  }
  else
  {
    info = DSAT_SYS_MODE_MISMATCH;
  }
  if (info != DSAT_NO_MISMATCH)
  {
    DS_AT_MSG1_ERROR("Mismatch info:%d",info);
    ph_val->dsat_net_reg_state.dsat_creg_reported.pending_cell_info_update = TRUE;
  }
  return result;
}

/*===========================================================================

FUNCTION UPDATE_STATE

DESCRIPTION
  This function changes the state of +CREG.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void update_state
(
  uint32                  *prev,
  uint32                   latest,
  dsat_creg_report_e_type  flag,
  dsat_creg_report_e_type *report_creg
)
{
  if(*prev != latest)
  {
    *report_creg |= flag;
    DS_AT_MSG3_HIGH("CREG STATE CHANGE:: prev %d latest %d  flag %d",*prev ,latest,flag);
    *prev =  latest;
  }
} /* update_state */

/*===========================================================================

FUNCTION DSATETSICALL_UPDATE_CREG_LAC_CELL_ID

DESCRIPTION
  This function update CELL ID/LAC ID when COPS command is under process.
  It also set CREG pending flag.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_update_creg_lac_cell_id
(
  const ds_at_cm_ss_event_type  *event_ptr,        /* DS event pointer */
  dsat_creg_report_e_type       *report_creg
)
{
#if 0
#define UPDATE_STATE(prev,latest,flag)\
			  update_state(prev, latest, flag, report_creg);
#endif

#define UPDATE_STATE(prev,latest,flag)\
	if(prev != latest)\
	{\
	  *report_creg |= flag;\
	  DS_AT_MSG3_HIGH("CREG STATE CHANGE:: prev %d latest %d  flag %d",prev ,latest,flag);\
	  prev =  latest;\
	}\


#define PREV_PLMN_LAC   (ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac)
#define PREV_CELL_ID    (ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id)
#define PREV_PSC        (ph_val->dsat_net_reg_state.dsat_creg_reported.psc)
#ifdef FEATURE_DSAT_LTE
#define PREV_TAC        (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac)
#define PREV_RAC_MME    (ph_val->dsat_net_reg_state.dsat_creg_reported.lte_rac_or_mme_code)
#endif /* FEATURE_DSAT_LTE */

  uint64                        changed_fields = 0;
  dsatcmif_servs_state_info *ph_val   = NULL;

  if (NULL == event_ptr)
  {
    DS_AT_MSG0_ERROR("NULL event_ptr");
    return;
  }
  
  ph_val = dsat_get_base_addr(DSAT_PH_VALS, TRUE);
  
  if (NULL == ph_val)
  {
    return;
  }

  changed_fields = event_ptr->event_info.changed_fields;

  if ((DSAT_SS_SYS_ID_MASK | DSAT_SS_LAC_TAC_RAC_CHGD_MASK) & changed_fields)
  {
    if(DSAT_SS_SYS_ID_MASK & changed_fields)
    {
      UPDATE_STATE(PREV_PLMN_LAC,event_ptr->event_info.sys_id.id.plmn_lac.lac,REPORT_CREG_LAC)  
    }

   
#ifdef FEATURE_DSAT_LTE
    if(DSAT_SS_LAC_TAC_RAC_CHGD_MASK & changed_fields)
    {
      UPDATE_STATE(PREV_TAC,event_ptr->event_info.lte_tac,REPORT_CREG_LTE_TAC)
      UPDATE_STATE(PREV_RAC_MME,event_ptr->event_info.lte_rac_or_mme_code,REPORT_CREG_LAC_RAC_MME)
    }
#endif /* FEATURE_DSAT_LTE*/
  }
  /*Update Cell-id only when there is a cell-id change or the serving system 
    is also updated to system on which cell info is received from. As part of 
    serving system update CM will send the SS EVENT to ATCOPs with change in the 
    either SS_SYS_MODE_MASK(If it is new RAT) or SS_SYS_ID_MASK(If it is new PLMN)
    For NB_IOT -> CIOT transition, there won't be change in SYS_MODE, hence it's 
    essential to check for CIOT_LTE_SYS_MODE_MASK in NB, CATM RAT supported builds.*/
   if(((DSAT_SS_CELL_INFO_MASK & changed_fields) &&
     (TRUE == etsicall_is_valid_cell_info(&event_ptr->event_info)))
     || (((DSAT_SS_SYS_MODE_MASK | DSAT_SS_SYS_ID_MASK | DSAT_SS_CIOT_LTE_SYS_MODE_MASK) & changed_fields) && 
      ph_val->dsat_net_reg_state.dsat_creg_reported.pending_cell_info_update == TRUE))
  {
    UPDATE_STATE(PREV_CELL_ID,event_ptr->event_info.cell_info.cell_id,REPORT_CREG_CELL_ID)
    UPDATE_STATE(PREV_PSC,event_ptr->event_info.cell_info.psc,REPORT_CREG_CELL_PSC)
    ph_val->dsat_net_reg_state.dsat_creg_reported.pending_cell_info_update = FALSE;
  }
}/*dsatetsicall_update_creg_lac_cell_id*/


/*===========================================================================

FUNCTION UPDATE_STATE_CHANGE

DESCRIPTION
  This function changes the state of +CREG.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void update_state_change
(
  net_reg_status_e_type*   prev,
  net_reg_status_e_type    latest,
  dsat_creg_report_e_type  flag,
  dsat_creg_report_e_type* report_creg)
{
  if(*prev != latest)
  {
     *report_creg |= flag;
     DS_AT_MSG3_HIGH("STATE CHANGE:: prev %d latest %d  flag %d",*prev ,latest,flag);
     *prev =  latest;
  }
}/* update_state_change */

/*===========================================================================

FUNCTION DSATETSICALL_CREG_STATE_MACHINE

DESCRIPTION
  This function generates the unsolicited result code for registration
  commands +CREG and +CGREG.  The command parameter <n> controls whether
  results are presented or suppressed.

DEPENDENCIES
  None
  
RETURN VALUE
  None

SIDE EFFECTS
  None
  
===========================================================================*/
void dsatetsicall_creg_state_machine
(
  const ds_at_cm_ss_event_type * event_ptr        /* DS event pointer */
)
{
#define UPDATE_STATE_CHANGE(prev,latest,flag)\
				update_state_change(&prev, latest, flag, &report_creg);

#define IS_STATE_ULOCK(reg_rej_st)\
        ((dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_ONLY && reg_rej_st == DSAT_CREG_STAT_CNG_PS_LCK)||\
        (dsat_rej_srv_domain == SYS_SRV_DOMAIN_PS_ONLY && reg_rej_st == DSAT_CREG_STAT_CNG_CS_LCK))\

#define PREV_CS_DOMAIN  ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS]
#define PREV_PS_DOMAIN  ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS]

  dsat_creg_report_e_type      report_creg = REPORT_NONE;
  sys_srv_domain_e_type        dsat_rej_srv_domain;
  sys_roam_status_e_type       roaming;
  uint64                       changed_fields = 0;
  net_reg_status_e_type        net_val = DSAT_NET_REG_NONE; 
  sys_sim_state_e_type         sim_state;
  sys_srv_domain_e_type        srv_capability;
  dsatcmif_servs_state_info  *ph_val   = NULL;
  boolean                      ps_data_suspend;

  ph_val = dsat_get_base_addr(DSAT_PH_VALS, TRUE);

  if ( NULL == event_ptr )
  {
    DS_AT_MSG0_ERROR("NULL event_ptr ");
    return;
  }

  dsat_rej_srv_domain = event_ptr->event_info.srv_domain;
  roaming = event_ptr->event_info.roam_status;
  net_val = dsatetsicall_creg_get_net_reg_status(event_ptr);
  sim_state = event_ptr->event_info.sim_state;
  srv_capability = event_ptr->event_info.srv_capability;
  changed_fields = event_ptr->event_info.changed_fields;
  ps_data_suspend = event_ptr->event_info.ps_data_suspend;
  
  DS_AT_MSG7_HIGH(" CS %d PS %d Lac %d Cell id %d lte_tac %d  reg_rej %d sim_state %d",
        ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS],
        ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS],
        ph_val->dsat_net_reg_state.dsat_creg_reported.plmn_lac,
        ph_val->dsat_net_reg_state.dsat_creg_reported.cell_id,
        ph_val->dsat_net_reg_state.dsat_creg_reported.lte_tac,
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state,
        sim_state);

  if(CM_SS_EVENT_REG_REJECT == event_ptr->event)
  {
   /* Moved CREG state into Registration denied till camped indication recevied */
    dsat_rej_srv_domain = event_ptr->event_info.reg_reject_info.reject_srv_domain;
    if( dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_ONLY )
    {
     /* Update CS reject cause */
      UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CREG)
      if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_PS_LCK ||
         ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
      {
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
      }else
      {
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CS_LCK;
      }
    }
    else if( dsat_rej_srv_domain == SYS_SRV_DOMAIN_PS_ONLY )
    {
      /* Update PS reject cause */
      UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CGREG)
      if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CS_LCK ||
         ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
      {
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
      }else
      {
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_PS_LCK;
      }
    }
    else if(dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_PS)
    {
        /* Update both reject causes */
      UPDATE_STATE_CHANGE(PREV_CS_DOMAIN ,DSAT_NET_REG_DENIED,REPORT_CREG)
      UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CGREG)
      ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
    }
  }
  else if(CM_SS_EVENT_SRV_CHANGED == event_ptr->event)
  {
    dsatetsicall_update_creg_lac_cell_id(event_ptr, &report_creg);
    if(DSAT_SS_SIM_STATE_MASK & changed_fields)
    {
      if ( sim_state == SYS_SIM_STATE_CS_INVALID )
      {
        UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CREG)

      if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_PS_LCK ||
         ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
        {
          ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
        }else
        {
          ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CS_LCK;
        }
      }
      else if ( sim_state == SYS_SIM_STATE_PS_INVALID )
      {
        UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CGREG)
        if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CS_LCK ||
           ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
        {
          ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
        }
        else
        {
          ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_PS_LCK;
        }
      }
      else if ( sim_state == SYS_SIM_STATE_CS_PS_INVALID )
      {
        UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CREG)
        UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_DENIED,REPORT_CGREG)
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
      }
    }
    /* Check for ps_data_suspend value in addition to the PS_DATA_SUSPEND_MASK. 
       PS data is suspended when ps_data_suspend is 1 */
    if((DSAT_SS_PS_DATA_SUSPEND_MASK & changed_fields) && (ps_data_suspend == TRUE))
    {
      if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CS_LCK ||
         ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
      {
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CSPS_LCK;
      }
      else
      {
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_PS_LCK;
      }
    }

    if((ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state != DSAT_CREG_STAT_CNG_UNLCK 
         && ((DSAT_SS_PS_DATA_SUSPEND_MASK & changed_fields) && (ps_data_suspend == FALSE)))
         || (ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state != DSAT_CREG_STAT_CNG_UNLCK &&
         !(DSAT_SS_PS_DATA_SUSPEND_MASK & changed_fields)) )
    {
      if(event_ptr->event_info.srv_status == SYS_SRV_STATUS_SRV)
      {
        if(dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_PS || dsat_rej_srv_domain == SYS_SRV_DOMAIN_NO_SRV)
        {
          ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
        }
        else if(dsat_rej_srv_domain == SYS_SRV_DOMAIN_CS_ONLY)
        {
          if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
          {
            ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_PS_LCK;
          }
          else if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CS_LCK)
          {
            ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
          }
        }
        else if(dsat_rej_srv_domain == SYS_SRV_DOMAIN_PS_ONLY)
        {
          if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_CSPS_LCK)
          {
            ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_CS_LCK;
          }
          else if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_PS_LCK)
          {
            ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
          }
        }
      }
      else if((event_ptr->event_info.srv_status == SYS_SRV_STATUS_NO_SRV )||
       (event_ptr->event_info.srv_status == SYS_SRV_STATUS_PWR_SAVE ))
      {
        ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
      }
    }

    if(SYS_SRV_DOMAIN_CAMPED == dsat_rej_srv_domain)
    {
       /* MS found the right system but not yet registered or attached. */
       /* Dont report CREG but clear CREG state */
       ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state = DSAT_CREG_STAT_CNG_UNLCK;
         /*If cops in Deregistration state then creg must be No service and reg_rej */
       if ( DSAT_COPS_MODE_AUTO == (dsat_num_item_type)dsatutil_get_val(
                             DSATETSI_EXT_ACT_COPS_ETSI_IDX,0,MIX_NUM_TYPE))
       {
         if(ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_PS] == DSAT_NET_REG_NONE ||
            DSAT_SS_SYS_MODE_MASK & changed_fields)
         {
             /*If creg is in No searching mode due to cfun 0 or cops 2 then move creg to Searching */
           UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_SEARCHING ,REPORT_CGREG)
         }
         if(ph_val->dsat_net_reg_state.dsat_creg_reported.net_domain[DSAT_NET_REG_DOMAIN_CS] == DSAT_NET_REG_NONE ||
            DSAT_SS_SYS_MODE_MASK & changed_fields)
         {
            UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_SEARCHING ,REPORT_CREG)
         }
       }
    }
    else if(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state == DSAT_CREG_STAT_CNG_UNLCK ||
               (IS_STATE_ULOCK(ph_val->dsat_net_reg_state.dsat_creg_reported.reg_rej_state)))
    {
      dsat_num_item_type cemode = (dsat_num_item_type)dsatutil_get_val( DSATETSI_EXT_CEMODE_IDX,0,NUM_TYPE);

      switch (event_ptr->event_info.srv_status)
      {
        case SYS_SRV_STATUS_SRV:
        {
          if(sim_state != SYS_SIM_STATE_NOT_AVAILABLE)
          {
          switch(dsat_rej_srv_domain)
          {
            case SYS_SRV_DOMAIN_CS_ONLY:
             if( SYS_ROAM_STATUS_OFF == roaming )
             {
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_HOME ,REPORT_CREG)
             }else
             {
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_ROAMING  ,REPORT_CREG)
             }
               /*SET PS to DSAT_NET_REG_SEARCHING*/
             if(srv_capability == SYS_SRV_DOMAIN_CS_PS)
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_SEARCHING ,REPORT_CGREG)
             }else if(PREV_PS_DOMAIN != DSAT_NET_REG_DENIED)
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_NONE ,REPORT_CGREG)
             }
             
            break;
            case SYS_SRV_DOMAIN_PS_ONLY:
             if( SYS_ROAM_STATUS_OFF == roaming )
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_HOME ,REPORT_CGREG)
             }else
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_ROAMING  ,REPORT_CGREG)
             }
               /*SET CS to DSAT_NET_REG_SEARCHING*/
             if(srv_capability == SYS_SRV_DOMAIN_CS_PS)
             {
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_SEARCHING ,REPORT_CREG)
             }else if(PREV_CS_DOMAIN != DSAT_NET_REG_DENIED)
             {
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_NONE,REPORT_CREG)
             }
              
            break;
            case SYS_SRV_DOMAIN_CS_PS:
             if( SYS_ROAM_STATUS_OFF == roaming )
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_HOME ,REPORT_CGREG)
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_HOME ,REPORT_CREG)
             }else
             {
               UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,DSAT_NET_REG_ROAMING  ,REPORT_CGREG)
               UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,DSAT_NET_REG_ROAMING  ,REPORT_CREG)
             }
             break;
             
            default:
             break;
          }
        }
        }
        break;
        case SYS_SRV_STATUS_LIMITED:
        case SYS_SRV_STATUS_LIMITED_REGIONAL:
        {
          switch(dsat_rej_srv_domain)
          {
            case SYS_SRV_DOMAIN_CS_ONLY:
              UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,net_val ,REPORT_CREG)
            break;
            case SYS_SRV_DOMAIN_PS_ONLY:
              UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val ,REPORT_CGREG)
              
            break;
            case SYS_SRV_DOMAIN_CS_PS:
            case SYS_SRV_DOMAIN_NO_SRV:
              switch(cemode)
              {
                case DSAT_EPS_PS_MODE_1:
                case DSAT_EPS_PS_MODE_2:
                  UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
                  break;
                default:
                  UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
                  UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,net_val  ,REPORT_CREG)
                  break;
              }
              break;
            default:
              break;
          }
        }
        break;
        case SYS_SRV_STATUS_NO_SRV:
        case SYS_SRV_STATUS_PWR_SAVE:
          switch(cemode)
          {
            case DSAT_EPS_PS_MODE_1:
            case DSAT_EPS_PS_MODE_2:
              UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
              break;
            default:
              UPDATE_STATE_CHANGE(PREV_PS_DOMAIN,net_val  ,REPORT_CGREG)
              UPDATE_STATE_CHANGE(PREV_CS_DOMAIN,net_val  ,REPORT_CREG)
              break;
          }
          break;
        default:
          break;
      }
    }
  }

  /* Check pending flag(While Cops is under process) */
  if( ph_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg)
  {
    report_creg = report_creg | ph_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg;
    DS_AT_MSG2_HIGH(" Report Creg %d Cops Pending CREG  %d",
        report_creg,
        ph_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg);
 
    ph_val->dsat_net_reg_state.dsat_creg_reported.cops_pending_report_creg = REPORT_NONE;
  }
  if(report_creg)
  {
    if (DSAT_DL_VALIDATE_SYMBOL_ADDR(dsatdl_vtable.dsatetsicall_report_creg_result_fp) )
    {
      dsatdl_vtable.dsatetsicall_report_creg_result_fp(report_creg);
    }
  }

 return;
} /* dsatetsicall_creg_state_machine */

/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_CONNECT_EX

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_CONNECT event.  

DEPENDENCIES
  None

RETURN VALUE
  DSAT_OK :          if +CHLD command processing complete.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_connect_ex
(
  ds_at_cm_call_event_type*  call_event     /* call event pointer         */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_EVENT;
  dsatetsicall_call_state_info  *call_val = NULL;

  call_val = dsat_get_base_addr(DSAT_CALL_VALS, TRUE);
  if (NULL == call_val)
  {
    return DSAT_ASYNC_EVENT;
  }
#ifdef FEATURE_ETSI_PBM
    /* Change last dial record for this call ID to be connected.
       This moved into non-voice block as OEMCM makes entry for voice calls
       and duplicate entries were created */
    dsatme_ld_connected();
#endif /* defined(FEATURE_ETSI_PBM)  */

  /* Update +CIND indicators */
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALLSETUP,
                                           DSAT_CIND_CSETUP_NONE);
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALL, 1);

  if ( (call_event->event_info.call_type != CM_CALL_TYPE_VOICE) &&
       (call_event->event_info.call_type != CM_CALL_TYPE_EMERGENCY) )
  {
    return result;
  }  

  DS_AT_MSG1_MED("evt_conn: call id %d", call_event->event_info.call_id);

  /* Generate debug message call list */
  etsicall_show_call_lists();

  /* Search for and if found remove call id from etsicall_active_call_ids */
  if ( etsicall_search_call_list(&call_val->etsicall_num_active_calls,
                                  call_val->etsicall_active_call_ids,
                                 call_event->event_info.call_id,
                                 TRUE) )
  {
    DS_AT_MSG0_HIGH("Call id was already in active call list");
  }


  /* Search for and if found remove call id from etsicall_held_call_ids */
  if ( etsicall_search_call_list(&call_val->etsicall_num_held_calls,
                                  call_val->etsicall_held_call_ids,
                                 call_event->event_info.call_id,
                                 TRUE) )
  {
    DS_AT_MSG0_HIGH("CONNECT event's call id was already in held call list");
  }

  if ( call_val->etsicall_wait_call_present &&
       call_val->etsicall_wait_call_id == call_event->event_info.call_id )
  {
    call_val->etsicall_wait_call_present = FALSE;
  }

  if ( call_val->etsicall_num_active_calls + 1 > CM_CALL_ID_MAX )
  {
    DS_AT_MSG0_HIGH("etsicall_num_active_calls would exceed bound");
  }
  else
  {
    /* Add call id to active call list */
    call_val->etsicall_active_call_ids[call_val->etsicall_num_active_calls++] = 
      call_event->event_info.call_id;
  }

  /* Generate debug message call list */
  etsicall_show_call_lists();

  /* Clear the call id before connect */
  if(call_val->call_info_before_connect.call_id == call_event->event_info.call_id)
  {
    call_val->call_info_before_connect.call_id = CM_CALL_ID_INVALID;
    call_val->call_info_before_connect.info_type = CM_CALL_MODE_INFO_NONE;	
  }

  if( dsatcmif_is_voice_call_type (call_event->event_info.call_type ) )
  {	
    /* Store mode info type */
    if(call_event->event_info.call_id < CM_CALL_ID_MAX)
    {
      call_val->mode_info[call_event->event_info.call_id] = call_event->event_info.dsat_mode_info.info_type;
    }
  }

  if(etsicall_cmd_pending == CMD_NONE)
  {
    result = dsatvoice_call_event_connect(&call_event->event_info);
  }

  return result;
} /* dsatetsicall_call_event_connect_ex */



/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_END_EX

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_MNG_CALLS_CONF event and removes the call id ended from 
  our call state info.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
/* ARGSUSED */
dsat_result_enum_type dsatetsicall_call_event_end_ex
(
  ds_at_cm_call_event_type *call_event /* Call event pointer */
)
{
  dsat_result_enum_type            result = DSAT_ASYNC_EVENT;
  cm_call_id_type                  call_id;
  dsatetsicall_call_state_info *call_val = NULL;

  call_event->event_info.is_call_id_found     = FALSE;
  call_event->event_info.is_call_among_active = FALSE;

  call_val = dsat_get_base_addr(DSAT_CALL_VALS, TRUE);
  if (NULL == call_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  call_id = call_event->event_info.call_id;

  DS_AT_MSG1_MED("evt_end: call id %d", call_id);

  /* Update +CIND callsetup indicator */
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALLSETUP,
                                           DSAT_CIND_CSETUP_NONE);
  /* Update +CIND call index indicator */
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALL, 0);

  /* Generate debug message call list */
  etsicall_show_call_lists();

  if ( call_event->event_info.call_type == CM_CALL_TYPE_VOICE ||
       call_event->event_info.call_type == CM_CALL_TYPE_EMERGENCY )
  {
    /* Search for and if found remove call id from etsicall_active_call_ids and 
       decrement etsicall_num_active_calls */
    if ( etsicall_search_call_list(&call_val->etsicall_num_active_calls,
                                    call_val->etsicall_active_call_ids,
                                   call_id,
                                   TRUE) )
    {
      call_event->event_info.is_call_id_found = TRUE;
      call_event->event_info.is_call_among_active = TRUE;
    }
    /* If not found in active call list search for and if found remove call id 
       from etsicall_held_call_ids and decrement etsicall_num_held_calls */
    else if ( etsicall_search_call_list(
      &call_val->etsicall_num_held_calls,
       call_val->etsicall_held_call_ids,
      call_id,
      TRUE) )
    {
      call_event->event_info.is_call_id_found = TRUE;
    } 
    /* If not found in active or held calls lists check wait call */
    else if ( call_val->etsicall_wait_call_present && 
              call_val->etsicall_wait_call_id == call_id )
    {
      call_val->etsicall_wait_call_present = FALSE;
      call_event->event_info.is_call_id_found = TRUE;
    }
    else
    {
      DS_AT_MSG0_HIGH("END event's call id not found");
    }

    /* Generate debug message call list */
    etsicall_show_call_lists();

    /* Clear the call id before connect */
    if(call_val->call_info_before_connect.call_id == call_id)
    {
      call_val->call_info_before_connect.call_id = CM_CALL_ID_INVALID;
      call_val->call_info_before_connect.info_type = CM_CALL_MODE_INFO_NONE;	
    }
  }
  return result;
} /* dsatetsicall_call_event_end_ex */


/*===========================================================================

FUNCTION DSATETSICALL_CALL_EVENT_INCOM

DESCRIPTION
  This function is called by dsatcmif_cm_call_event_handler when CM reports 
  the CM_CALL_EVENT_INCOM event and adds the waiting call id to our call state
  info.

DEPENDENCIES
  None

RETURN VALUE
  DSAT_CMD_ERR_RSP : if CM reports failure.
  DSAT_ASYNC_EVENT:  otherwise.

SIDE EFFECTS
  None
  
===========================================================================*/
dsat_result_enum_type dsatetsicall_call_event_incom
(
  ds_at_cm_call_event_type*  call_event    /* DS Command pointer         */
)
{
  dsat_result_enum_type result = DSAT_ASYNC_EVENT;
  dsatetsicall_call_state_info  *call_da_val = NULL;
  
  call_da_val = dsat_get_base_addr(DSAT_CALL_VALS, TRUE);
  if (NULL == call_da_val)
  {
    return DSAT_ASYNC_EVENT;
  }

  DS_AT_MSG1_HIGH("evt_incom: call id %d",call_event->event_info.call_id);

  /* Update +CIND callsetup indicator */
  (void)dsatetsime_change_indicator_state( DSAT_CIND_INDEX_CALLSETUP,
                                           DSAT_CIND_CSETUP_MTRING );

  if ( call_event->event_info.call_type == CM_CALL_TYPE_VOICE ||
       call_event->event_info.call_type == CM_CALL_TYPE_EMERGENCY )
  {
    call_da_val->etsicall_wait_call_present = TRUE;
    call_da_val->etsicall_wait_call_id = call_event->event_info.call_id;

    /* Generate debug message call list */
    etsicall_show_call_lists();
	
	DS_AT_MSG2_HIGH("evt_incom: call id %d %d",call_da_val->etsicall_num_active_calls,call_da_val->etsicall_num_held_calls);
    /* Only RING the TE when there are no active or held calls  */
    if ( (call_da_val->etsicall_num_active_calls == 0 ) && ( call_da_val->etsicall_num_held_calls 
== 0 ))
    {
      result = dsatvoice_call_event_incom(&call_event->event_info);
    }
    /* Else display the incoming call as a URC +CCWA: */
    else 
    {
      /* Update dsatvoice state machine state */
      voice_state[call_da_val->etsicall_wait_call_id].state = DSAT_VOICE_STATE_WAITING;
      voice_state[call_da_val->etsicall_wait_call_id].cmd_active = VOICE_CMD_NONE;
      voice_state[call_da_val->etsicall_wait_call_id].call_mode =  call_event->event_info.dsat_mode_info.info_type;
      call_event->event_info.report_ccwa = TRUE;
    }
  }

  return result;
} /* dsatetsicall_call_event_incom */

/*===========================================================================

FUNCTION ETSICALL_MOVE_CALLS

DESCRIPTION
  This function moves calls from one call list to another, excluding call
  excl_call_id if it is something other than CM_CALL_ID_INVALID. It is used by
  event handlers that maintain call state info.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of validation.
  possible values:
    TRUE:   if call id to be excluded was found
    FALSE : if not found

SIDE EFFECTS
  None
  
===========================================================================*/
LOCAL boolean etsicall_move_calls
(
  uint8 *fm_qty,
  cm_call_id_type *fm_list,
  uint8 *to_qty,
  cm_call_id_type *to_list,
  const cm_call_id_type excl_call_id
)
{
  uint8 fm_idx,to_idx;
  boolean excl_found = FALSE;

  for ( fm_idx = 0, to_idx = *to_qty;
        fm_idx < *fm_qty && fm_idx < CM_CALL_ID_MAX && to_idx < CM_CALL_ID_MAX;
        fm_idx++, to_idx++ )
  {
    if ( excl_call_id != CM_CALL_ID_INVALID &&
         fm_list[fm_idx] == excl_call_id )
    {
      excl_found = TRUE;
    }
    else
    {
      to_list[to_idx] = fm_list[fm_idx];
    }
  }

  if ( excl_found )
  {
    *to_qty += (*fm_qty - 1);
    *fm_qty = 1;
    fm_list[0] = excl_call_id;
  }
  else
  {
    *to_qty += *fm_qty;
    *fm_qty = 0;
  }

  return excl_found;
} /* etsicall_move_calls */



/*===========================================================================

FUNCTION ETSICALL_SEARCH_CALL_LIST

DESCRIPTION
  This function searches for the call id in the call list provided, 
  deleting it if remove is TRUE and returning TRUE if call id was found. 
  It is used by event handlers that maintain call state info.

DEPENDENCIES
  None

RETURN VALUE
  returns an enum that describes the result of validation.
  possible values:
    TRUE :  if call id was found
    FALSE : not found.

SIDE EFFECTS
  Call id is removed from list per boolean remove 
  
===========================================================================*/
boolean etsicall_search_call_list
(
  uint8 *call_qty,
  cm_call_id_type *call_list,
  const cm_call_id_type call_id,
  boolean rmv_call_id
)
{
  uint8 idx;
  boolean found = FALSE;

  /* Search call list for call id... */
  for ( idx = 0; 
        idx < *call_qty && idx < CM_CALL_ID_MAX; 
        idx++ )
  {
    /* If found... */
    if ( call_list[idx] == call_id )
    {
      found = TRUE;

      if ( rmv_call_id )
      {
        for ( ; 
              idx < (*call_qty - 1) && idx < (CM_CALL_ID_MAX - 1); 
              idx++ )
        {
          call_list[idx] = call_list[idx + 1];
        }

        if ( *call_qty != 0 )
        {
          (*call_qty)--;
        }
      }

      break;
    }
  }

  return found;
} /* etsicall_search_call_list */


/*===========================================================================

FUNCTION ETSICALL_SHOW_CALL_LISTS

DESCRIPTION
  This function displays the current call lists as diag messages.

DEPENDENCIES
  None

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL void etsicall_show_call_lists
(
  void
)
{
  uint8 idx;
  dsatetsicall_call_state_info  *call_val = NULL;
  
  call_val = dsat_get_base_addr(DSAT_CALL_VALS, TRUE);
  if (NULL == call_val)
  {
    return;
  }

  DS_AT_MSG1_MED("etsicall_num_active_calls %d",call_val->etsicall_num_active_calls);
  for (idx=0; idx < call_val->etsicall_num_active_calls; idx++)
  {
    DS_AT_MSG2_MED("etsicall_active_call_ids[%d] %d",
             idx, call_val->etsicall_active_call_ids[idx]);
  }

  DS_AT_MSG1_MED("etsicall_num_held_calls %d",call_val->etsicall_num_held_calls);
  for (idx=0; idx < call_val->etsicall_num_held_calls; idx++)
  {
    DS_AT_MSG2_MED("etsicall_held_call_ids[%d] %d",
             idx, call_val->etsicall_held_call_ids[idx]);
  }

  DS_AT_MSG2_MED("wait_call_present %d, id %d",
           call_val->etsicall_wait_call_present,call_val->etsicall_wait_call_id);

} 

#endif /* FEATURE_DSAT_ETSI_MODE */

