/*===========================================================================

                            D S _ Q M I _ I F . C

DESCRIPTION

  The Data Services WWAN external interface source file.

  This module will externalize the minimal but complete API for modules
  outside of data services to interface to WWAN logic.

  JD - Note some internal APIs exist in here currently - need to break this
       out into external and internal inter-module API files once logic is
       fleshed out.

EXTERNALIZED FUNCTIONS
  qmi_if_init()
    Initialize the WWAN interface layer

  qmi_if_reg_cm()
    Register for CM event reporting

  qmi_if_dereg_cm()
    Deregister CM event reporting

  qmi_if_media_connected()
    Indicate that the RMNET interface media (cable) is "connected".
  
  qmi_if_media_disconnected()
    Indicate that the RMNET interface media (cable) is "disconnected".

  qmi_if_get_max_channel_rate()
    This is used to obtain the max channel rate on the current radio
    technology in use

  qmi_if_get_current_channel_rate()
    This is used to obtain the current(instantaneous) channel rate on the current radio
    technology in use

  qmi_if_get_current_radio_if()
    Used to get the current servign system

  qmi_if_get_power_state
    It returns the current power status and battery level after querying them
    from the external charger module  
  
Copyright (c) 2004-2023 Qualcomm Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary.
===========================================================================*/
/*===========================================================================

                            EDIT HISTORY FOR FILE
  $Header: //components/rel/dataiot.mpss/2.0/interface/qmidata/src/ds_qmi_if.c#3 $

when        who    what, where, why
--------    ---    ----------------------------------------------------------
04/05/23    ks     Fixed DS task stack corruption issue by making the local
                   variable to dynamic.
10/06/17    ss     Added support for LTE-U 256 bands.
10/21/14    sk     QMI-DMS Service QCSI migration.
03/13/14    sah    Added support for tertiary subscription
02/13/14    vrk    Added cmd_type to qmi_dms_process_mmgsdi_operation_complete
11/27/13    sah    Fix to update PRL info in case of missing prl init event
09/27/13    wc     Support dynamic port configuration
07/30/13    vrk    Fix to allocate cmd_ptr for CM_PH_EVENT_CDMA_LOCK_MODE 
06/11/13    ms     KW error fixes.
06/07/13    rk     Add secondary subscription changes for mmgsdi
01/24/13    rk     Fix to prevent timing attack on qmi_if_check_spc routine.
06/11/12    sb     Fix to move to correct UIM state in case of CARD ERROR
                   event.
03/29/12    sa     New QMI utils api for spc checks.
03/09/12    sj     Add functionality to determine max tx and rx rates for TDSCDMA 
02/28/12    sj     Add support for TDSCDMA  
01/25/12    sj     Cache mode_capability from CM 
11/02/11    wc     Add qmi_dms_get_current_prl_info
10/10/11    sj     Add support for caching LTE band capability value 
10/21/11    wc     Fix incorrect prl_only value returned by dms_get_prl_ver
10/04/11    sa     Q6 free floating changes for QMI.
08/15/11    sa     GSDI cleanup changes.
06/22/11    wc     Send PRL init indication when PRL is loaded
04/27/11    ua     CMI-4 compliance. 
03/08/11    ua     Retreiving WCDMA/HSDPA/HSUPA default data rates from RRC.
02/15/11    kk     Added support for PRL_ONLY TLV in PRL_INFO message.
02/09/11    kk     Added support for LTE Data rates.
01/10/11    ss     Cleaning up of Globals for thread safety in Q6 Free 
                   Floating environment.
12/17/10    kk     Added log messages before ASSERTs.
06/21/10    kk     Fix to align to new MMGSDI APIs for PERSO requests.
06/19/10    vs     Changes for Dual IP support over single QMI instance
06/07/10    kk     Fix to update app_type and uim_state from all possible
                   events.
05/19/10    kk     Fix to prevent stale memory access.
05/05/10    kk     To allow opening of 1X or GW session based on featurization
05/05/10    kk     Fix to allow proper processing of SUBSCRIPTION_READY and
                   PIN events from MMGSDI.
11/10/09    jee    Changes to support MMGSDI re-architecture
10/22/09    kk     Windows7 compliance - WDS changes and BER/PER/FER support.
10/16/09    kk     Windows7 compliance - new messages and ATCoP dependencies.
10/09/09    kk     Windows7 compliance - NAS changes.
10/08/09    kk     Windows7 compliance - DMS changes.
02/19/09    am     DS Task De-coupling effort and introduction of DCC task.
08/23/06    ks     Changes to support multiple qmi/rmnet instances.
07/06/06    ks     Posting DS cmds for SS and PH events generated by CM to
                   send NAS responses in DS context. Other clean up
06/07/06    ks     Fixed signal strength reporting
05/01/06    ks     Handling new CM_PH events for NAS Register and Attach.
04/18/06    ks     Changed return value of qmi_if_get_sig_strength() to void.
03/06/06    ks     Using ps_iface_ioctl() to obtain data bearer rates.
09/08/05    ks     Major clean up. Added support to listen to CM phone_events.
                   Changed name to qmi_if.
05/31/05   jd/ks   Code review updates
05/11/05    ks     changed some names.
03/18/05    ks     Added Masks for Power State.
10/27/04    jd     Return linkspeed 153.6kbps
                   Added media connect/disconnect apis.
07/12/04    jd     Revamped qmi_if.  Added CM SS object client.
04/12/04    jd     added qmi_if_uim_used() to indicate if SIM is in use
03/16/04    jd     added qmi_if_connected() to indicate if in pkt service
03/16/04    jd     Added qmi_if_get_link_speed to return current link speed
04/20/04    jd     Initial implementation
===========================================================================*/


/*===========================================================================

                          INCLUDE FILES FOR MODULE

===========================================================================*/

/* Common definitions and customization headers */
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"


/* global headers */
#include "msg.h"
#include "err.h"

/* For EFS operations */
#include "fs_errno.h"
#include "fs_public.h"
#include "fs_sys_types.h"

/* external module's interface headers */
#include "cm.h"
#include "ds_pdn_ioctl.h"

/* serving task & module headers */
#include "ds_qmi_wds.h"
#include "ds_qmi_task.h"
#include "ds_qmi_dms.h"
#include "ds_qmux.h"
#include "ds_qmi_if.h"
#include "ds_qmi_if_ext.h"
#include "ds_qmi_defs.h"
#include "ds_qmux_ext.h"
#include "ds_qmi_svc.h"
#include "ds_qmi_svc_ext.h"

#include <stringl/stringl.h>


#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
/* GPRS/EDGE multislot default */
#include "gmm.h"
#if defined(FEATURE_WCDMA)
/* WCDMA HSUPA category default */
#ifdef FEATURE_SEGMENT_LOADING
#include "mcfg_seg_load.h"
#include "IWCDMA.h"
#else
#include "rrcdata.h"
#endif /*FEATURE_SEGMENT_LOADING*/

#endif /* defined(FEATURE_WCDMA) */
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */

#include "ds_rmnet_smi.h"
#include "ds_qmap.h"

#include "data_msg.h"
#include "ds_system_heap.h"
#include "qmi_crit_sect.h"
#include "sys_m_reset.h"
#include "ps_utils.h"
#include "dstaski.h"
#include "ds3gmmgsdiif.h"
#include "dssysmgr.h"
#include "ds_qmi_ctl.h"
#include "ds_rmnet_xport.h"
#include "ds_qmi_dsd.h"
#include "ds_qmi_dfs.h"
#include "ds_qmi_nipd.h"
#include "ds_qmi_wda.h"
#include "ds_qmi_at.h"

/*---------------------------------------------------------------------------
  Serving system changed bitmask - ?
---------------------------------------------------------------------------*/
#define QMI_CM_SRV_SYS_CHANGED_MASK (0x00                   |   \
                                     CM_SS_SRV_STATUS_MASK  |   \
                                     CM_SS_SRV_DOMAIN_MASK  |   \
                                     CM_SS_SRV_CAPABILITY_MASK  | \
                                     CM_SS_SYS_MODE_MASK    |   \
                                     CM_SS_ROAM_STATUS_MASK |   \
                                     CM_SS_SRV_IND_MASK         | \
                                     CM_SS_SYS_ID_MASK          | \
                                     CM_SS_SIM_STATE_MASK | \
                                     CM_SS_MOBILITY_MGMT_MASK | \
                                     CM_SS_LAC_TAC_RAC_CHGD_MASK | \
                                     CM_SS_CELL_INFO_MASK | \
                                     CM_SS_MCC_MASK )

/*---------------------------------------------------------------------------
  signal strength fields bitmask - ?
---------------------------------------------------------------------------*/
#define QMI_CM_SIGNAL_STR_CHANGE_MASK (0x00            | \
                                     CM_SS_RSSI_MASK | \
                                     CM_SS_ECIO_MASK | \
                                     CM_SS_IO_MASK   | \
                                     CM_SS_SINR_MASK | \
                                     CM_SS_BER_MASK  | \
                                     CM_SS_FER_MASK  | \
                                     CM_SS_RSRQ_MASK | \
                                     CM_SS_HDR_PER_MASK )

/*---------------------------------------------------------------------------
  For GSM and WCDMA, CM sends error rate on a 1 to 100 scale (as UINT8).
  For CDMA 1x and HDR, CM sends error rate on a 1 to 10000 scale (as UINT16).
  This multiplication factor is needed for normalization.
---------------------------------------------------------------------------*/
#define QMI_IF_GW_ERR_RATE_MULT_FACTOR 100
#define QMI_IF_MAX_GW_ERR_RATE         100
#define QMI_IF_MAX_CDMA_ERR_RATE       10000

/*===========================================================================

                                GLOBAL DATA

===========================================================================*/


/* This is the default QMI_IF command buffer. Make sure that it does not grow
 * beyond 512 bytes. In case you need a command buffer larger than 512 bytes,
 * declare a separate structure. */
typedef struct
{
  uint16  cmd_id; /* qmi_cmd_id_e_type */
  union
  {
    struct
    {
      uint8    otksl_flag;
    } otksl_update;
    
    struct
    {
#define MAX_MMGSDI_BUFFER_LEN  512
      struct
      {
        mmgsdi_cnf_enum_type  cnf_type;
        mmgsdi_cnf_type       cnf_data;
        uint8                 read_cnf_data[MAX_MMGSDI_BUFFER_LEN];
      } mmgsdi_cnf_info;
    } mmgsdi;

  } data;
} qmi_if_cmd_buf_type;

/*---------------------------------------------------------------------------
  WWAN device radio information
---------------------------------------------------------------------------*/
qmi_if_info_type  qmi_if_info;

/*---------------------------------------------------------------------------
  Whether the device is configured to allow EGPRS connections (3GPP only)
  For non-3GPP technologies, this should be set to FALSE by default
---------------------------------------------------------------------------*/
boolean qmi_if_edge_feature_support;

static qmi_crit_sect_type qmi_if_spc_crit_section;

/*===========================================================================

                            FORWARD DECLARATIONS

===========================================================================*/
// Failed attempt counter for qmi_if_check_spc()
static uint8 qmi_spc_attempt_counter;
#define QMI_MAX_SPC_ATTEMPTS    15

static void qmi_if_process_cmd
(
  void * cmd_ptr
);
/*= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

                        EXTERNAL FUNCTION DEFINTIONS

= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =*/

/*===========================================================================
  FUNCTION QMI_IF_INIT()

  DESCRIPTION
    Initialize the QMI interface layer
    This layer contains all the logic required for QMI subsystem to 
    interface with external modules, and vice versa.

  PARAMETERS
    None

  RETURN VALUE
    TRUE  - initialization succeeded
    FALSE - initialization failed

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_if_init
(
  void
)
{
  nv_item_type      *ds_nv_item_ptr;
  ds3g_mmgsdi_info_type  *ds_mmgsdi_ptr =NULL;
  cm_ph_info_s_type      *ph_info_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    Allocate heap memory for ph_info_ptr
  -------------------------------------------------------------------------*/
  DS_SYSTEM_HEAP_MEM_ALLOC_ASSERT(ph_info_ptr, sizeof(cm_ph_info_s_type),
                                  cm_ph_info_s_type*);

  memset(&qmi_if_info, 0, sizeof(qmi_if_info_type));
  memset(ph_info_ptr, 0, sizeof(cm_ph_info_s_type));

  QMI_INIT_CRIT_SECTION(&qmi_if_spc_crit_section);

  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  DS_SYSTEM_HEAP_MEM_ALLOC_ASSERT(ds_nv_item_ptr, sizeof(nv_item_type),
                                  nv_item_type*);
  if( ds_nv_item_ptr == NULL )
  {
    return FALSE;
  }

  /* OTKSL Flag used to check OTKSL has already been entered or not*/
  qmi_if_info.otksl_valid = FALSE;

  /* Read and cache some NV SPC check related items */
  memset(ds_nv_item_ptr, 0, sizeof(nv_item_type));
  qmi_if_info.sec_code_nv_status = ds_get_nv_item(NV_SEC_CODE_I, ds_nv_item_ptr);
  if(NV_DONE_S == qmi_if_info.sec_code_nv_status)
  {
    qmi_if_info.nv_sec_code = ds_nv_item_ptr->sec_code;
  }
  qmi_if_info.otksl_nv_status = ds_get_nv_item(NV_OTKSL_I, ds_nv_item_ptr);
  if(NV_DONE_S == qmi_if_info.otksl_nv_status)
  {
    qmi_if_info.nv_otksl = ds_nv_item_ptr->otksl;
  }
  qmi_if_info.otksl_flag_nv_status = ds_get_nv_item(NV_OTKSL_FLAG_I, ds_nv_item_ptr);
  if (NV_DONE_S == qmi_if_info.otksl_flag_nv_status)
  {
    qmi_if_info.nv_otksl_flag = ds_nv_item_ptr->otksl_flag;
  }

  /*-------------------------------------------------------------------------
    Intialize the below to CM UNinitialized values:
    CM_NETWORK_SEL_MODE_PREF_NONE=-1; CM_MODE_PREF_NONE=-1
  -------------------------------------------------------------------------*/
  qmi_if_info.ph_info.mode_pref = (cm_mode_pref_e_type )-1;                                         
  qmi_if_info.ph_info.oprt_mode = (sys_oprt_mode_e_type )-1; 
#if defined(FEATURE_CDMA) || defined(FEATURE_HDR)
  qmi_if_info.ph_info.cdma_lock_mode = (cm_cdma_lock_mode_e_type )-1;                                     
#endif
  qmi_if_info.spc_inited = TRUE;

#ifdef FEATURE_MMGSDI_SESSION_LIB

  //Get the ds_mmgsdi ptr from the PDNMGR.
  ds_mmgsdi_ptr = ds3g_get_mmgsdi_info_hndl();
  if(ds_mmgsdi_ptr == NULL)
  {
    DS_ERR_FATAL("Can not get the mmgsdi info ptr from the PDNMGR so asserting !!");
	return FALSE;
  }
  qmi_if_info.mmgsdi_client_id = ds_mmgsdi_ptr->client_id;
  
#endif /* FEATURE_MMGSDI_SESSION_LIB */

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
  /* Determine the current GPRS multislot classes */
  qmi_if_info.gw_info.gprs_multislot_class = gmm_read_gprs_multislot_class();
  memset(ds_nv_item_ptr, 0, sizeof(nv_item_type));
  /* if the item successfully read, use that value */
  if (NV_DONE_S == ds_get_nv_item(NV_MULTISLOT_CLASS_I, ds_nv_item_ptr))
  {
    /* check the valid GPRS multislot range which is 1-18 and 30-34 */
    if ((( 1 <= ds_nv_item_ptr->multislot_class) && 
         (18 >= ds_nv_item_ptr->multislot_class)) || 
        ((30 <= ds_nv_item_ptr->multislot_class) &&
         (34 >= ds_nv_item_ptr->multislot_class)))
    {
      qmi_if_info.gw_info.gprs_multislot_class =
        ds_nv_item_ptr->multislot_class;
    }
  }
  
  /* Determine the current EDGE multislot classes */
  qmi_if_info.gw_info.edge_multislot_class = gmm_read_edge_multislot_class();
  memset(ds_nv_item_ptr, 0, sizeof(nv_item_type));
  /* if the item successfully read, use that value */
  if (NV_DONE_S == ds_get_nv_item(NV_EDGE_MULTISLOT_CLASS_I, 
                                   ds_nv_item_ptr))
  {
    /* check the valid EDGE multislot range which is 1-34 */
    if (( 0 < ds_nv_item_ptr->edge_multislot_class) && 
        (34 >= ds_nv_item_ptr->edge_multislot_class))
    {
      qmi_if_info.gw_info.edge_multislot_class =
        ds_nv_item_ptr->edge_multislot_class;
    }
  }

  /* Determine whether EDGE is supported */
  #if defined(FEATURE_GSM_EGPRS) && !defined(FEATURE_EDGE_CAPABILITY_NOT_SUPPORTED)
  memset(ds_nv_item_ptr, 0, sizeof(nv_item_type));
  if (NV_DONE_S == ds_get_nv_item(NV_EDGE_FEATURE_SUPPORT_I,
                                   ds_nv_item_ptr))
  {
    qmi_if_edge_feature_support = ds_nv_item_ptr->edge_feature_support;
  }
  else
  {
    /* Default to enabled (this is the same behavior as in NAS MM) */
    qmi_if_edge_feature_support = TRUE;
  }
  #else
  /* EDGE is disabled by feature flag configuration */
  qmi_if_edge_feature_support = FALSE;
  #endif /* defined(FEATURE_GSM_EGPRS) && !defined(FEATURE_EDGE_CAPABILITY_NOT_SUPPORTED) */
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */

  cm_client_get_ph_info(ph_info_ptr);
  dssysmgr_cm_ph_cb(CM_PH_EVENT_OPRT_MODE ,ph_info_ptr);
  dssysmgr_cm_ph_cb(CM_PH_EVENT_INFO_AVAIL,ph_info_ptr);


  DS_SYSTEM_HEAP_MEM_FREE(ds_nv_item_ptr);
  DS_SYSTEM_HEAP_MEM_FREE(ph_info_ptr);
  return TRUE;
} /* qmi_if_init() */


/*===========================================================================
  FUNCTION QMI_IF_CHECK_SPC()

  DESCRIPTION
  	This function checks the SPC and OTKSL for r/w to NV items like ACCOLC 

  PARAMETERS - spc code, bCheck_otksl - if need to check for OTKSL if SPC fails 

  RETURN VALUE
    SPC Check Result 
 
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_if_spc_result_e_type qmi_if_check_spc
(
  uint8* spc_code, boolean bCheck_otksl
)
{
  qmi_if_spc_result_e_type spc_chk_result = QMI_SPC_OK; 

  nv_sec_code_type       sec_code;
  uint8                  i;
  qmi_if_cmd_buf_type *  cmd_payload =NULL;
  ds_command_type        *cmd_ptr= NULL;
  int                    spc_mismatch = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  DS_MSG0(MSG_LEGACY_MED,"qmi_if_check_spc() START");

  if(FALSE == qmi_if_info.spc_inited)
  {
    return QMI_SPC_ERR_INTERNAL;
  }

  QMI_ENTER_CRIT_SECTION(&qmi_if_spc_crit_section);

  /* Read SEC CODE from NV */
  if(qmi_if_info.sec_code_nv_status != NV_DONE_S)
  {
    DS_MSG0(MSG_LEGACY_MED,"QMI_SPC_FAIL");
    spc_chk_result = QMI_SPC_FAIL;
  }
  else
  {
    sec_code = qmi_if_info.nv_sec_code;
    /* Start out assuming it is ok */
    spc_chk_result = QMI_SPC_OK;

    /* Now check every character in the code, and make sure they match! */
    for (i = 0; i < NV_SEC_CODE_SIZE; i++) 
    {
      spc_mismatch |= (*(spc_code+i) ^ sec_code.digits[i]);
    }

    if (spc_mismatch)
      {
        DS_MSG0(MSG_LEGACY_MED,"QMI_SPC_FAIL 1");
        spc_chk_result = QMI_SPC_FAIL;
    }
  }

  if (bCheck_otksl) 
  {
    /* Only check the OTKSL if the SPC did not match. */
    if (QMI_SPC_FAIL == spc_chk_result)
    {
      /* Read OTKSL CODE from NV.  Only allow OTKSL to be used if this code is
         actually set, if it is inactive then OTKSL support has not been
         provisioned. */
      if(NV_DONE_S == qmi_if_info.otksl_nv_status)
      {
        sec_code = qmi_if_info.nv_otksl;
        /* Start out assuming it is ok */
        spc_chk_result = QMI_SPC_OK;
        spc_mismatch = 0;
        /* Now check every character in the code, and make sure they match! */
        for (i = 0; i < NV_SEC_CODE_SIZE; i++) 
        {
          spc_mismatch |= (*(spc_code+i) ^ sec_code.digits[i]); 
        }
        
        if (spc_mismatch)
          {
            spc_chk_result = QMI_SPC_FAIL;
        }

        /* See if the OTKSL code matched. */
        if (QMI_SPC_OK == spc_chk_result)
        {
          /* Check the current value of the OTKSL Flag.  Only allow OTKSL to be
             used if this flag is actually set, if it is inactive then OTKSL
             support has not been provisioned.

             Although this says it is a flag, it is really a decrementing
             counter for the number of retries remaining.*/
          if (NV_DONE_S == qmi_if_info.otksl_flag_nv_status)
          {
            /* Check that there are either retries remaining in the OTKSL Flag
               counter or that the correct OTKSL has already been entered since
               power-up. */
            if ((0 < qmi_if_info.nv_otksl_flag) || 
                                              (TRUE == qmi_if_info.otksl_valid))
            {
              /* If the OTKSL has not been entered before, need to update the
                 OTKSL Flag counter and global. */
              if (TRUE != qmi_if_info.otksl_valid)
              {
               /*-----------------------------------------------------------------------
                     Get a DS command buffer
                -----------------------------------------------------------------------*/
                cmd_ptr = ds_allocate_cmd_buf(sizeof(qmi_if_cmd_buf_type));
                if ((cmd_ptr == NULL) || (cmd_ptr->cmd_payload_ptr == NULL))
                {
                     DS_MSG0(MSG_LEGACY_ERROR,"Out of memory");                     
                     return QMI_SPC_ERR_INTERNAL;
                 }
                 cmd_ptr->hdr.cmd_id = DS_QMI_COMMON_IF_CMD;
                 cmd_payload = (qmi_if_cmd_buf_type *)cmd_ptr->cmd_payload_ptr;

                 cmd_payload->cmd_id = QMI_CMD_PROCESS_OTKSL_FLAG_UPDATE;
				 cmd_payload->data.otksl_update.otksl_flag = qmi_if_info.nv_otksl_flag - 1;


                 ds_put_cmd(cmd_ptr);
              }

            }
          }
        }
      }
    }
  }

  if(spc_chk_result == QMI_SPC_FAIL)
  {
    // Inc the falied attempt counter 
    qmi_spc_attempt_counter++;
    if (qmi_spc_attempt_counter > QMI_MAX_SPC_ATTEMPTS) 
    {
      spc_chk_result = QMI_SPC_LOCKED;

      if(cm_rpm_check_reset_allowed())
      {
        /* Issue a power down command to sys monitor */
        //ds_qmi_cflog_amss_call("sys_m_initiate_poweroff()");
        DS_MSG0(MSG_LEGACY_MED,"Triggered Sys Initate Poweroff");
        sys_m_initiate_poweroff();
      }
      else
      {
        DS_MSG1(MSG_LEGACY_ERROR,"qmi_spc_attempt_counter:%d exceeded MAX_Val.CM denied shutdown",qmi_spc_attempt_counter);
      }
    }
  }
  else
  {
    qmi_spc_attempt_counter = 0;
  }

  QMI_LEAVE_CRIT_SECTION(&qmi_if_spc_crit_section);
  DS_MSG0(MSG_LEGACY_MED,"qmi_if_check_spc() END");
  return spc_chk_result;
} /* qmi_if_check_spc() */


/*===========================================================================
  FUNCTION QMI_IF_PROCESS_CM_SS_EVENT()

  DESCRIPTION
    Process the CM SS event generated and call coresponding functions in
    QMI services to generate indications
  PARAMETERS
    ss_event  :  CM SS event
    ss_info   :  serving system info obtained from CM SS event
    asubs_id  :   On which subscription event was received
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_cm_ss_event
(
  cm_ss_event_e_type      ss_event,
  dssysmgr_ss_event_info_type  *ss_info
)
{
  boolean is_dev_mode_changed = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  DS_MSG3(MSG_LEGACY_MED,"Processing CM SS event (%x), changed_fields = (0x%x) (0x%x)"
                   "on subs_id:%d",
                   ss_event,
                   QWORD_HIGH(ss_info->changed_fields),
                   QWORD_LOW(ss_info->changed_fields)

        );

  switch (ss_event)
  {
    /*-----------------------------------------------------------------------
      On serving system change (as indicated by CM in changed_fields) or on 
      serving system event info ev (don't check changed fields in this case)
      - send serving system indication
      - send channel rate indication
    -----------------------------------------------------------------------*/
    case CM_SS_EVENT_SRV_CHANGED:
    case CM_SS_EVENT_INFO:
    {
      if ( ( (ss_event == CM_SS_EVENT_SRV_CHANGED) && 
             (ss_info->changed_fields & QMI_CM_SRV_SYS_CHANGED_MASK) ) ||
           (ss_event == CM_SS_EVENT_INFO) )
      {
        DS_MSG0(MSG_LEGACY_MED,"Got new serving system info, saving it in index : ");
       /* if(asubs_id == SYS_MODEM_AS_ID_1)
        {
           /*In single sim SVLTE case, if hybrid stack operational status changed then 
                       Device mode is changed b/w SVLTE and CSFB. Trigger an DMS indication to inform clients*
           is_dev_mode_changed = ((qmi_if_info.ss_info.is_hybr_stack_operational != 
                                  ss_info.is_hybr_stack_operational)?TRUE:FALSE);
        }*/
       qmi_if_info.ss_info.changed_fields = ss_info->changed_fields;
       qmi_if_info.ss_info.srv_capability = ss_info->srv_domain;
       qmi_if_info.ss_info.sys_mode = ss_info->sys_mode;
       qmi_if_info.ss_info.srv_status = ss_info->srv_status;
       
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA)
       qmi_if_info.ss_info.cell_srv_ind = ss_info->cell_srv_ind;
#endif       
        qmi_if_info.inited = TRUE;
        
        if(is_dev_mode_changed)
        {
          qmi_dms_device_mode_changed();
        }
      }
      break;
    }

    default:
      break;
  }
} /* qmi_if_process_cm_ss_event() */



/*===========================================================================
  FUNCTION QMI_IF_PROCESS_CM_PH_EVENT()

  DESCRIPTION
    Process the CM SS event generated and call coresponding functions in
    QMI services to generate indications

  PARAMETERS
    ph_event  :  CM Ph event
    ph_info   :  Phone info obtained from CM Ph event
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_cm_ph_event
(
  cm_ph_event_e_type      ph_event,
  dssysmgr_ph_event_info_type  *ph_info    
)
{
  nv_stat_enum_type  nv_status;
  nv_item_type      *ds_nv_item_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  DS_MSG1(MSG_LEGACY_MED,"Processing Phone Event 0x%X from CM", ph_event);

  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  DS_SYSTEM_HEAP_MEM_ALLOC_ASSERT(ds_nv_item_ptr, sizeof(nv_item_type),
                                  nv_item_type*);
  if(ds_nv_item_ptr ==NULL)
  {
    DS_MSG0(MSG_LEGACY_MED,"Alloc fail ");
    return;
  }
 switch (ph_event)
  {
    case CM_PH_EVENT_INFO_AVAIL:
      {
        /*  Update ph cache */
        if( CM_MODE_PREF_EMERGENCY != ph_info->mode_pref) 
        {
          qmi_if_info.ph_info.mode_pref = ph_info->mode_pref;
        }
#ifdef LTE_BAND_NUM
        memscpy(&qmi_if_info.ph_info.lte_band_capability,
                sizeof(sys_lte_band_mask_e_type),
                 &ph_info->lte_band_capability,

                sizeof(sys_lte_band_mask_e_type));
#else
        qmi_if_info.ph_info.lte_band_capability = ph_info->lte_band_capability;
#endif /* LTE_BAND_NUM */
        qmi_if_info.ph_info.mode_capability = ph_info->mode_capability;
        qmi_if_info.ph_info.oprt_mode = ph_info->oprt_mode;
   #if defined(FEATURE_GSM) || defined(FEATURE_WCDMA)\
			  || defined(FEATURE_CDMA) || defined(FEATURE_HDR)
        qmi_if_info.ph_info.band_capability = ph_info->band_capability;
   #endif
        break;
      }

    case CM_PH_EVENT_SYS_SEL_PREF:
      /* If emergency mode is sent in mode_pref from CM, 
         we need to set that boolean and not update mode_pref field 
         so that qmi sys_sel_pref IND message can send both TLVs.
      */
      if( CM_MODE_PREF_EMERGENCY != ph_info->mode_pref) 
      {
        qmi_if_info.ph_info.mode_pref = ph_info->mode_pref;
      }
      break;

    case CM_PH_EVENT_OPRT_MODE:
      /* If transitioning out of PLPM -> ONLINE remove the PLPM NV Flag */
      if ((SYS_OPRT_MODE_LPM == qmi_if_info.ph_info.oprt_mode) && 
          (SYS_OPRT_MODE_ONLINE == ph_info->oprt_mode))
      {
        /* Check PLPM NV */
        /* Read the nv for LPM persistence flag */
        nv_status = ds_get_nv_item( NV_LPM_PERSISTENCE_I, ds_nv_item_ptr );
        if (NV_DONE_S == nv_status)
        {
          /* Clear nv for LPM or set it for P_LPM only if the nv doesn't match
             the mode request*/
          if (ds_nv_item_ptr->lpm_persistence)
          {
            /* Clear the PLPM Flag */
            ds_nv_item_ptr->lpm_persistence = 0;
            if (NV_DONE_S != ds_put_nv_item(NV_LPM_PERSISTENCE_I, ds_nv_item_ptr))
            {
              DS_MSG1(MSG_LEGACY_ERROR,"Could not set NV_LPM_PERSISTENCE_I to %d",
                              ds_nv_item_ptr->lpm_persistence);
            }
          }
        }
        }

      if (qmi_if_info.ph_info.oprt_mode != ph_info->oprt_mode)
      {
        qmi_if_info.ph_info.oprt_mode = ph_info->oprt_mode;
         qmi_dms_generate_oprt_mode_ind(qmi_if_info.ph_info.oprt_mode);
	}
	break;
    default:
      DS_MSG1(MSG_LEGACY_MED,"Shouldn't be getting this event (%d) here", ph_event);
  }

  DS_SYSTEM_HEAP_MEM_FREE(ds_nv_item_ptr);
} /* qmi_if_process_cm_ph_event() */

/*===========================================================================
  FUNCTION QMI_IF_PROCESS_CM_CALL_EVENT()

  DESCRIPTION
    Process the CM SS event generated and call coresponding functions in
    QMI services to generate indications

  PARAMETERS
    call_event  :  CM call event
    call_info   :  call event info
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*
void qmi_if_process_cm_call_event
(
  cm_call_event_e_type      call_event,
  qmi_if_cm_call_info_type  call_info    
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*
  DS_MSG1(MSG_LEGACY_MED,"Processing Call Event 0x%X from CM", call_event);

  switch (call_event)
  {
  case CM_CALL_EVENT_ORIG:

    case CM_CALL_EVENT_CONNECT:
    case CM_CALL_EVENT_END:
      qmi_if_info.call_info.call_event     = call_event;
      qmi_if_info.call_info.call_type      = call_info.call_type;
      qmi_if_info.call_info.call_id        = call_info.call_id;
      qmi_dms_process_call_event();
      break;

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
#if defined(FEATURE_OTASP)
    case CM_CALL_EVENT_OTASP_STATUS:
      qmi_if_info.call_info.call_event     = call_event;
      qmi_if_info.call_info.call_type      = call_info.call_type;
      qmi_if_info.call_info.otasp_state    = call_info.otasp_state;
      qmi_dms_process_call_event();
      break;
#endif /* defined(FEATURE_OTASP) *
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) *

    default:
      DS_ASSERT(0);
  }
} /* qmi_if_process_cm_call_event() */

/*===========================================================================
  FUNCTION QMI_IF_PROCESS_OTKSL_FLAG_UPDATE()

  DESCRIPTION
    Updates the otksl flag NV item in DCC task

  PARAMETERS
    otksl_flag  :  otksl flag value
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_otksl_flag_update
(
  uint8      otksl_flag
)
{
  nv_item_type      *ds_nv_item_ptr;

  DS_MSG0(MSG_LEGACY_MED,"qmi_if_process_otksl_flag_update() START");
  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  DS_SYSTEM_HEAP_MEM_ALLOC_ASSERT(ds_nv_item_ptr, sizeof(nv_item_type),
                                  nv_item_type*);
  if(ds_nv_item_ptr !=NULL)
  {
    memset(ds_nv_item_ptr, 0, sizeof(nv_item_type));
    ds_nv_item_ptr->otksl_flag = otksl_flag;

    (void) ds_put_nv_item(NV_OTKSL_FLAG_I, ds_nv_item_ptr);
    qmi_if_info.otksl_valid = TRUE;
 
  /* Update local cache */
    qmi_if_info.nv_otksl_flag = otksl_flag;
    DS_SYSTEM_HEAP_MEM_FREE(ds_nv_item_ptr);
  }

  DS_MSG0(MSG_LEGACY_MED,"qmi_if_process_otksl_flag_update() END");
} /* qmi_if_process_otksl_flag_update() */

/*===========================================================================
FUNCTION  QMI_IF_INFO_GET_PTR

DESCRIPTION
  Returns the ptr to qmi_if_info.

DEPENDENCIES
  None

RETURNS
  Ptr to global variable qmi_if_info.

SIDE EFFECTS
  None

===========================================================================*/
qmi_if_info_type * qmi_if_info_get_ptr
(
  void
)
{
  return &qmi_if_info;
}

#ifdef FEATURE_MMGSDI_SESSION_LIB
/*===========================================================================
  FUNCTION QMI_IF_MMGSDI_RESP_CBACK()

  DESCRIPTION
    Callback function called by mmgsdi to return response

  PARAMETERS
    status  : return status
    cnf     : type of cnf response
    cnf_ptr : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_mmgsdi_resp_cback
(
  mmgsdi_return_enum_type  status, 
  mmgsdi_cnf_enum_type     cnf,
  const mmgsdi_cnf_type *  cnf_ptr
)
{
  qmi_if_cmd_buf_type *  cmd_payload;
  int32                    len = 0;
  ds_command_type        *cmd_ptr= NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  DS_MSG1(MSG_LEGACY_MED,"Got response from MMGSDI for cnf_type: %d, posting cmd to DCC",
                  cnf);
  /*-----------------------------------------------------------------------
    Get a DS command buffer
  -----------------------------------------------------------------------*/
   cmd_ptr = ds_allocate_cmd_buf(sizeof(qmi_if_cmd_buf_type));
   if ((cmd_ptr == NULL) || (cmd_ptr->cmd_payload_ptr == NULL))
   {
      DS_MSG0(MSG_LEGACY_ERROR,"Out of memory");
      return ;
    } 
   cmd_ptr->hdr.cmd_id = DS_QMI_COMMON_IF_CMD;
   cmd_payload = (qmi_if_cmd_buf_type *)cmd_ptr->cmd_payload_ptr;
  
   cmd_payload->cmd_id = QMI_CMD_MMGSDI_OPERATION_COMPLETE;
   cmd_payload->data.mmgsdi.mmgsdi_cnf_info.cnf_type = cnf;
   cmd_payload->data.mmgsdi.mmgsdi_cnf_info.cnf_data = *cnf_ptr;
   if (cnf == MMGSDI_READ_CNF)
   {
     if (cnf_ptr->read_cnf.read_data.data_ptr != NULL)
     {
       len = MIN(cnf_ptr->read_cnf.read_data.data_len,
                 MAX_MMGSDI_BUFFER_LEN);
       memscpy(cmd_payload->data.mmgsdi.mmgsdi_cnf_info.read_cnf_data,
               len,
               cnf_ptr->read_cnf.read_data.data_ptr, 
               len);
       cmd_payload->data.mmgsdi.mmgsdi_cnf_info.cnf_data.read_cnf.\
        read_data.data_ptr = 
        &(cmd_payload->data.mmgsdi.mmgsdi_cnf_info.read_cnf_data[0]);
     }
   }
	  
   ds_put_cmd(cmd_ptr);
} /* qmi_if_mmgsdi_resp_cback */

/*===========================================================================
  FUNCTION QMI_IF_PROCESS_MMGSDI_OPERATION_COMPLETE()

  DESCRIPTION
    To send a response to the QMI pin operation requested by the client.
    
  PARAMETERS
    cnf_type : Type of MMGSDI PIN confirmation
    cnf_data : Response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_mmgsdi_operation_complete
(
  mmgsdi_cnf_enum_type    cnf_type,
  mmgsdi_cnf_type        *cnf_data
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    
  switch(cnf_type)
  {
    case MMGSDI_CLIENT_ID_AND_EVT_REG_CNF:
      /*if (MMGSDI_SUCCESS 
        != cnf_data->client_id_and_evt_reg_cnf.response_header.mmgsdi_status)
      {
        DS_ERR_FATAL("MMGSDI session registration failed");
        return;
      }
      qmi_if_info.mmgsdi_client_id = 
        cnf_data->client_id_and_evt_reg_cnf.response_header.client_id;

      qmi_if_mmgsdi_session_reg ();*/
      break;

    case MMGSDI_READ_CNF:
      qmi_dms_process_mmgsdi_operation_complete(cnf_type,
                                                cnf_data);
      break;

    default:
      DS_MSG1(MSG_LEGACY_MED,"Received unhandled cnf_type %d from mmgsdi", cnf_type);
      break;
  }
} /* qmi_if_process_mmgsdi_operation_complete */

/*===========================================================================
  FUNCTION QMI_IF_MAP_MMGSDI_STATUS_TO_ERRVAL

  DESCRIPTION
    To obtain QMI client-specific error message from MMGSDI error message
    
  PARAMETERS
    mmgsdi_status   : MMGSDI return value
    line.. Line number where MMGSDI status is not success

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_error_e_type qmi_if_map_mmgsdi_status_to_errval
(
  mmgsdi_return_enum_type  mmgsdi_status,
  unsigned int       line
)
{
  qmi_error_e_type  errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  switch(mmgsdi_status)
  {
    case MMGSDI_WARNING_NO_INFO_GIVEN:
    case MMGSDI_INCOMPAT_PIN_STATUS:
      errval = QMI_ERR_NO_EFFECT;
      break;

    case MMGSDI_INCORRECT_CODE:
    case MMGSDI_INCORRECT_PARAMS:
      errval = QMI_ERR_INCORRECT_PIN;
      break;

    case MMGSDI_CODE_BLOCKED:
      errval = QMI_ERR_PIN_BLOCKED;
      break;

    case MMGSDI_CODE_PERM_BLOCKED:
      errval = QMI_ERR_PIN_PERM_BLOCKED;
      break;

    case MMGSDI_PIN_NOT_INITIALIZED:
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      break;

    case MMGSDI_ACCESS_DENIED:
      errval = QMI_ERR_ACCESS_DENIED;
      break;

    default:
      DS_MSG0(MSG_LEGACY_MED,"Unhandled mmgsdi_status received");
      errval = QMI_ERR_INTERNAL;
  }

  DS_MSG3(MSG_LEGACY_MED,"Mmgsdi_status = %d at line no. %d is not success , errval = %d", mmgsdi_status,line,errval);
  return errval;
} /* qmi_if_map_mmgsdi_status_to_errval() */
#endif /* FEATURE_MMGSDI_SESSION_LIB */

/*===========================================================================
  FUNCTION  QMI_IF_EDGE_SUPPORTED

  DESCRIPTION
    Determines whether EDGE is configured as enabled or disabled

  PARAMETERS
    None

  RETURN VALUE
    True if EGPRS is supported by the current configuration, false otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_if_edge_supported
(
  void
)
{
  return qmi_if_edge_feature_support;
} /* qmi_if_edge_supported() */

/*===========================================================================
  FUNCTION QMI_IF_PROCESS_CMD

  DESCRIPTION
    This function processes a QMI IF command or event.

    It is called by the QMI command handler and will dispatch the
    associated command/event handler function.

  PARAMETERS
    cmd_ptr:  private data buffer containing the QMI IF command
              information.

  RETURN VALUE
    None

  DEPENDENCIES
    QMI IF must already have been initialized

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_if_process_cmd
(
  void * cmd_ptr
)
{
  qmi_if_cmd_buf_type *cmd_buf_ptr = NULL;
/*-------------------------------------------------------------------------*/

  DS_ASSERT(cmd_ptr != NULL);
  cmd_buf_ptr = (qmi_if_cmd_buf_type *)cmd_ptr;

  switch(cmd_buf_ptr->cmd_id)
  {
    case QMI_CMD_CM_CLIENT_ACTIVATE:
      break;
    case QMI_CMD_PROCESS_OTKSL_FLAG_UPDATE:
      qmi_if_process_otksl_flag_update(
                                cmd_buf_ptr->data.otksl_update.otksl_flag);
      break;
  #ifdef FEATURE_MMGSDI_SESSION_LIB
    case QMI_CMD_MMGSDI_SESSION_READY:
      /*qmi_dms_process_uim_get_state(
          cmd_buf_ptr->data.mmgsdi.mmgsdi_evt_info.event,
          cmd_buf_ptr->data.mmgsdi.mmgsdi_evt_info.card_err_info,
          cmd_buf_ptr->data.mmgsdi.mmgsdi_evt_info.activated);*/
      break;

    case QMI_CMD_MMGSDI_OPERATION_COMPLETE:
      qmi_if_process_mmgsdi_operation_complete(
        cmd_buf_ptr->data.mmgsdi.mmgsdi_cnf_info.cnf_type,
        &cmd_buf_ptr->data.mmgsdi.mmgsdi_cnf_info.cnf_data);
      break;

  #endif /* FEATURE_MMGSDI_SESSION_LIB */
    
    case QMI_CMD_NEW_CM_OPRT_MODE_INFO:
     /* qmi_if_process_cm_ph_event( cmd_buf_ptr->data.cm_ph.event,
                                  cmd_buf_ptr->data.cm_ph.info );*/
      break;

    case QMI_CMD_NEW_CM_PH_INFO:
     /* qmi_if_process_cm_ph_event(cmd_buf_ptr->data.cm_ph.event,
                                 cmd_buf_ptr->data.cm_ph.info);*/
      
      break;

    case QMI_CMD_NEW_CM_SS_INFO:
   /*   qmi_if_process_cm_ss_event(cmd_buf_ptr->data.cm_ss.event,
                                 cmd_buf_ptr->data.cm_ss.info,
                                 cmd_buf_ptr->data.cm_ss.asubs_id);*/
      break;
  
    default:
      DS_MSG1(MSG_LEGACY_MED,"Ignoring QMI IF cmd %d", cmd_buf_ptr->cmd_id);
      break;

  }/* switch(cmd_buf_ptr->cmd_id) */
  DS_MSG0(MSG_LEGACY_MED,"QMI_DCC_SEND_CMD_EX: De Allocated QMI IF cmd buf" );
  return;
} /* qmi_if_process_cmd() */

/*===========================================================================
  FUNCTION QMI_DFS_INTERNAL_EP_ID_TO_QMI_EP_ID

  DESCRIPTION
    Convert internal EP ID to QMI EP ID

  PARAMETERS
    ep_id: internal end point id
      
  RETURN VALUE
    qmi_ep_id_type
 
  DEPENDENCIES
 
  SIDE EFFECTS
    None
===========================================================================*/
data_ep_id_type_v01 qmi_internal_ep_id_to_qmi_ep_id
(
  uint32 ep_id
)
{
  data_ep_id_type_v01 qmi_ep_id = {0};
  qmi_ep_id.ep_type = ((ep_id & 0xFFFFFFFF)>>24);
  qmi_ep_id.iface_id = (ep_id & 0x00FFFFFF);
  
  return qmi_ep_id;
}

/*===========================================================================
FUNCTION      ds_qmi_process_commands

DESCRIPTION   This function processes Ds QMI commands. A command processing
              function is called based on the type of command received.

              This function should be called by the top-level task dispatcher
              whenever any Ds QMI command is received.

DEPENDENCIES  DS task should have been initialized prior to calling this
              function.

RETURN VALUE  None

SIDE EFFECTS  None
===========================================================================*/
void ds_qmi_process_commands
(
  ds_command_type  *cmd_ptr
)
{
 
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
 if(cmd_ptr == NULL)
 {

   DS_ASSERT(0);
   return;
 }

 switch( cmd_ptr->hdr.cmd_id )
 {
 /*-----------------------------------------------------------------------
  Processing of new commands
  -----------------------------------------------------------------------*/
 case DS_QMI_RMNET_SM_EV_CMD:
 	  rmnet_sm_process_ev_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
     break;
 case DS_QMI_RMNET_SM_CMD:
 	 rmnet_sm_process_cmd(cmd_ptr->hdr.cmd_id,cmd_ptr->cmd_payload_ptr);
    break;

 case DS_QMI_QMUX_RX_CMD:
	 break;
 	
 case DS_QMI_COMMON_IF_CMD:
      //qmi_process_legacy_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
      qmi_if_process_cmd(cmd_ptr->cmd_payload_ptr);
	 break;

 case DS_QMI_QMUX_CMD:    //DS_QMI_CMD
 	  qmi_qmux_process_cmd(cmd_ptr->cmd_payload_ptr);
 	break;
 case DS_QMI_QMAP_CMD:
 	 ds_qmap_process_cmd(cmd_ptr->cmd_payload_ptr);
 	break;

 case  DS_QMI_CTL_SVC_CMD:
     qmi_ctli_process_cmd(cmd_ptr->cmd_payload_ptr);
 	break;
 
 case DS_QMI_INIT_LEGACY_SERVICES_CMD:
       qmi_process_init_legacy_services(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
	 break;
 	
 case DS_QMI_RECV_LEGACY_SERVICES_REQ_CMD:
      qmi_svc_process_legacy_svc_req_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
	 break;
 	
 case DS_QMI_RMNET_XPORT_CMD:
      rmnet_xport_cmd_hdlr(cmd_ptr->hdr.cmd_id,cmd_ptr->cmd_payload_ptr);
	 break;

#ifdef FEATURE_DATA_PS_464XLAT  //Clat will be needed in next release
 case DS_CLAT_SM_START_CMD:
 case DS_CLAT_SM_STOP_CMD:
 case DS_CLAT_SM_IPV4_IFACE_UP_CMD:
 case DS_CLAT_SM_IPV4_IFACE_DOWN_CMD:
 case DS_CLAT_SM_IPV6_IFACE_UP_CMD:
 case DS_CLAT_SM_IPV6_IFACE_DOWN_CMD:
 case DS_CLAT_SM_IPV6_IFACE_PREFIX_UPDATE_CMD:
 case DS_CLAT_SM_PLAT_AVAILABLE_CMD:
 case DS_CLAT_SM_PLAT_UNAVAILABLE_CMD:
 case DS_CLAT_SM_DNS_PROXY_ENABLED_CMD:
 case DS_CLAT_SM_DNS_PROXY_DISABLED_CMD:
 case DS_CLAT_SM_DNS64_CALLBACK_CMD:
 case DS_CLAT_SM_DPM_CONTEXT_REGISTERED_CMD:
	 break;	 
#endif /* FEATURE_DATA_PS_464XLAT */
 	
 case DS_QMI_DSD_SVC_CMD:
      qmi_dsdi_process_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
	 break;

 case DS_QMI_DMS_SVC_CMD:
      qmi_dmsi_process_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
	 break;
 	
 case DS_QMI_DFS_SVC_CMD:
	 qmi_dfsi_process_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
	 break;
 	
 case DS_QMI_NIPD_SVC_CMD:
 	   qmi_nipdi_process_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
	 break;
 	
 case DS_QMI_WDS_SVC_CMD:
       qmi_wdsi_process_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
	 break;
 	
 case DS_QMI_WDA_SVC_CMD:
       qmi_wdai_process_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
	 break;
 	
 case DS_QMI_AT_SVC_CMD: 	
#ifdef FEATURE_DATA_ATCOP 	
	 qmi_ati_process_cmd(cmd_ptr->hdr.cmd_id, cmd_ptr->cmd_payload_ptr);
#endif /* FEATURE_DATA_ATCOP */
	 break;
 default:
  DS_ASSERT(0);
  break;
 }
}
