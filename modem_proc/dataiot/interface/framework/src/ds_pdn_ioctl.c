/*===========================================================================

                      D S _ P D N _ I O C T L. C

DESCRIPTION
  This file contains functions used by various modules to access
  network interface.

EXTERNALIZED FUNCTIONS

Copyright (c)  2019 QUALCOMM Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary
===========================================================================*/

/*===========================================================================

                      EDIT HISTORY FOR FILE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $Header: //components/rel/dataiot.mpss/2.0/interface/framework/src/ds_pdn_ioctl.c#1 $ $DateTime: 2020/03/17 08:03:16 $ $Author: pwbldsvc $

when        who    what, where, why
--------    ---    ----------------------------------------------------------
01/05/18    mkumarsa    Initial version of the pdn ioctl module.
===========================================================================*/

/*===========================================================================

                       INCLUDE FILES FOR THE MODULE

===========================================================================*/
#include "ds_headers.h"
#include "dssocki.h"
#include "ds_pdn_ioctl.h"
#include "ds_defsi.h"
#include "ds_fwk.h"
#include "ps_in.h"
#include "ps_addri_v6.h"
#include "ds_pdn_manager.h"
#include "ds_qos_net_initiated_req.h"
#include <stringl/stringl.h>
#include "dss_control.h"
#include "ds_fwki.h"
#include "ps_stat_logging.h"
#include "ps_ip.h"


/*===========================================================================

                      INTERNAL FUNCTION DEFINITIONS

===========================================================================*/

/*===========================================================================
FUNCTION DS_PDN_IOCTLI_MODE_HANDLER_CBACK()

DESCRIPTION
  This function calls the  the ioctl function pointer of the 
  specified technology based on the IOCTL NAME  

DEPENDENCIES
  None

PARAMETERS
  pdn_ptr_info : PDN pointer on which operation needs to be performed
  ip_type        :ip type of the call to idenytify the PDN 
  ioctl_name     : IOCTl NAME 
  argval_ptr     : argval ptr where the contents needs to be put
  ps_errno       : errno generated by the current tecnology function poinet.

RETURN VALUE
   0 : on success
  -1 : on failure

SIDE EFFECTS
 None
===========================================================================*/
static int ds_pdn_ioctli_mode_handler_cback
(
  ds_pdn_mgr_s              *pdn_ptr_info,
  ip_addr_enum_type          ip_type,
  ds_pdn_ioctl_type          ioctl_name,
  void                      *argval_ptr,
  sint15                    *ps_errno
)
{
  ds_fwk_mh_e_type                         mh_type = DS_FWK_MH_MAX;
  ds_fw_mh_info_type                       *mh_info = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*-------------------------------------------------------------------------
    Call the mode handler registered ioctl callback.
  -------------------------------------------------------------------------*/

  mh_type= ds_fwk_get_current_mh();
  if(mh_type != DS_FWK_MH_MAX)
  {
    mh_info = ds_fwk_get_mh(mh_type);
    if(mh_info != NULL )
    {
       return mh_info->pdn_operations.ioctl_f_ptr(pdn_ptr_info,
                                                  ip_type,
                                                  ioctl_name,
                                                  argval_ptr,
                                                  ps_errno);
    }
  }
  *ps_errno = DS_EINVAL;
  return -1;
} /* ps_iface_ioctli_mode_handler_cback() */

/*===========================================================================

                      EXTERNAL FUNCTION DEFINITIONS

===========================================================================*/
/*===========================================================================
FUNCTION DS_PDN_IOCTL()

DESCRIPTION
  This function performs various operations on the given interface.
  Typically, these operations are to get or set a value.

DEPENDENCIES
  None.

PARAMETERS

  client_type             -   client_type on which the specified operations
                              is to be performed

  client_handle      -        The client_handle on whcih the call was brought up

  ioctl_name                  Ioctl name 
  
  argval_ptr                  Pointer to structure where info will be given
  
  ps_errno                   -Error code returned in case of failure (Error
                              values are those defined in dserrno.h)

                              DS_EBADF - Returned by dss_iface_ioctl() if the
                              specified id_ptr is invalid (i.e. id_ptr does
                              not map to a valid ps_iface_ptr).

                              DS_EINVAL - Returned by dss_iface_ioctl() when
                              the specified IOCTL does not belong to the
                              common set of IOCTLs and there is no IOCTL mode
                              handler registered for the specified interface.

                              DS_EOPNOTSUPP - Returned by the lower level
                              IOCTL mode handler when specified IOCTL is not
                              supported by the interface. For instance, this
                              would be returned by interfaces that do not
                              support a certain "iface specific common IOCTL"
                              (i.e. these are common IOCTLs, but the
                              implementation is mode specific, for example,
                              GO_DORMANT).

                              DS_EFAULT - This error code is returned if the
                              specified arguments for the IOCTL are correct
                              but dss_iface_ioctl() or a mode handler
                              encounters an error while executing the IOCTL..
                              For instance, if the 1X interface cannot
                              "GO_DORMANT" it would return this error.

                              DS_NOMEMORY - This error code is returned if we
                              run out of buffers during execution.

RETURN VALUE
  0 - on success
  -1 - on failure

SIDE EFFECTS
  None.

===========================================================================*/
int ds_pdn_ioctl
(
  uint8                      client_type,
  sint15                     client_handle,
  ds_pdn_ioctl_type          ioctl_name,
  void                      *argval_ptr,
  sint15                    *ps_errno
)
{
  ip_addr_type                              *ip_addr                = NULL;
  ip_addr_type                              *gateway_ip_addr        = NULL;
  ip_addr_type                              *ipv4_subnet_mask       = NULL;
  ps_ip_addr_type                            ret_ip_addr ={0};
  uint32                                    *mtu                    = NULL;
#ifdef FEATURE_DATA_PS_IPV6
  ds_pdn_ioctl_priv_ipv6_addr_type          *priv_addr;
  int                                        result;  
  ps_ipv6_iid_params_type                    iid_params;
#endif /* FEATURE_DATA_PS_IPV6 */
  uint8                                      index;
  ds_pdn_ioctl_get_all_dns_addrs_type       *get_dns_addrs_ptr = NULL;
  ds_pdn_ioctl_ims_params_info_type         *ims_info;
  ds_pdn_op_reserved_pco_type               *op_reserved_pco_info_ptr = NULL;
  ds_fwk_s_type                             *fwk_inst =NULL;
  ds_fwk_clnt_info_s_type                    clnt_info_ptr ={0};
  ds_pdn_mgr_s                              *pdn_ptr_info = NULL;
  ds_pdn_mgr_instance_type_e                 pdn_instance;
  sint15                                     dss_nethandle;
  ip_addr_enum_type                          ip_type = IPV4_ADDR;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (ps_errno == NULL)
  {
    DS_ERR_FATAL("ps_iface_ioctl(): NULL args");
    return -1;
  }

  *ps_errno = DSS_SUCCESS;
  DS_MSG3(MSG_LEGACY_HIGH,"client_type %d,client_handle %d ioctl %d",
          client_type,client_handle,ioctl_name);

  if((client_type != DS_FWK_CLIENT_RMNET &&
      client_type != DS_FWK_CLIENT_RMSM &&
      client_type != DS_FWK_CLIENT_SOCKETS)||
     (client_handle == DS_FWK_INVALID_CLNT_HANDLE))
  {
    *ps_errno = DS_EBADF;
     goto bail;	  
  }
  if(client_type == DS_FWK_CLIENT_SOCKETS)
  {
     dss_nethandle = client_handle;
     client_handle = dss_get_handle(client_handle);
  }
  
  ds_fwk_get_clnt_info_from_handle(client_type,client_handle,&clnt_info_ptr);
  if(clnt_info_ptr.fw_inst == NULL)
  {   
     DS_MSG0(MSG_LEGACY_ERROR,"No framework "
            "instance could be found for this call");
    *ps_errno = DS_EBADF;
     goto bail;
  }

  fwk_inst = clnt_info_ptr.fw_inst;
  if(clnt_info_ptr.ip_type == IPV6_ADDR)
  {
      pdn_ptr_info = fwk_inst->v6_pdn_ptr;
      pdn_instance = DS_PDN_INSTANCE_IPV6;
      ip_type = IPV6_ADDR;
  }
  else if(clnt_info_ptr.ip_type == IPV4_ADDR)
  {
     pdn_ptr_info = fwk_inst->v4_pdn_ptr;	   
     pdn_instance = DS_PDN_INSTANCE_IPV4;
     ip_type = IPV4_ADDR;
  }
  else if(clnt_info_ptr.ip_type == NON_IP_ADDR)
  {
     pdn_ptr_info = fwk_inst->non_ip_pdn_ptr;    
     pdn_instance = DS_PDN_INSTANCE_NON_IP;
     ip_type = NON_IP_ADDR;
  }
  else
  {
    DS_MSG1(MSG_LEGACY_ERROR,"wrong ip type %d",clnt_info_ptr.ip_type);
    *ps_errno = DS_EBADF;
     goto bail;
  }

  /*-------------------------------------------------------------------------
    More special case: For the followign IOCTLs the iface addr family
    needs to verified.
  -------------------------------------------------------------------------*/
  switch(ioctl_name)
  {
#ifdef FEATURE_DATA_PS_IPV6
    case DS_PDN_IOCTL_GENERATE_PRIV_IPV6_ADDR:
    case DS_PDN_IOCTL_GET_IPV6_REMAINING_ROUTER_LIFETIME:
    if (clnt_info_ptr.ip_type != IPV6_ADDR)
    {
         DS_MSG0(MSG_LEGACY_ERROR,"ds_pdn_ioctl():v6 PDN required");
        *ps_errno = DS_EINVAL;
         goto bail;
    }
    break;
    default:
     break;
#endif /* FEATURE_DATA_PS_IPV6 */
  } /* switch (ioctl_name) */

  /*-------------------------------------------------------------------------
    Service the IOCTL based on the ioctl name
  -------------------------------------------------------------------------*/
  switch (ioctl_name)
  {
     case DS_PDN_IOCTL_GET_ALL_DNS_ADDR:
       get_dns_addrs_ptr = (ds_pdn_ioctl_get_all_dns_addrs_type *)argval_ptr;
       if (NULL == get_dns_addrs_ptr ||
           0    == get_dns_addrs_ptr->num_dns_addrs ||
           NULL == get_dns_addrs_ptr->dns_addrs_ptr)
       {
         *ps_errno = DS_EFAULT;
         goto bail;
       }  
      /*---------------------------------------------------------------------
        Print retrieved DNS addresses.
      ---------------------------------------------------------------------*/
       ds_fwk_get_all_dns_addrs(fwk_inst,get_dns_addrs_ptr->dns_addrs_ptr,
                               &(get_dns_addrs_ptr->num_dns_addrs),
                               pdn_instance);

       if(clnt_info_ptr.ip_type == IPV4_ADDR)
       {
         for(index = 0; index < get_dns_addrs_ptr->num_dns_addrs; index++)
         {
           IPV4_ADDR_MSG(get_dns_addrs_ptr->dns_addrs_ptr[index].addr.v4);
         }

       }
#ifdef FEATURE_DATA_PS_IPV6
       else if(clnt_info_ptr.ip_type == IPV6_ADDR)
       {
         for(index = 0; index < get_dns_addrs_ptr->num_dns_addrs; index++)
         {
           IPV6_ADDR_MSG(get_dns_addrs_ptr->dns_addrs_ptr[index].addr.v6);
         }
       }
#endif /* FEATURE_DATA_PS_IPV6 */

       break;
    /*-----------------------------------------------------------------------
      Get MTU of iface
    -----------------------------------------------------------------------*/
     case DS_PDN_IOCTL_GET_MTU:
       if (NULL == argval_ptr)
       {
         *ps_errno = DS_EFAULT;
         goto bail;
       }
       mtu = (uint32 *)argval_ptr;      
      *mtu = ds_fwk_get_mtu(fwk_inst ,clnt_info_ptr.ip_type); 
       DS_MSG_SPRINTF_1(MSG_LEGACY_MED,"ds_pdn_ioctl(): "
                       "MTU is %d", *mtu);
       break;
    /*-----------------------------------------------------------------------
      Get Path MTU of framework instance
    -----------------------------------------------------------------------*/
     case DS_PDN_IOCTL_GET_PATH_MTU:
       if (NULL == argval_ptr)
       {
         *ps_errno = DS_EFAULT;
         goto bail;
       }
       mtu = (uint32 *)argval_ptr;      
       *mtu = ps_ip_calc_path_mtu(clnt_info_ptr.ip_type, fwk_inst); 
       DS_MSG_SPRINTF_1(MSG_LEGACY_MED,"ds_pdn_ioctl(): "
                       "Path MTU is %d", *mtu);
       break;
    /*-----------------------------------------------------------------------
      Get op res pco of iface
    -----------------------------------------------------------------------*/
     case DS_PDN_IOCTL_GET_OP_RES_PCO:
      if (NULL == argval_ptr)
      {
        *ps_errno = DS_EFAULT;
         goto bail;
      }
      op_reserved_pco_info_ptr = (ds_pdn_op_reserved_pco_type *)argval_ptr;	  
      if(0 != ds_fwk_get_op_reserved_pco
            (pdn_ptr_info,op_reserved_pco_info_ptr))
      {
         *ps_errno = DS_EINVAL;
          goto bail;
      }
      break;
    /*-----------------------------------------------------------------------
      Get IP addr of iface
    -----------------------------------------------------------------------*/
     case DS_PDN_IOCTL_GET_IP_ADDR:
      if (NULL == argval_ptr)
      {
        *ps_errno = DS_EFAULT;
         goto bail;
      }

      ip_addr = (ip_addr_type *)argval_ptr;
      ip_addr->type = clnt_info_ptr.ip_type;
      ret_ip_addr.type = ip_addr->type;
      ds_fwk_get_ip_addr(fwk_inst,ret_ip_addr.type,&ret_ip_addr);
 
      switch(ip_addr->type)
      {
        case IPV4_ADDR:
          ip_addr->addr.v4 = ret_ip_addr.addr.v4.ps_s_addr;
          IPV4_ADDR_MSG(ip_addr->addr.v4);
          break;

#ifdef FEATURE_DATA_PS_IPV6
        case IPV6_ADDR:
          ip_addr->addr.v6[0] = ret_ip_addr.addr.v6.ps_s6_addr64[0];
          ip_addr->addr.v6[1] = ret_ip_addr.addr.v6.ps_s6_addr64[1];
          IPV6_ADDR_MSG(ip_addr->addr.v6);
          break;
#endif

        default:
          ip_addr->type = IP_ADDR_INVALID;
          *ps_errno = DS_EFAULT;
          break;
      }
      break;
    /*-----------------------------------------------------------------------
      Get gateway's IP address.
    -----------------------------------------------------------------------*/
     case DS_PDN_IOCTL_GET_GATEWAY_ADDR:
      if (NULL == argval_ptr)
      {
        *ps_errno = DS_EFAULT;
         goto bail;
      }

      gateway_ip_addr = (ds_pdn_ioctl_gateway_addr_type *)argval_ptr;
      ret_ip_addr.type = IP_ANY_ADDR;
      ds_fwk_get_peer_addr(pdn_ptr_info,&ret_ip_addr,pdn_instance,fwk_inst);

      gateway_ip_addr->type = ret_ip_addr.type;
      switch(gateway_ip_addr->type)
      {
        case IPV4_ADDR:
          gateway_ip_addr->addr.v4 = ret_ip_addr.addr.v4.ps_s_addr;
          IPV4_ADDR_MSG(gateway_ip_addr->addr.v4);
          break;

#ifdef FEATURE_DATA_PS_IPV6
        case IPV6_ADDR:
          gateway_ip_addr->addr.v6[0] = ret_ip_addr.addr.v6.ps_s6_addr64[0];
          gateway_ip_addr->addr.v6[1] = ret_ip_addr.addr.v6.ps_s6_addr64[1];
          IPV6_ADDR_MSG(gateway_ip_addr->addr.v6);
          break;
#endif

        default:
          gateway_ip_addr->type = IP_ADDR_INVALID;
          *ps_errno = DS_EFAULT;
          break;
      }
      break;

      /*-----------------------------------------------------------------------
      Get IPv4 subnet mask
      -----------------------------------------------------------------------*/
     case DS_PDN_IOCTL_GET_SUBNET_MASK:
      if (NULL == argval_ptr)
      {
        *ps_errno = DS_EFAULT;
        DS_MSG0(MSG_LEGACY_ERROR,"NULL agval_ptr");
        goto bail;
      }
      if(clnt_info_ptr.ip_type != IPV4_ADDR)
      {
         DS_MSG_SPRINTF_2(MSG_LEGACY_ERROR,
                          "DS_PDN_IOCTL_GET_SUBNET_MASK is not supported "
                           "on IPv6 fw_inst %d iptype %d",
                           clnt_info_ptr.fw_inst, clnt_info_ptr.ip_type);
         *ps_errno = DS_EAFNOSUPPORT;
          goto bail;
      }
      ipv4_subnet_mask = (ds_pdn_ioctl_subnet_mask_type *)argval_ptr;
       if( 0 != ds_fwk_get_subnet_mask(pdn_ptr_info,
                                       argval_ptr,
                                       pdn_instance,
                                       fwk_inst,ps_errno))
       {
         *ps_errno = DS_EINVAL;
          goto bail;
       }
      break;

     case DS_PDN_IOCTL_GET_IMS_PARAMS:
      if (NULL == argval_ptr)
      {
        *ps_errno = DS_EFAULT;
        goto bail;
      }
	  
      ims_info = (ds_pdn_ioctl_ims_params_info_type *) argval_ptr;
      if(0 != ds_fwk_get_sip_serv_addr_ex(fwk_inst,
                                            ims_info->sip_addr_array,
                                          &ims_info->sip_addr_cnt,
                                          pdn_instance))
      {
        *ps_errno = DS_EFAULT;
         goto bail;
      }

    /*-----------------------------------------------------------------------
      Get SIP domain name list.
      Ask deepka whether the sim _domain_list is needed or not
    -----------------------------------------------------------------------*/ 
      ds_fwk_get_sip_domain_names(fwk_inst,
                                    ims_info->domain_name_array,
                                    &ims_info->domain_name_count);             
      break;
     case DS_PDN_FLOW_IOCTL_QOS_GET_GRANTED_FLOW_SPEC:
     {
        *ps_errno = DS_EOPNOTSUPP;
         goto bail;
     }
     case DS_PDN_IOCTL_QOS_NET_INITIATED_REQUEST:
     case DS_PDN_IOCTL_QOS_NET_INITIATED_RELEASE:
     case DS_PDN_IOCTL_QOS_GET_GRANTED_FLOW_SPEC:
     {
       if(client_type == DS_FWK_CLIENT_SOCKETS) 
       {
         if (FALSE == dss_qos_ioctl_handler(dss_nethandle,
                                          ioctl_name,
                                          argval_ptr,
                                          ps_errno))
         {
           DS_MSG3(MSG_LEGACY_ERROR,"Error in handling event %d for"
                                     "DSS Nethandle %d, error %d ",
                                      ioctl_name, dss_nethandle, *ps_errno);
          *ps_errno = DS_EOPNOTSUPP;
           goto bail;
         }
       }
       else
       {
        *ps_errno = DS_EFAULT;
         goto bail;
       }
     }   
     break;
    case DS_PDN_IOCTL_REG_EVENT_CB: 
    { 
       if(client_type == DS_FWK_CLIENT_SOCKETS) 
       { 
          if(FALSE ==  dssocki_reg_ev(dss_nethandle,
                                     ((ds_pdn_ioctl_ev_cb_type *)argval_ptr)->\
                                      event_cb,
                                    ((ds_pdn_ioctl_ev_cb_type *)argval_ptr)->event,
                                    ((ds_pdn_ioctl_ev_cb_type *)argval_ptr)->\
                                     user_data_ptr))
        {
           DS_MSG0(MSG_LEGACY_ERROR,"PDN ioctl failed for"
                                    "DS_PDN_IOCTL_REG_EVENT_CB ");
          *ps_errno  = DS_EOPNOTSUPP;
           goto bail;
        }
      }
      else
      {
         *ps_errno = DS_EFAULT;
          goto bail;
      }
  
    }
    break;
 
    case DS_PDN_IOCTL_DEREG_EVENT_CB:
    {
      if(client_type == DS_FWK_CLIENT_SOCKETS)
      {
        if(FALSE == dssocki_dereg_ev(dss_nethandle,
                                    ((ds_pdn_ioctl_ev_cb_type *)argval_ptr)->\
                                      event_cb,
                                    ((ds_pdn_ioctl_ev_cb_type *)argval_ptr)->event,
                                    ((ds_pdn_ioctl_ev_cb_type *)argval_ptr)->\
                                      user_data_ptr))
        {
           DS_MSG0(MSG_LEGACY_ERROR,"PDN ioctl failed for"
                                    "DS_PDN_IOCTL_DEREG_EVENT_CB ");
           *ps_errno  = DS_EOPNOTSUPP;
            goto bail;
        }
      }
      else
      {
        *ps_errno = DS_EFAULT;
         goto bail;
       }
    }
    break;

    case DS_PDN_IOCTL_GENERATE_PRIV_IPV6_ADDR:
   
#ifdef FEATURE_DATA_PS_IPV6
     if (clnt_info_ptr.ip_type == IPV6_ADDR)
     {
        priv_addr = (ds_pdn_ioctl_priv_ipv6_addr_type *) argval_ptr;
          if (NULL == priv_addr || NULL == priv_addr->ip_addr)
          {
             *ps_errno = DS_EFAULT;
              goto bail;
          }
      /*---------------------------------------------------------------------
        This is an application initiated request to generate a new privacy
        address.
      ---------------------------------------------------------------------*/
            iid_params.app_request = TRUE;
            iid_params.is_unique   = priv_addr->is_unique;
   
            result = ps_generate_priv_ipv6_addr(fwk_inst,
                                               &ret_ip_addr,
                                               &iid_params,
                                                ps_errno);
            if (0 != result)
            {
               goto bail;
            }
            priv_addr->ip_addr->type       = ret_ip_addr.type;
            priv_addr->ip_addr->addr.v6[0] = ret_ip_addr.addr.v6.ps_s6_addr64[0];
            priv_addr->ip_addr->addr.v6[1] = ret_ip_addr.addr.v6.ps_s6_addr64[1];
     }
     else
     {
       *ps_errno =DS_EFAULT;
        goto bail;
     }
     break;
 #endif	  
    case DS_PDN_IOCTL_GET_PDN_STATS:
     if(NULL == argval_ptr) 
     {
        *ps_errno = DS_EFAULT;
         goto bail;
     }
     if(0 != ds_fwk_get_pdn_stats
             (
               PS_STAT_FWK_ALL,
               fwk_inst,
               ip_type,
               argval_ptr
            ))
     {
        *ps_errno = DS_EFAULT;
         goto bail;
     }
     break;
    case DS_PDN_IOCTL_RESET_PDN_STATS:	
     if(0 != ds_fwk_reset_pdn_stats(fwk_inst,ip_type,ps_errno))
     {
        *ps_errno = DS_EFAULT;
         goto bail;
     }
     break;    
    case  DS_PDN_IOCTL_3GPP_GET_SESSION_PARAMS:
    case  DS_PDN_IOCTL_3GPP_GET_LTE_REESTAB_CALLTYPE:
    case  DS_PDN_IOCTL_3GPP_SET_LTE_REESTAB_CALLTYPE:
    case  DS_PDN_IOCTL_3GPP_FORCE_PDN_DISCONNECT:
    case  DS_PDN_IOCTL_SET_SUBSEQUENT_DATA_TRANSFER_STATUS:
    case  DS_PDN_IOCTL_GET_SUBSEQUENT_DATA_TRANSFER_STATUS:
    case  DS_PDN_IOCTL_3GPP_MO_EXCP_IN_USE:
    case  DS_PDN_IOCTL_GET_SPLMN_RATE_CONTROL_INFO:
    case  DS_PDN_IOCTL_GET_APN_RATE_CONTROL_INFO:
    case  DS_PDN_IOCTL_SET_SILENT_REDIAL:
    { 
       if (-1 == ds_pdn_ioctli_mode_handler_cback (pdn_ptr_info,
                                                   ip_type,
                                                   ioctl_name,
                                                   argval_ptr,
                                                   ps_errno))
       {
         goto bail;
       }
       break;
    }
    default:
    {
      *ps_errno = DS_EOPNOTSUPP;
       goto bail;
    }
  } /* switch */

  /*-------------------------------------------------------------------------
    In success case, we break out of the switch. Please be aware of this
    if you are adding any code after the above switch statement.
  -------------------------------------------------------------------------*/
  return 0;

bail:
  DS_MSG_SPRINTF_1(MSG_LEGACY_ERROR,"ds_pdn_ioctl err %d", *ps_errno);
  return -1;

} /* ds_pdn_ioctl() */

