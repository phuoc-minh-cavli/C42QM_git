#ifndef __LOWI_RESPONSE_H__
#define __LOWI_RESPONSE_H__

/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

        LOWI Response Interface Header file

GENERAL DESCRIPTION
  This file contains the structure definitions and function prototypes for
  LOWIResponse

  Copyright (c) 2012, 2017 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
  
  Copyright (c) 2013 - 2014 Qualcomm Atheros, Inc.
  Qualcomm Atheros Confidential and Proprietary. All Rights Reserved. 


=============================================================================*/
#if APSS
#include <inc/lowi_const.h>
#include <inc/lowi_scan_measurement.h>
#else
#include "lowi_const.h"
#include "lowi_scan_measurement.h"
#endif

namespace qc_loc_fw
{

// Forward declaration
class LOWIRequest;

/**
 * Base class for Response
 */
class LOWIResponse
{
protected:
  static const char* const TAG;
private:
  uint32 requestId;
public:
  /** Type of Response*/
  enum eResponseType
  {
    RESPONSE_TYPE_UNKNOWN = 0,
    DISCOVERY_SCAN,
    RANGING_SCAN,
    CAPABILITY,
    RESET_CACHE,
    ASYNC_DISCOVERY_SCAN_RESULTS,
#if !APSS
    WLAN_EVENTS
#endif
  };

  /**
   * Defines status of the Scan Request.
   */
  enum eScanStatus
  {
    SCAN_STATUS_UNKNOWN = 0,
    /** Measurements were obtained successfully from the WLAN driver.
     * Note that SUCCESS does not guarantee that there is at least one
     * measurement in this packet. It is possible to have zero measurement
     * and a SUCCESS; if there are no APs in the vicinity.*/
    SCAN_STATUS_SUCCESS,
    /** Indicates that the number of pending clients have reached the maximum*/
    SCAN_STATUS_BUSY,
    /** Unable to initiate request to driver*/
    SCAN_STATUS_DRIVER_ERROR,
    /** Unable to get response from driver*/
    SCAN_STATUS_DRIVER_TIMEOUT,
    /** There is an internal error condition that causes
     * LOWI unable to provide any measurements*/
    SCAN_STATUS_INTERNAL_ERROR,
    /** Invalid request*/
    SCAN_STATUS_INVALID_REQ,
    /** Request not supported */
    SCAN_STATUS_NOT_SUPPORTED,
    /** Wifi not enabled. NOT AVAILABLE EXCEPT ON APSS */
    SCAN_STATUS_NO_WIFI,
    /** LOWI-LP Service error */
    SCAN_STATUS_LOWI_LP_SERVICE_ERROR
  };

  /**
   * Constructor
   * @param uint32 requestId generated by the client for request
   */
  LOWIResponse (uint32 requestId);
  /**
   * Destructor
   */
  virtual ~LOWIResponse () = 0;

  /**
   * Request id generated and provided in request by the client.
   * Echoed back in the response.
   * @return Corresponding Request id
   */
  uint32 getRequestId ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType () = 0;
};

/**
 * This class defines the Capabilities of the WifiDriver
 */
class LOWICapabilities
{
public:
  /** true if Discovery scan is supported*/
  bool discoveryScanSupported;

  /** true if Ranging scan is supported*/
  bool rangingScanSupported;

  /** true is Active scan is supported*/
  bool activeScanSupported;
  /** Highest bandwidth support for ranging requests from eRangingBandwidth*/
  uint8 bwSupport;
  /** Bit mask representing preambles supported for ranging requests from eRangingPreamble*/
  uint8 preambleSupport;
// The following bitmasks define the ranging capabilities supported by LOWI-LP
#define LOWI_ONE_SIDED_RANGING_MASK  0x0001 /**< One sided Ranging supported from LOWI-LP */
#define LOWI_TWO_SIDED_RANGING_MASK  0x0002 /**< FW supports supports two-sided ranging */
  /** Represents ranging capabilities supported by the loaded driver.
   Bit masks above are used. */
  uint32 supportedRangingCapablities;

public:
  /**
   * Constructor
   */
  LOWICapabilities ();
};

/**
 * Response to the Capability Request
 */
class LOWICapabilityResponse : public LOWIResponse
{
private:
  LOWICapabilities mCapabilities;
  bool             mStatus;
public:
  /**
   * Constructor
   * @param uint32 requestId generated by the client for request
   * @param LOWICapabilities Capabilities object
   * @param bool true for success, false to indicate failure
   */
  LOWICapabilityResponse (uint32 requestId, LOWICapabilities capabilities, bool status);
  /** Destructor*/
  virtual ~LOWICapabilityResponse ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType ();

  /**
   * Return the capabilities
   * @return LOWICapabilities
   */
  LOWICapabilities getCapabilities ();

  /**
   * Returns the status of the Request
   * @return bool true for success, false otherwise
   */
  bool getStatus ();

};

/**
 * Response to the Cache reset Request
 */
class LOWICacheResetResponse : public LOWIResponse
{
private:
  bool mCacheResetStatus;
public:
  /**
   * Constructor
   * @param uint32 requestId generated by the client for request
   * @param bool true for success, false to indicate failure
   */
  LOWICacheResetResponse (uint32 requestId, bool status);
  /** Destructor*/
  virtual ~LOWICacheResetResponse ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType ();

  /**
   * Returns the status of the Request
   * @return bool true for success, false otherwise
   */
  bool getStatus ();
};

/**
 * Response to the Discovery Scan Request
 */
class LOWIDiscoveryScanResponse : public LOWIResponse
{
public:
  /** Response type*/
  enum eScanTypeResponse
  {
    WLAN_SCAN_TYPE_UNKNOWN = 0,
    WLAN_SCAN_TYPE_PASSIVE, // Passive scan only
    WLAN_SCAN_TYPE_ACTIVE,  // Active scan, Passive scan on DFS channels
    WLAN_SCAN_TYPE_ACTIVE_ONLY // Pure active scan only. No channels scanned restricted by DFS */
  };

  /** This may be different than the requested ScanType,
   * since user may request active scan, but if there’s an ongoing
   * passive scan results, LOWI may give back those results.*/
  eScanTypeResponse       scanTypeResponse;
  /** Status of the scan */
  eScanStatus             scanStatus;
  /** Time at the end of scan – should be equal to the timestamp of the
   * latest measurement in this packet. If there are zero measurements,
   * timestamp is the time when the response from the driver is received.
   * In msec, since January 1, 1970 UTC
   */
  uint64                   timestamp;
  /** Dynamic array containing received ScanMeasurement*/
  vector <LOWIScanMeasurement*> scanMeasurements;
  /** Dynamic array containing the scanned frequencies */
  vector <LOWIChannelInfo>      scannedFreq;

  /**
   * Constructor
   * @param uint32 Corresponding Request Id generated by the client for request
   */
  LOWIDiscoveryScanResponse (uint32 requestId);
  /** Destructor*/
  virtual ~LOWIDiscoveryScanResponse ();

  /**
   * Returns the response type
   * @return eResponseType type of Response
   */
  virtual eResponseType getResponseType ();
};

/**
 * Response to the Ranging scan Request
 */
class LOWIRangingScanResponse: public LOWIResponse
{
public:
  /** Status of the scan */
  eScanStatus             scanStatus;
  /** Dynamic array containing received ScanMeasurement*/
  vector <LOWIScanMeasurement*> scanMeasurements;

  /**
   * Constructor
   * @param uint32 Request Id generated by the client for Request
   */
  LOWIRangingScanResponse (uint32 requestId);
  /** Destructor*/
  virtual ~LOWIRangingScanResponse ();

  /**
   * Returns the response type
   * @return eResponseType type of Response
   */
  virtual eResponseType getResponseType ();
};

class LOWIAsyncDiscoveryScanResultResponse :
  public LOWIDiscoveryScanResponse
{
public:
    /**
     * Constructor
     * @param uint32 Corresponding Request Id generated
     *               by the client for request
     */
    LOWIAsyncDiscoveryScanResultResponse (uint32 requestId);
    /** Destructor*/
    virtual ~LOWIAsyncDiscoveryScanResultResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();
};

#if !APSS
class LOWIWlanEventResponse : public LOWIResponse
{
private:
public:
  // Bitmask for the type of events
  #define WLAN_CONNECTION_EVENT_MASK 0x00000002
  #define WLAN_HANDOFF_EVENT_MASK 0x00000004

  /** The Event/s that caused the response to be generated.
    * It could be a number of events including
    * Connection or handoff etc. Client should use the bitmasks
    * WLAN_CONNECTION_EVENT_MASK,
    * WLAN_HANDOFF_EVENT_MASK to determine the event/s and then
    * use the relevant fields below accordingly.
    * i.e. For a status query request, the handoff will probably
    * not be valid as a specific event would rather trigger it.
    *
    * In case of an event response, all the types of events may come.
    * i.e. If client gets a connected / handoff event, they should
    * parse the data in Bssid, Freq, SSID etc..
    */
  uint64 wlanEvent;

  /**
   * Returns the WLAN connection status CONNECTED / DISCONNECTED
   * true for Connected, false for DISCONNECTED
   */
  bool connected;

  /**
   * Returns the WLAN hadoff status happened or not
   * true for Happened, false for Not
   */
  bool handoff;

  /**
   * Returns the BSSID of the connected Node.
   * LOWIMacAddress BSSID of the connected Node
   */
  LOWIMacAddress connectedNodeBssid;

  /**
   * Returns the freq of the connected Node.
   * Frequency of the connected Node
   */
  uint32 connectedNodeFreq;

  /**
   * Connected node RSSI in dBm
   */
  int16 connectedNodeRssi;

  /**
   * Returns the SSID of the connected Node.
   * LOWISsid SSID of the connected Node
   */
  LOWISsid connectedNodeSsid;

  /**
   * Returns the BSSID of the Handoff Node.
   * LOWIMacAddress BSSID of the handoff Node
   */
  LOWIMacAddress handoffNodeBssid;

  /**
   * Returns the freq of the Handoff Node.
   * Frequency of the handoff Node
   */
  uint32 handoffNodeFreq;

  /**
   * Handoff node RSSI in dBm
   */
  int16 handoffNodeRssi;

  /**
   * Returns the SSID of the Handoff Node.
   * LOWISsid SSID of the handoff Node
   */
  LOWISsid handoffNodeSsid;

  /**
   * Constructor
   * @param uint32 requestId generated by the client of the request.
   */
  LOWIWlanEventResponse (uint32 requestId);

    /** Destructor*/
    virtual ~LOWIWlanEventResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();
};

#endif

} // namespace qc_loc_fw

#endif //#ifndef __LOWI_RESPONSE_H__
