#ifndef MCFG_DIAG_I_H
#define MCFG_DIAG_I_H

/*==========================================================================

                   Diagnostic Packet Definitions for MCFG

  Description: Definitions of MCFG packets. These define the diagnostic
  interface between MCFG and the external device.

Copyright (c) 2012 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
===========================================================================*/

/*===========================================================================

                            Edit History

  $Header: //components/rel/mcfg_fwk.mpss/7.10.1.1/mcfg_diag/src/mcfg_diag_i.h#2 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
03/25/15   sbt     created
===========================================================================*/

#include "comdef.h"
#include "diagcmd.h"
#include "diagpkt.h"
#include "fs_lib.h"

/* -------------------------------------------------------------------------
 * Definitions of MCFG diagnostic packets.
 * ------------------------------------------------------------------------- */

#ifdef FEATURE_MCFG_DIAG_SUPPORT

#ifdef FEATURE_MCFG_DIAG_SUPPORT_EXTENDED
PACKED void * PACKED_POST
mcfg_fs_diag_efs2_error_rsp (int32, PACKED void * PACKED_POST, uint16);

/*
 * Permitted operations.
 */
#define MCFG_FS_DIAG_STAT     1 /* Obtain information about a named file      */
#define MCFG_FS_DIAG_PUT      2 /* Write a EFS item file in order*/
#define MCFG_FS_DIAG_GET      3 /* Read a EFS item file in order */
#define MCFG_FS_DIAG_ERR      4 /* Send an EFS Error Packet back through DIAG */

/*
 * Any error codes in fs_errno.h can be returned by the MCFG Diag interface.
 * In addition, these additional diag-specific values are possible:
 *
 * Error codes generated by the MCFG Diag interface. Note that we use values
 * about 0x40000000 to avoid clashing with the errno values used by EFS2.
 */
#define MCFG_FS_DIAG_INCONSISTENT_STATE  0x40000001
#define MCFG_FS_DIAG_INVALID_SEQ_NO      0x40000002
#define MCFG_FS_DIAG_DIR_NOT_OPEN        0x40000003
#define MCFG_FS_DIAG_DIRENT_NOT_FOUND    0x40000004
#define MCFG_FS_DIAG_INVALID_PATH        0x40000005
#define MCFG_FS_DIAG_PATH_TOO_LONG       0x40000006
#define MCFG_FS_DIAG_TOO_MANY_OPEN_DIRS  0x40000007
#define MCFG_FS_DIAG_INVALID_DIR_ENTRY   0x40000008
#define MCFG_FS_DIAG_TOO_MANY_OPEN_FILES 0x40000009
#define MCFG_FS_DIAG_UNKNOWN_FILETYPE    0x4000000a
#define MCFG_FS_DIAG_NOT_NAND_FLASH      0x4000000b
#define MCFG_FS_DIAG_UNAVAILABLE_INFO    0x4000000c

/* File types.
 */
#define MCFG_FS_DIAG_FTYPE_REG     0x00   /* Regular file                        */
#define MCFG_FS_DIAG_FTYPE_DIR     0x01   /* Directory                           */
#define MCFG_FS_DIAG_FTYPE_LINK    0x02   /* Symbolic link                       */
#define MCFG_FS_DIAG_FTYPE_IMVBL   0x03   /* Immovable file                      */
#define MCFG_FS_DIAG_FTYPE_UNKNOWN 0x0f   /* Unknown file type                   */

/*
 * Default window sizes. Set to large numbers because the target can support
 * essentially unlimited windowing without doing any extra work.
 */
#define MCFG_FS_TARG_PKT_WINDOW_DEFAULT  0x100000
#define MCFG_FS_TARG_BYTE_WINDOW_DEFAULT 0x100000
#define MCFG_FS_HOST_PKT_WINDOW_DEFAULT  0x100000
#define MCFG_FS_HOST_BYTE_WINDOW_DEFAULT 0x100000
#define MCFG_FS_ITER_PKT_WINDOW_DEFAULT  0x100000
#define MCFG_FS_ITER_BYTE_WINDOW_DEFAULT 0x100000

/*
 * Protocol version information.
 */
#define MCFG_FS_DIAG_VERSION     0x0001
#define MCFG_FS_DIAG_MIN_VERSION 0x0001
#define MCFG_FS_DIAG_MAX_VERSION 0x0001

/*
 * Feature Bits.
 */
#define MCFG_FS_FEATURE_BITS 0x00000000

/* Maximum size of a read request. */
#define MCFG_FS_DIAG_MAX_READ_REQ    1024

/* -------------------------------------------------------------------------
 * PACKET STRUCTURES
 *
 * General Note: Fields after the errno field in the response packet may not
 * exist if the errno value is not equal to zero. A non-zero errno value
 * indicates that an error occurred during the processing of the request.
 * If errno == 0, all fields exist. If errno != 0, errno is the last field
 * in the response packet that can be relied upon to exist.
 *
 * ------------------------------------------------------------------------- */

/*
 * Stat Packet
 *
 * Used to retrieve information about a named file or directory.
 */
typedef PACKED struct PACKED_POST {
  diagpkt_subsys_header_type hdr;
  uint32 fs_type;
  uint32 sub_id;
  char path[1];         /* Pathname (null-terminated string)               */
} mcfg_fs_diag_stat_req_type;

typedef PACKED struct PACKED_POST {
  diagpkt_subsys_header_type hdr;
  int32 diag_errno;        /* Error code if error, 0 otherwise             */
  int32 mode;              /* File mode                                    */
  int32 size;              /* File size in bytes                           */
  int32 nlink;             /* Number of links                              */
  int32 atime;             /* Time of last access                          */
  int32 mtime;             /* Time of last modification                    */
  int32 ctime;             /* Time of last status change                   */
} mcfg_fs_diag_stat_rsp_type;


/*
 * Get File Packet
 *
 * Used to read the contents of a named file. Note that the response packet
 * does not explicitly contain the number of bytes read, since this can be
 * computed from the packet size. The number of bytes actually read may be
 * less than the number specified in the request packet if EOF is encountered
 * (this is not an error).
 *
 */
typedef PACKED struct PACKED_POST {
  diagpkt_subsys_header_type hdr;
  uint32 data_length;      /* Number of bytes to read                      */
  uint32 path_length;      /* Length of the path name (ignored)            */
  uint16 sequence_number;  /* Number for Synchronization / Correlation     */
  uint32 fs_type;
  uint32 sub_id;
  char path[1];            /* Pathname (null-terminated string)            */
} mcfg_fs_diag_get_req_type;

typedef PACKED struct PACKED_POST {
  diagpkt_subsys_header_type hdr;
  int32  diag_errno;       /* Error code if error, 0 otherwise             */
  uint16 sequence_number;  /* Acknowledge Synchronization / Correlation num */
  char   data[1];          /* The data read out                            */
} mcfg_fs_diag_get_rsp_type;

/*
 * Put File Packet
 *
 * Used to write data into an item file. Unless an error occurs, all the
 * bytes specified in the data field of the request packet are written to
 * the file. If there is an error, the error field will be non-zero.
 *
 */
typedef PACKED struct PACKED_POST {
  diagpkt_subsys_header_type hdr;
  uint32 data_length;      /* Length of the data packet                    */
  uint32 flags;            /* Options for creating the item                */
  uint16 sequence_number;  /* Number for Synchronization / Correlation     */
  uint32 fs_type;
  uint32 sub_id;
  char  data[1];           /* The data to be written                       */
  char  path[1];           /* Pathname (null-terminated string)            */
} mcfg_fs_diag_put_req_type;

typedef PACKED struct PACKED_POST {
  diagpkt_subsys_header_type hdr;
  int32 diag_errno;        /* Error code if error, 0 otherwise             */
  uint16 sequence_number;  /* Acknowledge Synchronization / Correlation num */
} mcfg_fs_diag_put_rsp_type;


/*
 * MCFG FS Diag Error Packet
 *
 * To provide for better error handling response, this generic packet should
 * be returned in the case where MCFG errors will occur, but can not be
 * passed back in the normal response packets of the handlers.
 *
 */

typedef PACKED struct PACKED_POST {
  diagpkt_subsys_header_type hdr;
  int32 diag_errno;        /* Error code to be handled */
  byte pkt[32];
} mcfg_fs_diag_error_rsp_type;

#endif /* FEATURE_MCFG_DIAG_SUPPORT_EXTENDED */
#endif /* FEATURE_MCFG_DIAG_SUPPORT */

#endif /* MCFG_DIAG_I_H */

