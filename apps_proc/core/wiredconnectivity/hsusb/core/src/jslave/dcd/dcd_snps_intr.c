/*
===========================================================================

FILE:         dcd_snps_intr.c

DESCRIPTION: This file handles interrupts generated by the SNPS USB3.0 core. 

$Header: //components/rel/core.tx/6.0/wiredconnectivity/hsusb/core/src/jslave/dcd/dcd_snps_intr.c#1 $

===========================================================================

===========================================================================
Copyright © 2010 Qualcomm Technologies Incorporated.
All Rights Reserved.
QUALCOMM Proprietary
===========================================================================
*/

/*==============================================================================
Include files
=============================================================================*/

#include "dcd_snps.h"
#include "hsu_common_int.h"
#include <jusb_common_int.h>
#include "jos_int.h"
#include "hsu_al_task.h"
#include "hsu_os_abstract_bus.h"
#include "hsu_lpm_snps.h"
#include "hsu_platform.h"

/*==============================================================================
Internal Function Definitions
==============================================================================*/

/*================================ Handle Events ==============================*/


#define SNPS_DCD_LPM_ENTRY 0x4
#define SNPS_DCD_LPM_EXIT  0x8


/**
* Function name:  snps_dcd_handle_connect
* Description: Handle a CONNECT event received from the controller
* Parameters:
*     @sc: (IN) The DCD SW context
*
* Return value: 0 on success, otherwise an error code
* Scope: local
**/
static jresult_t snps_dcd_handle_connect(snps_dcd_soft_dc_t *sc)
{
  static const device_speed_t hw2soft_speed[] =
    {SPEED_HIGH, SPEED_FULL, SPEED_LOW, SPEED_FULL, SPEED_SUPER};
  juint32_t DCTL;
  snps_dcd_ep_desc_t* ep0_out = &sc->ep_desc_table[SNPS_DCD_EP0_OUT_ADDR];
  snps_dcd_ep_desc_t* ep0_in = &sc->ep_desc_table[SNPS_DCD_EP0_IN_ADDR];
  jresult_t rc = HSU_JSUCCESS;
  juint32_t connectSpd;

  /* Handle CONNECT only if controller state is not connected */
  if (sc->conn_status >= SNPS_DCD_STATE_CONNECTED)
  {
    DBG_W(DSLAVE_DCD, ("snps_dcd_handle_connect: already connected\n"));
    return HSU_JSUCCESS;
  }

  /* Read connection speed, and store it */
  connectSpd = (HWIO_DSTS_INM(HWIO_DSTS_CONNECTSPD_BMSK)
    >> HWIO_DSTS_CONNECTSPD_SHFT);
  
  if (connectSpd >= sizeof(hw2soft_speed) / sizeof(device_speed_t))
  {
    sc->speed = SPEED_UNKNOWN;
    HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, connection_speed_unknown");    
    return EUNKNOWN;
  }
  sc->speed = hw2soft_speed[connectSpd];
  HSU_ULOG_1(NO_MSG, SNPS_LOG, "connection_speed %u", sc->speed);

  HSU_ULOG_ENUM(NO_MSG, BUS_LOG, "snps_dcd_handle_connect", sc->speed, HSU_SPEED_OFFSET2);
  /* RAM Clock Select to bus clock */
  HWIO_GCTL_OUTM(HWIO_GCTL_RAMCLKSEL_BMSK, (0x0 >> HWIO_GCTL_RAMCLKSEL_SHFT));

  if (sc->speed == SPEED_SUPER)
  {
    /* Enable Suspend for USB2.0 PHY */
    hsu_lpm_snps_set_hs_phy_suspend_L2_transition(TRUE);

    /* Disable Suspend for USB3.0 PHY */
    //hsu_lpm_snps_set_ss_phy_suspend_P3_transition(FALSE);

    DCTL = HWIO_DCTL_IN;
#ifdef FEATURE_HS_USB_SNPS_ENABLE_U1U2
    /* Accept U1 and U2 */
    DCTL = HSU_VAR_OUTM(DCTL, TRUE, HWIO_DCTL_INITU1ENA_BMSK, HWIO_DCTL_INITU1ENA_SHFT);
    DCTL = HSU_VAR_OUTM(DCTL, TRUE, HWIO_DCTL_INITU2ENA_BMSK, HWIO_DCTL_INITU2ENA_SHFT);
#else
    /* Do not accept U1 and U2 */
    DCTL = HSU_VAR_OUTM(DCTL, FALSE, HWIO_DCTL_INITU1ENA_BMSK, HWIO_DCTL_INITU1ENA_SHFT);
    DCTL = HSU_VAR_OUTM(DCTL, FALSE, HWIO_DCTL_INITU2ENA_BMSK, HWIO_DCTL_INITU2ENA_SHFT);
#endif /* FEATURE_HS_USB_SNPS_ENABLE_U1U2 */
    HWIO_DCTL_OUT(DCTL);

  }
  else
  {
    /* Disable Suspend for USB2.0 PHY */
    hsu_lpm_snps_set_hs_phy_suspend_L2_transition(FALSE);

    /* Enable Suspend for USB3.0 PHY */
    //hsu_lpm_snps_set_ss_phy_suspend_P3_transition(TRUE);
  }

  /* Update packet size EP parameter according to speed */
  ep0_out->packet_size = core_get_max_packet_size(PIPE_CONTROL, sc->speed);
  ep0_in->packet_size = core_get_max_packet_size(PIPE_CONTROL, sc->speed);

  rc = snps_dcd_config_ep_cfg(ep0_out, TRUE, TRUE);
  if (rc != HSU_JSUCCESS)
  {
    HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, snps_dcd_config_ep_cfg_OUT_EP_failed");    
    return rc;
  }

  rc = snps_dcd_config_ep_cfg(ep0_in, TRUE, TRUE);
  if (rc != HSU_JSUCCESS)
  {
    HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, snps_dcd_config_ep_cfg_IN_EP_failed");        
    return rc;
  }

  /* Connect notification to the CORE layer. */
  if (sc->events)
  {
    if (sc->events->core_connect)
    {
      sc->events->core_connect(sc->core_ctx, sc->speed);
    }
  }

  sc->conn_status = SNPS_DCD_STATE_CONNECTED;

  return HSU_JSUCCESS;
}

/**
* Function name:  snps_dcd_handle_disconnect
* Description: Handle a DISCONNECT event received from the controller
* Parameters:
*     @sc: (IN) The DCD SW context
*
* Return value: 0 on success, otherwise an error code
* Scope: local
**/
static jresult_t snps_dcd_handle_disconnect(snps_dcd_soft_dc_t *sc)
{
  jresult_t rc = HSU_JSUCCESS;
  uint32 i;
  juint32_t DCTL;
  hsu_platform_info_type const * platform_info = hsu_platform_get_info();

  /* Handle DISCONNECT only if controller is connected */
  if (sc->conn_status <= SNPS_DCD_STATE_ENABLED)
  {
    HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, already_disconnected");        
    return HSU_JSUCCESS;
  }

  // Disallow enumeration immediately until state machine is finished with all the transitions
  // TODO this should only be done when state machine is active (ECM)
  core_disallow_enumeration(((core_t *)(sc->core_ctx))->core_number);

  sc->conn_status = SNPS_DCD_STATE_ENABLED;
  sc->speed       = SPEED_UNKNOWN;

  /* Disconnect notification to the CORE layer. */
  if (sc->events)
  {
    if (sc->events->core_disconnect)
    {
      sc->events->core_disconnect(sc->core_ctx);
    }
  }

  /* Clear stall indication from all endpoints except the default endpoints*/
  for (i=2; i < sc->max_available_eps; i++)
  {
    snps_dcd_ep_desc_t* ep = &sc->ep_desc_table[i];
    rc = snps_dcd_stall_ep(ep, FALSE);
  }

  /* Do not accept U1 and U2 */
  DCTL = HWIO_DCTL_IN;
  DCTL = HSU_VAR_OUTM(DCTL, FALSE, HWIO_DCTL_ACCEPTU1ENA_BMSK, HWIO_DCTL_ACCEPTU1ENA_SHFT);
  DCTL = HSU_VAR_OUTM(DCTL, FALSE, HWIO_DCTL_ACCEPTU2ENA_BMSK, HWIO_DCTL_ACCEPTU2ENA_SHFT);
  HWIO_DCTL_OUT(DCTL);
  
  /* Set device address to default */
  HWIO_DCFG_OUTM(HWIO_DCFG_DEVADDR_BMSK, (0x0 << HWIO_DCFG_DEVADDR_SHFT));

  /* Clear Suspend for USB2.0 PHY */
  hsu_lpm_snps_set_hs_phy_suspend_L2_transition(FALSE);

  /* Clear Suspend for USB3.0 PHY */
  //hsu_lpm_snps_set_ss_phy_suspend_P3_transition(FALSE);
  
  HWIO_HS_PHY_CTRL_OUTM(HWIO_HS_PHY_CTRL_UTMI_OTG_VBUS_VALID_BMSK, (0x0 << HWIO_HS_PHY_CTRL_UTMI_OTG_VBUS_VALID_SHFT));
  HWIO_HS_PHY_CTRL_OUTM(HWIO_HS_PHY_CTRL_SW_SESSVLD_SEL_BMSK, (0x0 << HWIO_HS_PHY_CTRL_SW_SESSVLD_SEL_SHFT));

#if 0
  switch (platform_info->hsu_platform_id)
  {
    case HSU_PLATFORM_VIRTIO:
    case HSU_PLATFORM_RUMI:
    break;
    default:
    {
      HWIO_SS_PHY_CTRL_OUTM(HWIO_SS_PHY_CTRL_LANE0_PWR_PRESENT_BMSK, (0x0 << HWIO_SS_PHY_CTRL_LANE0_PWR_PRESENT_SHFT));
    }
    break;
  }
#endif
  /* Stop controller */
  HWIO_DCTL_OUTM(HWIO_DCTL_RUN_STOP_BMSK, (0x0 << HWIO_DCTL_RUN_STOP_SHFT));

  return rc;
}

/**
* Function name:  snps_dcd_handle_reset
* Description: Handle a RESET event received from the controller
* Parameters:
*     @sc: (IN) The DCD SW context
*
* Return value: 0 on success, otherwise an error code
* Scope: local
**/
static jresult_t snps_dcd_handle_reset(snps_dcd_soft_dc_t *sc)
{
  juint32_t DCTL;
  jresult_t rc = HSU_JSUCCESS;
  uint32 i;
  core_t *core = (core_t *)sc->core_ctx;

  /* Handle DISCONNECT only if controller is connected */
  if (sc->conn_status <= SNPS_DCD_STATE_ENABLED)
  {
    HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, not_connected, exiting_API");      
    return HSU_JSUCCESS;
  }

  // Reset all the function suspend related states for all interfaces
  for (i = 0; i < core->configs->interface_count; i++)
  {
    core->configs->interfaces[i].function_remote_wake_enable = FALSE;
    core->configs->interfaces[i].function_remote_wake_requested = FALSE;
    core->configs->interfaces[i].function_remote_wake_tnotifification_pending = FALSE;
    core->configs->interfaces[i].is_function_suspend = FALSE;   
    //core->configs->interfaces[i].function_pipe_queue = FALSE;
  }

  sc->conn_status = SNPS_DCD_STATE_ENABLED;
  sc->speed       = SPEED_UNKNOWN;

  /* Disconnect notification to the CORE layer. */
  if (sc->events)
  {
    if (sc->events->core_disconnect)
    {
      sc->events->core_disconnect(sc->core_ctx);
    }
  }

  /* Clear stall indication from all endpoints except the default endpoints*/
  for (i=2; i < sc->max_available_eps; i++)
  {
    snps_dcd_ep_desc_t* ep = &sc->ep_desc_table[i];
    rc = snps_dcd_stall_ep(ep, FALSE);
  }

  /* Clear Suspend for USB2.0 PHY */
  hsu_lpm_snps_set_hs_phy_suspend_L2_transition(FALSE);

  /* Clear Suspend for USB3.0 PHY */
  //hsu_lpm_snps_set_ss_phy_suspend_P3_transition(FALSE);

  /* Do not accept U1 and U2 */
  DCTL = HWIO_DCTL_IN;
  DCTL = HSU_VAR_OUTM(DCTL, FALSE, HWIO_DCTL_ACCEPTU1ENA_BMSK, HWIO_DCTL_ACCEPTU1ENA_SHFT);
  DCTL = HSU_VAR_OUTM(DCTL, FALSE, HWIO_DCTL_ACCEPTU2ENA_BMSK, HWIO_DCTL_ACCEPTU2ENA_SHFT);
  HWIO_DCTL_OUT(DCTL);
  
  /* Set device address to default */
  HWIO_DCFG_OUTM(HWIO_DCFG_DEVADDR_BMSK, (0x0 << HWIO_DCFG_DEVADDR_SHFT));

  return rc;
}

/**
* Function name:  snps_dcd_handle_suspend
* Description: Handle SNPS_DCD_LINK_STATE_SUSPEND_U3 event received from the 
               controller
* Parameters:
*     @sc: (IN) The DCD SW context
*
* Return value: 0 on success, otherwise an error code
* Scope: local
**/
static jresult_t snps_dcd_handle_suspend(snps_dcd_soft_dc_t *sc)
{
  jresult_t rc = HSU_JSUCCESS;

  /* Handle SUSPEND only if controller is connected */
  if (sc->conn_status <= SNPS_DCD_STATE_ENABLED)
  {
    HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, not_connected");     
    return HSU_JSUCCESS;
  }

  // Required for function remote wake
  snps_dcd_set_usb_link_state_change_event_enable(TRUE);

  if (sc->events->core_suspend)
  {
    sc->events->core_suspend(sc->core_ctx);
  }

  return rc;
}

/**
* Function name:  snps_dcd_handle_resume
* Description: Handle SNPS_DCD_DEVT_WKUPEVTEN event received from the controller
* Parameters:
*     @sc: (IN) The DCD SW context
*
* Return value: 0 on success, otherwise an error code
* Scope: local
**/
jresult_t snps_dcd_handle_resume(snps_dcd_soft_dc_t *sc)
{
  jresult_t rc = HSU_JSUCCESS;

  /* Handle RESUME only if controller is connected */
  if (sc->conn_status <= SNPS_DCD_STATE_ENABLED)
  {
    HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, not_connected");         
    return HSU_JSUCCESS;
  }

  if (sc->events->core_resume)
  {
    sc->events->core_resume(sc->core_ctx);
  }

  return rc;
}

/**
* Function name:  snps_dcd_handle_ep_event
* Description: Handle all EP events 
* Parameters:
*     @sc: (IN) The DCD SW context
*     @hw_address: (IN) The EP HW address
*     @event_type: (IN) Type of event to handle
*     @event_status: (IN) Status of event 
*     @event_params: (IN) Additional parameter for the event 
*
* Return value: 0 on success, otherwise an error code
* Scope: local
**/
static jresult_t snps_dcd_handle_ep_event(snps_dcd_soft_dc_t *sc, juint8_t hw_address, 
                                          juint8_t event_type, juint8_t event_status, juint16_t event_params)
{
  snps_dcd_ep_desc_t* ep = &sc->ep_desc_table[hw_address];
  juint16_t stream_id = event_params;

  switch (event_type)
  {
  case SNPS_DCD_DEPVT_XFER_COMPLETE:
    if (ep->hw_addr == 0x3)
    {
       HSU_ULOG_2(NO_MSG, DBG_E_LOG, "DIAG: XFER_COMPLETE, EP 0x%X, stream_id %u", ep->hw_addr, stream_id);
    }
    HSU_ULOG_2(NO_MSG, SNPS_LOG, "XFER_COMPLETE, EP 0x%X, stream_id %u", ep->hw_addr, stream_id);

    if(ep->streams == NULL)
    {
        // This can happen if we get disconnect notification (we do abort EP)
        // while HW has completed a read and is generating a Xfer event
        HSU_ULOG_1(ERROR_MSG, DBG_E_LOG, "Ignore event as EP 0x%X is already unconfigured", ep->hw_addr);
        return HSU_JSUCCESS;
    }

    HSU_CHK_EP_STREAM_ID(ep, stream_id);
    ep->streams[stream_id].xfer_rsc_idx = 0;
    snps_dcd_handle_xfer_completion(ep, stream_id);
    break;
#if 0	
//#ifndef FEATURE_HS_USB_PRE_SILICON_BU  
  case SNPS_DCD_DEPVT_FIFO_UNDERRUN_OVERRUN:
    HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, fifo_UNDERRUN_OVERRUN");     
    snps_dcd_handle_fifo_overrun_underrun(ep, stream_id);
    break;
    //9x35VBU
#endif    
  case SNPS_DCD_DEPVT_XFER_INPROGRESS:
    HSU_ULOG_1(NO_MSG, SNPS_LOG, "XFER_INPROGRESS, EP 0x%X", ep->hw_addr);

	if(ep->streams == NULL)
    {
        // This can happen if we get disconnect notification (we do abort EP)
        // while HW has completed a read and is generating a Xfer event
        HSU_ULOG_1(ERROR_MSG, DBG_E_LOG, "Ignore event as EP 0x%X is already unconfigured", ep->hw_addr);
        return HSU_JSUCCESS;
    }

    ep->xfer_in_progress = 1;

    if (PIPE_ISOC == HSU_GET_PIPE_TYPE(ep))
    {
      //abort the transfers, if we miss the interval during a transfer
      if(event_status & SNPS_DCD_DEPVT_ISOC_MISSED_INTRVL_MASK)
      {
        ep->xfer_nrdy_elapsed = TRUE;
        ep->xfer_in_progress = 0;
        hsu_event_log(EVT_MISSED_ISOC_INTERVAL, ((core_t*)(ep->sc->core_ctx))->core_number);
      }    
    }
    snps_dcd_handle_timeout(ep); 
    break;

  case SNPS_DCD_DEPVT_XFER_NOTREADY:
    HSU_ULOG_1(NO_MSG, SNPS_LOG, "XFER_NOTREADY, EP 0x%X", ep->hw_addr);
    if(ep->soft_addr == 0)
    {
      snps_dcd_ctrl_sm_notify(ep, 0, SNPS_CTRL_EVT_XFER_NOTREADY);
    }
    else if (PIPE_ISOC == HSU_GET_PIPE_TYPE(ep))
    {
      if (ep->streams[SNPS_DCD_DEFAULT_STREAM].cur_req == NULL)
      {
        DBG_V(DSLAVE_DCD, ("snps_dcd_handle_ep_event: ISOC Request is not queued during xfer_nrdy event"));
        ep->xfer_nrdy_elapsed = TRUE;
      }
      else
      {
        snps_dcd_submit_isoc_request(ep, event_params, TRUE);
      }  
    }    
    break;
  case SNPS_DCD_DEPVT_STREAM:
    HSU_ULOG_2(NO_MSG, SNPS_LOG, "STREAM, EP 0x%X, stream_id %u", ep->hw_addr, stream_id);
    break;
  case SNPS_DCD_DEPVT_EP_CMD_COMPLETE:
    if (PIPE_ISOC == HSU_GET_PIPE_TYPE(ep))
    {
      /*Abort the xfer, if we missed an interval by the time xfer command is queued to the HW. SNPS spec Sec 8.3.5 (step 4) */
      if(event_status & SNPS_BUS_TIME_EXPIRY_BMSK)
      {
        //Only do "End transfer" on the EP but retain the request for requeue
        if (HSU_JSUCCESS != snps_dcd_abort_xfer(ep))
        {
          HSU_ULOG(ERROR_MSG, DBG_E_LOG, "DCD, abort_xfer_failed_for_ISOC");
        }
        
        ep->xfer_in_progress = 0;
        ep->xfer_nrdy_elapsed = TRUE;
      }
      HSU_ULOG(NO_MSG, SNPS_LOG, "EP_CMD_COMPLETE");
    }
    else
    {
      switch ((event_params & SNPS_DCD_DEPVT_EP_CMD_COMPLETE__COMMAND_TYPE_BMSK) >> SNPS_DCD_DEPVT_EP_CMD_COMPLETE__COMMAND_TYPE_SHFT)
      {
        case SNPS_DCD_DEPCMD_CMDTYPE_SETEPXFERRES:
        {
          // Print:
          HSU_ULOG_2(NO_MSG, SNPS_LOG, "EP_CMD_COMPLETE, set_xfer_res, no_xfer_rsc %u, EP 0x%X",
            (event_status & SNPS_NO_XFER_RESOURCE_AVAIL_BMSK) >> SNPS_NO_XFER_RESOURCE_AVAIL_SHFT,
            ep->hw_addr
            );
        }
        break;

        case SNPS_DCD_DEPCMD_CMDTYPE_STARTTRANSFER:
        {
          // Print:
          //   CMD TYPE
          //   XFER_RSC_IDX
          //   BUS TIME EXPIRY
          //   ERROR on invalid transfer index if applicable 
          HSU_ULOG_4(NO_MSG, SNPS_LOG, "EP_CMD_COMPLETE, start_transfer, xfer_rsc %u, bus_time_exp %u, no_xfer_rsc %u, EP 0x%X",
            (event_params & SNPS_DCD_DEPVT_EP_CMD_COMPLETE__XFER_RSC_IDX_BMSK) >> SNPS_DCD_DEPVT_EP_CMD_COMPLETE__XFER_RSC_IDX_SHFT,
            (event_status & SNPS_BUS_TIME_EXPIRY_BMSK) >> SNPS_BUS_TIME_EXPIRY_SHFT,
            (event_status & SNPS_NO_XFER_RESOURCE_AVAIL_BMSK) >> SNPS_NO_XFER_RESOURCE_AVAIL_SHFT,
            ep->hw_addr
            );
        }
        break;

        case SNPS_DCD_DEPCMD_CMDTYPE_ENDTRANSFER:
        {
          // Print:
          //  ERROR if invalid transfer resource was specified
          //  
          HSU_ULOG_3(NO_MSG, SNPS_LOG, "EP_CMD_COMPLETE, end_xfer, dma_stopped %u, invalid_xfer_rsc %u, EP 0x%X",
//            ((SNPS_DCD_DEPVT_EP_CMD_COMPLETE__DMA_STOPPED_VAL) == ((event_type & SNPS_DCD_DEPVT_EP_CMD_COMPLETE__DMA_STOPPED_BMSK) >> SNPS_DCD_DEPVT_EP_CMD_COMPLETE__DMA_STOPPED_SHFT)),
            ((event_type & SNPS_DCD_DEPVT_EP_CMD_COMPLETE__DMA_STOPPED_BMSK) >> SNPS_DCD_DEPVT_EP_CMD_COMPLETE__DMA_STOPPED_SHFT), // non-zero means DMA stopped
            (event_status & SNPS_NO_XFER_RESOURCE_AVAIL_BMSK) >> SNPS_NO_XFER_RESOURCE_AVAIL_SHFT,
            ep->hw_addr
            );
        }
        break;

        case SNPS_DCD_DEPCMD_CMDTYPE_SETEPCONF:            
        case SNPS_DCD_DEPCMD_CMDTYPE_SETSTALL:
        case SNPS_DCD_DEPCMD_CMDTYPE_CLEARSTALL:
        case SNPS_DCD_DEPCMD_CMDTYPE_UPDATETRANSFER:
        case SNPS_DCD_DEPCMD_CMDTYPE_STARTNEWCFG:
        default:
        {
          HSU_ULOG_1(NO_MSG, SNPS_LOG, "EP_CMD_COMPLETE, EP 0x%X", ep->hw_addr);
        }
        break;
      }
    }
    break;
  default:
    HSU_ULOG_2(ERROR_MSG, DBG_E_LOG, "DCD, unknown_event %d, EP 0x%X", event_type, hw_address);
    break;
  }

  return HSU_JSUCCESS;
}

/**
* Function name:  snps_dcd_handle_device_event
* Description: Handle all DEVICE events 
* Parameters:
*     @sc: (IN) The DCD SW context
*     @event_type: (IN) Type of event to handle
*     @event_info: (IN) Additional parameter for the event 
*
* Return value: 0 on success, otherwise an error code
* Scope: local
**/
static jresult_t snps_dcd_handle_device_event(snps_dcd_soft_dc_t *sc, juint8_t event_type, 
                                              juint8_t event_info)
{
  jresult_t rc = HSU_JSUCCESS;
  core_t *core = (core_t *)sc->core_ctx;

  HSU_ASSERT(core);

  switch (event_type)
  {
    case SNPS_DCD_DEVT_DISCONNEVTEN:
    {
      HSU_ULOG(HIGH_MSG, BUS_LOG, "disconnect");
      rc = snps_dcd_handle_disconnect(sc);
    }
    break;

    case SNPS_DCD_DEVT_USBRSTEN:
    {
      HSU_ULOG(HIGH_MSG, BUS_LOG, "usb_reset");
      rc = snps_dcd_handle_reset(sc);

      // Disable U0/U1/U2 events and remote wakeup pending flag
      sc->is_remote_wakeup_pending = FALSE;
      snps_dcd_set_usb_link_state_change_event_enable(FALSE);    

      // Propagate RESET notification
      jnotify_os(NOTIFY_DEVICE_RESET, (void *)j_device_get_bus(sc->dev));
    }  
    break;

    case SNPS_DCD_DEVT_CONNECTDONEEN:
    {
      HSU_ULOG(HIGH_MSG, BUS_LOG, "connection_done");  
      rc = snps_dcd_handle_connect(sc);
    }
    break;

    case SNPS_DCD_DEVT_ULSCNGEN:
    {
      event_info &= SNPS_DCD_EVENT_INFO_MASK;
      
      HSU_ULOG_1(NO_MSG, SNPS_LOG, "LINK_STATE_CHANGE, event_info %u", (event_info));
      
      hsu_os_bus_core_exit_lpm(core->core_index);

      switch (event_info)
      {
        case SNPS_DCD_LINK_STATE_SUSPEND_U3:
        {
          HSU_ULOG(HIGH_MSG, BUS_LOG, "link_state_change, SUSPEND_U3");
          // snps_dcd_set_usb_link_state_change_event_enable(FALSE); // Remove as it will be cleared upon U0
          // Do not call SUPSEND for Link Events
          // rc = snps_dcd_handle_suspend(sc);
        }
        break;

        case SNPS_DCD_LINK_STATE_U0:
        {
          if (sc->is_remote_wakeup_pending)
          {
            // Disable U0/U1/U2 events and remote wakeup pending flag
            sc->is_remote_wakeup_pending = FALSE;
            snps_dcd_set_usb_link_state_change_event_enable(FALSE);    

            HSU_ULOG(HIGH_MSG, BUS_LOG, "snps_dcd_ops_wake_the_host, resume_U0_from_remote_wakeup");
            rc = snps_dcd_handle_resume(sc);
          }
          if (SPEED_SUPER == core->curr_speed)
          {
            // Upon U0 scan all function and see if it's necessary to report function remote wake
            snps_dcd_function_wakeup_cb(sc);
          }
        }
        break;

        case SNPS_DCD_LINK_STATE_U1:
        {
          // snps_dcd_set_usb_link_state_change_event_enable(FALSE);
          HSU_ULOG(HIGH_MSG, BUS_LOG, "link_state_change, U1");
        }
        break;

        case SNPS_DCD_LINK_STATE_U2:
        {
          // snps_dcd_set_usb_link_state_change_event_enable(FALSE);
          HSU_ULOG(HIGH_MSG, BUS_LOG,  "link_state_change, U2");
        }
        break;

        default:
        {          
          HSU_ULOG_1(ERROR_MSG, DBG_E_LOG, "DCD, link_state_change, UNKNOWN %u", event_info);
        }
      }
    }
    break;

    case SNPS_DCD_DEVT_SUSPENTEVTEN:
    {
      event_info &= SNPS_DCD_EVENT_INFO_MASK;
        
      if ( (SPEED_SUPER != core->curr_speed) &&
           (SNPS_DCD_LINK_STATE_L1 == event_info) )
      {        
        HSU_ULOG(HIGH_MSG, SNPS_LOG, "L1_ENTER");
        hsu_event_log(EVT_L1_ENTER, core->core_index);     
      }
      else
      {
        HSU_ULOG(HIGH_MSG, BUS_LOG, "SUSPEND");      
        rc = snps_dcd_handle_suspend(sc);
      }
    }
    break;

    
    case SNPS_DCD_DEVT_WKUPEVTEN:
    {
      if ( (CORE_SUSPENDED != core->core_state) 
        && (SPEED_HIGH == core->curr_speed) )
      {
        HSU_ULOG(HIGH_MSG, SNPS_LOG, "L1_EXIT");       
        hsu_event_log(EVT_L1_EXIT, core->core_index);     
      }
      else
      {
        HSU_ULOG(HIGH_MSG, BUS_LOG, "RESUME");

        // Disable U0/U1/U2 events and remote wakeup pending flag
        sc->is_remote_wakeup_pending = FALSE;
        snps_dcd_set_usb_link_state_change_event_enable(FALSE);    

        rc = snps_dcd_handle_resume(sc);

        if (SPEED_SUPER == core->curr_speed)
        {
          // Upon U0 scan all function and see if it's necessary to report function remote wake
          snps_dcd_function_wakeup_cb(sc);
        }
      }
    }
    break;

#if 0	
//#ifndef FEATURE_HS_USB_PRE_SILICON_BU
//9x35VBU  
  case SNPS_DCD_DEVT_ENDOFPERFRAME:
  case SNPS_DCD_DEVT_SOF:
  case SNPS_DCD_DEVT_ERRTICERR:
  case SNPS_DCD_DEVT_CMDCMPLEN:
  case SNPS_DCD_DEVT_EVNTOVRFLWEN:
  case SNPS_DCD_DEVT_TSTLMPRECVD:
    HSU_ULOG_1(ERROR_MSG, DBG_E_LOG, "event %u is not support", event_type);
    break;
#endif     
  default:
    HSU_ULOG_1(ERROR_MSG, DBG_E_LOG, "DCD, unknown_event %u", event_type);
    break;
  }

  return rc;
}

/*================================ ISR & DSR ================================*/

/**
* Function name:  snps_dcd_intr
* Description: DCD Interrupt handler. Handles all hardware interrupts, and
*              prepare data for the software interrupt handler
* Parameters: 
*     @arg: (IN) snps_dcd_soft_dc_t: DCD software context
*
* Return value: ISR_CALL_SOFT_INTR when software interrupt handling is needed,
*               ISR_DONT_CALL_SOFT_INTR otherwise
* Scope: local
**/

static jint_t snps_dcd_intr(void* arg)
{
  snps_dcd_soft_dc_t *sc = (snps_dcd_soft_dc_t *)arg;
  juint8_t rc = ISR_DONT_CALL_SOFT_INTR;
  juint8_t event_buffer_index = SNPS_DCD_DEFAULT_EVT_BUF_ID;
  snps_dcd_event_buffer_t* event_buffer = &(sc->event_buffer[event_buffer_index]);
  juint16_t count;

  uint32  irq_status;

  //==========================================================================
  // Power Event IRQ handling
  //==========================================================================

  // Read and acknowledge/clear the interrupts, so they do not retrigger
  irq_status = HWIO_PWR_EVNT_IRQ_STAT_IN;
  if (irq_status)
  {
    HWIO_PWR_EVNT_IRQ_STAT_OUT(irq_status);

#if 0
{
    // For additional debugging only
    uint32 reg = 0;
    reg = HWIO_USB30_STS_REG_IN;
    if ((~reg) & (1 << HWIO_USB30_STS_REG_CTRL_SUSPEND_N_SHFT))
    {
      // P3_L2
      HSU_ULOG(NO_MSG, BUS_LOG, "L2");
    }
    else if ((~reg) & (1 << HWIO_USB30_STS_REG_CTRL_L1_SUSPEND_N_SHFT))
    {
      // P2_L1
      HSU_ULOG(NO_MSG, BUS_LOG, "L1");
    }
    else if ((~reg) & (1 << HWIO_USB30_STS_REG_CTRL_SLEEP_N_SHFT))
    {
      // P1
      HSU_ULOG(NO_MSG, BUS_LOG, "P1");
    }
    else
    {
      HSU_ULOG(NO_MSG, BUS_LOG, "P0");
    }
}
#endif

    // 0 - PHY is not in LPM
    // 1 - PHY is in P1
    // 2 - PHY is in P2/L1
    // 3 - PHY is in P3/L2
    if ((irq_status & HWIO_PWR_EVNT_IRQ_STAT_LPM_IN_L2_IRQ_STAT_BMSK) && (irq_status & HWIO_PWR_EVNT_IRQ_STAT_LPM_OUT_L2_IRQ_STAT_BMSK))
    {
      uint32 reg = 0;  
      reg = HWIO_USB30_STS_REG_IN;

      HSU_ULOG(NO_MSG, BUS_LOG, "Concurrent IN OUT L2");      
      /* State bits have negative logic */
      if ((~reg) & (1 << HWIO_USB30_STS_REG_USB30_CTRL_SUSPEND_N_SHFT))
      {
        // P3_L2
        // HSU_ULOG(NO_MSG, BUS_LOG, "L2");
        //if (rexl4_queue_dpc(hsu_os_bus_schedule_lpm_entry_for_usb3_pwr_evt_irq, PWR_EVNT_PHY_L2))
        rc = ISR_CALL_SOFT_INTR;
        sc->intr_to_handle |= SNPS_DCD_LPM_ENTRY;
        HSU_ULOG_NOFN_1(NO_MSG, BUS_LOG, "pwr_evnt_irq_stat_lpm, queued_l2_lpm_IN_soft_intr, irq_status 0x%X",irq_status);
      }
      else if ((~reg) & (1 << HWIO_USB30_STS_REG_USB30_CTRL_L1_SUSPEND_N_SHFT))
      {
        // P2_L1
        // HSU_ULOG(NO_MSG, BUS_LOG, "L1");
      }
      else if ((~reg) & (1 << HWIO_USB30_STS_REG_USB30_CTRL_SLEEP_N_SHFT))
      {
        // P1
        // HSU_ULOG(NO_MSG, BUS_LOG, "P1");
      }
      else
      {
        // HSU_ULOG(NO_MSG, BUS_LOG, "P0");
        //if (rexl4_queue_dpc(hsu_os_bus_schedule_lpm_exit_for_usb3_pwr_evt_irq, PWR_EVNT_PHY_L2))
        rc = ISR_CALL_SOFT_INTR;
        sc->intr_to_handle |= SNPS_DCD_LPM_EXIT;
        HSU_ULOG_NOFN_1(NO_MSG, BUS_LOG, "pwr_evnt_irq_stat_lpm, queued_l2_lpm_OUT_soft_intr, irq_status 0x%X",irq_status);
      }
    }
    else
    {
      if (irq_status & HWIO_PWR_EVNT_IRQ_STAT_LPM_IN_L2_IRQ_STAT_BMSK)
      {
        //if (rexl4_queue_dpc(hsu_os_bus_schedule_lpm_entry_for_usb3_pwr_evt_irq, PWR_EVNT_PHY_L2))
        rc = ISR_CALL_SOFT_INTR;
        sc->intr_to_handle |= SNPS_DCD_LPM_ENTRY;
        HSU_ULOG_NOFN_1(NO_MSG, BUS_LOG, "pwr_evnt_irq_stat_lpm, queued_l2_lpm_IN_soft_intr, irq_status 0x%X",irq_status);
      }

      if (irq_status & HWIO_PWR_EVNT_IRQ_STAT_LPM_OUT_L2_IRQ_STAT_BMSK)
      {
        //if (rexl4_queue_dpc(hsu_os_bus_schedule_lpm_exit_for_usb3_pwr_evt_irq, PWR_EVNT_PHY_L2))
        rc = ISR_CALL_SOFT_INTR;
        sc->intr_to_handle |= SNPS_DCD_LPM_EXIT;
        HSU_ULOG_NOFN_1(NO_MSG, BUS_LOG, "pwr_evnt_irq_stat_lpm, queued_l2_lpm_OUT_soft_intr, irq_status 0x%X",irq_status);
      }
    }
#if 0
    if (irq_status & HWIO_PWR_EVNT_IRQ_STAT_POWERDOWN_IN_P3_IRQ_STAT_BMSK)
    {
      //if (rexl4_queue_dpc(hsu_os_bus_schedule_lpm_entry_for_usb3_pwr_evt_irq, PWR_EVNT_PHY_P3))
      rc = ISR_CALL_SOFT_INTR;
      sc->intr_to_handle |= SNPS_DCD_LPM_ENTRY;
        HSU_ULOG_NOFN_1(NO_MSG, BUS_LOG, "pwr_evnt_irq_stat_lpm, queued_p3_lpm_IN_dpc_task, irq_status 0x%X",irq_status);
    }

    if (irq_status & HWIO_PWR_EVNT_IRQ_STAT_POWERDOWN_OUT_P3_IRQ_STAT_BMSK)
    {
      //if (rexl4_queue_dpc(hsu_os_bus_schedule_lpm_exit_for_usb3_pwr_evt_irq, PWR_EVNT_PHY_P3))
      rc = ISR_CALL_SOFT_INTR;
      sc->intr_to_handle |= SNPS_DCD_LPM_EXIT;
      HSU_ULOG_NOFN_1(NO_MSG, BUS_LOG, "pwr_evnt_irq_stat_lpm, queued_p3_lpm_OUT_dpc_task, irq_status 0x%X",irq_status);
    }
#endif
    if (irq_status & HWIO_PWR_EVNT_IRQ_MASK_USB30_GSI_L1_EXIT_IRQ_MASK_BMSK)
    {
      HSU_ULOG_1(NO_MSG, BUS_LOG, "pwr_evnt_irq_stat_gsi_l1_exit, issue remote wakeup, irq_status 0x%08X",irq_status);
      HWIO_DCTL_OUTM(HWIO_DCTL_ULSTCHNGREQ_BMSK, 0x0UL << HWIO_DCTL_ULSTCHNGREQ_SHFT);        
      HWIO_DCTL_OUTM(HWIO_DCTL_ULSTCHNGREQ_BMSK, 0x8UL << HWIO_DCTL_ULSTCHNGREQ_SHFT);
    }

    // Disabling due to getting printed too many times
    //if (irq_status & HWIO_PWR_EVNT_IRQ_STAT_LPM_OUT_RX_ELECIDLE_IRQ_STAT_BMSK)
    //{
    //  HSU_ULOG_NOFN_1(NO_MSG, BUS_LOG, "pwr_evnt_irq_stat_lpm, out_elec_idle_irq, irq_status 0x%X",irq_status);
    //}
  }

  //==========================================================================
  // Event IRQ
  //==========================================================================

  count = snps_dcd_get_event_buffer_count(sc, event_buffer_index);
  
  /* HSU fix - Lock the spinlock to protect from dsr in multi-core environment */
  jspinlock_lock(sc->lock);
  /* End of HSU fix */

  /* Check interrupt source */
  if (count)
  {
    /* Advance HW pointer for "produced" events */
    event_buffer[event_buffer_index].hw_current_addr += count/sizeof(snps_dcd_event_t);
    if (event_buffer[event_buffer_index].hw_current_addr >= event_buffer[event_buffer_index].high_addr)
    {
      event_buffer[event_buffer_index].hw_current_addr -=
        event_buffer[event_buffer_index].buffer_size/sizeof(snps_dcd_event_t);
    }
    /* Clear interrupt source */
    snps_dcd_set_event_buffer_count(sc, event_buffer_index, count);

//#ifdef FEATURE_HS_USB_VIRTIO_PCIEB
//#define PCIE_BRIDGE_CONTROL_REGISTERS     0x10000
//#define PCIE_BRIDGE_INTERRUPT_STS_REG     (PCIE_BRIDGE_CONTROL_REGISTERS + 0xc)
//    //HAL_ssusb_Write32(4, PCIE_BRIDGE_INTERRUPT_STS_REG, 1);
//#endif /* FEATURE_HS_USB_VIRTIO_PCIEB */

    rc = ISR_CALL_SOFT_INTR;
  }

  /* handle events posted from the outside */
  if ( ((interrupt_resource_info_type *)(sc->irq_res))->event & 
                                     HSU_OS_BUS_DISCONNECT_EVT )
  {
      rc = ISR_CALL_SOFT_INTR;
      sc->intr_to_handle |= SNPS_DCD_PMIC_VBUS_DISCONNECT;
      HSU_ULOG(HIGH_MSG, BUS_LOG, "disconnect_event, PMIC_to_SNPS");
      ((interrupt_resource_info_type *)(sc->irq_res))->event &= 
                                   (~HSU_OS_BUS_DISCONNECT_EVT);
  }

  if ( ((interrupt_resource_info_type *)(sc->irq_res))->event & 
                                     HSU_OS_BUS_CONNECT_EVT )
  {
      rc = ISR_CALL_SOFT_INTR;
      sc->intr_to_handle |= SNPS_DCD_PMIC_VBUS_CONNECT;
      HSU_ULOG(HIGH_MSG, BUS_LOG, "connect_event, PMIC_to_SNPS");      
      ((interrupt_resource_info_type *)(sc->irq_res))->event &= 
                                   (~HSU_OS_BUS_CONNECT_EVT);
  }

  /* HSU fix - Lock the spinlock to protect from dsr in multi-core environment */
  jspinlock_unlock(sc->lock);
  /* End of HSU fix */
  
  return rc;
}

/**
* Function name:  snps_dcd_soft_intr
* Description: DCD software interrupt handler. Handle post processing of
*              hardware interrupts
* Parameters: 
*     @arg: (IN) snps_dcd_soft_dc_t: DCD software context
*
* Return: None.
* Scope: local
**/
static void snps_dcd_soft_intr(void* arg)
{
  snps_dcd_soft_dc_t *sc = (snps_dcd_soft_dc_t *)arg;
  juint8_t event_buffer_index = SNPS_DCD_DEFAULT_EVT_BUF_ID;
  snps_dcd_event_buffer_t* event_buffer = &(sc->event_buffer[event_buffer_index]);
  snps_dcd_event_t* hw_current_addr_local;
  juint8_t to_handle;

  /* Mutual exclusion for event_buffer between DSR and ISR */
  jspinlock_lock(sc->lock);
  hw_current_addr_local = event_buffer[event_buffer_index].hw_current_addr;
  to_handle   = sc->intr_to_handle;
  sc->intr_to_handle = 0;
  jspinlock_unlock(sc->lock);

  /* Go over all pending events from the event buffer */
  while (event_buffer[event_buffer_index].sw_current_addr != hw_current_addr_local)
  {
    /* Get next event from the event buffer */
    snps_dcd_event_t* event = event_buffer[event_buffer_index].sw_current_addr;

    /* Advance SW pointer for "consumed" events */
    event_buffer[event_buffer_index].sw_current_addr += 1;
    if (event_buffer[event_buffer_index].sw_current_addr >= event_buffer[event_buffer_index].high_addr)
    {
      event_buffer[event_buffer_index].sw_current_addr -=
        event_buffer[event_buffer_index].buffer_size/sizeof(snps_dcd_event_t);
    }

    if (event->DEPEVT.EPEvt == 0)
    {
      /* Endpoint specific interrupt */
      snps_dcd_handle_ep_event(sc, (juint8_t)event->DEPEVT.PhysicalEPNum, 
        (juint8_t)event->DEPEVT.type, (juint8_t)event->DEPEVT.EventStatus, 
        (juint16_t)event->DEPEVT.EventParam);
    }
    else if (0 == event->DEVT.DEVEvt)
    {
      /* Device specific interrupt : TODO FEATURE_HS_USB_PRE_SILICON_BU */
      snps_dcd_handle_device_event(sc, (juint8_t)event->DEVT.type, 
        (juint8_t)event->DEVT.EvtInfo);
      //9x35VBU
    }
    else
    {
      HSU_ULOG_1(ERROR_MSG, DBG_E_LOG, "DCD, unknown_non_device_event %d", event->value);
    }
  }

  if (to_handle & SNPS_DCD_PMIC_VBUS_DISCONNECT)
  {
    /* Device specific interrupt : TODO FEATURE_HS_USB_PRE_SILICON_BU */
    snps_dcd_handle_device_event(sc, SNPS_DCD_DEVT_DISCONNEVTEN,0);
    
      /* Notify OS Abstraction of the disconnect event. 
      Restart core may be performed, pass this as parameter in high word. */
      jnotify_os(NOTIFY_DEVICE_DISCONNECT, 
        (void*)((juint32_t)j_device_get_bus(sc->dev) | (juint16_t)1 << 16));  
  }

  if (to_handle & SNPS_DCD_PMIC_VBUS_CONNECT)
  {
    // Will perform restart core in AL task
    jnotify_os(NOTIFY_DEVICE_CONNECT, 
          (void *)j_device_get_bus(sc->dev));
  }

  if (to_handle & SNPS_DCD_LPM_ENTRY)
  {
    hsu_os_bus_schedule_lpm_entry_for_usb3_pwr_evt_irq (PWR_EVNT_PHY_L2);
  }

  if (to_handle & SNPS_DCD_LPM_EXIT)
  {
    hsu_os_bus_schedule_lpm_exit_for_usb3_pwr_evt_irq (PWR_EVNT_PHY_L2);
  }
}

/**
* Function name:  snps_dcd_config_interrupts
* Description: Register the DCD's ISR & DSR with the OS
* Parameters:
*     @sc: (IN) The DCD SW context
*
* Return value: 0 on success, otherwise an error code
* Scope: global
**/
jresult_t snps_dcd_config_interrupts(snps_dcd_soft_dc_t *sc)
{
  jresult_t rc = HSU_JSUCCESS;
  hsu_platform_info_type const * platform_info = hsu_platform_get_info();

  /* Register ISR & DSR with OS abstraction */
  rc = jinterrupt_setup(sc->irq_res, snps_dcd_intr, sc, snps_dcd_soft_intr, sc, 
    &sc->interrupt_h);
  if (rc != HSU_JSUCCESS)
  {
    HSU_ULOG_1(ERROR_MSG, DBG_E_LOG, "DCD, failed_to_reg_interrupt, rc %d", rc);
  }
  else 
  {
    /* Enable interrupts for default set of events */
    HWIO_DEVTEN_OUT(SNPS_DCD_DEVTEN_DEFAULT);
  }

  return rc;
}
