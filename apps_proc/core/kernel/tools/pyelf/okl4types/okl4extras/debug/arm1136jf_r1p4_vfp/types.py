# Australian Public Licence B (OZPLB)
# 
# Version 1-0
# 
# Copyright (c) 2006-2010, Open Kernel Labs, Inc.
# 
# All rights reserved.
# 
# Developed by: Embedded, Real-time and Operating Systems Program (ERTOS)
#               National ICT Australia
#               http://www.ertos.nicta.com.au
# 
# Permission is granted by Open Kernel Labs, Inc., free of charge, to
# any person obtaining a copy of this software and any associated
# documentation files (the "Software") to deal with the Software without
# restriction, including (without limitation) the rights to use, copy,
# modify, adapt, merge, publish, distribute, communicate to the public,
# sublicense, and/or sell, lend or rent out copies of the Software, and
# to permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
# 
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimers.
# 
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimers in the documentation and/or other materials provided
#       with the distribution.
# 
#     * Neither the name of Open Kernel Labs, Inc., nor the names of its
#       contributors, may be used to endorse or promote products derived
#       from this Software without specific prior written permission.
# 
# EXCEPT AS EXPRESSLY STATED IN THIS LICENCE AND TO THE FULL EXTENT
# PERMITTED BY APPLICABLE LAW, THE SOFTWARE IS PROVIDED "AS-IS", AND
# NATIONAL ICT AUSTRALIA AND ITS CONTRIBUTORS MAKE NO REPRESENTATIONS,
# WARRANTIES OR CONDITIONS OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
# BUT NOT LIMITED TO ANY REPRESENTATIONS, WARRANTIES OR CONDITIONS
# REGARDING THE CONTENTS OR ACCURACY OF THE SOFTWARE, OR OF TITLE,
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT,
# THE ABSENCE OF LATENT OR OTHER DEFECTS, OR THE PRESENCE OR ABSENCE OF
# ERRORS, WHETHER OR NOT DISCOVERABLE.
# 
# TO THE FULL EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL
# NATIONAL ICT AUSTRALIA OR ITS CONTRIBUTORS BE LIABLE ON ANY LEGAL
# THEORY (INCLUDING, WITHOUT LIMITATION, IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHERWISE) FOR ANY CLAIM, LOSS, DAMAGES OR OTHER
# LIABILITY, INCLUDING (WITHOUT LIMITATION) LOSS OF PRODUCTION OR
# OPERATION TIME, LOSS, DAMAGE OR CORRUPTION OF DATA OR RECORDS; OR LOSS
# OF ANTICIPATED SAVINGS, OPPORTUNITY, REVENUE, PROFIT OR GOODWILL, OR
# OTHER ECONOMIC LOSS; OR ANY SPECIAL, INCIDENTAL, INDIRECT,
# CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES, ARISING OUT OF OR IN
# CONNECTION WITH THIS LICENCE, THE SOFTWARE OR THE USE OF OR OTHER
# DEALINGS WITH THE SOFTWARE, EVEN IF NATIONAL ICT AUSTRALIA OR ITS
# CONTRIBUTORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH CLAIM, LOSS,
# DAMAGES OR OTHER LIABILITY.
# 
# If applicable legislation implies representations, warranties, or
# conditions, or imposes obligations or liability on Open Kernel Labs, Inc.
# or one of its contributors in respect of the Software that
# cannot be wholly or partly excluded, restricted or modified, the
# liability of Open Kernel Labs, Inc. or the contributor is limited, to
# the full extent permitted by the applicable legislation, at its
# option, to:
# a.  in the case of goods, any one or more of the following:
# i.  the replacement of the goods or the supply of equivalent goods;
# ii.  the repair of the goods;
# iii. the payment of the cost of replacing the goods or of acquiring
#  equivalent goods;
# iv.  the payment of the cost of having the goods repaired; or
# b.  in the case of services:
# i.  the supplying of the services again; or
# ii.  the payment of the cost of having the services supplied again.
# 
# The construction, validity and performance of this licence is governed
# by the laws in force in New South Wales, Australia.

# Auto generated file - do not modify

"""
Python classes that represent kernel data structures for elfweaver to
handle and write out the initial kernel structures.
"""

# Pylint wrongly reports W0233 on the nested anonymous types.
#pylint: disable-msg=W0233
# Pylint complains about the use of lambda functions in properties
#pylint: disable-msg=W0212
# Pylint is also confused about properties in anon classes
#pylint: disable-msg=W0201
# Long lines are hard to control in autogenerated files.
#pylint: disable-msg=C0301
# Ignore pylint complaints about too many lines in the file.
#pylint: disable-msg=C0302
# The design below requires lots of variables, return statements and branches.
#pylint: disable-msg=R0902
#pylint: disable-msg=R0911
#pylint: disable-msg=R0912

from weaver.weavertypes import ElfweaverType, ElfweaverTypeException


# Misc kernel definitions
WORD_BITS = 32
WORD_BITS_SIGNED = 32
WORD_SIZE = 4
ARM_MODE = 0L
THUMB_MODE = 1L
JAZELLE_MODE = 2L
THUMBEE_MODE = 3L
DEFAULT_MODE = 4L
MPOINTER_WORD_SIZE = 6L
TRACEBUFFER_NOTIFY_BIT = 1L
TRACEBUFFER_ENABLED = 1L
TRACEBUFFER_MAGIC_ = 992680715L
TRACEBUFFER_VERSION = 4L
TRACEBUFFER_ID = 1L
TRACEBUFFER_NUM_BUFFERS = 2L
MESSAGE_QUEUE_INLINE_WORDS = 2L
MESSAGE_TAG_INLINE = 0L
MESSAGE_TAG_INPLACE = 2L
MESSAGE_TAG_STANDARD = 3L
MESSAGE_TAG_CAPABILITY = 1L
MESSAGE_QUEUE_NONEMPTY = 4096L
MESSAGE_QUEUE_NONFULL = 8192L
MESSAGE_QUEUE_BUFFER_SET = 16384L
CRITSECT_FREE = -1L
CRITSECT_CONTENDED = 2147483648L
CRITSECT_MAX_RETRIES = 100L
KERNEL_1_1_MAPPING_PERMS = 132110L
TTBCR_INIT_VAL = 0L
KMMU_MAX_SEGMENTS = 256L
OKL4_INTERRUPT_IRQ = 0L
OKL4_INTERRUPT_FIQ = 1L
KCAP_INVALID = -1L
HYBRID_MUTEX_FREE = -1L
# STANDARD_RECEIVE_CALL has no python definition
# INPLACE_RECEIVE_CALL has no python definition
# ANY_RECEIVE_CALL has no python definition
INITIAL_SUSPEND = 0L
# SCHEDULER_IDLE_PRIORITY has no python definition
CPU_ID_INVALID = -1L
ASID_INVALID = 4294967295L
# MMU_BUFFER_AREA_PAGESIZE has no python definition

# Kernel object definitions

class OKL4_bool(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long bool;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "bool"
    _type_libokl4_name = "bool_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_unsigned_long(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "unsigned long"
    _type_libokl4_name = "unsigned long"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_signed_long(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "signed long"
    _type_libokl4_name = "signed long"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_unsigned(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "unsigned"
    _type_libokl4_name = "unsigned"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_int(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "int"
    _type_libokl4_name = "int"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_signed_char(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 1
    _type_alignment = 1
    _type_name = "signed char"
    _type_libokl4_name = "signed char"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 1, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(1, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_unsigned_char(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 1
    _type_alignment = 1
    _type_name = "unsigned char"
    _type_libokl4_name = "unsigned char"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 1, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(1, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_char_ptr(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "char *"
    _type_libokl4_name = "char"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_void_ptr(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "void *"
    _type_libokl4_name = "void"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_padding_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef signed char padding_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 1
    _type_alignment = 1
    _type_name = "padding_t"
    _type_libokl4_name = "padding_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 1, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(1, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_word_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long word_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "word_t"
    _type_libokl4_name = "word_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_sword_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef signed long sword_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "sword_t"
    _type_libokl4_name = "sword_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_int_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef int int_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "int_t"
    _type_libokl4_name = "int_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_byte_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned char byte_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 1
    _type_alignment = 1
    _type_name = "byte_t"
    _type_libokl4_name = "byte_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 1, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(1, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_sbyte_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef signed char sbyte_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 1
    _type_alignment = 1
    _type_name = "sbyte_t"
    _type_libokl4_name = "sbyte_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 1, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(1, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_string_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef const char *string_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "string_t"
    _type_libokl4_name = "string_t"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_int16_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef signed short int16_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 2
    _type_alignment = 2
    _type_name = "int16_t"
    _type_libokl4_name = "int16_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 2, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(2, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_uint16_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned short uint16_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 2
    _type_alignment = 2
    _type_name = "uint16_t"
    _type_libokl4_name = "uint16_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 2, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(2, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_int32_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef signed long int32_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "int32_t"
    _type_libokl4_name = "int32_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_uint32_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long uint32_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "uint32_t"
    _type_libokl4_name = "uint32_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_int64_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef signed long long int64_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 8
    _type_name = "int64_t"
    _type_libokl4_name = "int64_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 8, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(8, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_uint64_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long long uint64_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 8
    _type_name = "uint64_t"
    _type_libokl4_name = "uint64_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 8, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(8, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_registers(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct registers {
    word_t r0;
    word_t r1;
    word_t r2;
    word_t r3;
    word_t r4;
    word_t r5;
    word_t r6;
    word_t r7;
    word_t r8;
    word_t r9;
    word_t r10;
    word_t r11;
    word_t r12;
    word_t r13;
    word_t r14;
    word_t r15;
    word_t cpsr;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "r0" : {'offset': 0},
        "r1" : {'offset': 4},
        "r2" : {'offset': 8},
        "r3" : {'offset': 12},
        "r4" : {'offset': 16},
        "r5" : {'offset': 20},
        "r6" : {'offset': 24},
        "r7" : {'offset': 28},
        "r8" : {'offset': 32},
        "r9" : {'offset': 36},
        "r10" : {'offset': 40},
        "r11" : {'offset': 44},
        "r12" : {'offset': 48},
        "r13" : {'offset': 52},
        "r14" : {'offset': 56},
        "r15" : {'offset': 60},
        "cpsr" : {'offset': 64},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._r0 = 0
        self._r1 = 0
        self._r2 = 0
        self._r3 = 0
        self._r4 = 0
        self._r5 = 0
        self._r6 = 0
        self._r7 = 0
        self._r8 = 0
        self._r9 = 0
        self._r10 = 0
        self._r11 = 0
        self._r12 = 0
        self._r13 = 0
        self._r14 = 0
        self._r15 = 0
        self._cpsr = 16

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 68
    _type_alignment = 4
    _type_name = "registers"
    _type_libokl4_name = "cpu_registers"

    def _set_r0(self, r0_):
        """Set r0 and flag this type as modified"""
        self._r0 =  r0_
        self._dirty = True

    r0 = property(lambda self: self._r0, _set_r0)

    def _set_r1(self, r1_):
        """Set r1 and flag this type as modified"""
        self._r1 =  r1_
        self._dirty = True

    r1 = property(lambda self: self._r1, _set_r1)

    def _set_r2(self, r2_):
        """Set r2 and flag this type as modified"""
        self._r2 =  r2_
        self._dirty = True

    r2 = property(lambda self: self._r2, _set_r2)

    def _set_r3(self, r3_):
        """Set r3 and flag this type as modified"""
        self._r3 =  r3_
        self._dirty = True

    r3 = property(lambda self: self._r3, _set_r3)

    def _set_r4(self, r4_):
        """Set r4 and flag this type as modified"""
        self._r4 =  r4_
        self._dirty = True

    r4 = property(lambda self: self._r4, _set_r4)

    def _set_r5(self, r5_):
        """Set r5 and flag this type as modified"""
        self._r5 =  r5_
        self._dirty = True

    r5 = property(lambda self: self._r5, _set_r5)

    def _set_r6(self, r6_):
        """Set r6 and flag this type as modified"""
        self._r6 =  r6_
        self._dirty = True

    r6 = property(lambda self: self._r6, _set_r6)

    def _set_r7(self, r7_):
        """Set r7 and flag this type as modified"""
        self._r7 =  r7_
        self._dirty = True

    r7 = property(lambda self: self._r7, _set_r7)

    def _set_r8(self, r8_):
        """Set r8 and flag this type as modified"""
        self._r8 =  r8_
        self._dirty = True

    r8 = property(lambda self: self._r8, _set_r8)

    def _set_r9(self, r9_):
        """Set r9 and flag this type as modified"""
        self._r9 =  r9_
        self._dirty = True

    r9 = property(lambda self: self._r9, _set_r9)

    def _set_r10(self, r10_):
        """Set r10 and flag this type as modified"""
        self._r10 =  r10_
        self._dirty = True

    r10 = property(lambda self: self._r10, _set_r10)

    def _set_r11(self, r11_):
        """Set r11 and flag this type as modified"""
        self._r11 =  r11_
        self._dirty = True

    r11 = property(lambda self: self._r11, _set_r11)

    def _set_r12(self, r12_):
        """Set r12 and flag this type as modified"""
        self._r12 =  r12_
        self._dirty = True

    r12 = property(lambda self: self._r12, _set_r12)

    def _set_r13(self, r13_):
        """Set r13 and flag this type as modified"""
        self._r13 =  r13_
        self._dirty = True

    r13 = property(lambda self: self._r13, _set_r13)

    def _set_r14(self, r14_):
        """Set r14 and flag this type as modified"""
        self._r14 =  r14_
        self._dirty = True

    r14 = property(lambda self: self._r14, _set_r14)

    def _set_r15(self, r15_):
        """Set r15 and flag this type as modified"""
        self._r15 =  r15_
        self._dirty = True

    r15 = property(lambda self: self._r15, _set_r15)

    def _set_cpsr(self, cpsr_):
        """Set cpsr and flag this type as modified"""
        self._cpsr =  cpsr_
        self._dirty = True

    cpsr = property(lambda self: self._cpsr, _set_cpsr)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.r0, 4, addr + 0)
        image.patch(symbol, self.r1, 4, addr + 4)
        image.patch(symbol, self.r2, 4, addr + 8)
        image.patch(symbol, self.r3, 4, addr + 12)
        image.patch(symbol, self.r4, 4, addr + 16)
        image.patch(symbol, self.r5, 4, addr + 20)
        image.patch(symbol, self.r6, 4, addr + 24)
        image.patch(symbol, self.r7, 4, addr + 28)
        image.patch(symbol, self.r8, 4, addr + 32)
        image.patch(symbol, self.r9, 4, addr + 36)
        image.patch(symbol, self.r10, 4, addr + 40)
        image.patch(symbol, self.r11, 4, addr + 44)
        image.patch(symbol, self.r12, 4, addr + 48)
        image.patch(symbol, self.r13, 4, addr + 52)
        image.patch(symbol, self.r14, 4, addr + 56)
        image.patch(symbol, self.r15, 4, addr + 60)
        image.patch(symbol, self.cpsr, 4, addr + 64)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.r0,
                name + '.r0', False)
        string += self._field_to_string(self.r1,
                name + '.r1', False)
        string += self._field_to_string(self.r2,
                name + '.r2', False)
        string += self._field_to_string(self.r3,
                name + '.r3', False)
        string += self._field_to_string(self.r4,
                name + '.r4', False)
        string += self._field_to_string(self.r5,
                name + '.r5', False)
        string += self._field_to_string(self.r6,
                name + '.r6', False)
        string += self._field_to_string(self.r7,
                name + '.r7', False)
        string += self._field_to_string(self.r8,
                name + '.r8', False)
        string += self._field_to_string(self.r9,
                name + '.r9', False)
        string += self._field_to_string(self.r10,
                name + '.r10', False)
        string += self._field_to_string(self.r11,
                name + '.r11', False)
        string += self._field_to_string(self.r12,
                name + '.r12', False)
        string += self._field_to_string(self.r13,
                name + '.r13', False)
        string += self._field_to_string(self.r14,
                name + '.r14', False)
        string += self._field_to_string(self.r15,
                name + '.r15', False)
        string += self._field_to_string(self.cpsr,
                name + '.cpsr', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.r0))
        data.append(self._pack(4, self.r1))
        data.append(self._pack(4, self.r2))
        data.append(self._pack(4, self.r3))
        data.append(self._pack(4, self.r4))
        data.append(self._pack(4, self.r5))
        data.append(self._pack(4, self.r6))
        data.append(self._pack(4, self.r7))
        data.append(self._pack(4, self.r8))
        data.append(self._pack(4, self.r9))
        data.append(self._pack(4, self.r10))
        data.append(self._pack(4, self.r11))
        data.append(self._pack(4, self.r12))
        data.append(self._pack(4, self.r13))
        data.append(self._pack(4, self.r14))
        data.append(self._pack(4, self.r15))
        data.append(self._pack(4, self.cpsr))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_interrupt_type_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t interrupt_type_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "interrupt_type_t"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_cpu_mode(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t cpu_mode_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cpu_mode"
    _type_libokl4_name = "cpu_mode"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_atomic_plain_word_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t atomic_plain_word_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "atomic_plain_word_t"
    _type_libokl4_name = "atomic_plain_word_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_atomic_word(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct atomic_word {
    volatile atomic_plain_word_t value;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "atomic_word"
    _type_libokl4_name = "atomic_word"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_atomic_word_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct atomic_word atomic_word_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "atomic_word_t"
    _type_libokl4_name = "atomic_word_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_designator_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t designator_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "designator_t"
    _type_libokl4_name = "kcap_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_mpointer(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct mpointer {
    void *blocked;
    struct cap *cap;
    list_entry_t list_entry;
    void *object;
    unwind_t unwindid;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "blocked" : {'offset': 0},
        "cap" : {'offset': 4},
        "list_entry" : {'offset': 8},
        "object" : {'offset': 16},
        "unwindid" : {'offset': 20},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.blocked = None
        self.cap = None

        this_addr = None if address is None else self._address + 8
        self.list_entry = OKL4_list_entry_t(this_addr, self)
        self.object = None
        self._unwindid = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.list_entry.set_address(address + 8)

    _type_size = 24
    _type_alignment = 4
    _type_name = "mpointer"
    _type_libokl4_name = ""

    def _set_unwindid(self, unwindid_):
        """Set unwindid and flag this type as modified"""
        self._unwindid =  unwindid_
        self._dirty = True

    unwindid = property(lambda self: self._unwindid, _set_unwindid)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.blocked)
        self._pointer_patch(image, symbol, 4, addr + 4, self.cap)
        self.list_entry.patch(image, symbol, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 16, self.object)
        image.patch(symbol, self.unwindid, 4, addr + 20)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.blocked,
                name + '.blocked', True)
        string += self._field_to_string(self.cap,
                name + '.cap', True)
        string += self._field_to_string(self.list_entry,
                name + '.list_entry', False)
        string += self._field_to_string(self.object,
                name + '.object', True)
        string += self._field_to_string(self.unwindid,
                name + '.unwindid', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.blocked)
        self._pointer_to_data(data, 4, self.cap)
        data.append(self.list_entry.to_data())
        self._pointer_to_data(data, 4, self.object)
        data.append(self._pack(4, self.unwindid))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.list_entry.get_phys_relocs(base_offset + self.get_offset_of('list_entry')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.blocked is not None:
            return True
        if self.cap is not None:
            return True
        if self.list_entry.dirty:
            return True
        if self.object is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_objmanager_object_header(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct objmanager_object_header {
    designator_t master_designator;
    struct domain *master_domain;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "master_designator" : {'offset': 0},
        "master_domain" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._master_designator = 0
        self.master_domain = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "objmanager_object_header"
    _type_libokl4_name = ""

    def _set_master_designator(self, master_designator_):
        """Set master_designator and flag this type as modified"""
        self._master_designator =  master_designator_
        self._dirty = True

    master_designator = property(lambda self: self._master_designator, _set_master_designator)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.master_designator, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.master_domain)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.master_designator,
                name + '.master_designator', False)
        string += self._field_to_string(self.master_domain,
                name + '.master_domain', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.master_designator))
        self._pointer_to_data(data, 4, self.master_domain)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.master_domain is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_objtype(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long objtype_t;
#define OBJTYPE_BARRIER ((objtype_t)0x1UL)
#define OBJTYPE_DOMAIN ((objtype_t)0x2UL)
#define OBJTYPE_HYBRID_MUTEX ((objtype_t)0x3UL)
#define OBJTYPE_INTERRUPT ((objtype_t)0x4UL)
#define OBJTYPE_INTLOCK_CONTROL ((objtype_t)0x5UL)
#define OBJTYPE_MESSAGE_QUEUE ((objtype_t)0x6UL)
#define OBJTYPE_MMU_CONTEXT ((objtype_t)0x7UL)
#define OBJTYPE_MUTEX ((objtype_t)0x8UL)
#define OBJTYPE_PLATFORM_CONTROL ((objtype_t)0x9UL)
#define OBJTYPE_PROCESSOR_CONTROL ((objtype_t)0xaUL)
#define OBJTYPE_PROFILE_CONTROL ((objtype_t)0xbUL)
#define OBJTYPE_SEGMENT ((objtype_t)0xcUL)
#define OBJTYPE_SEMAPHORE ((objtype_t)0xdUL)
#define OBJTYPE_SWITCH_TABLE ((objtype_t)0xeUL)
#define OBJTYPE_THREAD ((objtype_t)0xfUL)
#define OBJTYPE_TRACEBUFFER_CONTROL ((objtype_t)0x10UL)
#define OBJTYPE_INVALID ((objtype_t)0x0UL)
#define OBJTYPE_MAX ((objtype_t)0x10UL)

    """

    OBJTYPE_BARRIER = 1
    OBJTYPE_DOMAIN = 2
    OBJTYPE_HYBRID_MUTEX = 3
    OBJTYPE_INTERRUPT = 4
    OBJTYPE_INTLOCK_CONTROL = 5
    OBJTYPE_MESSAGE_QUEUE = 6
    OBJTYPE_MMU_CONTEXT = 7
    OBJTYPE_MUTEX = 8
    OBJTYPE_PLATFORM_CONTROL = 9
    OBJTYPE_PROCESSOR_CONTROL = 10
    OBJTYPE_PROFILE_CONTROL = 11
    OBJTYPE_SEGMENT = 12
    OBJTYPE_SEMAPHORE = 13
    OBJTYPE_SWITCH_TABLE = 14
    OBJTYPE_THREAD = 15
    OBJTYPE_TRACEBUFFER_CONTROL = 16
    OBJTYPE_INVALID = 0
    OBJTYPE_MAX = 16

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "objtype"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_rights_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t rights_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "rights_t"
    _type_libokl4_name = "rights_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_unwind(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long unwind_t;
#define UNWIND_NONE ((unwind_t)0x0UL)
#define UNWIND_MUTEX_LOCK ((unwind_t)0x1UL)
#define UNWIND_MUTEX_HYBRID_LOCK ((unwind_t)0x2UL)
#define UNWIND_IPC ((unwind_t)0x3UL)
#define UNWIND_MESSAGE_QUEUE ((unwind_t)0x4UL)
#define UNWIND_SEMAPHORE_DOWN ((unwind_t)0x5UL)
#define UNWIND_MMU_ATTACH ((unwind_t)0x6UL)

    """

    UNWIND_NONE = 0
    UNWIND_MUTEX_LOCK = 1
    UNWIND_MUTEX_HYBRID_LOCK = 2
    UNWIND_IPC = 3
    UNWIND_MESSAGE_QUEUE = 4
    UNWIND_SEMAPHORE_DOWN = 5
    UNWIND_MMU_ATTACH = 6

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "unwind"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_domain(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct domain {
    struct objmanager_object_header header;
    struct {
        word_t alloc_count;
        list_head_t attachments;
        struct cap *clist;
        word_t clist_entries;
        struct cap *first_free_cap;
        struct node heap;
        word_t ref_count;
        word_t used_entries;
    } objmanager;
    struct {
        word_t num_entries;
        struct reply_token *reply_token_free_list_head;
        struct reply_token *reply_token_table;
        word_t used_entries;
    } ipc;
    struct {
        struct kdb_object *info;
    } kdb;
    struct {
        word_t max_prio;
    } scheduler;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "objmanager" : {'offset': 8},
        "ipc" : {'offset': 48},
        "kdb" : {'offset': 64},
        "scheduler" : {'offset': 68},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_0(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "alloc_count" : {'offset': 0},
                "attachments" : {'offset': 4},
                "clist" : {'offset': 12},
                "clist_entries" : {'offset': 16},
                "first_free_cap" : {'offset': 20},
                "heap" : {'offset': 24},
                "ref_count" : {'offset': 32},
                "used_entries" : {'offset': 36},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._alloc_count = 0

                this_addr = None if address is None else self._address + 4
                self.attachments = OKL4_list_head_t(this_addr, self)
                self.clist = None
                self._clist_entries = 0
                self.first_free_cap = None

                this_addr = None if address is None else self._address + 24
                self.heap = OKL4_node(this_addr, self)
                self._ref_count = 0
                self._used_entries = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.attachments.set_address(address + 4)
                self.heap.set_address(address + 24)

            _type_size = 40
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_alloc_count(self, alloc_count_):
                """Set alloc_count and flag this type as modified"""
                self._alloc_count =  alloc_count_
                self._dirty = True

            alloc_count = property(lambda self: self._alloc_count, _set_alloc_count)

            def _set_clist_entries(self, clist_entries_):
                """Set clist_entries and flag this type as modified"""
                self._clist_entries =  clist_entries_
                self._dirty = True

            clist_entries = property(lambda self: self._clist_entries, _set_clist_entries)

            def _set_ref_count(self, ref_count_):
                """Set ref_count and flag this type as modified"""
                self._ref_count =  ref_count_
                self._dirty = True

            ref_count = property(lambda self: self._ref_count, _set_ref_count)

            def _set_used_entries(self, used_entries_):
                """Set used_entries and flag this type as modified"""
                self._used_entries =  used_entries_
                self._dirty = True

            used_entries = property(lambda self: self._used_entries, _set_used_entries)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.alloc_count, 4, addr + 0)
                self.attachments.patch(image, symbol, addr + 4)
                self._pointer_patch(image, symbol, 4, addr + 12, self.clist)
                image.patch(symbol, self.clist_entries, 4, addr + 16)
                self._pointer_patch(image, symbol, 4, addr + 20, self.first_free_cap)
                self.heap.patch(image, symbol, addr + 24)
                image.patch(symbol, self.ref_count, 4, addr + 32)
                image.patch(symbol, self.used_entries, 4, addr + 36)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.alloc_count,
                        name + '.alloc_count', False)
                string += self._field_to_string(self.attachments,
                        name + '.attachments', False)
                string += self._field_to_string(self.clist,
                        name + '.clist', True)
                string += self._field_to_string(self.clist_entries,
                        name + '.clist_entries', False)
                string += self._field_to_string(self.first_free_cap,
                        name + '.first_free_cap', True)
                string += self._field_to_string(self.heap,
                        name + '.heap', False)
                string += self._field_to_string(self.ref_count,
                        name + '.ref_count', False)
                string += self._field_to_string(self.used_entries,
                        name + '.used_entries', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.alloc_count))
                data.append(self.attachments.to_data())
                self._pointer_to_data(data, 4, self.clist)
                data.append(self._pack(4, self.clist_entries))
                self._pointer_to_data(data, 4, self.first_free_cap)
                data.append(self.heap.to_data())
                data.append(self._pack(4, self.ref_count))
                data.append(self._pack(4, self.used_entries))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.attachments.get_phys_relocs(base_offset + self.get_offset_of('attachments')))
                relocs.extend(self.heap.get_phys_relocs(base_offset + self.get_offset_of('heap')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.attachments.dirty:
                    return True
                if self.clist is not None:
                    return True
                if self.first_free_cap is not None:
                    return True
                if self.heap.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.objmanager = OKL4_AnonymousType_0(this_addr, self)

        class OKL4_AnonymousType_1(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "num_entries" : {'offset': 0},
                "reply_token_free_list_head" : {'offset': 4},
                "reply_token_table" : {'offset': 8},
                "used_entries" : {'offset': 12},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._num_entries = 0
                self.reply_token_free_list_head = None
                self.reply_token_table = None
                self._used_entries = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 16
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_num_entries(self, num_entries_):
                """Set num_entries and flag this type as modified"""
                self._num_entries =  num_entries_
                self._dirty = True

            num_entries = property(lambda self: self._num_entries, _set_num_entries)

            def _set_used_entries(self, used_entries_):
                """Set used_entries and flag this type as modified"""
                self._used_entries =  used_entries_
                self._dirty = True

            used_entries = property(lambda self: self._used_entries, _set_used_entries)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.num_entries, 4, addr + 0)
                self._pointer_patch(image, symbol, 4, addr + 4, self.reply_token_free_list_head)
                self._pointer_patch(image, symbol, 4, addr + 8, self.reply_token_table)
                image.patch(symbol, self.used_entries, 4, addr + 12)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.num_entries,
                        name + '.num_entries', False)
                string += self._field_to_string(self.reply_token_free_list_head,
                        name + '.reply_token_free_list_head', True)
                string += self._field_to_string(self.reply_token_table,
                        name + '.reply_token_table', True)
                string += self._field_to_string(self.used_entries,
                        name + '.used_entries', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.num_entries))
                self._pointer_to_data(data, 4, self.reply_token_free_list_head)
                self._pointer_to_data(data, 4, self.reply_token_table)
                data.append(self._pack(4, self.used_entries))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.reply_token_free_list_head is not None:
                    return True
                if self.reply_token_table is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 48
        self.ipc = OKL4_AnonymousType_1(this_addr, self)

        class OKL4_AnonymousType_2(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 64
        self.kdb = OKL4_AnonymousType_2(this_addr, self)

        class OKL4_AnonymousType_3(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "max_prio" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._max_prio = 255

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_max_prio(self, max_prio_):
                """Set max_prio and flag this type as modified"""
                self._max_prio =  max_prio_
                self._dirty = True

            max_prio = property(lambda self: self._max_prio, _set_max_prio)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.max_prio, 4, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.max_prio,
                        name + '.max_prio', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.max_prio))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 68
        self.scheduler = OKL4_AnonymousType_3(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.objmanager.set_address(address + 8)
        self.ipc.set_address(address + 48)
        self.kdb.set_address(address + 64)
        self.scheduler.set_address(address + 68)

    _type_size = 72
    _type_alignment = 4
    _type_name = "domain"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.objmanager.patch(image, symbol, addr + 8)
        self.ipc.patch(image, symbol, addr + 48)
        self.kdb.patch(image, symbol, addr + 64)
        self.scheduler.patch(image, symbol, addr + 68)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.objmanager,
                name + '.objmanager', False)
        string += self._field_to_string(self.ipc,
                name + '.ipc', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)
        string += self._field_to_string(self.scheduler,
                name + '.scheduler', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.objmanager.to_data())
        data.append(self.ipc.to_data())
        data.append(self.kdb.to_data())
        data.append(self.scheduler.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.objmanager.get_phys_relocs(base_offset + self.get_offset_of('objmanager')))
        relocs.extend(self.ipc.get_phys_relocs(base_offset + self.get_offset_of('ipc')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        relocs.extend(self.scheduler.get_phys_relocs(base_offset + self.get_offset_of('scheduler')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.objmanager.dirty:
            return True
        if self.ipc.dirty:
            return True
        if self.kdb.dirty:
            return True
        if self.scheduler.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_cap(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct cap {
    struct domain *domain;
    union {
        list_entry_t list_entry;
        list_head_t aliases;
        struct cap *next_free;
    } list;
    list_head_t mpointers;
    void *object;
    rights_t rights;
    word_t type;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "domain" : {'offset': 0},
        "list" : {'offset': 4},
        "mpointers" : {'offset': 12},
        "object" : {'offset': 20},
        "rights" : {'offset': 24},
        "type" : {'offset': 28},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.domain = None

        class OKL4_AnonymousType_4(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "list_entry" : {},
                "aliases" : {},
                "next_free" : {},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.list_entry = OKL4_list_entry_t(this_addr, self)

                this_addr = None if address is None else self._address + 0
                self.aliases = OKL4_list_head_t(this_addr, self)
                self.next_free = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.list_entry.set_address(address + 0)
                self.aliases.set_address(address + 0)

            _type_size = 8
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                pass

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.list_entry,
                        name + '.list_entry', False)
                string += self._field_to_string(self.aliases,
                        name + '.aliases', False)
                string += self._field_to_string(self.next_free,
                        name + '.next_free', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                count = 0
                field_size = 0
                if self.list_entry.dirty:
                    count += 1
                    field_size = 8
                    data.append(self.list_entry.to_data())
                if self.aliases.dirty:
                    count += 1
                    field_size = 8
                    data.append(self.aliases.to_data())
                dirty_test = False
                if self.next_free is not None:
                    dirty_test = True
                if dirty_test:
                    count += 1
                    field_size = 4
                    data.append(self._pack(4, self.next_free.get_address()))
                if count > 1:
                    raise ElfweaverTypeException('More than one entry in the union value has been set')
                bytes_left = 8 - field_size
                for val in (8, 4, 2, 1):
                    while bytes_left >= val:
                        data.append(self._pack(val, 0))
                        bytes_left -= val

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 4
        self.list = OKL4_AnonymousType_4(this_addr, self)

        this_addr = None if address is None else self._address + 12
        self.mpointers = OKL4_list_head_t(this_addr, self)
        self.object = None
        self._rights = 0
        self._type = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.list.set_address(address + 4)
        self.mpointers.set_address(address + 12)

    _type_size = 32
    _type_alignment = 4
    _type_name = "cap"
    _type_libokl4_name = ""

    def _set_rights(self, rights_):
        """Set rights and flag this type as modified"""
        self._rights =  rights_
        self._dirty = True

    rights = property(lambda self: self._rights, _set_rights)

    def _set_type(self, type_):
        """Set type and flag this type as modified"""
        self._type =  type_
        self._dirty = True

    type = property(lambda self: self._type, _set_type)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.domain)
        self.list.patch(image, symbol, addr + 4)
        self.mpointers.patch(image, symbol, addr + 12)
        self._pointer_patch(image, symbol, 4, addr + 20, self.object)
        image.patch(symbol, self.rights, 4, addr + 24)
        image.patch(symbol, self.type, 4, addr + 28)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.list,
                name + '.list', False)
        string += self._field_to_string(self.mpointers,
                name + '.mpointers', False)
        string += self._field_to_string(self.object,
                name + '.object', True)
        string += self._field_to_string(self.rights,
                name + '.rights', False)
        string += self._field_to_string(self.type,
                name + '.type', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.domain)
        data.append(self.list.to_data())
        data.append(self.mpointers.to_data())
        self._pointer_to_data(data, 4, self.object)
        data.append(self._pack(4, self.rights))
        data.append(self._pack(4, self.type))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.list.get_phys_relocs(base_offset + self.get_offset_of('list')))
        relocs.extend(self.mpointers.get_phys_relocs(base_offset + self.get_offset_of('mpointers')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.domain is not None:
            return True
        if self.list.dirty:
            return True
        if self.mpointers.dirty:
            return True
        if self.object is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_obj_alloc_header(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct obj_alloc_header {
    word_t alloc_size;
    word_t block_header_offset;
    list_head_t block_list;
    struct obj_alloc_block_header *free_block;
    word_t pool_block_size;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "alloc_size" : {'offset': 0},
        "block_header_offset" : {'offset': 4},
        "block_list" : {'offset': 8},
        "free_block" : {'offset': 16},
        "pool_block_size" : {'offset': 20},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._alloc_size = 0
        self._block_header_offset = 0

        this_addr = None if address is None else self._address + 8
        self.block_list = OKL4_list_head_t(this_addr, self)
        self.free_block = None
        self._pool_block_size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.block_list.set_address(address + 8)

    _type_size = 24
    _type_alignment = 4
    _type_name = "obj_alloc_header"
    _type_libokl4_name = ""

    def _set_alloc_size(self, alloc_size_):
        """Set alloc_size and flag this type as modified"""
        self._alloc_size =  alloc_size_
        self._dirty = True

    alloc_size = property(lambda self: self._alloc_size, _set_alloc_size)

    def _set_block_header_offset(self, block_header_offset_):
        """Set block_header_offset and flag this type as modified"""
        self._block_header_offset =  block_header_offset_
        self._dirty = True

    block_header_offset = property(lambda self: self._block_header_offset, _set_block_header_offset)

    def _set_pool_block_size(self, pool_block_size_):
        """Set pool_block_size and flag this type as modified"""
        self._pool_block_size =  pool_block_size_
        self._dirty = True

    pool_block_size = property(lambda self: self._pool_block_size, _set_pool_block_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.alloc_size, 4, addr + 0)
        image.patch(symbol, self.block_header_offset, 4, addr + 4)
        self.block_list.patch(image, symbol, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 16, self.free_block)
        image.patch(symbol, self.pool_block_size, 4, addr + 20)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.alloc_size,
                name + '.alloc_size', False)
        string += self._field_to_string(self.block_header_offset,
                name + '.block_header_offset', False)
        string += self._field_to_string(self.block_list,
                name + '.block_list', False)
        string += self._field_to_string(self.free_block,
                name + '.free_block', True)
        string += self._field_to_string(self.pool_block_size,
                name + '.pool_block_size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.alloc_size))
        data.append(self._pack(4, self.block_header_offset))
        data.append(self.block_list.to_data())
        self._pointer_to_data(data, 4, self.free_block)
        data.append(self._pack(4, self.pool_block_size))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.block_list.get_phys_relocs(base_offset + self.get_offset_of('block_list')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.block_list.dirty:
            return True
        if self.free_block is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_obj_alloc_block_header(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct obj_alloc_block_header {
    word_t *free_object;
    list_entry_t list_entry;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "free_object" : {'offset': 0},
        "list_entry" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.free_object = None

        this_addr = None if address is None else self._address + 4
        self.list_entry = OKL4_list_entry_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.list_entry.set_address(address + 4)

    _type_size = 12
    _type_alignment = 4
    _type_name = "obj_alloc_block_header"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.free_object)
        self.list_entry.patch(image, symbol, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.free_object,
                name + '.free_object', True)
        string += self._field_to_string(self.list_entry,
                name + '.list_entry', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.free_object)
        data.append(self.list_entry.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.list_entry.get_phys_relocs(base_offset + self.get_offset_of('list_entry')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.free_object is not None:
            return True
        if self.list_entry.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_phys_attachment(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct phys_attachment {
    word_t detach_progress;
    list_entry_t list_entry;
    word_t size;
    attach_status_t status;
    void *vbase;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "detach_progress" : {'offset': 0},
        "list_entry" : {'offset': 4},
        "size" : {'offset': 12},
        "status" : {'offset': 16},
        "vbase" : {'offset': 20},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._detach_progress = 0

        this_addr = None if address is None else self._address + 4
        self.list_entry = OKL4_list_entry_t(this_addr, self)
        self._size = 0
        self._status = 0
        self.vbase = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.list_entry.set_address(address + 4)

    _type_size = 24
    _type_alignment = 4
    _type_name = "phys_attachment"
    _type_libokl4_name = ""

    def _set_detach_progress(self, detach_progress_):
        """Set detach_progress and flag this type as modified"""
        self._detach_progress =  detach_progress_
        self._dirty = True

    detach_progress = property(lambda self: self._detach_progress, _set_detach_progress)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_status(self, status_):
        """Set status and flag this type as modified"""
        self._status =  status_
        self._dirty = True

    status = property(lambda self: self._status, _set_status)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.detach_progress, 4, addr + 0)
        self.list_entry.patch(image, symbol, addr + 4)
        image.patch(symbol, self.size, 4, addr + 12)
        image.patch(symbol, self.status, 4, addr + 16)
        self._pointer_patch(image, symbol, 4, addr + 20, self.vbase)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.detach_progress,
                name + '.detach_progress', False)
        string += self._field_to_string(self.list_entry,
                name + '.list_entry', False)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.status,
                name + '.status', False)
        string += self._field_to_string(self.vbase,
                name + '.vbase', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.detach_progress))
        data.append(self.list_entry.to_data())
        data.append(self._pack(4, self.size))
        data.append(self._pack(4, self.status))
        self._pointer_to_data(data, 4, self.vbase)

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.list_entry.get_phys_relocs(base_offset + self.get_offset_of('list_entry')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.list_entry.dirty:
            return True
        if self.vbase is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_attach_status(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef sword_t attach_status_t;
#define ATTACH_STATUS_FREE ((attach_status_t)0x0UL)
#define ATTACH_STATUS_HEAP ((attach_status_t)0xffffffffUL)
#define ATTACH_STATUS_MAX_ATTACHED ((attach_status_t)0x7fffffffUL)

    """

    ATTACH_STATUS_FREE = 0
    ATTACH_STATUS_HEAP = 4294967295
    ATTACH_STATUS_MAX_ATTACHED = 2147483647

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "attach_status"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_node(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct node {
    struct node *next;
    word_t size;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "next" : {'offset': 0},
        "size" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.next = None
        self._size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "node"
    _type_libokl4_name = ""

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.next)
        image.patch(symbol, self.size, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.next,
                name + '.next', True)
        string += self._field_to_string(self.size,
                name + '.size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.next)
        data.append(self._pack(4, self.size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.next is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_segment(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct segment {
    struct objmanager_object_header header;
    struct phys_attachment attachment;
    struct {
        struct kdb_object *info;
    } kdb;
    struct {
        cache_mask_t attribs_mask;
        word_t base;
        segment_flags_t flags;
        word_t rwx_mask;
        word_t size;
    } segment;
    list_entry_t segment_list;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "attachment" : {'offset': 8},
        "kdb" : {'offset': 32},
        "segment" : {'offset': 36},
        "segment_list" : {'offset': 56},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        this_addr = None if address is None else self._address + 8
        self.attachment = OKL4_phys_attachment(this_addr, self)

        class OKL4_AnonymousType_5(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 32
        self.kdb = OKL4_AnonymousType_5(this_addr, self)

        class OKL4_AnonymousType_6(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "attribs_mask" : {'offset': 0},
                "base" : {'phys_reloc': 0, 'offset': 4},
                "flags" : {'offset': 8},
                "rwx_mask" : {'offset': 12},
                "size" : {'offset': 16},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._attribs_mask = 0
                self._base = 0
                self._flags = 0
                self._rwx_mask = 0
                self._size = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 20
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_attribs_mask(self, attribs_mask_):
                """Set attribs_mask and flag this type as modified"""
                self._attribs_mask =  attribs_mask_
                self._dirty = True

            attribs_mask = property(lambda self: self._attribs_mask, _set_attribs_mask)

            def _set_base(self, base_):
                """Set base and flag this type as modified"""
                self._base =  base_
                self._dirty = True

            base = property(lambda self: self._base, _set_base)

            def _set_flags(self, flags_):
                """Set flags and flag this type as modified"""
                self._flags =  flags_
                self._dirty = True

            flags = property(lambda self: self._flags, _set_flags)

            def _set_rwx_mask(self, rwx_mask_):
                """Set rwx_mask and flag this type as modified"""
                self._rwx_mask =  rwx_mask_
                self._dirty = True

            rwx_mask = property(lambda self: self._rwx_mask, _set_rwx_mask)

            def _set_size(self, size_):
                """Set size and flag this type as modified"""
                self._size =  size_
                self._dirty = True

            size = property(lambda self: self._size, _set_size)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.attribs_mask, 4, addr + 0)
                image.patch(symbol, self.base, 4, addr + 4)
                image.patch(symbol, self.flags, 4, addr + 8)
                image.patch(symbol, self.rwx_mask, 4, addr + 12)
                image.patch(symbol, self.size, 4, addr + 16)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.attribs_mask,
                        name + '.attribs_mask', False)
                string += self._field_to_string(self.base,
                        name + '.base', False)
                string += self._field_to_string(self.flags,
                        name + '.flags', False)
                string += self._field_to_string(self.rwx_mask,
                        name + '.rwx_mask', False)
                string += self._field_to_string(self.size,
                        name + '.size', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.attribs_mask))
                data.append(self._pack(4, self.base))
                data.append(self._pack(4, self.flags))
                data.append(self._pack(4, self.rwx_mask))
                data.append(self._pack(4, self.size))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 36
        self.segment = OKL4_AnonymousType_6(this_addr, self)

        this_addr = None if address is None else self._address + 56
        self.segment_list = OKL4_list_entry_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.attachment.set_address(address + 8)
        self.kdb.set_address(address + 32)
        self.segment.set_address(address + 36)
        self.segment_list.set_address(address + 56)

    _type_size = 64
    _type_alignment = 4
    _type_name = "segment"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.attachment.patch(image, symbol, addr + 8)
        self.kdb.patch(image, symbol, addr + 32)
        self.segment.patch(image, symbol, addr + 36)
        self.segment_list.patch(image, symbol, addr + 56)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.attachment,
                name + '.attachment', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)
        string += self._field_to_string(self.segment,
                name + '.segment', False)
        string += self._field_to_string(self.segment_list,
                name + '.segment_list', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.attachment.to_data())
        data.append(self.kdb.to_data())
        data.append(self.segment.to_data())
        data.append(self.segment_list.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.attachment.get_phys_relocs(base_offset + self.get_offset_of('attachment')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        relocs.extend(self.segment.get_phys_relocs(base_offset + self.get_offset_of('segment')))
        relocs.extend(self.segment_list.get_phys_relocs(base_offset + self.get_offset_of('segment_list')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.attachment.dirty:
            return True
        if self.kdb.dirty:
            return True
        if self.segment.dirty:
            return True
        if self.segment_list.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_segment_flags(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t segment_flags_t;
#define SEGMENT_FLAGS_NONE ((segment_flags_t)0x0UL)
#define SEGMENT_FLAGS_ALIASED ((segment_flags_t)0x1UL)

    """

    SEGMENT_FLAGS_NONE = 0
    SEGMENT_FLAGS_ALIASED = 1

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "segment_flags"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_mutex(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct mutex {
    struct objmanager_object_header header;
    struct {
        struct kdb_object *info;
    } kdb;
    struct {
        struct syncpoint condvar_wait_queue;
        word_t count;
        bool is_counted;
        struct syncpoint syncpoint;
        list_entry_t thread_list_entry;
    } mutex;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kdb" : {'offset': 8},
        "mutex" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_7(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.kdb = OKL4_AnonymousType_7(this_addr, self)

        class OKL4_AnonymousType_8(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "condvar_wait_queue" : {'offset': 0},
                "count" : {'offset': 24},
                "is_counted" : {'offset': 28},
                "syncpoint" : {'offset': 32},
                "thread_list_entry" : {'offset': 56},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.condvar_wait_queue = OKL4_syncpoint(this_addr, self)
                self._count = 0
                self._is_counted = 0

                this_addr = None if address is None else self._address + 32
                self.syncpoint = OKL4_syncpoint(this_addr, self)

                this_addr = None if address is None else self._address + 56
                self.thread_list_entry = OKL4_list_entry_t(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.condvar_wait_queue.set_address(address + 0)
                self.syncpoint.set_address(address + 32)
                self.thread_list_entry.set_address(address + 56)

            _type_size = 64
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_count(self, count_):
                """Set count and flag this type as modified"""
                self._count =  count_
                self._dirty = True

            count = property(lambda self: self._count, _set_count)

            def _set_is_counted(self, is_counted_):
                """Set is_counted and flag this type as modified"""
                self._is_counted =  is_counted_
                self._dirty = True

            is_counted = property(lambda self: self._is_counted, _set_is_counted)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.condvar_wait_queue.patch(image, symbol, addr + 0)
                image.patch(symbol, self.count, 4, addr + 24)
                image.patch(symbol, self.is_counted, 4, addr + 28)
                self.syncpoint.patch(image, symbol, addr + 32)
                self.thread_list_entry.patch(image, symbol, addr + 56)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.condvar_wait_queue,
                        name + '.condvar_wait_queue', False)
                string += self._field_to_string(self.count,
                        name + '.count', False)
                string += self._field_to_string(self.is_counted,
                        name + '.is_counted', False)
                string += self._field_to_string(self.syncpoint,
                        name + '.syncpoint', False)
                string += self._field_to_string(self.thread_list_entry,
                        name + '.thread_list_entry', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.condvar_wait_queue.to_data())
                data.append(self._pack(4, self.count))
                data.append(self._pack(4, self.is_counted))
                data.append(self.syncpoint.to_data())
                data.append(self.thread_list_entry.to_data())

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.condvar_wait_queue.get_phys_relocs(base_offset + self.get_offset_of('condvar_wait_queue')))
                relocs.extend(self.syncpoint.get_phys_relocs(base_offset + self.get_offset_of('syncpoint')))
                relocs.extend(self.thread_list_entry.get_phys_relocs(base_offset + self.get_offset_of('thread_list_entry')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.condvar_wait_queue.dirty:
                    return True
                if self.syncpoint.dirty:
                    return True
                if self.thread_list_entry.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 12
        self.mutex = OKL4_AnonymousType_8(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.kdb.set_address(address + 8)
        self.mutex.set_address(address + 12)

    _type_size = 76
    _type_alignment = 4
    _type_name = "mutex"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.kdb.patch(image, symbol, addr + 8)
        self.mutex.patch(image, symbol, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)
        string += self._field_to_string(self.mutex,
                name + '.mutex', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.kdb.to_data())
        data.append(self.mutex.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        relocs.extend(self.mutex.get_phys_relocs(base_offset + self.get_offset_of('mutex')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.kdb.dirty:
            return True
        if self.mutex.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_hybrid_mutex(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct hybrid_mutex {
    struct objmanager_object_header header;
    struct {
        struct syncpoint wait_queue;
    } condvar;
    struct {
        struct syncpoint syncpoint;
        list_entry_t thread_list_entry;
    } hybrid_mutex;
    struct {
        struct kdb_object *info;
    } kdb;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "condvar" : {'offset': 8},
        "hybrid_mutex" : {'offset': 32},
        "kdb" : {'offset': 64},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_9(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "wait_queue" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.wait_queue = OKL4_syncpoint(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.wait_queue.set_address(address + 0)

            _type_size = 24
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.wait_queue.patch(image, symbol, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.wait_queue,
                        name + '.wait_queue', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.wait_queue.to_data())

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.wait_queue.get_phys_relocs(base_offset + self.get_offset_of('wait_queue')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.wait_queue.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.condvar = OKL4_AnonymousType_9(this_addr, self)

        class OKL4_AnonymousType_10(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "syncpoint" : {'offset': 0},
                "thread_list_entry" : {'offset': 24},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.syncpoint = OKL4_syncpoint(this_addr, self)

                this_addr = None if address is None else self._address + 24
                self.thread_list_entry = OKL4_list_entry_t(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.syncpoint.set_address(address + 0)
                self.thread_list_entry.set_address(address + 24)

            _type_size = 32
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.syncpoint.patch(image, symbol, addr + 0)
                self.thread_list_entry.patch(image, symbol, addr + 24)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.syncpoint,
                        name + '.syncpoint', False)
                string += self._field_to_string(self.thread_list_entry,
                        name + '.thread_list_entry', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.syncpoint.to_data())
                data.append(self.thread_list_entry.to_data())

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.syncpoint.get_phys_relocs(base_offset + self.get_offset_of('syncpoint')))
                relocs.extend(self.thread_list_entry.get_phys_relocs(base_offset + self.get_offset_of('thread_list_entry')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.syncpoint.dirty:
                    return True
                if self.thread_list_entry.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 32
        self.hybrid_mutex = OKL4_AnonymousType_10(this_addr, self)

        class OKL4_AnonymousType_11(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 64
        self.kdb = OKL4_AnonymousType_11(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.condvar.set_address(address + 8)
        self.hybrid_mutex.set_address(address + 32)
        self.kdb.set_address(address + 64)

    _type_size = 68
    _type_alignment = 4
    _type_name = "hybrid_mutex"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.condvar.patch(image, symbol, addr + 8)
        self.hybrid_mutex.patch(image, symbol, addr + 32)
        self.kdb.patch(image, symbol, addr + 64)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.condvar,
                name + '.condvar', False)
        string += self._field_to_string(self.hybrid_mutex,
                name + '.hybrid_mutex', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.condvar.to_data())
        data.append(self.hybrid_mutex.to_data())
        data.append(self.kdb.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.condvar.get_phys_relocs(base_offset + self.get_offset_of('condvar')))
        relocs.extend(self.hybrid_mutex.get_phys_relocs(base_offset + self.get_offset_of('hybrid_mutex')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.condvar.dirty:
            return True
        if self.hybrid_mutex.dirty:
            return True
        if self.kdb.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_hybrid_user_status(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef uint32_t hybrid_user_status_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "hybrid_user_status"
    _type_libokl4_name = "hybrid_user_status"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_barrier(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct barrier {
    struct objmanager_object_header header;
    struct {
        word_t count;
        word_t count_init;
        struct syncpoint syncpoint;
    } barrier;
    struct {
        struct kdb_object *info;
    } kdb;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "barrier" : {'offset': 8},
        "kdb" : {'offset': 40},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_12(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "count" : {'offset': 0},
                "count_init" : {'offset': 4},
                "syncpoint" : {'offset': 8},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._count = 0
                self._count_init = 0

                this_addr = None if address is None else self._address + 8
                self.syncpoint = OKL4_syncpoint(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.syncpoint.set_address(address + 8)

            _type_size = 32
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_count(self, count_):
                """Set count and flag this type as modified"""
                self._count =  count_
                self._dirty = True

            count = property(lambda self: self._count, _set_count)

            def _set_count_init(self, count_init_):
                """Set count_init and flag this type as modified"""
                self._count_init =  count_init_
                self._dirty = True

            count_init = property(lambda self: self._count_init, _set_count_init)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.count, 4, addr + 0)
                image.patch(symbol, self.count_init, 4, addr + 4)
                self.syncpoint.patch(image, symbol, addr + 8)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.count,
                        name + '.count', False)
                string += self._field_to_string(self.count_init,
                        name + '.count_init', False)
                string += self._field_to_string(self.syncpoint,
                        name + '.syncpoint', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.count))
                data.append(self._pack(4, self.count_init))
                data.append(self.syncpoint.to_data())

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.syncpoint.get_phys_relocs(base_offset + self.get_offset_of('syncpoint')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.syncpoint.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.barrier = OKL4_AnonymousType_12(this_addr, self)

        class OKL4_AnonymousType_13(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 40
        self.kdb = OKL4_AnonymousType_13(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.barrier.set_address(address + 8)
        self.kdb.set_address(address + 40)

    _type_size = 44
    _type_alignment = 4
    _type_name = "barrier"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.barrier.patch(image, symbol, addr + 8)
        self.kdb.patch(image, symbol, addr + 40)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.barrier,
                name + '.barrier', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.barrier.to_data())
        data.append(self.kdb.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.barrier.get_phys_relocs(base_offset + self.get_offset_of('barrier')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.barrier.dirty:
            return True
        if self.kdb.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_reply_cap_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t reply_cap_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "reply_cap_t"
    _type_libokl4_name = "reply_cap_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_ipc_return_callback_function_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "ipc_return_callback_function_t"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_reply_token(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct reply_token {
    struct thread *client;
    union {
        list_entry_t defunct_list_entry;
    } list;
    struct reply_token *next_free;
    struct thread *server;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "client" : {'offset': 0},
        "list" : {'offset': 4},
        "next_free" : {'offset': 12},
        "server" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.client = None

        class OKL4_AnonymousType_14(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "defunct_list_entry" : {},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.defunct_list_entry = OKL4_list_entry_t(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.defunct_list_entry.set_address(address + 0)

            _type_size = 8
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                pass

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.defunct_list_entry,
                        name + '.defunct_list_entry', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                count = 0
                field_size = 0
                if self.defunct_list_entry.dirty:
                    count += 1
                    field_size = 8
                    data.append(self.defunct_list_entry.to_data())
                if count > 1:
                    raise ElfweaverTypeException('More than one entry in the union value has been set')
                bytes_left = 8 - field_size
                for val in (8, 4, 2, 1):
                    while bytes_left >= val:
                        data.append(self._pack(val, 0))
                        bytes_left -= val

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 4
        self.list = OKL4_AnonymousType_14(this_addr, self)
        self.next_free = None
        self.server = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.list.set_address(address + 4)

    _type_size = 20
    _type_alignment = 4
    _type_name = "reply_token"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.client)
        self.list.patch(image, symbol, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 12, self.next_free)
        self._pointer_patch(image, symbol, 4, addr + 16, self.server)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.client,
                name + '.client', True)
        string += self._field_to_string(self.list,
                name + '.list', False)
        string += self._field_to_string(self.next_free,
                name + '.next_free', True)
        string += self._field_to_string(self.server,
                name + '.server', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.client)
        data.append(self.list.to_data())
        self._pointer_to_data(data, 4, self.next_free)
        self._pointer_to_data(data, 4, self.server)

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.list.get_phys_relocs(base_offset + self.get_offset_of('list')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.client is not None:
            return True
        if self.list.dirty:
            return True
        if self.next_free is not None:
            return True
        if self.server is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_ipc_transferred(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long ipc_transferred_t;
#define IPC_TRANSFERRED_TRUSTED_MASK ((ipc_transferred_t)0x80000000UL)
#define IPC_TRANSFERRED_TRUSTED_BIT ((ipc_transferred_t)0x1fUL)

    """

    IPC_TRANSFERRED_TRUSTED_MASK = 2147483648
    IPC_TRANSFERRED_TRUSTED_BIT = 31

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "ipc_transferred"
    _type_libokl4_name = "ipc_transferred"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tls_thread_data(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct tls_thread_data {
    word_t pointer;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "pointer" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._pointer = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "tls_thread_data"
    _type_libokl4_name = ""

    def _set_pointer(self, pointer_):
        """Set pointer and flag this type as modified"""
        self._pointer =  pointer_
        self._dirty = True

    pointer = property(lambda self: self._pointer, _set_pointer)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.pointer, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.pointer,
                name + '.pointer', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.pointer))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_profile_control(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct profile_control {
    struct objmanager_object_header header;
    struct {
        struct kdb_object *info;
    } kdb;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kdb" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_15(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.kdb = OKL4_AnonymousType_15(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.kdb.set_address(address + 8)

    _type_size = 12
    _type_alignment = 4
    _type_name = "profile_control"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.kdb.patch(image, symbol, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.kdb.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.kdb.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_tracebuffer_control(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct tracebuffer_control {
    struct objmanager_object_header header;
    struct {
        struct kdb_object *info;
    } kdb;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kdb" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_16(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.kdb = OKL4_AnonymousType_16(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.kdb.set_address(address + 8)

    _type_size = 12
    _type_alignment = 4
    _type_name = "tracebuffer_control"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.kdb.patch(image, symbol, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.kdb.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.kdb.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_tracepoint_entry(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct tracepoint_entry {
    uint32_t time_offset;
    tracepoint_id_t id;
    tracepoint_info_t info;
    word_t data[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "time_offset" : {'offset': 0},
        "id" : {'offset': 4},
        "info" : {'offset': 8},
        "data" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._time_offset = 0
        self._id = 0
        self._info = 0
        self.data = [None] * 1

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "tracepoint_entry"
    _type_libokl4_name = "tracepoint_entry"

    def _set_time_offset(self, time_offset_):
        """Set time_offset and flag this type as modified"""
        self._time_offset =  time_offset_
        self._dirty = True

    time_offset = property(lambda self: self._time_offset, _set_time_offset)

    def _set_id(self, id_):
        """Set id and flag this type as modified"""
        self._id =  id_
        self._dirty = True

    id = property(lambda self: self._id, _set_id)

    def _set_info(self, info_):
        """Set info and flag this type as modified"""
        self._info =  info_
        self._dirty = True

    info = property(lambda self: self._info, _set_info)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.time_offset, 4, addr + 0)
        image.patch(symbol, self.id, 4, addr + 4)
        image.patch(symbol, self.info, 4, addr + 8)
        for i, item in enumerate(self.data):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.time_offset,
                name + '.time_offset', False)
        string += self._field_to_string(self.id,
                name + '.id', False)
        string += self._field_to_string(self.info,
                name + '.info', False)
        string += self._field_to_string(self.data,
                name + '.data', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.time_offset))
        data.append(self._pack(4, self.id))
        data.append(self._pack(4, self.info))
        for item in self.data:
            data.append(self._pack(4, item))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.data):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_tracepoint_id(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef uint32_t tracepoint_id_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "tracepoint_id"
    _type_libokl4_name = "tracepoint_id"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracepoint_info(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef uint32_t tracepoint_info_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "tracepoint_info"
    _type_libokl4_name = "tracepoint_info"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracepoint_event(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long tp_evt_t;
#define TP_EVT_DEBUG_EVENT ((tp_evt_t)0x0UL)
#define TP_EVT_SYS_THREAD_CREATE ((tp_evt_t)0x1UL)
#define TP_EVT_SYS_DOMAIN_CREATE ((tp_evt_t)0x2UL)
#define TP_EVT_SYS_MUTEX_CREATE ((tp_evt_t)0x3UL)
#define TP_EVT_SYS_HYBRID_MUTEX_CREATE ((tp_evt_t)0x4UL)
#define TP_EVT_SYS_MMU_CONTEXT_CREATE ((tp_evt_t)0x5UL)
#define TP_EVT_SYS_SEGMENT_CREATE ((tp_evt_t)0x6UL)
#define TP_EVT_OBJ_THREAD_CREATE ((tp_evt_t)0x7UL)
#define TP_EVT_OBJ_DOMAIN_CREATE ((tp_evt_t)0x8UL)
#define TP_EVT_OBJ_MUTEX_CREATE ((tp_evt_t)0x9UL)
#define TP_EVT_OBJ_HYBRID_MUTEX_CREATE ((tp_evt_t)0xaUL)
#define TP_EVT_OBJ_MMU_CONTEXT_CREATE ((tp_evt_t)0xbUL)
#define TP_EVT_OBJ_SEGMENT_CREATE ((tp_evt_t)0xcUL)
#define TP_EVT_OBJ_THREAD_DELETE ((tp_evt_t)0xdUL)
#define TP_EVT_OBJ_DOMAIN_DELETE ((tp_evt_t)0xeUL)
#define TP_EVT_OBJ_MUTEX_DELETE ((tp_evt_t)0xfUL)
#define TP_EVT_OBJ_HYBRID_MUTEX_DELETE ((tp_evt_t)0x10UL)
#define TP_EVT_OBJ_MMU_CONTEXT_DELETE ((tp_evt_t)0x11UL)
#define TP_EVT_OBJ_SEGMENT_DELETE ((tp_evt_t)0x12UL)
#define TP_EVT_OBJ_INTERRUPT_DELETE ((tp_evt_t)0x13UL)
#define TP_EVT_OBJ_PLATFORM_CONTROL_DELETE ((tp_evt_t)0x14UL)
#define TP_EVT_SYS_CAP_REVOKE ((tp_evt_t)0x15UL)
#define TP_EVT_SYS_CAP_COPY ((tp_evt_t)0x16UL)
#define TP_EVT_SYS_OBJECT_DELETE ((tp_evt_t)0x17UL)
#define TP_EVT_SYS_MMU_MAP_PAGE ((tp_evt_t)0x18UL)
#define TP_EVT_SYS_MMU_UNMAP_PAGE ((tp_evt_t)0x19UL)
#define TP_EVT_SYS_MMU_FLUSH_RANGE ((tp_evt_t)0x1aUL)
#define TP_EVT_SYS_SWITCH_TABLE_CREATE ((tp_evt_t)0x1bUL)
#define TP_EVT_OBJ_SWITCH_TABLE_DELETE ((tp_evt_t)0x1cUL)
#define TP_EVT_SYS_MESSAGE_QUEUE_CREATE ((tp_evt_t)0x1dUL)
#define TP_EVT_OBJ_MESSAGE_QUEUE_CREATE ((tp_evt_t)0x1eUL)
#define TP_EVT_OBJ_MESSAGE_QUEUE_DELETE ((tp_evt_t)0x1fUL)
#define TP_EVT_SYS_SEMAPHORE_CREATE ((tp_evt_t)0x20UL)
#define TP_EVT_OBJ_SEMAPHORE_CREATE ((tp_evt_t)0x21UL)
#define TP_EVT_OBJ_SEMAPHORE_DELETE ((tp_evt_t)0x22UL)
#define TP_EVT_SYS_BARRIER_CREATE ((tp_evt_t)0x23UL)
#define TP_EVT_OBJ_BARRIER_CREATE ((tp_evt_t)0x24UL)
#define TP_EVT_OBJ_BARRIER_DELETE ((tp_evt_t)0x25UL)
#define TP_EVT_SYS_CHANNEL_CREATE ((tp_evt_t)0x26UL)
#define TP_EVT_OBJ_CHANNEL_CREATE ((tp_evt_t)0x27UL)
#define TP_EVT_OBJ_CHANNEL_DELETE ((tp_evt_t)0x28UL)
#define TP_EVT_SYS_MUTEX_LOCK ((tp_evt_t)0x29UL)
#define TP_EVT_SYS_MUTEX_UNLOCK ((tp_evt_t)0x2aUL)
#define TP_EVT_SYS_MUTEX_CONDVAR_WAIT ((tp_evt_t)0x2bUL)
#define TP_EVT_SYS_MUTEX_CONDVAR_SIGNAL ((tp_evt_t)0x2cUL)
#define TP_EVT_SYS_MUTEX_CONDVAR_BROADCAST ((tp_evt_t)0x2dUL)
#define TP_EVT_MTX_MUTEX_ACQUIRE ((tp_evt_t)0x2eUL)
#define TP_EVT_MTX_MUTEX_RELEASE ((tp_evt_t)0x2fUL)
#define TP_EVT_MTX_MUTEX_INCREMENT ((tp_evt_t)0x30UL)
#define TP_EVT_MTX_MUTEX_DECREMENT ((tp_evt_t)0x31UL)
#define TP_EVT_MTX_MUTEX_BLOCK ((tp_evt_t)0x32UL)
#define TP_EVT_SYS_HYBRID_MUTEX_LOCK ((tp_evt_t)0x33UL)
#define TP_EVT_SYS_HYBRID_MUTEX_UNLOCK ((tp_evt_t)0x34UL)
#define TP_EVT_SYS_HYBRID_CONDVAR_WAIT ((tp_evt_t)0x35UL)
#define TP_EVT_SYS_HYBRID_CONDVAR_SIGNAL ((tp_evt_t)0x36UL)
#define TP_EVT_SYS_HYBRID_CONDVAR_BROADCAST ((tp_evt_t)0x37UL)
#define TP_EVT_MTX_HYBRID_MUTEX_ACQUIRE ((tp_evt_t)0x38UL)
#define TP_EVT_MTX_HYBRID_MUTEX_RELEASE ((tp_evt_t)0x39UL)
#define TP_EVT_MTX_HYBRID_MUTEX_BLOCK ((tp_evt_t)0x3aUL)
#define TP_EVT_SCH_SCHEDULER_BLOCK ((tp_evt_t)0x3bUL)
#define TP_EVT_SCH_SCHEDULER_UNBLOCK ((tp_evt_t)0x3cUL)
#define TP_EVT_SCH_CONTEXT_SWITCH ((tp_evt_t)0x3dUL)
#define TP_EVT_EXC_SWI_SYSCALL ((tp_evt_t)0x3eUL)
#define TP_EVT_EXC_PAGEFAULT ((tp_evt_t)0x3fUL)
#define TP_EVT_KDB_SET_OBJECT_NAME ((tp_evt_t)0x40UL)
#define TP_EVT_MAX ((tp_evt_t)0x41UL)

    """

    TP_EVT_DEBUG_EVENT = 0
    TP_EVT_SYS_THREAD_CREATE = 1
    TP_EVT_SYS_DOMAIN_CREATE = 2
    TP_EVT_SYS_MUTEX_CREATE = 3
    TP_EVT_SYS_HYBRID_MUTEX_CREATE = 4
    TP_EVT_SYS_MMU_CONTEXT_CREATE = 5
    TP_EVT_SYS_SEGMENT_CREATE = 6
    TP_EVT_OBJ_THREAD_CREATE = 7
    TP_EVT_OBJ_DOMAIN_CREATE = 8
    TP_EVT_OBJ_MUTEX_CREATE = 9
    TP_EVT_OBJ_HYBRID_MUTEX_CREATE = 10
    TP_EVT_OBJ_MMU_CONTEXT_CREATE = 11
    TP_EVT_OBJ_SEGMENT_CREATE = 12
    TP_EVT_OBJ_THREAD_DELETE = 13
    TP_EVT_OBJ_DOMAIN_DELETE = 14
    TP_EVT_OBJ_MUTEX_DELETE = 15
    TP_EVT_OBJ_HYBRID_MUTEX_DELETE = 16
    TP_EVT_OBJ_MMU_CONTEXT_DELETE = 17
    TP_EVT_OBJ_SEGMENT_DELETE = 18
    TP_EVT_OBJ_INTERRUPT_DELETE = 19
    TP_EVT_OBJ_PLATFORM_CONTROL_DELETE = 20
    TP_EVT_SYS_CAP_REVOKE = 21
    TP_EVT_SYS_CAP_COPY = 22
    TP_EVT_SYS_OBJECT_DELETE = 23
    TP_EVT_SYS_MMU_MAP_PAGE = 24
    TP_EVT_SYS_MMU_UNMAP_PAGE = 25
    TP_EVT_SYS_MMU_FLUSH_RANGE = 26
    TP_EVT_SYS_SWITCH_TABLE_CREATE = 27
    TP_EVT_OBJ_SWITCH_TABLE_DELETE = 28
    TP_EVT_SYS_MESSAGE_QUEUE_CREATE = 29
    TP_EVT_OBJ_MESSAGE_QUEUE_CREATE = 30
    TP_EVT_OBJ_MESSAGE_QUEUE_DELETE = 31
    TP_EVT_SYS_SEMAPHORE_CREATE = 32
    TP_EVT_OBJ_SEMAPHORE_CREATE = 33
    TP_EVT_OBJ_SEMAPHORE_DELETE = 34
    TP_EVT_SYS_BARRIER_CREATE = 35
    TP_EVT_OBJ_BARRIER_CREATE = 36
    TP_EVT_OBJ_BARRIER_DELETE = 37
    TP_EVT_SYS_CHANNEL_CREATE = 38
    TP_EVT_OBJ_CHANNEL_CREATE = 39
    TP_EVT_OBJ_CHANNEL_DELETE = 40
    TP_EVT_SYS_MUTEX_LOCK = 41
    TP_EVT_SYS_MUTEX_UNLOCK = 42
    TP_EVT_SYS_MUTEX_CONDVAR_WAIT = 43
    TP_EVT_SYS_MUTEX_CONDVAR_SIGNAL = 44
    TP_EVT_SYS_MUTEX_CONDVAR_BROADCAST = 45
    TP_EVT_MTX_MUTEX_ACQUIRE = 46
    TP_EVT_MTX_MUTEX_RELEASE = 47
    TP_EVT_MTX_MUTEX_INCREMENT = 48
    TP_EVT_MTX_MUTEX_DECREMENT = 49
    TP_EVT_MTX_MUTEX_BLOCK = 50
    TP_EVT_SYS_HYBRID_MUTEX_LOCK = 51
    TP_EVT_SYS_HYBRID_MUTEX_UNLOCK = 52
    TP_EVT_SYS_HYBRID_CONDVAR_WAIT = 53
    TP_EVT_SYS_HYBRID_CONDVAR_SIGNAL = 54
    TP_EVT_SYS_HYBRID_CONDVAR_BROADCAST = 55
    TP_EVT_MTX_HYBRID_MUTEX_ACQUIRE = 56
    TP_EVT_MTX_HYBRID_MUTEX_RELEASE = 57
    TP_EVT_MTX_HYBRID_MUTEX_BLOCK = 58
    TP_EVT_SCH_SCHEDULER_BLOCK = 59
    TP_EVT_SCH_SCHEDULER_UNBLOCK = 60
    TP_EVT_SCH_CONTEXT_SWITCH = 61
    TP_EVT_EXC_SWI_SYSCALL = 62
    TP_EVT_EXC_PAGEFAULT = 63
    TP_EVT_KDB_SET_OBJECT_NAME = 64
    TP_EVT_MAX = 65

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "tracepoint_event"
    _type_libokl4_name = "tracepoint_event"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracepoint_major(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long tracepoint_major_t;
#define TRACEPOINT_MAJOR_DEBUG ((tracepoint_major_t)0x0UL)
#define TRACEPOINT_MAJOR_OBJECT_MANAGER ((tracepoint_major_t)0x1UL)
#define TRACEPOINT_MAJOR_MMU ((tracepoint_major_t)0x2UL)
#define TRACEPOINT_MAJOR_MUTEX ((tracepoint_major_t)0x3UL)
#define TRACEPOINT_MAJOR_SCHEDULER ((tracepoint_major_t)0x4UL)
#define TRACEPOINT_MAJOR_EXCEPTION ((tracepoint_major_t)0x5UL)

    """

    TRACEPOINT_MAJOR_DEBUG = 0
    TRACEPOINT_MAJOR_OBJECT_MANAGER = 1
    TRACEPOINT_MAJOR_MMU = 2
    TRACEPOINT_MAJOR_MUTEX = 3
    TRACEPOINT_MAJOR_SCHEDULER = 4
    TRACEPOINT_MAJOR_EXCEPTION = 5

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "tracepoint_major"
    _type_libokl4_name = "tracepoint_major"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracepoint_minor(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long tracepoint_minor_t;
#define TRACEPOINT_MINOR_DEBUG_DEFAULT ((tracepoint_minor_t)0x0UL)
#define TRACEPOINT_MINOR_OBJECT_MANAGER_LIFECYCLE ((tracepoint_minor_t)0x1UL)
#define TRACEPOINT_MINOR_KDB_OBJECT_MANAGER ((tracepoint_minor_t)0x2UL)
#define TRACEPOINT_MINOR_MMU_MAPPING ((tracepoint_minor_t)0x3UL)
#define TRACEPOINT_MINOR_MUTEX_OPS ((tracepoint_minor_t)0x4UL)
#define TRACEPOINT_MINOR_HYBRID_MUTEX_OPS ((tracepoint_minor_t)0x5UL)
#define TRACEPOINT_MINOR_SCHEDULER_THREAD_STATE ((tracepoint_minor_t)0x6UL)
#define TRACEPOINT_MINOR_EXCEPTION_ENTRY ((tracepoint_minor_t)0x7UL)

    """

    TRACEPOINT_MINOR_DEBUG_DEFAULT = 0
    TRACEPOINT_MINOR_OBJECT_MANAGER_LIFECYCLE = 1
    TRACEPOINT_MINOR_KDB_OBJECT_MANAGER = 2
    TRACEPOINT_MINOR_MMU_MAPPING = 3
    TRACEPOINT_MINOR_MUTEX_OPS = 4
    TRACEPOINT_MINOR_HYBRID_MUTEX_OPS = 5
    TRACEPOINT_MINOR_SCHEDULER_THREAD_STATE = 6
    TRACEPOINT_MINOR_EXCEPTION_ENTRY = 7

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "tracepoint_minor"
    _type_libokl4_name = "tracepoint_minor"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracebuffer_header(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct tracebuffer_header {
    uint32_t magic;
    uint32_t version;
    uint32_t id;
    uint32_t num_buffers;
    uint32_t log_mask;
    uint32_t active_buffer;
    uint32_t empty_buffers;
    uint32_t buffer_size;
    word_t buffer_offsets[2];
    word_t buffer_heads[2];
    word_t buffer_wrap_counts[2];
    uint64_t buffer_timestamps[2];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "magic" : {'offset': 0},
        "version" : {'offset': 4},
        "id" : {'offset': 8},
        "num_buffers" : {'offset': 12},
        "log_mask" : {'offset': 16},
        "active_buffer" : {'offset': 20},
        "empty_buffers" : {'offset': 24},
        "buffer_size" : {'offset': 28},
        "buffer_offsets" : {'offset': 32},
        "buffer_heads" : {'offset': 40},
        "buffer_wrap_counts" : {'offset': 48},
        "buffer_timestamps" : {'offset': 56},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._magic = 0
        self._version = 0
        self._id = 0
        self._num_buffers = 0
        self._log_mask = 0
        self._active_buffer = 0
        self._empty_buffers = 0
        self._buffer_size = 0
        self.buffer_offsets = [None] * 2
        self.buffer_heads = [None] * 2
        self.buffer_wrap_counts = [None] * 2
        self.buffer_timestamps = [None] * 2

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 72
    _type_alignment = 8
    _type_name = "tracebuffer_header"
    _type_libokl4_name = "tracebuffer_header"

    def _set_magic(self, magic_):
        """Set magic and flag this type as modified"""
        self._magic =  magic_
        self._dirty = True

    magic = property(lambda self: self._magic, _set_magic)

    def _set_version(self, version_):
        """Set version and flag this type as modified"""
        self._version =  version_
        self._dirty = True

    version = property(lambda self: self._version, _set_version)

    def _set_id(self, id_):
        """Set id and flag this type as modified"""
        self._id =  id_
        self._dirty = True

    id = property(lambda self: self._id, _set_id)

    def _set_num_buffers(self, num_buffers_):
        """Set num_buffers and flag this type as modified"""
        self._num_buffers =  num_buffers_
        self._dirty = True

    num_buffers = property(lambda self: self._num_buffers, _set_num_buffers)

    def _set_log_mask(self, log_mask_):
        """Set log_mask and flag this type as modified"""
        self._log_mask =  log_mask_
        self._dirty = True

    log_mask = property(lambda self: self._log_mask, _set_log_mask)

    def _set_active_buffer(self, active_buffer_):
        """Set active_buffer and flag this type as modified"""
        self._active_buffer =  active_buffer_
        self._dirty = True

    active_buffer = property(lambda self: self._active_buffer, _set_active_buffer)

    def _set_empty_buffers(self, empty_buffers_):
        """Set empty_buffers and flag this type as modified"""
        self._empty_buffers =  empty_buffers_
        self._dirty = True

    empty_buffers = property(lambda self: self._empty_buffers, _set_empty_buffers)

    def _set_buffer_size(self, buffer_size_):
        """Set buffer_size and flag this type as modified"""
        self._buffer_size =  buffer_size_
        self._dirty = True

    buffer_size = property(lambda self: self._buffer_size, _set_buffer_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.magic, 4, addr + 0)
        image.patch(symbol, self.version, 4, addr + 4)
        image.patch(symbol, self.id, 4, addr + 8)
        image.patch(symbol, self.num_buffers, 4, addr + 12)
        image.patch(symbol, self.log_mask, 4, addr + 16)
        image.patch(symbol, self.active_buffer, 4, addr + 20)
        image.patch(symbol, self.empty_buffers, 4, addr + 24)
        image.patch(symbol, self.buffer_size, 4, addr + 28)
        for i, item in enumerate(self.buffer_offsets):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 32)
        for i, item in enumerate(self.buffer_heads):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 40)
        for i, item in enumerate(self.buffer_wrap_counts):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 48)
        for i, item in enumerate(self.buffer_timestamps):
            value = 0 if item is None else item
            image.patch(symbol, value, 8, addr + i * 8 + 56)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.magic,
                name + '.magic', False)
        string += self._field_to_string(self.version,
                name + '.version', False)
        string += self._field_to_string(self.id,
                name + '.id', False)
        string += self._field_to_string(self.num_buffers,
                name + '.num_buffers', False)
        string += self._field_to_string(self.log_mask,
                name + '.log_mask', False)
        string += self._field_to_string(self.active_buffer,
                name + '.active_buffer', False)
        string += self._field_to_string(self.empty_buffers,
                name + '.empty_buffers', False)
        string += self._field_to_string(self.buffer_size,
                name + '.buffer_size', False)
        string += self._field_to_string(self.buffer_offsets,
                name + '.buffer_offsets', False)
        string += self._field_to_string(self.buffer_heads,
                name + '.buffer_heads', False)
        string += self._field_to_string(self.buffer_wrap_counts,
                name + '.buffer_wrap_counts', False)
        string += self._field_to_string(self.buffer_timestamps,
                name + '.buffer_timestamps', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.magic))
        data.append(self._pack(4, self.version))
        data.append(self._pack(4, self.id))
        data.append(self._pack(4, self.num_buffers))
        data.append(self._pack(4, self.log_mask))
        data.append(self._pack(4, self.active_buffer))
        data.append(self._pack(4, self.empty_buffers))
        data.append(self._pack(4, self.buffer_size))
        for item in self.buffer_offsets:
            data.append(self._pack(4, item))
        for item in self.buffer_heads:
            data.append(self._pack(4, item))
        for item in self.buffer_wrap_counts:
            data.append(self._pack(4, item))
        for item in self.buffer_timestamps:
            data.append(self._pack(8, item))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.buffer_offsets):
            return True
        if self._array_dirty_test(self.buffer_heads):
            return True
        if self._array_dirty_test(self.buffer_wrap_counts):
            return True
        if self._array_dirty_test(self.buffer_timestamps):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_interrupt_notify_return_callback_function_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "interrupt_notify_return_callback_function_t"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_platform_control(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct platform_control {
    struct objmanager_object_header header;
    struct {
        struct kdb_object *info;
    } kdb;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kdb" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_17(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.kdb = OKL4_AnonymousType_17(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.kdb.set_address(address + 8)

    _type_size = 12
    _type_alignment = 4
    _type_name = "platform_control"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.kdb.patch(image, symbol, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.kdb.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.kdb.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_soc_error_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t soc_error_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "soc_error_t"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_interrupt_soc_descriptor_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t interrupt_soc_descriptor_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "interrupt_soc_descriptor_t"
    _type_libokl4_name = "interrupt_soc_descriptor_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_interrupt(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct interrupt {
    struct objmanager_object_header header;
    struct {
        word_t interrupt_number;
    } irq;
    struct {
        struct kdb_object *info;
    } kdb;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "irq" : {'offset': 8},
        "kdb" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_18(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "interrupt_number" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._interrupt_number = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_interrupt_number(self, interrupt_number_):
                """Set interrupt_number and flag this type as modified"""
                self._interrupt_number =  interrupt_number_
                self._dirty = True

            interrupt_number = property(lambda self: self._interrupt_number, _set_interrupt_number)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.interrupt_number, 4, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.interrupt_number,
                        name + '.interrupt_number', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.interrupt_number))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.irq = OKL4_AnonymousType_18(this_addr, self)

        class OKL4_AnonymousType_19(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 12
        self.kdb = OKL4_AnonymousType_19(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.irq.set_address(address + 8)
        self.kdb.set_address(address + 12)

    _type_size = 16
    _type_alignment = 4
    _type_name = "interrupt"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.irq.patch(image, symbol, addr + 8)
        self.kdb.patch(image, symbol, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.irq,
                name + '.irq', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.irq.to_data())
        data.append(self.kdb.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.irq.get_phys_relocs(base_offset + self.get_offset_of('irq')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.irq.dirty:
            return True
        if self.kdb.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_interrupt_soc_token_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t interrupt_soc_token_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "interrupt_soc_token_t"
    _type_libokl4_name = "interrupt_soc_token_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_exception_data(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct exception_data {
    word_t label;
    word_t fault;
    word_t ip;
    word_t mmu_badge;
    word_t thread_badge;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "label" : {'offset': 0},
        "fault" : {'offset': 4},
        "ip" : {'offset': 8},
        "mmu_badge" : {'offset': 12},
        "thread_badge" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._label = 0
        self._fault = 0
        self._ip = 0
        self._mmu_badge = 0
        self._thread_badge = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 20
    _type_alignment = 4
    _type_name = "exception_data"
    _type_libokl4_name = "exception_data"

    def _set_label(self, label_):
        """Set label and flag this type as modified"""
        self._label =  label_
        self._dirty = True

    label = property(lambda self: self._label, _set_label)

    def _set_fault(self, fault_):
        """Set fault and flag this type as modified"""
        self._fault =  fault_
        self._dirty = True

    fault = property(lambda self: self._fault, _set_fault)

    def _set_ip(self, ip_):
        """Set ip and flag this type as modified"""
        self._ip =  ip_
        self._dirty = True

    ip = property(lambda self: self._ip, _set_ip)

    def _set_mmu_badge(self, mmu_badge_):
        """Set mmu_badge and flag this type as modified"""
        self._mmu_badge =  mmu_badge_
        self._dirty = True

    mmu_badge = property(lambda self: self._mmu_badge, _set_mmu_badge)

    def _set_thread_badge(self, thread_badge_):
        """Set thread_badge and flag this type as modified"""
        self._thread_badge =  thread_badge_
        self._dirty = True

    thread_badge = property(lambda self: self._thread_badge, _set_thread_badge)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.label, 4, addr + 0)
        image.patch(symbol, self.fault, 4, addr + 4)
        image.patch(symbol, self.ip, 4, addr + 8)
        image.patch(symbol, self.mmu_badge, 4, addr + 12)
        image.patch(symbol, self.thread_badge, 4, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.label,
                name + '.label', False)
        string += self._field_to_string(self.fault,
                name + '.fault', False)
        string += self._field_to_string(self.ip,
                name + '.ip', False)
        string += self._field_to_string(self.mmu_badge,
                name + '.mmu_badge', False)
        string += self._field_to_string(self.thread_badge,
                name + '.thread_badge', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.label))
        data.append(self._pack(4, self.fault))
        data.append(self._pack(4, self.ip))
        data.append(self._pack(4, self.mmu_badge))
        data.append(self._pack(4, self.thread_badge))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_exc_class(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long exc_class_t;
#define EXC_CLASS_PAGEFAULT ((exc_class_t)0x0UL)
#define EXC_CLASS_DATA_ABT ((exc_class_t)0x10000000UL)
#define EXC_CLASS_PREFETCH_ABT ((exc_class_t)0x20000000UL)
#define EXC_CLASS_EXCEPTION ((exc_class_t)0x30000000UL)
#define EXC_CLASS_SYSCALL ((exc_class_t)0x40000000UL)
#define EXC_CLASS_MASK ((exc_class_t)0xf0000000UL)
#define EXC_CLASS_SWITCH_TABLE ((exc_class_t)0x50000000UL)

    """

    EXC_CLASS_PAGEFAULT = 0
    EXC_CLASS_DATA_ABT = 268435456
    EXC_CLASS_PREFETCH_ABT = 536870912
    EXC_CLASS_EXCEPTION = 805306368
    EXC_CLASS_SYSCALL = 1073741824
    EXC_CLASS_MASK = 4026531840
    EXC_CLASS_SWITCH_TABLE = 1342177280

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "exc_class"
    _type_libokl4_name = "exc_class"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_cache_type(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long cache_type_t;
#define CACHE_TYPE_L1_D ((cache_type_t)0x100UL)
#define CACHE_TYPE_L1_I ((cache_type_t)0x200UL)
#define CACHE_TYPE_L1 ((cache_type_t)0x300UL)
#define CACHE_TYPE_L2 ((cache_type_t)0xc00UL)
#define CACHE_TYPE_MASK ((cache_type_t)0xf00UL)

    """

    CACHE_TYPE_L1_D = 256
    CACHE_TYPE_L1_I = 512
    CACHE_TYPE_L1 = 768
    CACHE_TYPE_L2 = 3072
    CACHE_TYPE_MASK = 3840

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cache_type"
    _type_libokl4_name = "cache_type"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_cache_action(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long cache_action_t;
#define CACHE_ACTION_CLEAN ((cache_action_t)0x1UL)
#define CACHE_ACTION_INVALIDATE ((cache_action_t)0x2UL)
#define CACHE_ACTION_CLEAN_INVALIDATE ((cache_action_t)0x3UL)
#define CACHE_ACTION_MASK ((cache_action_t)0x3UL)

    """

    CACHE_ACTION_CLEAN = 1
    CACHE_ACTION_INVALIDATE = 2
    CACHE_ACTION_CLEAN_INVALIDATE = 3
    CACHE_ACTION_MASK = 3

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cache_action"
    _type_libokl4_name = "cache_action"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_cache_ops_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t cache_ops_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cache_ops_t"
    _type_libokl4_name = "cache_ops_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_switch_table(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct switch_table {
    struct objmanager_object_header header;
    struct {
        struct kdb_object *info;
    } kdb;
    struct switch_table_data switch_table;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kdb" : {'offset': 8},
        "switch_table" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_20(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.kdb = OKL4_AnonymousType_20(this_addr, self)

        this_addr = None if address is None else self._address + 12
        self.switch_table = OKL4_switch_table_data(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.kdb.set_address(address + 8)
        self.switch_table.set_address(address + 12)

    _type_size = 36
    _type_alignment = 4
    _type_name = "switch_table"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.kdb.patch(image, symbol, addr + 8)
        self.switch_table.patch(image, symbol, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)
        string += self._field_to_string(self.switch_table,
                name + '.switch_table', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.kdb.to_data())
        data.append(self.switch_table.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        relocs.extend(self.switch_table.get_phys_relocs(base_offset + self.get_offset_of('switch_table')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.kdb.dirty:
            return True
        if self.switch_table.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_entry_point_info(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct entry_point_info {
    word_t ip_entry;
    cpu_mode_t mode_entry;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "ip_entry" : {'offset': 0},
        "mode_entry" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._ip_entry = 0
        self._mode_entry = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "entry_point_info"
    _type_libokl4_name = ""

    def _set_ip_entry(self, ip_entry_):
        """Set ip_entry and flag this type as modified"""
        self._ip_entry =  ip_entry_
        self._dirty = True

    ip_entry = property(lambda self: self._ip_entry, _set_ip_entry)

    def _set_mode_entry(self, mode_entry_):
        """Set mode_entry and flag this type as modified"""
        self._mode_entry =  mode_entry_
        self._dirty = True

    mode_entry = property(lambda self: self._mode_entry, _set_mode_entry)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.ip_entry, 4, addr + 0)
        image.patch(symbol, self.mode_entry, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.ip_entry,
                name + '.ip_entry', False)
        string += self._field_to_string(self.mode_entry,
                name + '.mode_entry', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.ip_entry))
        data.append(self._pack(4, self.mode_entry))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_switch_table_data(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct switch_table_data {
    struct domain *dest_domain;
    struct mmu_context *dest_mmu;
    struct entry_point_info *entries;
    bool intlock;
    word_t num_entries;
    word_t return_stub_ip;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "dest_domain" : {'offset': 0},
        "dest_mmu" : {'offset': 4},
        "entries" : {'offset': 8},
        "intlock" : {'offset': 12},
        "num_entries" : {'offset': 16},
        "return_stub_ip" : {'offset': 20},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.dest_domain = None
        self.dest_mmu = None
        self.entries = None
        self._intlock = 0
        self._num_entries = 0
        self._return_stub_ip = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 24
    _type_alignment = 4
    _type_name = "switch_table_data"
    _type_libokl4_name = ""

    def _set_intlock(self, intlock_):
        """Set intlock and flag this type as modified"""
        self._intlock =  intlock_
        self._dirty = True

    intlock = property(lambda self: self._intlock, _set_intlock)

    def _set_num_entries(self, num_entries_):
        """Set num_entries and flag this type as modified"""
        self._num_entries =  num_entries_
        self._dirty = True

    num_entries = property(lambda self: self._num_entries, _set_num_entries)

    def _set_return_stub_ip(self, return_stub_ip_):
        """Set return_stub_ip and flag this type as modified"""
        self._return_stub_ip =  return_stub_ip_
        self._dirty = True

    return_stub_ip = property(lambda self: self._return_stub_ip, _set_return_stub_ip)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.dest_domain)
        self._pointer_patch(image, symbol, 4, addr + 4, self.dest_mmu)
        self._pointer_patch(image, symbol, 4, addr + 8, self.entries)
        image.patch(symbol, self.intlock, 4, addr + 12)
        image.patch(symbol, self.num_entries, 4, addr + 16)
        image.patch(symbol, self.return_stub_ip, 4, addr + 20)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.dest_domain,
                name + '.dest_domain', True)
        string += self._field_to_string(self.dest_mmu,
                name + '.dest_mmu', True)
        string += self._field_to_string(self.entries,
                name + '.entries', True)
        string += self._field_to_string(self.intlock,
                name + '.intlock', False)
        string += self._field_to_string(self.num_entries,
                name + '.num_entries', False)
        string += self._field_to_string(self.return_stub_ip,
                name + '.return_stub_ip', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.dest_domain)
        self._pointer_to_data(data, 4, self.dest_mmu)
        self._pointer_to_data(data, 4, self.entries)
        data.append(self._pack(4, self.intlock))
        data.append(self._pack(4, self.num_entries))
        data.append(self._pack(4, self.return_stub_ip))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.dest_domain is not None:
            return True
        if self.dest_mmu is not None:
            return True
        if self.entries is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_queue(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct message_queue {
    struct objmanager_object_header header;
    struct {
        bool initialised;
        struct mpointer mmu_context;
        word_t quota;
        word_t quota_used;
    } buff_area;
    struct {
        struct kdb_object *info;
    } kdb;
    struct {
        word_t head;
        word_t max_messages;
        struct async_message *msgs;
        struct syncpoint syncpoint;
        word_t tail;
    } msgq;
    struct notify_list notify_buffer_set;
    struct notify_list notify_nonempty;
    struct notify_list notify_nonfull;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "buff_area" : {'offset': 8},
        "kdb" : {'offset': 44},
        "msgq" : {'offset': 48},
        "notify_buffer_set" : {'offset': 88},
        "notify_nonempty" : {'offset': 96},
        "notify_nonfull" : {'offset': 104},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_21(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "initialised" : {'offset': 0},
                "mmu_context" : {'offset': 4},
                "quota" : {'offset': 28},
                "quota_used" : {'offset': 32},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._initialised = 0

                this_addr = None if address is None else self._address + 4
                self.mmu_context = OKL4_mpointer(this_addr, self)
                self._quota = 0
                self._quota_used = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.mmu_context.set_address(address + 4)

            _type_size = 36
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_initialised(self, initialised_):
                """Set initialised and flag this type as modified"""
                self._initialised =  initialised_
                self._dirty = True

            initialised = property(lambda self: self._initialised, _set_initialised)

            def _set_quota(self, quota_):
                """Set quota and flag this type as modified"""
                self._quota =  quota_
                self._dirty = True

            quota = property(lambda self: self._quota, _set_quota)

            def _set_quota_used(self, quota_used_):
                """Set quota_used and flag this type as modified"""
                self._quota_used =  quota_used_
                self._dirty = True

            quota_used = property(lambda self: self._quota_used, _set_quota_used)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.initialised, 4, addr + 0)
                self.mmu_context.patch(image, symbol, addr + 4)
                image.patch(symbol, self.quota, 4, addr + 28)
                image.patch(symbol, self.quota_used, 4, addr + 32)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.initialised,
                        name + '.initialised', False)
                string += self._field_to_string(self.mmu_context,
                        name + '.mmu_context', False)
                string += self._field_to_string(self.quota,
                        name + '.quota', False)
                string += self._field_to_string(self.quota_used,
                        name + '.quota_used', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.initialised))
                data.append(self.mmu_context.to_data())
                data.append(self._pack(4, self.quota))
                data.append(self._pack(4, self.quota_used))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.mmu_context.get_phys_relocs(base_offset + self.get_offset_of('mmu_context')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.mmu_context.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.buff_area = OKL4_AnonymousType_21(this_addr, self)

        class OKL4_AnonymousType_22(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 44
        self.kdb = OKL4_AnonymousType_22(this_addr, self)

        class OKL4_AnonymousType_23(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "head" : {'offset': 0},
                "max_messages" : {'offset': 4},
                "msgs" : {'offset': 8},
                "syncpoint" : {'offset': 12},
                "tail" : {'offset': 36},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._head = 0
                self._max_messages = 0
                self.msgs = None

                this_addr = None if address is None else self._address + 12
                self.syncpoint = OKL4_syncpoint(this_addr, self)
                self._tail = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.syncpoint.set_address(address + 12)

            _type_size = 40
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_head(self, head_):
                """Set head and flag this type as modified"""
                self._head =  head_
                self._dirty = True

            head = property(lambda self: self._head, _set_head)

            def _set_max_messages(self, max_messages_):
                """Set max_messages and flag this type as modified"""
                self._max_messages =  max_messages_
                self._dirty = True

            max_messages = property(lambda self: self._max_messages, _set_max_messages)

            def _set_tail(self, tail_):
                """Set tail and flag this type as modified"""
                self._tail =  tail_
                self._dirty = True

            tail = property(lambda self: self._tail, _set_tail)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.head, 4, addr + 0)
                image.patch(symbol, self.max_messages, 4, addr + 4)
                self._pointer_patch(image, symbol, 4, addr + 8, self.msgs)
                self.syncpoint.patch(image, symbol, addr + 12)
                image.patch(symbol, self.tail, 4, addr + 36)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.head,
                        name + '.head', False)
                string += self._field_to_string(self.max_messages,
                        name + '.max_messages', False)
                string += self._field_to_string(self.msgs,
                        name + '.msgs', True)
                string += self._field_to_string(self.syncpoint,
                        name + '.syncpoint', False)
                string += self._field_to_string(self.tail,
                        name + '.tail', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.head))
                data.append(self._pack(4, self.max_messages))
                self._pointer_to_data(data, 4, self.msgs)
                data.append(self.syncpoint.to_data())
                data.append(self._pack(4, self.tail))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.syncpoint.get_phys_relocs(base_offset + self.get_offset_of('syncpoint')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.msgs is not None:
                    return True
                if self.syncpoint.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 48
        self.msgq = OKL4_AnonymousType_23(this_addr, self)

        this_addr = None if address is None else self._address + 88
        self.notify_buffer_set = OKL4_notify_list(this_addr, self)

        this_addr = None if address is None else self._address + 96
        self.notify_nonempty = OKL4_notify_list(this_addr, self)

        this_addr = None if address is None else self._address + 104
        self.notify_nonfull = OKL4_notify_list(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.buff_area.set_address(address + 8)
        self.kdb.set_address(address + 44)
        self.msgq.set_address(address + 48)
        self.notify_buffer_set.set_address(address + 88)
        self.notify_nonempty.set_address(address + 96)
        self.notify_nonfull.set_address(address + 104)

    _type_size = 112
    _type_alignment = 4
    _type_name = "message_queue"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.buff_area.patch(image, symbol, addr + 8)
        self.kdb.patch(image, symbol, addr + 44)
        self.msgq.patch(image, symbol, addr + 48)
        self.notify_buffer_set.patch(image, symbol, addr + 88)
        self.notify_nonempty.patch(image, symbol, addr + 96)
        self.notify_nonfull.patch(image, symbol, addr + 104)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.buff_area,
                name + '.buff_area', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)
        string += self._field_to_string(self.msgq,
                name + '.msgq', False)
        string += self._field_to_string(self.notify_buffer_set,
                name + '.notify_buffer_set', False)
        string += self._field_to_string(self.notify_nonempty,
                name + '.notify_nonempty', False)
        string += self._field_to_string(self.notify_nonfull,
                name + '.notify_nonfull', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.buff_area.to_data())
        data.append(self.kdb.to_data())
        data.append(self.msgq.to_data())
        data.append(self.notify_buffer_set.to_data())
        data.append(self.notify_nonempty.to_data())
        data.append(self.notify_nonfull.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.buff_area.get_phys_relocs(base_offset + self.get_offset_of('buff_area')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        relocs.extend(self.msgq.get_phys_relocs(base_offset + self.get_offset_of('msgq')))
        relocs.extend(self.notify_buffer_set.get_phys_relocs(base_offset + self.get_offset_of('notify_buffer_set')))
        relocs.extend(self.notify_nonempty.get_phys_relocs(base_offset + self.get_offset_of('notify_nonempty')))
        relocs.extend(self.notify_nonfull.get_phys_relocs(base_offset + self.get_offset_of('notify_nonfull')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.buff_area.dirty:
            return True
        if self.kdb.dirty:
            return True
        if self.msgq.dirty:
            return True
        if self.notify_buffer_set.dirty:
            return True
        if self.notify_nonempty.dirty:
            return True
        if self.notify_nonfull.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_async_message_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct async_message async_message_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "payload" : {},
        "tag" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        class OKL4_AnonymousType_24(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "inline_words" : {},
                "any" : {},
                "buffer" : {},
                "capability" : {},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.inline_words = [None] * 2
                self.any = [None] * 2

                this_addr = None if address is None else self._address + 0
                self.buffer = OKL4_async_msg_buffer(this_addr, self)

                this_addr = None if address is None else self._address + 0
                self.capability = OKL4_async_message_payload_capability(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.buffer.set_address(address + 0)
                self.capability.set_address(address + 0)

            _type_size = 28
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                pass

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.inline_words,
                        name + '.inline_words', False)
                string += self._field_to_string(self.any,
                        name + '.any', False)
                string += self._field_to_string(self.buffer,
                        name + '.buffer', False)
                string += self._field_to_string(self.capability,
                        name + '.capability', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                count = 0
                field_size = 0
                dirty_test = False
                dirty_test = self._array_dirty_test(self.inline_words)
                if dirty_test:
                    count += 1
                    field_size = 8
                    for item in self.inline_words:
                        data.append(self._pack(4, item))
                dirty_test = False
                dirty_test = self._array_dirty_test(self.any)
                if dirty_test:
                    count += 1
                    field_size = 8
                    for item in self.any:
                        data.append(self._pack(4, item))
                if self.buffer.dirty:
                    count += 1
                    field_size = 16
                    data.append(self.buffer.to_data())
                if self.capability.dirty:
                    count += 1
                    field_size = 28
                    data.append(self.capability.to_data())
                if count > 1:
                    raise ElfweaverTypeException('More than one entry in the union value has been set')
                bytes_left = 28 - field_size
                for val in (8, 4, 2, 1):
                    while bytes_left >= val:
                        data.append(self._pack(val, 0))
                        bytes_left -= val

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.payload = OKL4_AnonymousType_24(this_addr, self)
        self._tag = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.payload.set_address(address + 0)

    _type_size = 32
    _type_alignment = 4
    _type_name = "async_message_t"
    _type_libokl4_name = ""

    def _set_tag(self, tag_):
        """Set tag and flag this type as modified"""
        self._tag =  tag_
        self._dirty = True

    tag = property(lambda self: self._tag, _set_tag)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.payload.patch(image, symbol, addr + 0)
        image.patch(symbol, self.tag, 4, addr + 28)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.payload,
                name + '.payload', False)
        string += self._field_to_string(self.tag,
                name + '.tag', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.payload.to_data())
        data.append(self._pack(4, self.tag))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.payload.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_async_message(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct async_message {
    union {
        word_t inline_words[2];
        word_t any[2];
        struct async_msg_buffer buffer;
        struct async_message_payload_capability capability;
    } payload;
    async_message_tag_t tag;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "payload" : {'offset': 0},
        "tag" : {'offset': 28},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        class OKL4_AnonymousType_25(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "inline_words" : {},
                "any" : {},
                "buffer" : {},
                "capability" : {},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.inline_words = [None] * 2
                self.any = [None] * 2

                this_addr = None if address is None else self._address + 0
                self.buffer = OKL4_async_msg_buffer(this_addr, self)

                this_addr = None if address is None else self._address + 0
                self.capability = OKL4_async_message_payload_capability(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.buffer.set_address(address + 0)
                self.capability.set_address(address + 0)

            _type_size = 28
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                pass

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.inline_words,
                        name + '.inline_words', False)
                string += self._field_to_string(self.any,
                        name + '.any', False)
                string += self._field_to_string(self.buffer,
                        name + '.buffer', False)
                string += self._field_to_string(self.capability,
                        name + '.capability', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                count = 0
                field_size = 0
                dirty_test = False
                dirty_test = self._array_dirty_test(self.inline_words)
                if dirty_test:
                    count += 1
                    field_size = 8
                    for item in self.inline_words:
                        data.append(self._pack(4, item))
                dirty_test = False
                dirty_test = self._array_dirty_test(self.any)
                if dirty_test:
                    count += 1
                    field_size = 8
                    for item in self.any:
                        data.append(self._pack(4, item))
                if self.buffer.dirty:
                    count += 1
                    field_size = 16
                    data.append(self.buffer.to_data())
                if self.capability.dirty:
                    count += 1
                    field_size = 28
                    data.append(self.capability.to_data())
                if count > 1:
                    raise ElfweaverTypeException('More than one entry in the union value has been set')
                bytes_left = 28 - field_size
                for val in (8, 4, 2, 1):
                    while bytes_left >= val:
                        data.append(self._pack(val, 0))
                        bytes_left -= val

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.payload = OKL4_AnonymousType_25(this_addr, self)
        self._tag = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.payload.set_address(address + 0)

    _type_size = 32
    _type_alignment = 4
    _type_name = "async_message"
    _type_libokl4_name = ""

    def _set_tag(self, tag_):
        """Set tag and flag this type as modified"""
        self._tag =  tag_
        self._dirty = True

    tag = property(lambda self: self._tag, _set_tag)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.payload.patch(image, symbol, addr + 0)
        image.patch(symbol, self.tag, 4, addr + 28)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.payload,
                name + '.payload', False)
        string += self._field_to_string(self.tag,
                name + '.tag', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.payload.to_data())
        data.append(self._pack(4, self.tag))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.payload.get_phys_relocs(base_offset + self.get_offset_of('payload')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.payload.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_async_message_tag(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long async_message_tag_t;
#define ASYNC_MESSAGE_TAG_INLINE_WORDS ((async_message_tag_t)0x0UL)
#define ASYNC_MESSAGE_TAG_ANY ((async_message_tag_t)0x1UL)
#define ASYNC_MESSAGE_TAG_BUFFER ((async_message_tag_t)0x2UL)
#define ASYNC_MESSAGE_TAG_CAPABILITY ((async_message_tag_t)0x3UL)

    """

    ASYNC_MESSAGE_TAG_INLINE_WORDS = 0
    ASYNC_MESSAGE_TAG_ANY = 1
    ASYNC_MESSAGE_TAG_BUFFER = 2
    ASYNC_MESSAGE_TAG_CAPABILITY = 3

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "async_message_tag"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_message_queue_thread_shared(ElfweaverType):
    """
    Implement a python class that represents the C type:

union message_queue_thread_shared {
    word_t pending_words[2];
    struct {
        bool block;
        word_t *buff;
        word_t buff_size;
        bool map_local;
        struct mpointer map_mmu_mpointer;
        struct mpointer map_msgq_mpointer;
        word_t map_page;
        bool mid_copy;
        word_t msg_size;
        struct message_queue *msgq;
        word_t recv_call;
        bool used_quota;
        word_t user_buff;
    } buff_area;
    struct async_message_payload_capability capability;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "pending_words" : {},
        "buff_area" : {},
        "capability" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.pending_words = [None] * 2

        class OKL4_AnonymousType_26(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "block" : {'offset': 0},
                "buff" : {'offset': 4},
                "buff_size" : {'offset': 8},
                "map_local" : {'offset': 12},
                "map_mmu_mpointer" : {'offset': 16},
                "map_msgq_mpointer" : {'offset': 40},
                "map_page" : {'offset': 64},
                "mid_copy" : {'offset': 68},
                "msg_size" : {'offset': 72},
                "msgq" : {'offset': 76},
                "recv_call" : {'offset': 80},
                "used_quota" : {'offset': 84},
                "user_buff" : {'offset': 88},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._block = 0
                self.buff = None
                self._buff_size = 0
                self._map_local = 0

                this_addr = None if address is None else self._address + 16
                self.map_mmu_mpointer = OKL4_mpointer(this_addr, self)

                this_addr = None if address is None else self._address + 40
                self.map_msgq_mpointer = OKL4_mpointer(this_addr, self)
                self._map_page = 0
                self._mid_copy = 0
                self._msg_size = 0
                self.msgq = None
                self._recv_call = 0
                self._used_quota = 0
                self._user_buff = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.map_mmu_mpointer.set_address(address + 16)
                self.map_msgq_mpointer.set_address(address + 40)

            _type_size = 92
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_block(self, block_):
                """Set block and flag this type as modified"""
                self._block =  block_
                self._dirty = True

            block = property(lambda self: self._block, _set_block)

            def _set_buff_size(self, buff_size_):
                """Set buff_size and flag this type as modified"""
                self._buff_size =  buff_size_
                self._dirty = True

            buff_size = property(lambda self: self._buff_size, _set_buff_size)

            def _set_map_local(self, map_local_):
                """Set map_local and flag this type as modified"""
                self._map_local =  map_local_
                self._dirty = True

            map_local = property(lambda self: self._map_local, _set_map_local)

            def _set_map_page(self, map_page_):
                """Set map_page and flag this type as modified"""
                self._map_page =  map_page_
                self._dirty = True

            map_page = property(lambda self: self._map_page, _set_map_page)

            def _set_mid_copy(self, mid_copy_):
                """Set mid_copy and flag this type as modified"""
                self._mid_copy =  mid_copy_
                self._dirty = True

            mid_copy = property(lambda self: self._mid_copy, _set_mid_copy)

            def _set_msg_size(self, msg_size_):
                """Set msg_size and flag this type as modified"""
                self._msg_size =  msg_size_
                self._dirty = True

            msg_size = property(lambda self: self._msg_size, _set_msg_size)

            def _set_recv_call(self, recv_call_):
                """Set recv_call and flag this type as modified"""
                self._recv_call =  recv_call_
                self._dirty = True

            recv_call = property(lambda self: self._recv_call, _set_recv_call)

            def _set_used_quota(self, used_quota_):
                """Set used_quota and flag this type as modified"""
                self._used_quota =  used_quota_
                self._dirty = True

            used_quota = property(lambda self: self._used_quota, _set_used_quota)

            def _set_user_buff(self, user_buff_):
                """Set user_buff and flag this type as modified"""
                self._user_buff =  user_buff_
                self._dirty = True

            user_buff = property(lambda self: self._user_buff, _set_user_buff)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.block, 4, addr + 0)
                self._pointer_patch(image, symbol, 4, addr + 4, self.buff)
                image.patch(symbol, self.buff_size, 4, addr + 8)
                image.patch(symbol, self.map_local, 4, addr + 12)
                self.map_mmu_mpointer.patch(image, symbol, addr + 16)
                self.map_msgq_mpointer.patch(image, symbol, addr + 40)
                image.patch(symbol, self.map_page, 4, addr + 64)
                image.patch(symbol, self.mid_copy, 4, addr + 68)
                image.patch(symbol, self.msg_size, 4, addr + 72)
                self._pointer_patch(image, symbol, 4, addr + 76, self.msgq)
                image.patch(symbol, self.recv_call, 4, addr + 80)
                image.patch(symbol, self.used_quota, 4, addr + 84)
                image.patch(symbol, self.user_buff, 4, addr + 88)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.block,
                        name + '.block', False)
                string += self._field_to_string(self.buff,
                        name + '.buff', True)
                string += self._field_to_string(self.buff_size,
                        name + '.buff_size', False)
                string += self._field_to_string(self.map_local,
                        name + '.map_local', False)
                string += self._field_to_string(self.map_mmu_mpointer,
                        name + '.map_mmu_mpointer', False)
                string += self._field_to_string(self.map_msgq_mpointer,
                        name + '.map_msgq_mpointer', False)
                string += self._field_to_string(self.map_page,
                        name + '.map_page', False)
                string += self._field_to_string(self.mid_copy,
                        name + '.mid_copy', False)
                string += self._field_to_string(self.msg_size,
                        name + '.msg_size', False)
                string += self._field_to_string(self.msgq,
                        name + '.msgq', True)
                string += self._field_to_string(self.recv_call,
                        name + '.recv_call', False)
                string += self._field_to_string(self.used_quota,
                        name + '.used_quota', False)
                string += self._field_to_string(self.user_buff,
                        name + '.user_buff', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.block))
                self._pointer_to_data(data, 4, self.buff)
                data.append(self._pack(4, self.buff_size))
                data.append(self._pack(4, self.map_local))
                data.append(self.map_mmu_mpointer.to_data())
                data.append(self.map_msgq_mpointer.to_data())
                data.append(self._pack(4, self.map_page))
                data.append(self._pack(4, self.mid_copy))
                data.append(self._pack(4, self.msg_size))
                self._pointer_to_data(data, 4, self.msgq)
                data.append(self._pack(4, self.recv_call))
                data.append(self._pack(4, self.used_quota))
                data.append(self._pack(4, self.user_buff))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.map_mmu_mpointer.get_phys_relocs(base_offset + self.get_offset_of('map_mmu_mpointer')))
                relocs.extend(self.map_msgq_mpointer.get_phys_relocs(base_offset + self.get_offset_of('map_msgq_mpointer')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.buff is not None:
                    return True
                if self.map_mmu_mpointer.dirty:
                    return True
                if self.map_msgq_mpointer.dirty:
                    return True
                if self.msgq is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.buff_area = OKL4_AnonymousType_26(this_addr, self)

        this_addr = None if address is None else self._address + 0
        self.capability = OKL4_async_message_payload_capability(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.buff_area.set_address(address + 0)
        self.capability.set_address(address + 0)

    _type_size = 92
    _type_alignment = 4
    _type_name = "message_queue_thread_shared"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        pass

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.pending_words,
                name + '.pending_words', False)
        string += self._field_to_string(self.buff_area,
                name + '.buff_area', False)
        string += self._field_to_string(self.capability,
                name + '.capability', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        count = 0
        field_size = 0
        dirty_test = False
        dirty_test = self._array_dirty_test(self.pending_words)
        if dirty_test:
            count += 1
            field_size = 8
            for item in self.pending_words:
                data.append(self._pack(4, item))
        if self.buff_area.dirty:
            count += 1
            field_size = 92
            data.append(self.buff_area.to_data())
        if self.capability.dirty:
            count += 1
            field_size = 28
            data.append(self.capability.to_data())
        if count > 1:
            raise ElfweaverTypeException('More than one entry in the union value has been set')
        bytes_left = 92 - field_size
        for val in (8, 4, 2, 1):
            while bytes_left >= val:
                data.append(self._pack(val, 0))
                bytes_left -= val

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_msgq_post_receive_callback_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "msgq_post_receive_callback_t"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_async_msg_buffer(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct async_msg_buffer {
    word_t *buff;
    word_t buff_size;
    word_t msg_size;
    bool use_quota;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "buff" : {'offset': 0},
        "buff_size" : {'offset': 4},
        "msg_size" : {'offset': 8},
        "use_quota" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.buff = None
        self._buff_size = 0
        self._msg_size = 0
        self._use_quota = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "async_msg_buffer"
    _type_libokl4_name = ""

    def _set_buff_size(self, buff_size_):
        """Set buff_size and flag this type as modified"""
        self._buff_size =  buff_size_
        self._dirty = True

    buff_size = property(lambda self: self._buff_size, _set_buff_size)

    def _set_msg_size(self, msg_size_):
        """Set msg_size and flag this type as modified"""
        self._msg_size =  msg_size_
        self._dirty = True

    msg_size = property(lambda self: self._msg_size, _set_msg_size)

    def _set_use_quota(self, use_quota_):
        """Set use_quota and flag this type as modified"""
        self._use_quota =  use_quota_
        self._dirty = True

    use_quota = property(lambda self: self._use_quota, _set_use_quota)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.buff)
        image.patch(symbol, self.buff_size, 4, addr + 4)
        image.patch(symbol, self.msg_size, 4, addr + 8)
        image.patch(symbol, self.use_quota, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.buff,
                name + '.buff', True)
        string += self._field_to_string(self.buff_size,
                name + '.buff_size', False)
        string += self._field_to_string(self.msg_size,
                name + '.msg_size', False)
        string += self._field_to_string(self.use_quota,
                name + '.use_quota', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.buff)
        data.append(self._pack(4, self.buff_size))
        data.append(self._pack(4, self.msg_size))
        data.append(self._pack(4, self.use_quota))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.buff is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_buff_area_freelist_entry(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct buff_area_freelist_entry {
    struct buff_area_freelist_entry *next;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "next" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.next = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "buff_area_freelist_entry"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.next)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.next,
                name + '.next', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.next)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.next is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_async_message_payload_capability(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct async_message_payload_capability {
    struct mpointer mpointer;
    rights_t rights;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "mpointer" : {'offset': 0},
        "rights" : {'offset': 24},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.mpointer = OKL4_mpointer(this_addr, self)
        self._rights = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.mpointer.set_address(address + 0)

    _type_size = 28
    _type_alignment = 4
    _type_name = "async_message_payload_capability"
    _type_libokl4_name = ""

    def _set_rights(self, rights_):
        """Set rights and flag this type as modified"""
        self._rights =  rights_
        self._dirty = True

    rights = property(lambda self: self._rights, _set_rights)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.mpointer.patch(image, symbol, addr + 0)
        image.patch(symbol, self.rights, 4, addr + 24)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.mpointer,
                name + '.mpointer', False)
        string += self._field_to_string(self.rights,
                name + '.rights', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.mpointer.to_data())
        data.append(self._pack(4, self.rights))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.mpointer.get_phys_relocs(base_offset + self.get_offset_of('mpointer')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.mpointer.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kdb_key_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef int_t kdb_key_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "kdb_key_t"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_kdb_object(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct kdb_object {
    list_entry_t list;
    byte_t name[12];
    void *object;
    word_t type;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "list" : {'offset': 0},
        "name" : {'offset': 8},
        "object" : {'offset': 20},
        "type" : {'offset': 24},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.list = OKL4_list_entry_t(this_addr, self)
        self.name = [None] * 12
        self.object = None
        self._type = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.list.set_address(address + 0)

    _type_size = 28
    _type_alignment = 4
    _type_name = "kdb_object"
    _type_libokl4_name = ""

    def _set_type(self, type_):
        """Set type and flag this type as modified"""
        self._type =  type_
        self._dirty = True

    type = property(lambda self: self._type, _set_type)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.list.patch(image, symbol, addr + 0)
        for i, item in enumerate(self.name):
            value = 0 if item is None else item
            image.patch(symbol, value, 1, addr + i * 1 + 8)
        self._pointer_patch(image, symbol, 4, addr + 20, self.object)
        image.patch(symbol, self.type, 4, addr + 24)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.list,
                name + '.list', False)
        string += self._field_to_string(self.name,
                name + '.name', False)
        string += self._field_to_string(self.object,
                name + '.object', True)
        string += self._field_to_string(self.type,
                name + '.type', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.list.to_data())
        for item in self.name:
            data.append(self._pack(1, item))
        self._pointer_to_data(data, 4, self.object)
        data.append(self._pack(4, self.type))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.list.get_phys_relocs(base_offset + self.get_offset_of('list')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.list.dirty:
            return True
        if self._array_dirty_test(self.name):
            return True
        if self.object is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_semaphore(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct semaphore {
    struct objmanager_object_header header;
    struct {
        struct kdb_object *info;
    } kdb;
    struct {
        struct syncpoint syncpoint;
        word_t value;
    } semaphore;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kdb" : {'offset': 8},
        "semaphore" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_27(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.kdb = OKL4_AnonymousType_27(this_addr, self)

        class OKL4_AnonymousType_28(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "syncpoint" : {'offset': 0},
                "value" : {'offset': 24},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.syncpoint = OKL4_syncpoint(this_addr, self)
                self._value = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.syncpoint.set_address(address + 0)

            _type_size = 28
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_value(self, value_):
                """Set value and flag this type as modified"""
                self._value =  value_
                self._dirty = True

            value = property(lambda self: self._value, _set_value)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.syncpoint.patch(image, symbol, addr + 0)
                image.patch(symbol, self.value, 4, addr + 24)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.syncpoint,
                        name + '.syncpoint', False)
                string += self._field_to_string(self.value,
                        name + '.value', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.syncpoint.to_data())
                data.append(self._pack(4, self.value))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.syncpoint.get_phys_relocs(base_offset + self.get_offset_of('syncpoint')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.syncpoint.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 12
        self.semaphore = OKL4_AnonymousType_28(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.kdb.set_address(address + 8)
        self.semaphore.set_address(address + 12)

    _type_size = 40
    _type_alignment = 4
    _type_name = "semaphore"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.kdb.patch(image, symbol, addr + 8)
        self.semaphore.patch(image, symbol, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)
        string += self._field_to_string(self.semaphore,
                name + '.semaphore', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.kdb.to_data())
        data.append(self.semaphore.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        relocs.extend(self.semaphore.get_phys_relocs(base_offset + self.get_offset_of('semaphore')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.kdb.dirty:
            return True
        if self.semaphore.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_notify_list_entry(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct notify_list_entry {
    list_entry_t list_entry;
    struct notify_list *notifier;
    struct thread *thread;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "list_entry" : {'offset': 0},
        "notifier" : {'offset': 8},
        "thread" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.list_entry = OKL4_list_entry_t(this_addr, self)
        self.notifier = None
        self.thread = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.list_entry.set_address(address + 0)

    _type_size = 16
    _type_alignment = 4
    _type_name = "notify_list_entry"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.list_entry.patch(image, symbol, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 8, self.notifier)
        self._pointer_patch(image, symbol, 4, addr + 12, self.thread)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.list_entry,
                name + '.list_entry', False)
        string += self._field_to_string(self.notifier,
                name + '.notifier', True)
        string += self._field_to_string(self.thread,
                name + '.thread', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.list_entry.to_data())
        self._pointer_to_data(data, 4, self.notifier)
        self._pointer_to_data(data, 4, self.thread)

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.list_entry.get_phys_relocs(base_offset + self.get_offset_of('list_entry')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.list_entry.dirty:
            return True
        if self.notifier is not None:
            return True
        if self.thread is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_notify_list(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct notify_list {
    list_head_t notifiees;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "notifiees" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.notifiees = OKL4_list_head_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.notifiees.set_address(address + 0)

    _type_size = 8
    _type_alignment = 4
    _type_name = "notify_list"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.notifiees.patch(image, symbol, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.notifiees,
                name + '.notifiees', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.notifiees.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.notifiees.get_phys_relocs(base_offset + self.get_offset_of('notifiees')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.notifiees.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_processor_control(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct processor_control {
    struct objmanager_object_header header;
    struct {
        struct kdb_object *info;
    } kdb;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kdb" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_29(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.kdb = OKL4_AnonymousType_29(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.kdb.set_address(address + 8)

    _type_size = 12
    _type_alignment = 4
    _type_name = "processor_control"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.kdb.patch(image, symbol, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.kdb.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.kdb.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_critical_section(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct critical_section {
    atomic_word_t state;
    word_t write_test;
    word_t count;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "state" : {'offset': 0},
        "write_test" : {'offset': 4},
        "count" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.state = OKL4_atomic_word_t(this_addr, self)
        self._write_test = 0
        self._count = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.state.set_address(address + 0)

    _type_size = 12
    _type_alignment = 4
    _type_name = "critical_section"
    _type_libokl4_name = "critical_section"

    def _set_write_test(self, write_test_):
        """Set write_test and flag this type as modified"""
        self._write_test =  write_test_
        self._dirty = True

    write_test = property(lambda self: self._write_test, _set_write_test)

    def _set_count(self, count_):
        """Set count and flag this type as modified"""
        self._count =  count_
        self._dirty = True

    count = property(lambda self: self._count, _set_count)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.state.patch(image, symbol, addr + 0)
        image.patch(symbol, self.write_test, 4, addr + 4)
        image.patch(symbol, self.count, 4, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.state,
                name + '.state', False)
        string += self._field_to_string(self.write_test,
                name + '.write_test', False)
        string += self._field_to_string(self.count,
                name + '.count', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.state.to_data())
        data.append(self._pack(4, self.write_test))
        data.append(self._pack(4, self.count))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.state.get_phys_relocs(base_offset + self.get_offset_of('state')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.state.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_error_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t error_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "error_t"
    _type_libokl4_name = "error_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_global(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct global {
    word_t preemption_check_enabled;
    uint32_t trace_info;
    struct thread *current_thread;
    word_t dcache_size_log2;
    word_t dcache_ways_log2;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "preemption_check_enabled" : {'offset': 0},
        "trace_info" : {'offset': 4},
        "current_thread" : {'offset': 8},
        "dcache_size_log2" : {'offset': 12},
        "dcache_ways_log2" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._preemption_check_enabled = 0
        self._trace_info = 0
        self.current_thread = None
        self._dcache_size_log2 = 0
        self._dcache_ways_log2 = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 20
    _type_alignment = 4
    _type_name = "global"
    _type_libokl4_name = ""

    def _set_preemption_check_enabled(self, preemption_check_enabled_):
        """Set preemption_check_enabled and flag this type as modified"""
        self._preemption_check_enabled =  preemption_check_enabled_
        self._dirty = True

    preemption_check_enabled = property(lambda self: self._preemption_check_enabled, _set_preemption_check_enabled)

    def _set_trace_info(self, trace_info_):
        """Set trace_info and flag this type as modified"""
        self._trace_info =  trace_info_
        self._dirty = True

    trace_info = property(lambda self: self._trace_info, _set_trace_info)

    def _set_dcache_size_log2(self, dcache_size_log2_):
        """Set dcache_size_log2 and flag this type as modified"""
        self._dcache_size_log2 =  dcache_size_log2_
        self._dirty = True

    dcache_size_log2 = property(lambda self: self._dcache_size_log2, _set_dcache_size_log2)

    def _set_dcache_ways_log2(self, dcache_ways_log2_):
        """Set dcache_ways_log2 and flag this type as modified"""
        self._dcache_ways_log2 =  dcache_ways_log2_
        self._dirty = True

    dcache_ways_log2 = property(lambda self: self._dcache_ways_log2, _set_dcache_ways_log2)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.preemption_check_enabled, 4, addr + 0)
        image.patch(symbol, self.trace_info, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.current_thread)
        image.patch(symbol, self.dcache_size_log2, 4, addr + 12)
        image.patch(symbol, self.dcache_ways_log2, 4, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.preemption_check_enabled,
                name + '.preemption_check_enabled', False)
        string += self._field_to_string(self.trace_info,
                name + '.trace_info', False)
        string += self._field_to_string(self.current_thread,
                name + '.current_thread', True)
        string += self._field_to_string(self.dcache_size_log2,
                name + '.dcache_size_log2', False)
        string += self._field_to_string(self.dcache_ways_log2,
                name + '.dcache_ways_log2', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.preemption_check_enabled))
        data.append(self._pack(4, self.trace_info))
        self._pointer_to_data(data, 4, self.current_thread)
        data.append(self._pack(4, self.dcache_size_log2))
        data.append(self._pack(4, self.dcache_ways_log2))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.current_thread is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_restart_function_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "restart_function_t"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_pause_callback_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "pause_callback_t"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_list_entry_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct list_entry list_entry_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "next" : {},
        "prev" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.next = None
        self.prev = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "list_entry_t"
    _type_libokl4_name = "list_entry_t"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.next)
        self._pointer_patch(image, symbol, 4, addr + 4, self.prev)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.next,
                name + '.next', True)
        string += self._field_to_string(self.prev,
                name + '.prev', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        if self.next is None:
            data.append(self._pack(4, 0xdededede))
        else:
            if isinstance(self.next, list):
                data.append(self._pack(4, self.next[0].get_address()))
            else:
                data.append(self._pack(4, self.next.get_address()))
        if self.prev is None:
            data.append(self._pack(4, 0xdededede))
        else:
            if isinstance(self.prev, list):
                data.append(self._pack(4, self.prev[0].get_address()))
            else:
                data.append(self._pack(4, self.prev.get_address()))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.next is not None:
            return True
        if self.prev is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_list_head_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct list_entry list_head_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "next" : {},
        "prev" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.next = None
        self.prev = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "list_head_t"
    _type_libokl4_name = "list_head_t"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.next)
        self._pointer_patch(image, symbol, 4, addr + 4, self.prev)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.next,
                name + '.next', True)
        string += self._field_to_string(self.prev,
                name + '.prev', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        if self.next is None:
            data.append(self._pack(4, self._address))
        else:
            data.append(self._pack(4, self.next.get_address()))
        if self.prev is None:
            data.append(self._pack(4, self._address))
        else:
            data.append(self._pack(4, self.prev.get_address()))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.next is not None:
            return True
        if self.prev is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_list_entry(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct MAY_ALIAS list_entry {
    struct list_entry *next;
    struct list_entry *prev;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "next" : {'offset': 0},
        "prev" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.next = None
        self.prev = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "list_entry"
    _type_libokl4_name = "list_entry"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.next)
        self._pointer_patch(image, symbol, 4, addr + 4, self.prev)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.next,
                name + '.next', True)
        string += self._field_to_string(self.prev,
                name + '.prev', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        if self.next is None:
            data.append(self._pack(4, 0xdededede))
        else:
            if isinstance(self.next, list):
                data.append(self._pack(4, self.next[0].get_address()))
            else:
                data.append(self._pack(4, self.next.get_address()))
        if self.prev is None:
            data.append(self._pack(4, 0xdededede))
        else:
            if isinstance(self.prev, list):
                data.append(self._pack(4, self.prev[0].get_address()))
            else:
                data.append(self._pack(4, self.prev.get_address()))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.next is not None:
            return True
        if self.prev is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_cpu_local(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct cpu_local {
    volatile word_t pending_interrupt;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "pending_interrupt" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._pending_interrupt = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cpu_local"
    _type_libokl4_name = ""

    def _set_pending_interrupt(self, pending_interrupt_):
        """Set pending_interrupt and flag this type as modified"""
        self._pending_interrupt =  pending_interrupt_
        self._dirty = True

    pending_interrupt = property(lambda self: self._pending_interrupt, _set_pending_interrupt)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.pending_interrupt, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.pending_interrupt,
                name + '.pending_interrupt', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.pending_interrupt))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_phys_reloc(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long phys_reloc_t;
#define PHYS_RELOC_VERSION ((phys_reloc_t)0x1UL)
#define PHYS_RELOC_ABS ((phys_reloc_t)0x0UL)
#define PHYS_RELOC_UNKNOWN ((phys_reloc_t)0x2UL)
#define PHYS_RELOC_ARMV6_L1_16MPAGE ((phys_reloc_t)0x3UL)
#define PHYS_RELOC_ARMV6_L1_1MPAGE ((phys_reloc_t)0x4UL)
#define PHYS_RELOC_ARMV6_L1_L2TABLE ((phys_reloc_t)0x5UL)
#define PHYS_RELOC_ARMV6_L2_64KPAGE ((phys_reloc_t)0x6UL)
#define PHYS_RELOC_ARMV6_L2_4KPAGE ((phys_reloc_t)0x7UL)

    """

    PHYS_RELOC_VERSION = 1
    PHYS_RELOC_ABS = 0
    PHYS_RELOC_UNKNOWN = 2
    PHYS_RELOC_ARMV6_L1_16MPAGE = 3
    PHYS_RELOC_ARMV6_L1_1MPAGE = 4
    PHYS_RELOC_ARMV6_L1_L2TABLE = 5
    PHYS_RELOC_ARMV6_L2_64KPAGE = 6
    PHYS_RELOC_ARMV6_L2_4KPAGE = 7

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "phys_reloc"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_phys_relocation(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct phys_relocation {
    word_t addr;
    phys_reloc_t type;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "addr" : {'offset': 0},
        "type" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._addr = 0
        self._type = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "phys_relocation"
    _type_libokl4_name = ""

    def _set_addr(self, addr_):
        """Set addr and flag this type as modified"""
        self._addr =  addr_
        self._dirty = True

    addr = property(lambda self: self._addr, _set_addr)

    def _set_type(self, type_):
        """Set type and flag this type as modified"""
        self._type =  type_
        self._dirty = True

    type = property(lambda self: self._type, _set_type)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.addr, 4, addr + 0)
        image.patch(symbol, self.type, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.addr,
                name + '.addr', False)
        string += self._field_to_string(self.type,
                name + '.type', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.addr))
        data.append(self._pack(4, self.type))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_thread(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct thread {
    struct objmanager_object_header header;
    struct {
        struct registers reg;
        void (*restart_function)(void) NORETURN;
    } hal;
    struct {
        error_t error;
        struct barrier *waiting_for;
    } barrier;
    struct {
        word_t address;
        word_t cur_address;
        word_t cur_remaining;
        bool flush_by_range;
        struct mpointer mmu_being_flushed;
        cache_ops_t operation;
        word_t physical_address;
        word_t size;
        word_t state;
    } cache;
    struct {
        struct mpointer cap_to_delete;
    } cap_transfer;
    struct {
        word_t condvar;
    } condvar;
    struct {
        word_t count;
        word_t write_test;
        atomic_word_t state;
        struct syncpoint syncpoint;
        designator_t me;
        bool is_blocked;
        word_t error;
        void *critsect;
    } critsect;
    struct {
        word_t badge;
        bool exception_failure;
        struct mpointer handler;
        struct exception_data data;
    } exception;
    struct {
        error_t error;
        list_head_t head;
        bool is_waiting;
        word_t tag;
        hybrid_user_status_t *user_state;
    } hybrid_mutex;
    struct {
        sword_t delivered_number;
        bool received;
        void (*restart_function)(void) NORETURN;
        word_t return_val;
        bool waiting;
    } interrupt;
    struct {
        bool calling;
        list_head_t defunct_reply_tokens;
        word_t error;
        void (*ipc_return_callback)(word_t current, error_t success, word_t tag, word_t from, word_t transferred) NORETURN;
        bool kernel_buffer;
        word_t rcv_buffer;
        struct syncpoint rcv_syncpoint;
        word_t rcv_words;
        struct reply_token *reply_token;
        bool sending;
        word_t snd_buffer;
        struct syncpoint snd_syncpoint;
        word_t snd_words;
        word_t tag;
        word_t token_count;
        word_t transferred;
        bool trusted;
        struct reply_token *wait_token;
        bool waiting;
        struct thread *waiting_for;
        bool was_notify;
    } ipc;
    struct {
        struct kdb_object *info;
    } kdb;
    struct mmu_thread_data mmu;
    struct {
        designator_t msgq_cap;
        void (*post_receive_func)(void);
        union message_queue_thread_shared shared;
        word_t waiting_callback;
        async_message_tag_t waiting_msg_type;
    } msgq;
    struct {
        error_t error;
        list_head_t head;
        struct mutex *waiting_for;
    } mutex;
    struct {
        word_t mask;
        word_t signals;
        bool waiting;
    } notify;
    struct {
        struct notify_list_entry entry[16];
    } notify_service;
    struct {
        bool being_deleted;
        struct mpointer blocked_on;
        struct mpointer deleting_object;
        struct domain *domain;
        void *object_being_created;
        union {
            struct {
                word_t num_segments;
                designator_t intlock_cap;
            } mmu_context;
            struct {
                word_t clist_entries;
                word_t max_prio;
                word_t reply_token_table_entries;
            } domain;
            struct {
                designator_t domain_id;
                designator_t mmu_context_id;
                word_t num_entries;
                word_t return_stub_ip;
                bool intlock;
            } switch_table;
        } object_creation_params;
        objtype_t object_type_being_created;
    } objmanager;
    struct thread_scheduler_data scheduler;
    struct {
        error_t error;
        struct semaphore *waiting_for;
    } semaphore;
    struct {
        word_t tls;
    } soc;
    struct {
        suspend_count_t count;
    } suspend;
    struct {
        word_t alt_tls;
        struct domain *caller_domain;
        struct mmu_context *caller_mmu;
        cpu_mode_t caller_mode;
        word_t caller_pc;
    } switch_table;
    struct {
        word_t totaltime_high;
        word_t totaltime_low;
        word_t val_timetest;
    } thread_profile;
    struct tls_thread_data tls;
    struct {
        bool allowed;
    } useraccess;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "hal" : {'offset': 8},
        "barrier" : {'offset': 80},
        "cache" : {'offset': 88},
        "cap_transfer" : {'offset': 144},
        "condvar" : {'offset': 168},
        "critsect" : {'offset': 172},
        "exception" : {'offset': 224},
        "hybrid_mutex" : {'offset': 276},
        "interrupt" : {'offset': 300},
        "ipc" : {'offset': 320},
        "kdb" : {'offset': 448},
        "mmu" : {'offset': 452},
        "msgq" : {'offset': 508},
        "mutex" : {'offset': 616},
        "notify" : {'offset': 632},
        "notify_service" : {'offset': 644},
        "objmanager" : {'offset': 900},
        "scheduler" : {'offset': 984},
        "semaphore" : {'offset': 1048},
        "soc" : {'offset': 1056},
        "suspend" : {'offset': 1060},
        "switch_table" : {'offset': 1064},
        "thread_profile" : {'offset': 1084},
        "tls" : {'offset': 1096},
        "useraccess" : {'offset': 1100},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_30(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "reg" : {'offset': 0},
                "restart_function" : {'offset': 68},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.reg = OKL4_registers(this_addr, self)
                self.restart_function = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.reg.set_address(address + 0)

            _type_size = 72
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.reg.patch(image, symbol, addr + 0)
                self._pointer_patch(image, symbol, 4, addr + 68, self.restart_function)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.reg,
                        name + '.reg', False)
                string += self._field_to_string(self.restart_function,
                        name + '.restart_function', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.reg.to_data())
                self._pointer_to_data(data, 4, self.restart_function)

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.reg.get_phys_relocs(base_offset + self.get_offset_of('reg')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.reg.dirty:
                    return True
                if self.restart_function is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.hal = OKL4_AnonymousType_30(this_addr, self)

        class OKL4_AnonymousType_31(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "error" : {'offset': 0},
                "waiting_for" : {'offset': 4},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._error = 0
                self.waiting_for = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 8
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_error(self, error_):
                """Set error and flag this type as modified"""
                self._error =  error_
                self._dirty = True

            error = property(lambda self: self._error, _set_error)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.error, 4, addr + 0)
                self._pointer_patch(image, symbol, 4, addr + 4, self.waiting_for)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.error,
                        name + '.error', False)
                string += self._field_to_string(self.waiting_for,
                        name + '.waiting_for', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.error))
                self._pointer_to_data(data, 4, self.waiting_for)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.waiting_for is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 80
        self.barrier = OKL4_AnonymousType_31(this_addr, self)

        class OKL4_AnonymousType_32(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "address" : {'offset': 0},
                "cur_address" : {'offset': 4},
                "cur_remaining" : {'offset': 8},
                "flush_by_range" : {'offset': 12},
                "mmu_being_flushed" : {'offset': 16},
                "operation" : {'offset': 40},
                "physical_address" : {'offset': 44},
                "size" : {'offset': 48},
                "state" : {'offset': 52},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._address = 0
                self._cur_address = 0
                self._cur_remaining = 0
                self._flush_by_range = 0

                this_addr = None if address is None else self._address + 16
                self.mmu_being_flushed = OKL4_mpointer(this_addr, self)
                self._operation = 0
                self._physical_address = 0
                self._size = 0
                self._state = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.mmu_being_flushed.set_address(address + 16)

            _type_size = 56
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_address(self, address_):
                """Set address and flag this type as modified"""
                self._address =  address_
                self._dirty = True

            address = property(lambda self: self._address, _set_address)

            def _set_cur_address(self, cur_address_):
                """Set cur_address and flag this type as modified"""
                self._cur_address =  cur_address_
                self._dirty = True

            cur_address = property(lambda self: self._cur_address, _set_cur_address)

            def _set_cur_remaining(self, cur_remaining_):
                """Set cur_remaining and flag this type as modified"""
                self._cur_remaining =  cur_remaining_
                self._dirty = True

            cur_remaining = property(lambda self: self._cur_remaining, _set_cur_remaining)

            def _set_flush_by_range(self, flush_by_range_):
                """Set flush_by_range and flag this type as modified"""
                self._flush_by_range =  flush_by_range_
                self._dirty = True

            flush_by_range = property(lambda self: self._flush_by_range, _set_flush_by_range)

            def _set_operation(self, operation_):
                """Set operation and flag this type as modified"""
                self._operation =  operation_
                self._dirty = True

            operation = property(lambda self: self._operation, _set_operation)

            def _set_physical_address(self, physical_address_):
                """Set physical_address and flag this type as modified"""
                self._physical_address =  physical_address_
                self._dirty = True

            physical_address = property(lambda self: self._physical_address, _set_physical_address)

            def _set_size(self, size_):
                """Set size and flag this type as modified"""
                self._size =  size_
                self._dirty = True

            size = property(lambda self: self._size, _set_size)

            def _set_state(self, state_):
                """Set state and flag this type as modified"""
                self._state =  state_
                self._dirty = True

            state = property(lambda self: self._state, _set_state)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.address, 4, addr + 0)
                image.patch(symbol, self.cur_address, 4, addr + 4)
                image.patch(symbol, self.cur_remaining, 4, addr + 8)
                image.patch(symbol, self.flush_by_range, 4, addr + 12)
                self.mmu_being_flushed.patch(image, symbol, addr + 16)
                image.patch(symbol, self.operation, 4, addr + 40)
                image.patch(symbol, self.physical_address, 4, addr + 44)
                image.patch(symbol, self.size, 4, addr + 48)
                image.patch(symbol, self.state, 4, addr + 52)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.address,
                        name + '.address', False)
                string += self._field_to_string(self.cur_address,
                        name + '.cur_address', False)
                string += self._field_to_string(self.cur_remaining,
                        name + '.cur_remaining', False)
                string += self._field_to_string(self.flush_by_range,
                        name + '.flush_by_range', False)
                string += self._field_to_string(self.mmu_being_flushed,
                        name + '.mmu_being_flushed', False)
                string += self._field_to_string(self.operation,
                        name + '.operation', False)
                string += self._field_to_string(self.physical_address,
                        name + '.physical_address', False)
                string += self._field_to_string(self.size,
                        name + '.size', False)
                string += self._field_to_string(self.state,
                        name + '.state', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.address))
                data.append(self._pack(4, self.cur_address))
                data.append(self._pack(4, self.cur_remaining))
                data.append(self._pack(4, self.flush_by_range))
                data.append(self.mmu_being_flushed.to_data())
                data.append(self._pack(4, self.operation))
                data.append(self._pack(4, self.physical_address))
                data.append(self._pack(4, self.size))
                data.append(self._pack(4, self.state))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.mmu_being_flushed.get_phys_relocs(base_offset + self.get_offset_of('mmu_being_flushed')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.mmu_being_flushed.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 88
        self.cache = OKL4_AnonymousType_32(this_addr, self)

        class OKL4_AnonymousType_33(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "cap_to_delete" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.cap_to_delete = OKL4_mpointer(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.cap_to_delete.set_address(address + 0)

            _type_size = 24
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.cap_to_delete.patch(image, symbol, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.cap_to_delete,
                        name + '.cap_to_delete', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.cap_to_delete.to_data())

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.cap_to_delete.get_phys_relocs(base_offset + self.get_offset_of('cap_to_delete')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.cap_to_delete.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 144
        self.cap_transfer = OKL4_AnonymousType_33(this_addr, self)

        class OKL4_AnonymousType_34(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "condvar" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._condvar = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_condvar(self, condvar_):
                """Set condvar and flag this type as modified"""
                self._condvar =  condvar_
                self._dirty = True

            condvar = property(lambda self: self._condvar, _set_condvar)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.condvar, 4, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.condvar,
                        name + '.condvar', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.condvar))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 168
        self.condvar = OKL4_AnonymousType_34(this_addr, self)

        class OKL4_AnonymousType_35(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "count" : {'offset': 0},
                "write_test" : {'offset': 4},
                "state" : {'offset': 8},
                "syncpoint" : {'offset': 12},
                "me" : {'offset': 36},
                "is_blocked" : {'offset': 40},
                "error" : {'offset': 44},
                "critsect" : {'offset': 48},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._count = 0
                self._write_test = 0

                this_addr = None if address is None else self._address + 8
                self.state = OKL4_atomic_word_t(this_addr, self)

                this_addr = None if address is None else self._address + 12
                self.syncpoint = OKL4_syncpoint(this_addr, self)
                self._me = 0
                self._is_blocked = 0
                self._error = 0
                self.critsect = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.state.set_address(address + 8)
                self.syncpoint.set_address(address + 12)

            _type_size = 52
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_count(self, count_):
                """Set count and flag this type as modified"""
                self._count =  count_
                self._dirty = True

            count = property(lambda self: self._count, _set_count)

            def _set_write_test(self, write_test_):
                """Set write_test and flag this type as modified"""
                self._write_test =  write_test_
                self._dirty = True

            write_test = property(lambda self: self._write_test, _set_write_test)

            def _set_me(self, me_):
                """Set me and flag this type as modified"""
                self._me =  me_
                self._dirty = True

            me = property(lambda self: self._me, _set_me)

            def _set_is_blocked(self, is_blocked_):
                """Set is_blocked and flag this type as modified"""
                self._is_blocked =  is_blocked_
                self._dirty = True

            is_blocked = property(lambda self: self._is_blocked, _set_is_blocked)

            def _set_error(self, error_):
                """Set error and flag this type as modified"""
                self._error =  error_
                self._dirty = True

            error = property(lambda self: self._error, _set_error)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.count, 4, addr + 0)
                image.patch(symbol, self.write_test, 4, addr + 4)
                self.state.patch(image, symbol, addr + 8)
                self.syncpoint.patch(image, symbol, addr + 12)
                image.patch(symbol, self.me, 4, addr + 36)
                image.patch(symbol, self.is_blocked, 4, addr + 40)
                image.patch(symbol, self.error, 4, addr + 44)
                self._pointer_patch(image, symbol, 4, addr + 48, self.critsect)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.count,
                        name + '.count', False)
                string += self._field_to_string(self.write_test,
                        name + '.write_test', False)
                string += self._field_to_string(self.state,
                        name + '.state', False)
                string += self._field_to_string(self.syncpoint,
                        name + '.syncpoint', False)
                string += self._field_to_string(self.me,
                        name + '.me', False)
                string += self._field_to_string(self.is_blocked,
                        name + '.is_blocked', False)
                string += self._field_to_string(self.error,
                        name + '.error', False)
                string += self._field_to_string(self.critsect,
                        name + '.critsect', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.count))
                data.append(self._pack(4, self.write_test))
                data.append(self.state.to_data())
                data.append(self.syncpoint.to_data())
                data.append(self._pack(4, self.me))
                data.append(self._pack(4, self.is_blocked))
                data.append(self._pack(4, self.error))
                self._pointer_to_data(data, 4, self.critsect)

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.state.get_phys_relocs(base_offset + self.get_offset_of('state')))
                relocs.extend(self.syncpoint.get_phys_relocs(base_offset + self.get_offset_of('syncpoint')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.state.dirty:
                    return True
                if self.syncpoint.dirty:
                    return True
                if self.critsect is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 172
        self.critsect = OKL4_AnonymousType_35(this_addr, self)

        class OKL4_AnonymousType_36(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "badge" : {'offset': 0},
                "exception_failure" : {'offset': 4},
                "handler" : {'offset': 8},
                "data" : {'offset': 32},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._badge = 0
                self._exception_failure = 0

                this_addr = None if address is None else self._address + 8
                self.handler = OKL4_mpointer(this_addr, self)

                this_addr = None if address is None else self._address + 32
                self.data = OKL4_exception_data(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.handler.set_address(address + 8)
                self.data.set_address(address + 32)

            _type_size = 52
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_badge(self, badge_):
                """Set badge and flag this type as modified"""
                self._badge =  badge_
                self._dirty = True

            badge = property(lambda self: self._badge, _set_badge)

            def _set_exception_failure(self, exception_failure_):
                """Set exception_failure and flag this type as modified"""
                self._exception_failure =  exception_failure_
                self._dirty = True

            exception_failure = property(lambda self: self._exception_failure, _set_exception_failure)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.badge, 4, addr + 0)
                image.patch(symbol, self.exception_failure, 4, addr + 4)
                self.handler.patch(image, symbol, addr + 8)
                self.data.patch(image, symbol, addr + 32)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.badge,
                        name + '.badge', False)
                string += self._field_to_string(self.exception_failure,
                        name + '.exception_failure', False)
                string += self._field_to_string(self.handler,
                        name + '.handler', False)
                string += self._field_to_string(self.data,
                        name + '.data', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.badge))
                data.append(self._pack(4, self.exception_failure))
                data.append(self.handler.to_data())
                data.append(self.data.to_data())

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.handler.get_phys_relocs(base_offset + self.get_offset_of('handler')))
                relocs.extend(self.data.get_phys_relocs(base_offset + self.get_offset_of('data')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.handler.dirty:
                    return True
                if self.data.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 224
        self.exception = OKL4_AnonymousType_36(this_addr, self)

        class OKL4_AnonymousType_37(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "error" : {'offset': 0},
                "head" : {'offset': 4},
                "is_waiting" : {'offset': 12},
                "tag" : {'offset': 16},
                "user_state" : {'offset': 20},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._error = 0

                this_addr = None if address is None else self._address + 4
                self.head = OKL4_list_head_t(this_addr, self)
                self._is_waiting = 0
                self._tag = 0
                self.user_state = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.head.set_address(address + 4)

            _type_size = 24
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_error(self, error_):
                """Set error and flag this type as modified"""
                self._error =  error_
                self._dirty = True

            error = property(lambda self: self._error, _set_error)

            def _set_is_waiting(self, is_waiting_):
                """Set is_waiting and flag this type as modified"""
                self._is_waiting =  is_waiting_
                self._dirty = True

            is_waiting = property(lambda self: self._is_waiting, _set_is_waiting)

            def _set_tag(self, tag_):
                """Set tag and flag this type as modified"""
                self._tag =  tag_
                self._dirty = True

            tag = property(lambda self: self._tag, _set_tag)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.error, 4, addr + 0)
                self.head.patch(image, symbol, addr + 4)
                image.patch(symbol, self.is_waiting, 4, addr + 12)
                image.patch(symbol, self.tag, 4, addr + 16)
                self._pointer_patch(image, symbol, 4, addr + 20, self.user_state)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.error,
                        name + '.error', False)
                string += self._field_to_string(self.head,
                        name + '.head', False)
                string += self._field_to_string(self.is_waiting,
                        name + '.is_waiting', False)
                string += self._field_to_string(self.tag,
                        name + '.tag', False)
                string += self._field_to_string(self.user_state,
                        name + '.user_state', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.error))
                data.append(self.head.to_data())
                data.append(self._pack(4, self.is_waiting))
                data.append(self._pack(4, self.tag))
                self._pointer_to_data(data, 4, self.user_state)

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.head.get_phys_relocs(base_offset + self.get_offset_of('head')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.head.dirty:
                    return True
                if self.user_state is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 276
        self.hybrid_mutex = OKL4_AnonymousType_37(this_addr, self)

        class OKL4_AnonymousType_38(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "delivered_number" : {'offset': 0},
                "received" : {'offset': 4},
                "restart_function" : {'offset': 8},
                "return_val" : {'offset': 12},
                "waiting" : {'offset': 16},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._delivered_number = 0
                self._received = 0
                self.restart_function = None
                self._return_val = 0
                self._waiting = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 20
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_delivered_number(self, delivered_number_):
                """Set delivered_number and flag this type as modified"""
                self._delivered_number =  delivered_number_
                self._dirty = True

            delivered_number = property(lambda self: self._delivered_number, _set_delivered_number)

            def _set_received(self, received_):
                """Set received and flag this type as modified"""
                self._received =  received_
                self._dirty = True

            received = property(lambda self: self._received, _set_received)

            def _set_return_val(self, return_val_):
                """Set return_val and flag this type as modified"""
                self._return_val =  return_val_
                self._dirty = True

            return_val = property(lambda self: self._return_val, _set_return_val)

            def _set_waiting(self, waiting_):
                """Set waiting and flag this type as modified"""
                self._waiting =  waiting_
                self._dirty = True

            waiting = property(lambda self: self._waiting, _set_waiting)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.delivered_number, 4, addr + 0)
                image.patch(symbol, self.received, 4, addr + 4)
                self._pointer_patch(image, symbol, 4, addr + 8, self.restart_function)
                image.patch(symbol, self.return_val, 4, addr + 12)
                image.patch(symbol, self.waiting, 4, addr + 16)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.delivered_number,
                        name + '.delivered_number', False)
                string += self._field_to_string(self.received,
                        name + '.received', False)
                string += self._field_to_string(self.restart_function,
                        name + '.restart_function', True)
                string += self._field_to_string(self.return_val,
                        name + '.return_val', False)
                string += self._field_to_string(self.waiting,
                        name + '.waiting', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.delivered_number))
                data.append(self._pack(4, self.received))
                self._pointer_to_data(data, 4, self.restart_function)
                data.append(self._pack(4, self.return_val))
                data.append(self._pack(4, self.waiting))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.restart_function is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 300
        self.interrupt = OKL4_AnonymousType_38(this_addr, self)

        class OKL4_AnonymousType_39(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "calling" : {'offset': 0},
                "defunct_reply_tokens" : {'offset': 4},
                "error" : {'offset': 12},
                "ipc_return_callback" : {'offset': 16},
                "kernel_buffer" : {'offset': 20},
                "rcv_buffer" : {'offset': 24},
                "rcv_syncpoint" : {'offset': 28},
                "rcv_words" : {'offset': 52},
                "reply_token" : {'offset': 56},
                "sending" : {'offset': 60},
                "snd_buffer" : {'offset': 64},
                "snd_syncpoint" : {'offset': 68},
                "snd_words" : {'offset': 92},
                "tag" : {'offset': 96},
                "token_count" : {'offset': 100},
                "transferred" : {'offset': 104},
                "trusted" : {'offset': 108},
                "wait_token" : {'offset': 112},
                "waiting" : {'offset': 116},
                "waiting_for" : {'offset': 120},
                "was_notify" : {'offset': 124},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._calling = 0

                this_addr = None if address is None else self._address + 4
                self.defunct_reply_tokens = OKL4_list_head_t(this_addr, self)
                self._error = 0
                self.ipc_return_callback = None
                self._kernel_buffer = 0
                self._rcv_buffer = 0

                this_addr = None if address is None else self._address + 28
                self.rcv_syncpoint = OKL4_syncpoint(this_addr, self)
                self._rcv_words = 0
                self.reply_token = None
                self._sending = 0
                self._snd_buffer = 0

                this_addr = None if address is None else self._address + 68
                self.snd_syncpoint = OKL4_syncpoint(this_addr, self)
                self._snd_words = 0
                self._tag = 0
                self._token_count = 1
                self._transferred = 0
                self._trusted = 0
                self.wait_token = None
                self._waiting = 0
                self.waiting_for = None
                self._was_notify = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.defunct_reply_tokens.set_address(address + 4)
                self.rcv_syncpoint.set_address(address + 28)
                self.snd_syncpoint.set_address(address + 68)

            _type_size = 128
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_calling(self, calling_):
                """Set calling and flag this type as modified"""
                self._calling =  calling_
                self._dirty = True

            calling = property(lambda self: self._calling, _set_calling)

            def _set_error(self, error_):
                """Set error and flag this type as modified"""
                self._error =  error_
                self._dirty = True

            error = property(lambda self: self._error, _set_error)

            def _set_kernel_buffer(self, kernel_buffer_):
                """Set kernel_buffer and flag this type as modified"""
                self._kernel_buffer =  kernel_buffer_
                self._dirty = True

            kernel_buffer = property(lambda self: self._kernel_buffer, _set_kernel_buffer)

            def _set_rcv_buffer(self, rcv_buffer_):
                """Set rcv_buffer and flag this type as modified"""
                self._rcv_buffer =  rcv_buffer_
                self._dirty = True

            rcv_buffer = property(lambda self: self._rcv_buffer, _set_rcv_buffer)

            def _set_rcv_words(self, rcv_words_):
                """Set rcv_words and flag this type as modified"""
                self._rcv_words =  rcv_words_
                self._dirty = True

            rcv_words = property(lambda self: self._rcv_words, _set_rcv_words)

            def _set_sending(self, sending_):
                """Set sending and flag this type as modified"""
                self._sending =  sending_
                self._dirty = True

            sending = property(lambda self: self._sending, _set_sending)

            def _set_snd_buffer(self, snd_buffer_):
                """Set snd_buffer and flag this type as modified"""
                self._snd_buffer =  snd_buffer_
                self._dirty = True

            snd_buffer = property(lambda self: self._snd_buffer, _set_snd_buffer)

            def _set_snd_words(self, snd_words_):
                """Set snd_words and flag this type as modified"""
                self._snd_words =  snd_words_
                self._dirty = True

            snd_words = property(lambda self: self._snd_words, _set_snd_words)

            def _set_tag(self, tag_):
                """Set tag and flag this type as modified"""
                self._tag =  tag_
                self._dirty = True

            tag = property(lambda self: self._tag, _set_tag)

            def _set_token_count(self, token_count_):
                """Set token_count and flag this type as modified"""
                self._token_count =  token_count_
                self._dirty = True

            token_count = property(lambda self: self._token_count, _set_token_count)

            def _set_transferred(self, transferred_):
                """Set transferred and flag this type as modified"""
                self._transferred =  transferred_
                self._dirty = True

            transferred = property(lambda self: self._transferred, _set_transferred)

            def _set_trusted(self, trusted_):
                """Set trusted and flag this type as modified"""
                self._trusted =  trusted_
                self._dirty = True

            trusted = property(lambda self: self._trusted, _set_trusted)

            def _set_waiting(self, waiting_):
                """Set waiting and flag this type as modified"""
                self._waiting =  waiting_
                self._dirty = True

            waiting = property(lambda self: self._waiting, _set_waiting)

            def _set_was_notify(self, was_notify_):
                """Set was_notify and flag this type as modified"""
                self._was_notify =  was_notify_
                self._dirty = True

            was_notify = property(lambda self: self._was_notify, _set_was_notify)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.calling, 4, addr + 0)
                self.defunct_reply_tokens.patch(image, symbol, addr + 4)
                image.patch(symbol, self.error, 4, addr + 12)
                self._pointer_patch(image, symbol, 4, addr + 16, self.ipc_return_callback)
                image.patch(symbol, self.kernel_buffer, 4, addr + 20)
                image.patch(symbol, self.rcv_buffer, 4, addr + 24)
                self.rcv_syncpoint.patch(image, symbol, addr + 28)
                image.patch(symbol, self.rcv_words, 4, addr + 52)
                self._pointer_patch(image, symbol, 4, addr + 56, self.reply_token)
                image.patch(symbol, self.sending, 4, addr + 60)
                image.patch(symbol, self.snd_buffer, 4, addr + 64)
                self.snd_syncpoint.patch(image, symbol, addr + 68)
                image.patch(symbol, self.snd_words, 4, addr + 92)
                image.patch(symbol, self.tag, 4, addr + 96)
                image.patch(symbol, self.token_count, 4, addr + 100)
                image.patch(symbol, self.transferred, 4, addr + 104)
                image.patch(symbol, self.trusted, 4, addr + 108)
                self._pointer_patch(image, symbol, 4, addr + 112, self.wait_token)
                image.patch(symbol, self.waiting, 4, addr + 116)
                self._pointer_patch(image, symbol, 4, addr + 120, self.waiting_for)
                image.patch(symbol, self.was_notify, 4, addr + 124)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.calling,
                        name + '.calling', False)
                string += self._field_to_string(self.defunct_reply_tokens,
                        name + '.defunct_reply_tokens', False)
                string += self._field_to_string(self.error,
                        name + '.error', False)
                string += self._field_to_string(self.ipc_return_callback,
                        name + '.ipc_return_callback', True)
                string += self._field_to_string(self.kernel_buffer,
                        name + '.kernel_buffer', False)
                string += self._field_to_string(self.rcv_buffer,
                        name + '.rcv_buffer', False)
                string += self._field_to_string(self.rcv_syncpoint,
                        name + '.rcv_syncpoint', False)
                string += self._field_to_string(self.rcv_words,
                        name + '.rcv_words', False)
                string += self._field_to_string(self.reply_token,
                        name + '.reply_token', True)
                string += self._field_to_string(self.sending,
                        name + '.sending', False)
                string += self._field_to_string(self.snd_buffer,
                        name + '.snd_buffer', False)
                string += self._field_to_string(self.snd_syncpoint,
                        name + '.snd_syncpoint', False)
                string += self._field_to_string(self.snd_words,
                        name + '.snd_words', False)
                string += self._field_to_string(self.tag,
                        name + '.tag', False)
                string += self._field_to_string(self.token_count,
                        name + '.token_count', False)
                string += self._field_to_string(self.transferred,
                        name + '.transferred', False)
                string += self._field_to_string(self.trusted,
                        name + '.trusted', False)
                string += self._field_to_string(self.wait_token,
                        name + '.wait_token', True)
                string += self._field_to_string(self.waiting,
                        name + '.waiting', False)
                string += self._field_to_string(self.waiting_for,
                        name + '.waiting_for', True)
                string += self._field_to_string(self.was_notify,
                        name + '.was_notify', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.calling))
                data.append(self.defunct_reply_tokens.to_data())
                data.append(self._pack(4, self.error))
                self._pointer_to_data(data, 4, self.ipc_return_callback)
                data.append(self._pack(4, self.kernel_buffer))
                data.append(self._pack(4, self.rcv_buffer))
                data.append(self.rcv_syncpoint.to_data())
                data.append(self._pack(4, self.rcv_words))
                self._pointer_to_data(data, 4, self.reply_token)
                data.append(self._pack(4, self.sending))
                data.append(self._pack(4, self.snd_buffer))
                data.append(self.snd_syncpoint.to_data())
                data.append(self._pack(4, self.snd_words))
                data.append(self._pack(4, self.tag))
                data.append(self._pack(4, self.token_count))
                data.append(self._pack(4, self.transferred))
                data.append(self._pack(4, self.trusted))
                self._pointer_to_data(data, 4, self.wait_token)
                data.append(self._pack(4, self.waiting))
                self._pointer_to_data(data, 4, self.waiting_for)
                data.append(self._pack(4, self.was_notify))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.defunct_reply_tokens.get_phys_relocs(base_offset + self.get_offset_of('defunct_reply_tokens')))
                relocs.extend(self.rcv_syncpoint.get_phys_relocs(base_offset + self.get_offset_of('rcv_syncpoint')))
                relocs.extend(self.snd_syncpoint.get_phys_relocs(base_offset + self.get_offset_of('snd_syncpoint')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.defunct_reply_tokens.dirty:
                    return True
                if self.ipc_return_callback is not None:
                    return True
                if self.rcv_syncpoint.dirty:
                    return True
                if self.reply_token is not None:
                    return True
                if self.snd_syncpoint.dirty:
                    return True
                if self.wait_token is not None:
                    return True
                if self.waiting_for is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 320
        self.ipc = OKL4_AnonymousType_39(this_addr, self)

        class OKL4_AnonymousType_40(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 448
        self.kdb = OKL4_AnonymousType_40(this_addr, self)

        this_addr = None if address is None else self._address + 452
        self.mmu = OKL4_mmu_thread_data(this_addr, self)

        class OKL4_AnonymousType_41(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "msgq_cap" : {'offset': 0},
                "post_receive_func" : {'offset': 4},
                "shared" : {'offset': 8},
                "waiting_callback" : {'offset': 100},
                "waiting_msg_type" : {'offset': 104},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._msgq_cap = 0
                self.post_receive_func = None

                class OKL4_AnonymousType_42(ElfweaverType):
                    """Implement an anonymous structure."""

                    # Field property list.  The keys are used to detect places where a
                    # renamed field has been missed.  The value describes various
                    # field properties.
                    _plist = {
                        "pending_words" : {},
                        "buff_area" : {},
                        "capability" : {},
                    }

                    def __init__(self, address, back_ptr = None, phys_addr = None):
                        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                        self.pending_words = [None] * 2

                        class OKL4_AnonymousType_43(ElfweaverType):
                            """Implement an anonymous structure."""

                            # Field property list.  The keys are used to detect places where a
                            # renamed field has been missed.  The value describes various
                            # field properties.
                            _plist = {
                                "block" : {'offset': 0},
                                "buff" : {'offset': 4},
                                "buff_size" : {'offset': 8},
                                "map_local" : {'offset': 12},
                                "map_mmu_mpointer" : {'offset': 16},
                                "map_msgq_mpointer" : {'offset': 40},
                                "map_page" : {'offset': 64},
                                "mid_copy" : {'offset': 68},
                                "msg_size" : {'offset': 72},
                                "msgq" : {'offset': 76},
                                "recv_call" : {'offset': 80},
                                "used_quota" : {'offset': 84},
                                "user_buff" : {'offset': 88},
                            }

                            def __init__(self, address, back_ptr = None, phys_addr = None):
                                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                                self._block = 0
                                self.buff = None
                                self._buff_size = 0
                                self._map_local = 0

                                this_addr = None if address is None else self._address + 16
                                self.map_mmu_mpointer = OKL4_mpointer(this_addr, self)

                                this_addr = None if address is None else self._address + 40
                                self.map_msgq_mpointer = OKL4_mpointer(this_addr, self)
                                self._map_page = 0
                                self._mid_copy = 0
                                self._msg_size = 0
                                self.msgq = None
                                self._recv_call = 0
                                self._used_quota = 0
                                self._user_buff = 0

                            def set_address(self, address, phys_addr = None):
                                """Set the virtual and physical address of the object."""

                                ElfweaverType.set_address(self, address, phys_addr)

                                self.map_mmu_mpointer.set_address(address + 16)
                                self.map_msgq_mpointer.set_address(address + 40)

                            _type_size = 92
                            _type_alignment = 4
                            _type_name = ""
                            _type_libokl4_name = ""

                            def _set_block(self, block_):
                                """Set block and flag this type as modified"""
                                self._block =  block_
                                self._dirty = True

                            block = property(lambda self: self._block, _set_block)

                            def _set_buff_size(self, buff_size_):
                                """Set buff_size and flag this type as modified"""
                                self._buff_size =  buff_size_
                                self._dirty = True

                            buff_size = property(lambda self: self._buff_size, _set_buff_size)

                            def _set_map_local(self, map_local_):
                                """Set map_local and flag this type as modified"""
                                self._map_local =  map_local_
                                self._dirty = True

                            map_local = property(lambda self: self._map_local, _set_map_local)

                            def _set_map_page(self, map_page_):
                                """Set map_page and flag this type as modified"""
                                self._map_page =  map_page_
                                self._dirty = True

                            map_page = property(lambda self: self._map_page, _set_map_page)

                            def _set_mid_copy(self, mid_copy_):
                                """Set mid_copy and flag this type as modified"""
                                self._mid_copy =  mid_copy_
                                self._dirty = True

                            mid_copy = property(lambda self: self._mid_copy, _set_mid_copy)

                            def _set_msg_size(self, msg_size_):
                                """Set msg_size and flag this type as modified"""
                                self._msg_size =  msg_size_
                                self._dirty = True

                            msg_size = property(lambda self: self._msg_size, _set_msg_size)

                            def _set_recv_call(self, recv_call_):
                                """Set recv_call and flag this type as modified"""
                                self._recv_call =  recv_call_
                                self._dirty = True

                            recv_call = property(lambda self: self._recv_call, _set_recv_call)

                            def _set_used_quota(self, used_quota_):
                                """Set used_quota and flag this type as modified"""
                                self._used_quota =  used_quota_
                                self._dirty = True

                            used_quota = property(lambda self: self._used_quota, _set_used_quota)

                            def _set_user_buff(self, user_buff_):
                                """Set user_buff and flag this type as modified"""
                                self._user_buff =  user_buff_
                                self._dirty = True

                            user_buff = property(lambda self: self._user_buff, _set_user_buff)

                            def patch(self, image, symbol, addr = 0):
                                """Patch the data in this type at symbol + addr."""

                                image.patch(symbol, self.block, 4, addr + 0)
                                self._pointer_patch(image, symbol, 4, addr + 4, self.buff)
                                image.patch(symbol, self.buff_size, 4, addr + 8)
                                image.patch(symbol, self.map_local, 4, addr + 12)
                                self.map_mmu_mpointer.patch(image, symbol, addr + 16)
                                self.map_msgq_mpointer.patch(image, symbol, addr + 40)
                                image.patch(symbol, self.map_page, 4, addr + 64)
                                image.patch(symbol, self.mid_copy, 4, addr + 68)
                                image.patch(symbol, self.msg_size, 4, addr + 72)
                                self._pointer_patch(image, symbol, 4, addr + 76, self.msgq)
                                image.patch(symbol, self.recv_call, 4, addr + 80)
                                image.patch(symbol, self.used_quota, 4, addr + 84)
                                image.patch(symbol, self.user_buff, 4, addr + 88)

                            def to_string(self, name = ''):
                                """Generate a human-readable form of the object."""

                                string = name + ' - ' + str(self) + '\n'

                                string += self._field_to_string(self.block,
                                        name + '.block', False)
                                string += self._field_to_string(self.buff,
                                        name + '.buff', True)
                                string += self._field_to_string(self.buff_size,
                                        name + '.buff_size', False)
                                string += self._field_to_string(self.map_local,
                                        name + '.map_local', False)
                                string += self._field_to_string(self.map_mmu_mpointer,
                                        name + '.map_mmu_mpointer', False)
                                string += self._field_to_string(self.map_msgq_mpointer,
                                        name + '.map_msgq_mpointer', False)
                                string += self._field_to_string(self.map_page,
                                        name + '.map_page', False)
                                string += self._field_to_string(self.mid_copy,
                                        name + '.mid_copy', False)
                                string += self._field_to_string(self.msg_size,
                                        name + '.msg_size', False)
                                string += self._field_to_string(self.msgq,
                                        name + '.msgq', True)
                                string += self._field_to_string(self.recv_call,
                                        name + '.recv_call', False)
                                string += self._field_to_string(self.used_quota,
                                        name + '.used_quota', False)
                                string += self._field_to_string(self.user_buff,
                                        name + '.user_buff', False)

                                return string

                            def to_data(self):
                                """Convert the object into binary form."""

                                data = []

                                data.append(self._pack(4, self.block))
                                self._pointer_to_data(data, 4, self.buff)
                                data.append(self._pack(4, self.buff_size))
                                data.append(self._pack(4, self.map_local))
                                data.append(self.map_mmu_mpointer.to_data())
                                data.append(self.map_msgq_mpointer.to_data())
                                data.append(self._pack(4, self.map_page))
                                data.append(self._pack(4, self.mid_copy))
                                data.append(self._pack(4, self.msg_size))
                                self._pointer_to_data(data, 4, self.msgq)
                                data.append(self._pack(4, self.recv_call))
                                data.append(self._pack(4, self.used_quota))
                                data.append(self._pack(4, self.user_buff))

                                return ''.join(data)

                            def get_phys_relocs(self, base_offset=0):
                                relocs = self._get_local_phys_reloc(base_offset)
                                relocs.extend(self.map_mmu_mpointer.get_phys_relocs(base_offset + self.get_offset_of('map_mmu_mpointer')))
                                relocs.extend(self.map_msgq_mpointer.get_phys_relocs(base_offset + self.get_offset_of('map_msgq_mpointer')))
                                return relocs


                            def _get_dirty(self):
                                """Check if any element of this type has been modified."""
                                if self._dirty:
                                    return True

                                if self.buff is not None:
                                    return True
                                if self.map_mmu_mpointer.dirty:
                                    return True
                                if self.map_msgq_mpointer.dirty:
                                    return True
                                if self.msgq is not None:
                                    return True

                                return False
                            dirty = property(_get_dirty)



                        this_addr = None if address is None else self._address + 0
                        self.buff_area = OKL4_AnonymousType_43(this_addr, self)

                        this_addr = None if address is None else self._address + 0
                        self.capability = OKL4_async_message_payload_capability(this_addr, self)

                    def set_address(self, address, phys_addr = None):
                        """Set the virtual and physical address of the object."""

                        ElfweaverType.set_address(self, address, phys_addr)

                        self.buff_area.set_address(address + 0)
                        self.capability.set_address(address + 0)

                    _type_size = 92
                    _type_alignment = 4
                    _type_name = "message_queue_thread_shared"
                    _type_libokl4_name = ""

                    def patch(self, image, symbol, addr = 0):
                        """Patch the data in this type at symbol + addr."""

                        pass

                    def to_string(self, name = ''):
                        """Generate a human-readable form of the object."""

                        string = name + ' - ' + str(self) + '\n'

                        string += self._field_to_string(self.pending_words,
                                name + '.pending_words', False)
                        string += self._field_to_string(self.buff_area,
                                name + '.buff_area', False)
                        string += self._field_to_string(self.capability,
                                name + '.capability', False)

                        return string

                    def to_data(self):
                        """Convert the object into binary form."""

                        data = []

                        count = 0
                        field_size = 0
                        dirty_test = False
                        dirty_test = self._array_dirty_test(self.pending_words)
                        if dirty_test:
                            count += 1
                            field_size = 8
                            for item in self.pending_words:
                                data.append(self._pack(4, item))
                        if self.buff_area.dirty:
                            count += 1
                            field_size = 92
                            data.append(self.buff_area.to_data())
                        if self.capability.dirty:
                            count += 1
                            field_size = 28
                            data.append(self.capability.to_data())
                        if count > 1:
                            raise ElfweaverTypeException('More than one entry in the union value has been set')
                        bytes_left = 92 - field_size
                        for val in (8, 4, 2, 1):
                            while bytes_left >= val:
                                data.append(self._pack(val, 0))
                                bytes_left -= val

                        return ''.join(data)



                    def _get_dirty(self):
                        """Check if any element of this type has been modified."""
                        if self._dirty:
                            return True


                        return False
                    dirty = property(_get_dirty)



                this_addr = None if address is None else self._address + 8
                self.shared = OKL4_AnonymousType_42(this_addr, self)
                self._waiting_callback = 0
                self._waiting_msg_type = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.shared.set_address(address + 8)

            _type_size = 108
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_msgq_cap(self, msgq_cap_):
                """Set msgq_cap and flag this type as modified"""
                self._msgq_cap =  msgq_cap_
                self._dirty = True

            msgq_cap = property(lambda self: self._msgq_cap, _set_msgq_cap)

            def _set_waiting_callback(self, waiting_callback_):
                """Set waiting_callback and flag this type as modified"""
                self._waiting_callback =  waiting_callback_
                self._dirty = True

            waiting_callback = property(lambda self: self._waiting_callback, _set_waiting_callback)

            def _set_waiting_msg_type(self, waiting_msg_type_):
                """Set waiting_msg_type and flag this type as modified"""
                self._waiting_msg_type =  waiting_msg_type_
                self._dirty = True

            waiting_msg_type = property(lambda self: self._waiting_msg_type, _set_waiting_msg_type)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.msgq_cap, 4, addr + 0)
                self._pointer_patch(image, symbol, 4, addr + 4, self.post_receive_func)
                self.shared.patch(image, symbol, addr + 8)
                image.patch(symbol, self.waiting_callback, 4, addr + 100)
                image.patch(symbol, self.waiting_msg_type, 4, addr + 104)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.msgq_cap,
                        name + '.msgq_cap', False)
                string += self._field_to_string(self.post_receive_func,
                        name + '.post_receive_func', True)
                string += self._field_to_string(self.shared,
                        name + '.shared', False)
                string += self._field_to_string(self.waiting_callback,
                        name + '.waiting_callback', False)
                string += self._field_to_string(self.waiting_msg_type,
                        name + '.waiting_msg_type', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.msgq_cap))
                self._pointer_to_data(data, 4, self.post_receive_func)
                data.append(self.shared.to_data())
                data.append(self._pack(4, self.waiting_callback))
                data.append(self._pack(4, self.waiting_msg_type))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.shared.get_phys_relocs(base_offset + self.get_offset_of('shared')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.post_receive_func is not None:
                    return True
                if self.shared.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 508
        self.msgq = OKL4_AnonymousType_41(this_addr, self)

        class OKL4_AnonymousType_44(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "error" : {'offset': 0},
                "head" : {'offset': 4},
                "waiting_for" : {'offset': 12},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._error = 0

                this_addr = None if address is None else self._address + 4
                self.head = OKL4_list_head_t(this_addr, self)
                self.waiting_for = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.head.set_address(address + 4)

            _type_size = 16
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_error(self, error_):
                """Set error and flag this type as modified"""
                self._error =  error_
                self._dirty = True

            error = property(lambda self: self._error, _set_error)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.error, 4, addr + 0)
                self.head.patch(image, symbol, addr + 4)
                self._pointer_patch(image, symbol, 4, addr + 12, self.waiting_for)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.error,
                        name + '.error', False)
                string += self._field_to_string(self.head,
                        name + '.head', False)
                string += self._field_to_string(self.waiting_for,
                        name + '.waiting_for', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.error))
                data.append(self.head.to_data())
                self._pointer_to_data(data, 4, self.waiting_for)

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.head.get_phys_relocs(base_offset + self.get_offset_of('head')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.head.dirty:
                    return True
                if self.waiting_for is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 616
        self.mutex = OKL4_AnonymousType_44(this_addr, self)

        class OKL4_AnonymousType_45(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "mask" : {'offset': 0},
                "signals" : {'offset': 4},
                "waiting" : {'offset': 8},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._mask = 0
                self._signals = 0
                self._waiting = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 12
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_mask(self, mask_):
                """Set mask and flag this type as modified"""
                self._mask =  mask_
                self._dirty = True

            mask = property(lambda self: self._mask, _set_mask)

            def _set_signals(self, signals_):
                """Set signals and flag this type as modified"""
                self._signals =  signals_
                self._dirty = True

            signals = property(lambda self: self._signals, _set_signals)

            def _set_waiting(self, waiting_):
                """Set waiting and flag this type as modified"""
                self._waiting =  waiting_
                self._dirty = True

            waiting = property(lambda self: self._waiting, _set_waiting)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.mask, 4, addr + 0)
                image.patch(symbol, self.signals, 4, addr + 4)
                image.patch(symbol, self.waiting, 4, addr + 8)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.mask,
                        name + '.mask', False)
                string += self._field_to_string(self.signals,
                        name + '.signals', False)
                string += self._field_to_string(self.waiting,
                        name + '.waiting', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.mask))
                data.append(self._pack(4, self.signals))
                data.append(self._pack(4, self.waiting))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 632
        self.notify = OKL4_AnonymousType_45(this_addr, self)

        class OKL4_AnonymousType_46(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "entry" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                if address is None:
                    self.entry = [OKL4_notify_list_entry(None, self)
                            for i in range(0, 16)]
                else:
                    self.entry = [OKL4_notify_list_entry(self._address + 0 + i * 16, self)
                            for i in range(0, 16)]

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                for (i, obj) in enumerate(self.entry):
                    obj.set_address(address + 0 + i * 16)

            _type_size = 256
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                for i, item in enumerate(self.entry):
                    item.patch(image, symbol, addr + i * 16 + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.entry,
                        name + '.entry', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                for item in self.entry:
                    data.append(item.to_data())

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self._array_dirty_test(self.entry):
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 644
        self.notify_service = OKL4_AnonymousType_46(this_addr, self)

        class OKL4_AnonymousType_47(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "being_deleted" : {'offset': 0},
                "blocked_on" : {'offset': 4},
                "deleting_object" : {'offset': 28},
                "domain" : {'offset': 52},
                "object_being_created" : {'offset': 56},
                "object_creation_params" : {'offset': 60},
                "object_type_being_created" : {'offset': 80},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._being_deleted = 0

                this_addr = None if address is None else self._address + 4
                self.blocked_on = OKL4_mpointer(this_addr, self)

                this_addr = None if address is None else self._address + 28
                self.deleting_object = OKL4_mpointer(this_addr, self)
                self.domain = None
                self.object_being_created = None

                class OKL4_AnonymousType_48(ElfweaverType):
                    """Implement an anonymous structure."""

                    # Field property list.  The keys are used to detect places where a
                    # renamed field has been missed.  The value describes various
                    # field properties.
                    _plist = {
                        "mmu_context" : {},
                        "domain" : {},
                        "switch_table" : {},
                    }

                    def __init__(self, address, back_ptr = None, phys_addr = None):
                        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                        class OKL4_AnonymousType_49(ElfweaverType):
                            """Implement an anonymous structure."""

                            # Field property list.  The keys are used to detect places where a
                            # renamed field has been missed.  The value describes various
                            # field properties.
                            _plist = {
                                "num_segments" : {'offset': 0},
                                "intlock_cap" : {'offset': 4},
                            }

                            def __init__(self, address, back_ptr = None, phys_addr = None):
                                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                                self._num_segments = 0
                                self._intlock_cap = 0

                            def set_address(self, address, phys_addr = None):
                                """Set the virtual and physical address of the object."""

                                ElfweaverType.set_address(self, address, phys_addr)


                            _type_size = 8
                            _type_alignment = 4
                            _type_name = ""
                            _type_libokl4_name = ""

                            def _set_num_segments(self, num_segments_):
                                """Set num_segments and flag this type as modified"""
                                self._num_segments =  num_segments_
                                self._dirty = True

                            num_segments = property(lambda self: self._num_segments, _set_num_segments)

                            def _set_intlock_cap(self, intlock_cap_):
                                """Set intlock_cap and flag this type as modified"""
                                self._intlock_cap =  intlock_cap_
                                self._dirty = True

                            intlock_cap = property(lambda self: self._intlock_cap, _set_intlock_cap)

                            def patch(self, image, symbol, addr = 0):
                                """Patch the data in this type at symbol + addr."""

                                image.patch(symbol, self.num_segments, 4, addr + 0)
                                image.patch(symbol, self.intlock_cap, 4, addr + 4)

                            def to_string(self, name = ''):
                                """Generate a human-readable form of the object."""

                                string = name + ' - ' + str(self) + '\n'

                                string += self._field_to_string(self.num_segments,
                                        name + '.num_segments', False)
                                string += self._field_to_string(self.intlock_cap,
                                        name + '.intlock_cap', False)

                                return string

                            def to_data(self):
                                """Convert the object into binary form."""

                                data = []

                                data.append(self._pack(4, self.num_segments))
                                data.append(self._pack(4, self.intlock_cap))

                                return ''.join(data)



                            def _get_dirty(self):
                                """Check if any element of this type has been modified."""
                                if self._dirty:
                                    return True


                                return False
                            dirty = property(_get_dirty)



                        this_addr = None if address is None else self._address + 0
                        self.mmu_context = OKL4_AnonymousType_49(this_addr, self)

                        class OKL4_AnonymousType_50(ElfweaverType):
                            """Implement an anonymous structure."""

                            # Field property list.  The keys are used to detect places where a
                            # renamed field has been missed.  The value describes various
                            # field properties.
                            _plist = {
                                "clist_entries" : {'offset': 0},
                                "max_prio" : {'offset': 4},
                                "reply_token_table_entries" : {'offset': 8},
                            }

                            def __init__(self, address, back_ptr = None, phys_addr = None):
                                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                                self._clist_entries = 0
                                self._max_prio = 0
                                self._reply_token_table_entries = 0

                            def set_address(self, address, phys_addr = None):
                                """Set the virtual and physical address of the object."""

                                ElfweaverType.set_address(self, address, phys_addr)


                            _type_size = 12
                            _type_alignment = 4
                            _type_name = ""
                            _type_libokl4_name = ""

                            def _set_clist_entries(self, clist_entries_):
                                """Set clist_entries and flag this type as modified"""
                                self._clist_entries =  clist_entries_
                                self._dirty = True

                            clist_entries = property(lambda self: self._clist_entries, _set_clist_entries)

                            def _set_max_prio(self, max_prio_):
                                """Set max_prio and flag this type as modified"""
                                self._max_prio =  max_prio_
                                self._dirty = True

                            max_prio = property(lambda self: self._max_prio, _set_max_prio)

                            def _set_reply_token_table_entries(self, reply_token_table_entries_):
                                """Set reply_token_table_entries and flag this type as modified"""
                                self._reply_token_table_entries =  reply_token_table_entries_
                                self._dirty = True

                            reply_token_table_entries = property(lambda self: self._reply_token_table_entries, _set_reply_token_table_entries)

                            def patch(self, image, symbol, addr = 0):
                                """Patch the data in this type at symbol + addr."""

                                image.patch(symbol, self.clist_entries, 4, addr + 0)
                                image.patch(symbol, self.max_prio, 4, addr + 4)
                                image.patch(symbol, self.reply_token_table_entries, 4, addr + 8)

                            def to_string(self, name = ''):
                                """Generate a human-readable form of the object."""

                                string = name + ' - ' + str(self) + '\n'

                                string += self._field_to_string(self.clist_entries,
                                        name + '.clist_entries', False)
                                string += self._field_to_string(self.max_prio,
                                        name + '.max_prio', False)
                                string += self._field_to_string(self.reply_token_table_entries,
                                        name + '.reply_token_table_entries', False)

                                return string

                            def to_data(self):
                                """Convert the object into binary form."""

                                data = []

                                data.append(self._pack(4, self.clist_entries))
                                data.append(self._pack(4, self.max_prio))
                                data.append(self._pack(4, self.reply_token_table_entries))

                                return ''.join(data)



                            def _get_dirty(self):
                                """Check if any element of this type has been modified."""
                                if self._dirty:
                                    return True


                                return False
                            dirty = property(_get_dirty)



                        this_addr = None if address is None else self._address + 0
                        self.domain = OKL4_AnonymousType_50(this_addr, self)

                        class OKL4_AnonymousType_51(ElfweaverType):
                            """Implement an anonymous structure."""

                            # Field property list.  The keys are used to detect places where a
                            # renamed field has been missed.  The value describes various
                            # field properties.
                            _plist = {
                                "domain_id" : {'offset': 0},
                                "mmu_context_id" : {'offset': 4},
                                "num_entries" : {'offset': 8},
                                "return_stub_ip" : {'offset': 12},
                                "intlock" : {'offset': 16},
                            }

                            def __init__(self, address, back_ptr = None, phys_addr = None):
                                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                                self._domain_id = 0
                                self._mmu_context_id = 0
                                self._num_entries = 0
                                self._return_stub_ip = 0
                                self._intlock = 0

                            def set_address(self, address, phys_addr = None):
                                """Set the virtual and physical address of the object."""

                                ElfweaverType.set_address(self, address, phys_addr)


                            _type_size = 20
                            _type_alignment = 4
                            _type_name = ""
                            _type_libokl4_name = ""

                            def _set_domain_id(self, domain_id_):
                                """Set domain_id and flag this type as modified"""
                                self._domain_id =  domain_id_
                                self._dirty = True

                            domain_id = property(lambda self: self._domain_id, _set_domain_id)

                            def _set_mmu_context_id(self, mmu_context_id_):
                                """Set mmu_context_id and flag this type as modified"""
                                self._mmu_context_id =  mmu_context_id_
                                self._dirty = True

                            mmu_context_id = property(lambda self: self._mmu_context_id, _set_mmu_context_id)

                            def _set_num_entries(self, num_entries_):
                                """Set num_entries and flag this type as modified"""
                                self._num_entries =  num_entries_
                                self._dirty = True

                            num_entries = property(lambda self: self._num_entries, _set_num_entries)

                            def _set_return_stub_ip(self, return_stub_ip_):
                                """Set return_stub_ip and flag this type as modified"""
                                self._return_stub_ip =  return_stub_ip_
                                self._dirty = True

                            return_stub_ip = property(lambda self: self._return_stub_ip, _set_return_stub_ip)

                            def _set_intlock(self, intlock_):
                                """Set intlock and flag this type as modified"""
                                self._intlock =  intlock_
                                self._dirty = True

                            intlock = property(lambda self: self._intlock, _set_intlock)

                            def patch(self, image, symbol, addr = 0):
                                """Patch the data in this type at symbol + addr."""

                                image.patch(symbol, self.domain_id, 4, addr + 0)
                                image.patch(symbol, self.mmu_context_id, 4, addr + 4)
                                image.patch(symbol, self.num_entries, 4, addr + 8)
                                image.patch(symbol, self.return_stub_ip, 4, addr + 12)
                                image.patch(symbol, self.intlock, 4, addr + 16)

                            def to_string(self, name = ''):
                                """Generate a human-readable form of the object."""

                                string = name + ' - ' + str(self) + '\n'

                                string += self._field_to_string(self.domain_id,
                                        name + '.domain_id', False)
                                string += self._field_to_string(self.mmu_context_id,
                                        name + '.mmu_context_id', False)
                                string += self._field_to_string(self.num_entries,
                                        name + '.num_entries', False)
                                string += self._field_to_string(self.return_stub_ip,
                                        name + '.return_stub_ip', False)
                                string += self._field_to_string(self.intlock,
                                        name + '.intlock', False)

                                return string

                            def to_data(self):
                                """Convert the object into binary form."""

                                data = []

                                data.append(self._pack(4, self.domain_id))
                                data.append(self._pack(4, self.mmu_context_id))
                                data.append(self._pack(4, self.num_entries))
                                data.append(self._pack(4, self.return_stub_ip))
                                data.append(self._pack(4, self.intlock))

                                return ''.join(data)



                            def _get_dirty(self):
                                """Check if any element of this type has been modified."""
                                if self._dirty:
                                    return True


                                return False
                            dirty = property(_get_dirty)



                        this_addr = None if address is None else self._address + 0
                        self.switch_table = OKL4_AnonymousType_51(this_addr, self)

                    def set_address(self, address, phys_addr = None):
                        """Set the virtual and physical address of the object."""

                        ElfweaverType.set_address(self, address, phys_addr)

                        self.mmu_context.set_address(address + 0)
                        self.domain.set_address(address + 0)
                        self.switch_table.set_address(address + 0)

                    _type_size = 20
                    _type_alignment = 4
                    _type_name = ""
                    _type_libokl4_name = ""

                    def patch(self, image, symbol, addr = 0):
                        """Patch the data in this type at symbol + addr."""

                        pass

                    def to_string(self, name = ''):
                        """Generate a human-readable form of the object."""

                        string = name + ' - ' + str(self) + '\n'

                        string += self._field_to_string(self.mmu_context,
                                name + '.mmu_context', False)
                        string += self._field_to_string(self.domain,
                                name + '.domain', False)
                        string += self._field_to_string(self.switch_table,
                                name + '.switch_table', False)

                        return string

                    def to_data(self):
                        """Convert the object into binary form."""

                        data = []

                        count = 0
                        field_size = 0
                        if self.mmu_context.dirty:
                            count += 1
                            field_size = 8
                            data.append(self.mmu_context.to_data())
                        if self.domain.dirty:
                            count += 1
                            field_size = 12
                            data.append(self.domain.to_data())
                        if self.switch_table.dirty:
                            count += 1
                            field_size = 20
                            data.append(self.switch_table.to_data())
                        if count > 1:
                            raise ElfweaverTypeException('More than one entry in the union value has been set')
                        bytes_left = 20 - field_size
                        for val in (8, 4, 2, 1):
                            while bytes_left >= val:
                                data.append(self._pack(val, 0))
                                bytes_left -= val

                        return ''.join(data)



                    def _get_dirty(self):
                        """Check if any element of this type has been modified."""
                        if self._dirty:
                            return True


                        return False
                    dirty = property(_get_dirty)



                this_addr = None if address is None else self._address + 60
                self.object_creation_params = OKL4_AnonymousType_48(this_addr, self)
                self._object_type_being_created = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.blocked_on.set_address(address + 4)
                self.deleting_object.set_address(address + 28)
                self.object_creation_params.set_address(address + 60)

            _type_size = 84
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_being_deleted(self, being_deleted_):
                """Set being_deleted and flag this type as modified"""
                self._being_deleted =  being_deleted_
                self._dirty = True

            being_deleted = property(lambda self: self._being_deleted, _set_being_deleted)

            def _set_object_type_being_created(self, object_type_being_created_):
                """Set object_type_being_created and flag this type as modified"""
                self._object_type_being_created =  object_type_being_created_
                self._dirty = True

            object_type_being_created = property(lambda self: self._object_type_being_created, _set_object_type_being_created)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.being_deleted, 4, addr + 0)
                self.blocked_on.patch(image, symbol, addr + 4)
                self.deleting_object.patch(image, symbol, addr + 28)
                self._pointer_patch(image, symbol, 4, addr + 52, self.domain)
                self._pointer_patch(image, symbol, 4, addr + 56, self.object_being_created)
                self.object_creation_params.patch(image, symbol, addr + 60)
                image.patch(symbol, self.object_type_being_created, 4, addr + 80)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.being_deleted,
                        name + '.being_deleted', False)
                string += self._field_to_string(self.blocked_on,
                        name + '.blocked_on', False)
                string += self._field_to_string(self.deleting_object,
                        name + '.deleting_object', False)
                string += self._field_to_string(self.domain,
                        name + '.domain', True)
                string += self._field_to_string(self.object_being_created,
                        name + '.object_being_created', True)
                string += self._field_to_string(self.object_creation_params,
                        name + '.object_creation_params', False)
                string += self._field_to_string(self.object_type_being_created,
                        name + '.object_type_being_created', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.being_deleted))
                data.append(self.blocked_on.to_data())
                data.append(self.deleting_object.to_data())
                self._pointer_to_data(data, 4, self.domain)
                self._pointer_to_data(data, 4, self.object_being_created)
                data.append(self.object_creation_params.to_data())
                data.append(self._pack(4, self.object_type_being_created))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.blocked_on.get_phys_relocs(base_offset + self.get_offset_of('blocked_on')))
                relocs.extend(self.deleting_object.get_phys_relocs(base_offset + self.get_offset_of('deleting_object')))
                relocs.extend(self.object_creation_params.get_phys_relocs(base_offset + self.get_offset_of('object_creation_params')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.blocked_on.dirty:
                    return True
                if self.deleting_object.dirty:
                    return True
                if self.domain is not None:
                    return True
                if self.object_being_created is not None:
                    return True
                if self.object_creation_params.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 900
        self.objmanager = OKL4_AnonymousType_47(this_addr, self)

        this_addr = None if address is None else self._address + 984
        self.scheduler = OKL4_thread_scheduler_data(this_addr, self)

        class OKL4_AnonymousType_52(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "error" : {'offset': 0},
                "waiting_for" : {'offset': 4},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._error = 0
                self.waiting_for = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 8
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_error(self, error_):
                """Set error and flag this type as modified"""
                self._error =  error_
                self._dirty = True

            error = property(lambda self: self._error, _set_error)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.error, 4, addr + 0)
                self._pointer_patch(image, symbol, 4, addr + 4, self.waiting_for)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.error,
                        name + '.error', False)
                string += self._field_to_string(self.waiting_for,
                        name + '.waiting_for', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.error))
                self._pointer_to_data(data, 4, self.waiting_for)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.waiting_for is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 1048
        self.semaphore = OKL4_AnonymousType_52(this_addr, self)

        class OKL4_AnonymousType_53(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "tls" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._tls = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_tls(self, tls_):
                """Set tls and flag this type as modified"""
                self._tls =  tls_
                self._dirty = True

            tls = property(lambda self: self._tls, _set_tls)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.tls, 4, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.tls,
                        name + '.tls', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.tls))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 1056
        self.soc = OKL4_AnonymousType_53(this_addr, self)

        class OKL4_AnonymousType_54(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "count" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._count = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_count(self, count_):
                """Set count and flag this type as modified"""
                self._count =  count_
                self._dirty = True

            count = property(lambda self: self._count, _set_count)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.count, 4, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.count,
                        name + '.count', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.count))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 1060
        self.suspend = OKL4_AnonymousType_54(this_addr, self)

        class OKL4_AnonymousType_55(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "alt_tls" : {'offset': 0},
                "caller_domain" : {'offset': 4},
                "caller_mmu" : {'offset': 8},
                "caller_mode" : {'offset': 12},
                "caller_pc" : {'offset': 16},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._alt_tls = 0
                self.caller_domain = None
                self.caller_mmu = None
                self._caller_mode = 0
                self._caller_pc = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 20
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_alt_tls(self, alt_tls_):
                """Set alt_tls and flag this type as modified"""
                self._alt_tls =  alt_tls_
                self._dirty = True

            alt_tls = property(lambda self: self._alt_tls, _set_alt_tls)

            def _set_caller_mode(self, caller_mode_):
                """Set caller_mode and flag this type as modified"""
                self._caller_mode =  caller_mode_
                self._dirty = True

            caller_mode = property(lambda self: self._caller_mode, _set_caller_mode)

            def _set_caller_pc(self, caller_pc_):
                """Set caller_pc and flag this type as modified"""
                self._caller_pc =  caller_pc_
                self._dirty = True

            caller_pc = property(lambda self: self._caller_pc, _set_caller_pc)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.alt_tls, 4, addr + 0)
                self._pointer_patch(image, symbol, 4, addr + 4, self.caller_domain)
                self._pointer_patch(image, symbol, 4, addr + 8, self.caller_mmu)
                image.patch(symbol, self.caller_mode, 4, addr + 12)
                image.patch(symbol, self.caller_pc, 4, addr + 16)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.alt_tls,
                        name + '.alt_tls', False)
                string += self._field_to_string(self.caller_domain,
                        name + '.caller_domain', True)
                string += self._field_to_string(self.caller_mmu,
                        name + '.caller_mmu', True)
                string += self._field_to_string(self.caller_mode,
                        name + '.caller_mode', False)
                string += self._field_to_string(self.caller_pc,
                        name + '.caller_pc', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.alt_tls))
                self._pointer_to_data(data, 4, self.caller_domain)
                self._pointer_to_data(data, 4, self.caller_mmu)
                data.append(self._pack(4, self.caller_mode))
                data.append(self._pack(4, self.caller_pc))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.caller_domain is not None:
                    return True
                if self.caller_mmu is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 1064
        self.switch_table = OKL4_AnonymousType_55(this_addr, self)

        class OKL4_AnonymousType_56(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "totaltime_high" : {'offset': 0},
                "totaltime_low" : {'offset': 4},
                "val_timetest" : {'offset': 8},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._totaltime_high = 0
                self._totaltime_low = 0
                self._val_timetest = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 12
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_totaltime_high(self, totaltime_high_):
                """Set totaltime_high and flag this type as modified"""
                self._totaltime_high =  totaltime_high_
                self._dirty = True

            totaltime_high = property(lambda self: self._totaltime_high, _set_totaltime_high)

            def _set_totaltime_low(self, totaltime_low_):
                """Set totaltime_low and flag this type as modified"""
                self._totaltime_low =  totaltime_low_
                self._dirty = True

            totaltime_low = property(lambda self: self._totaltime_low, _set_totaltime_low)

            def _set_val_timetest(self, val_timetest_):
                """Set val_timetest and flag this type as modified"""
                self._val_timetest =  val_timetest_
                self._dirty = True

            val_timetest = property(lambda self: self._val_timetest, _set_val_timetest)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.totaltime_high, 4, addr + 0)
                image.patch(symbol, self.totaltime_low, 4, addr + 4)
                image.patch(symbol, self.val_timetest, 4, addr + 8)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.totaltime_high,
                        name + '.totaltime_high', False)
                string += self._field_to_string(self.totaltime_low,
                        name + '.totaltime_low', False)
                string += self._field_to_string(self.val_timetest,
                        name + '.val_timetest', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.totaltime_high))
                data.append(self._pack(4, self.totaltime_low))
                data.append(self._pack(4, self.val_timetest))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 1084
        self.thread_profile = OKL4_AnonymousType_56(this_addr, self)

        this_addr = None if address is None else self._address + 1096
        self.tls = OKL4_tls_thread_data(this_addr, self)

        class OKL4_AnonymousType_57(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "allowed" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._allowed = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_allowed(self, allowed_):
                """Set allowed and flag this type as modified"""
                self._allowed =  allowed_
                self._dirty = True

            allowed = property(lambda self: self._allowed, _set_allowed)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.allowed, 4, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.allowed,
                        name + '.allowed', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.allowed))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 1100
        self.useraccess = OKL4_AnonymousType_57(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.hal.set_address(address + 8)
        self.barrier.set_address(address + 80)
        self.cache.set_address(address + 88)
        self.cap_transfer.set_address(address + 144)
        self.condvar.set_address(address + 168)
        self.critsect.set_address(address + 172)
        self.exception.set_address(address + 224)
        self.hybrid_mutex.set_address(address + 276)
        self.interrupt.set_address(address + 300)
        self.ipc.set_address(address + 320)
        self.kdb.set_address(address + 448)
        self.mmu.set_address(address + 452)
        self.msgq.set_address(address + 508)
        self.mutex.set_address(address + 616)
        self.notify.set_address(address + 632)
        self.notify_service.set_address(address + 644)
        self.objmanager.set_address(address + 900)
        self.scheduler.set_address(address + 984)
        self.semaphore.set_address(address + 1048)
        self.soc.set_address(address + 1056)
        self.suspend.set_address(address + 1060)
        self.switch_table.set_address(address + 1064)
        self.thread_profile.set_address(address + 1084)
        self.tls.set_address(address + 1096)
        self.useraccess.set_address(address + 1100)

    _type_size = 1104
    _type_alignment = 4
    _type_name = "thread"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.hal.patch(image, symbol, addr + 8)
        self.barrier.patch(image, symbol, addr + 80)
        self.cache.patch(image, symbol, addr + 88)
        self.cap_transfer.patch(image, symbol, addr + 144)
        self.condvar.patch(image, symbol, addr + 168)
        self.critsect.patch(image, symbol, addr + 172)
        self.exception.patch(image, symbol, addr + 224)
        self.hybrid_mutex.patch(image, symbol, addr + 276)
        self.interrupt.patch(image, symbol, addr + 300)
        self.ipc.patch(image, symbol, addr + 320)
        self.kdb.patch(image, symbol, addr + 448)
        self.mmu.patch(image, symbol, addr + 452)
        self.msgq.patch(image, symbol, addr + 508)
        self.mutex.patch(image, symbol, addr + 616)
        self.notify.patch(image, symbol, addr + 632)
        self.notify_service.patch(image, symbol, addr + 644)
        self.objmanager.patch(image, symbol, addr + 900)
        self.scheduler.patch(image, symbol, addr + 984)
        self.semaphore.patch(image, symbol, addr + 1048)
        self.soc.patch(image, symbol, addr + 1056)
        self.suspend.patch(image, symbol, addr + 1060)
        self.switch_table.patch(image, symbol, addr + 1064)
        self.thread_profile.patch(image, symbol, addr + 1084)
        self.tls.patch(image, symbol, addr + 1096)
        self.useraccess.patch(image, symbol, addr + 1100)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.hal,
                name + '.hal', False)
        string += self._field_to_string(self.barrier,
                name + '.barrier', False)
        string += self._field_to_string(self.cache,
                name + '.cache', False)
        string += self._field_to_string(self.cap_transfer,
                name + '.cap_transfer', False)
        string += self._field_to_string(self.condvar,
                name + '.condvar', False)
        string += self._field_to_string(self.critsect,
                name + '.critsect', False)
        string += self._field_to_string(self.exception,
                name + '.exception', False)
        string += self._field_to_string(self.hybrid_mutex,
                name + '.hybrid_mutex', False)
        string += self._field_to_string(self.interrupt,
                name + '.interrupt', False)
        string += self._field_to_string(self.ipc,
                name + '.ipc', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)
        string += self._field_to_string(self.mmu,
                name + '.mmu', False)
        string += self._field_to_string(self.msgq,
                name + '.msgq', False)
        string += self._field_to_string(self.mutex,
                name + '.mutex', False)
        string += self._field_to_string(self.notify,
                name + '.notify', False)
        string += self._field_to_string(self.notify_service,
                name + '.notify_service', False)
        string += self._field_to_string(self.objmanager,
                name + '.objmanager', False)
        string += self._field_to_string(self.scheduler,
                name + '.scheduler', False)
        string += self._field_to_string(self.semaphore,
                name + '.semaphore', False)
        string += self._field_to_string(self.soc,
                name + '.soc', False)
        string += self._field_to_string(self.suspend,
                name + '.suspend', False)
        string += self._field_to_string(self.switch_table,
                name + '.switch_table', False)
        string += self._field_to_string(self.thread_profile,
                name + '.thread_profile', False)
        string += self._field_to_string(self.tls,
                name + '.tls', False)
        string += self._field_to_string(self.useraccess,
                name + '.useraccess', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.hal.to_data())
        data.append(self.barrier.to_data())
        data.append(self.cache.to_data())
        data.append(self.cap_transfer.to_data())
        data.append(self.condvar.to_data())
        data.append(self.critsect.to_data())
        data.append(self.exception.to_data())
        data.append(self.hybrid_mutex.to_data())
        data.append(self.interrupt.to_data())
        data.append(self.ipc.to_data())
        data.append(self.kdb.to_data())
        data.append(self.mmu.to_data())
        data.append(self.msgq.to_data())
        data.append(self.mutex.to_data())
        data.append(self.notify.to_data())
        data.append(self.notify_service.to_data())
        data.append(self.objmanager.to_data())
        data.append(self.scheduler.to_data())
        data.append(self.semaphore.to_data())
        data.append(self.soc.to_data())
        data.append(self.suspend.to_data())
        data.append(self.switch_table.to_data())
        data.append(self.thread_profile.to_data())
        data.append(self.tls.to_data())
        data.append(self.useraccess.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.hal.get_phys_relocs(base_offset + self.get_offset_of('hal')))
        relocs.extend(self.barrier.get_phys_relocs(base_offset + self.get_offset_of('barrier')))
        relocs.extend(self.cache.get_phys_relocs(base_offset + self.get_offset_of('cache')))
        relocs.extend(self.cap_transfer.get_phys_relocs(base_offset + self.get_offset_of('cap_transfer')))
        relocs.extend(self.condvar.get_phys_relocs(base_offset + self.get_offset_of('condvar')))
        relocs.extend(self.critsect.get_phys_relocs(base_offset + self.get_offset_of('critsect')))
        relocs.extend(self.exception.get_phys_relocs(base_offset + self.get_offset_of('exception')))
        relocs.extend(self.hybrid_mutex.get_phys_relocs(base_offset + self.get_offset_of('hybrid_mutex')))
        relocs.extend(self.interrupt.get_phys_relocs(base_offset + self.get_offset_of('interrupt')))
        relocs.extend(self.ipc.get_phys_relocs(base_offset + self.get_offset_of('ipc')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        relocs.extend(self.mmu.get_phys_relocs(base_offset + self.get_offset_of('mmu')))
        relocs.extend(self.msgq.get_phys_relocs(base_offset + self.get_offset_of('msgq')))
        relocs.extend(self.mutex.get_phys_relocs(base_offset + self.get_offset_of('mutex')))
        relocs.extend(self.notify.get_phys_relocs(base_offset + self.get_offset_of('notify')))
        relocs.extend(self.notify_service.get_phys_relocs(base_offset + self.get_offset_of('notify_service')))
        relocs.extend(self.objmanager.get_phys_relocs(base_offset + self.get_offset_of('objmanager')))
        relocs.extend(self.scheduler.get_phys_relocs(base_offset + self.get_offset_of('scheduler')))
        relocs.extend(self.semaphore.get_phys_relocs(base_offset + self.get_offset_of('semaphore')))
        relocs.extend(self.soc.get_phys_relocs(base_offset + self.get_offset_of('soc')))
        relocs.extend(self.suspend.get_phys_relocs(base_offset + self.get_offset_of('suspend')))
        relocs.extend(self.switch_table.get_phys_relocs(base_offset + self.get_offset_of('switch_table')))
        relocs.extend(self.thread_profile.get_phys_relocs(base_offset + self.get_offset_of('thread_profile')))
        relocs.extend(self.tls.get_phys_relocs(base_offset + self.get_offset_of('tls')))
        relocs.extend(self.useraccess.get_phys_relocs(base_offset + self.get_offset_of('useraccess')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.hal.dirty:
            return True
        if self.barrier.dirty:
            return True
        if self.cache.dirty:
            return True
        if self.cap_transfer.dirty:
            return True
        if self.condvar.dirty:
            return True
        if self.critsect.dirty:
            return True
        if self.exception.dirty:
            return True
        if self.hybrid_mutex.dirty:
            return True
        if self.interrupt.dirty:
            return True
        if self.ipc.dirty:
            return True
        if self.kdb.dirty:
            return True
        if self.mmu.dirty:
            return True
        if self.msgq.dirty:
            return True
        if self.mutex.dirty:
            return True
        if self.notify.dirty:
            return True
        if self.notify_service.dirty:
            return True
        if self.objmanager.dirty:
            return True
        if self.scheduler.dirty:
            return True
        if self.semaphore.dirty:
            return True
        if self.soc.dirty:
            return True
        if self.suspend.dirty:
            return True
        if self.switch_table.dirty:
            return True
        if self.thread_profile.dirty:
            return True
        if self.tls.dirty:
            return True
        if self.useraccess.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_syncpoint(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct syncpoint {
    struct thread *donatee;
    list_head_t donators;
    list_entry_t held_syncpoints_list_entry;
    inheritance_type_t inheritance_type;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "donatee" : {'offset': 0},
        "donators" : {'offset': 4},
        "held_syncpoints_list_entry" : {'offset': 12},
        "inheritance_type" : {'offset': 20},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.donatee = None

        this_addr = None if address is None else self._address + 4
        self.donators = OKL4_list_head_t(this_addr, self)

        this_addr = None if address is None else self._address + 12
        self.held_syncpoints_list_entry = OKL4_list_entry_t(this_addr, self)
        self._inheritance_type = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.donators.set_address(address + 4)
        self.held_syncpoints_list_entry.set_address(address + 12)

    _type_size = 24
    _type_alignment = 4
    _type_name = "syncpoint"
    _type_libokl4_name = ""

    def _set_inheritance_type(self, inheritance_type_):
        """Set inheritance_type and flag this type as modified"""
        self._inheritance_type =  inheritance_type_
        self._dirty = True

    inheritance_type = property(lambda self: self._inheritance_type, _set_inheritance_type)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.donatee)
        self.donators.patch(image, symbol, addr + 4)
        self.held_syncpoints_list_entry.patch(image, symbol, addr + 12)
        image.patch(symbol, self.inheritance_type, 4, addr + 20)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.donatee,
                name + '.donatee', True)
        string += self._field_to_string(self.donators,
                name + '.donators', False)
        string += self._field_to_string(self.held_syncpoints_list_entry,
                name + '.held_syncpoints_list_entry', False)
        string += self._field_to_string(self.inheritance_type,
                name + '.inheritance_type', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.donatee)
        data.append(self.donators.to_data())
        data.append(self.held_syncpoints_list_entry.to_data())
        data.append(self._pack(4, self.inheritance_type))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.donators.get_phys_relocs(base_offset + self.get_offset_of('donators')))
        relocs.extend(self.held_syncpoints_list_entry.get_phys_relocs(base_offset + self.get_offset_of('held_syncpoints_list_entry')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.donatee is not None:
            return True
        if self.donators.dirty:
            return True
        if self.held_syncpoints_list_entry.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_suspend_count_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t suspend_count_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "suspend_count_t"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_priority_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef sword_t priority_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "priority_t"
    _type_libokl4_name = "priority_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_cpu_id_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t cpu_id_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cpu_id_t"
    _type_libokl4_name = "cpu_id_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_seize_opaque(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct seize_opaque {
    word_t val;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "val" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._val = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "seize_opaque"
    _type_libokl4_name = ""

    def _set_val(self, val_):
        """Set val and flag this type as modified"""
        self._val =  val_
        self._dirty = True

    val = property(lambda self: self._val, _set_val)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.val, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.val,
                name + '.val', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.val))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_seize_opaque_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct seize_opaque seize_opaque_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "val" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._val = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "seize_opaque_t"
    _type_libokl4_name = ""

    def _set_val(self, val_):
        """Set val and flag this type as modified"""
        self._val =  val_
        self._dirty = True

    val = property(lambda self: self._val, _set_val)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.val, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.val,
                name + '.val', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.val))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_scheduler_queue(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct scheduler_queue {
    word_t bitmap_l2[8];
    word_t bitmap_l1;
    priority_t highest_prio;
    struct {
        word_t num_threads;
    } metrics;
    list_head_t priorities[256];
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "bitmap_l2" : {'offset': 0},
        "bitmap_l1" : {'offset': 32},
        "highest_prio" : {'offset': 36},
        "metrics" : {'offset': 40},
        "priorities" : {'offset': 44},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.bitmap_l2 = [None] * 8
        self._bitmap_l1 = 0
        self._highest_prio = 0

        class OKL4_AnonymousType_58(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "num_threads" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._num_threads = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_num_threads(self, num_threads_):
                """Set num_threads and flag this type as modified"""
                self._num_threads =  num_threads_
                self._dirty = True

            num_threads = property(lambda self: self._num_threads, _set_num_threads)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.num_threads, 4, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.num_threads,
                        name + '.num_threads', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.num_threads))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 40
        self.metrics = OKL4_AnonymousType_58(this_addr, self)
        if address is None:
            self.priorities = [OKL4_list_head_t(None, self)
                    for i in range(0, 256)]
        else:
            self.priorities = [OKL4_list_head_t(self._address + 44 + i * 8, self)
                    for i in range(0, 256)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.metrics.set_address(address + 40)
        for (i, obj) in enumerate(self.priorities):
            obj.set_address(address + 44 + i * 8)

    _type_size = 2092
    _type_alignment = 4
    _type_name = "scheduler_queue"
    _type_libokl4_name = ""

    def _set_bitmap_l1(self, bitmap_l1_):
        """Set bitmap_l1 and flag this type as modified"""
        self._bitmap_l1 =  bitmap_l1_
        self._dirty = True

    bitmap_l1 = property(lambda self: self._bitmap_l1, _set_bitmap_l1)

    def _set_highest_prio(self, highest_prio_):
        """Set highest_prio and flag this type as modified"""
        self._highest_prio =  highest_prio_
        self._dirty = True

    highest_prio = property(lambda self: self._highest_prio, _set_highest_prio)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        for i, item in enumerate(self.bitmap_l2):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 0)
        image.patch(symbol, self.bitmap_l1, 4, addr + 32)
        image.patch(symbol, self.highest_prio, 4, addr + 36)
        self.metrics.patch(image, symbol, addr + 40)
        for i, item in enumerate(self.priorities):
            item.patch(image, symbol, addr + i * 8 + 44)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.bitmap_l2,
                name + '.bitmap_l2', False)
        string += self._field_to_string(self.bitmap_l1,
                name + '.bitmap_l1', False)
        string += self._field_to_string(self.highest_prio,
                name + '.highest_prio', False)
        string += self._field_to_string(self.metrics,
                name + '.metrics', False)
        string += self._field_to_string(self.priorities,
                name + '.priorities', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        for item in self.bitmap_l2:
            data.append(self._pack(4, item))
        data.append(self._pack(4, self.bitmap_l1))
        data.append(self._pack(4, self.highest_prio))
        data.append(self.metrics.to_data())
        for item in self.priorities:
            data.append(item.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.metrics.get_phys_relocs(base_offset + self.get_offset_of('metrics')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.bitmap_l2):
            return True
        if self.metrics.dirty:
            return True
        if self._array_dirty_test(self.priorities):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_thread_scheduler_data(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct thread_scheduler_data {
    priority_t base_priority;
    word_t current_timeslice;
    struct syncpoint *donating_to;
    list_entry_t donators_list_entry;
    list_head_t held_syncpoints;
    list_entry_t list_entry;
    struct mpointer *pause_mthread;
    priority_t priority;
    bool started;
    suspend_count_t suspend_count;
    word_t tasklock_val;
    bool tasklocked;
    word_t timeslice_length;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "base_priority" : {'offset': 0},
        "current_timeslice" : {'offset': 4},
        "donating_to" : {'offset': 8},
        "donators_list_entry" : {'offset': 12},
        "held_syncpoints" : {'offset': 20},
        "list_entry" : {'offset': 28},
        "pause_mthread" : {'offset': 36},
        "priority" : {'offset': 40},
        "started" : {'offset': 44},
        "suspend_count" : {'offset': 48},
        "tasklock_val" : {'offset': 52},
        "tasklocked" : {'offset': 56},
        "timeslice_length" : {'offset': 60},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._base_priority = 0
        self._current_timeslice = 10000
        self.donating_to = None

        this_addr = None if address is None else self._address + 12
        self.donators_list_entry = OKL4_list_entry_t(this_addr, self)

        this_addr = None if address is None else self._address + 20
        self.held_syncpoints = OKL4_list_head_t(this_addr, self)

        this_addr = None if address is None else self._address + 28
        self.list_entry = OKL4_list_entry_t(this_addr, self)
        self.pause_mthread = None
        self._priority = 0
        self._started = 0
        self._suspend_count = 1
        self._tasklock_val = 0
        self._tasklocked = 0
        self._timeslice_length = 10000

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.donators_list_entry.set_address(address + 12)
        self.held_syncpoints.set_address(address + 20)
        self.list_entry.set_address(address + 28)

    _type_size = 64
    _type_alignment = 4
    _type_name = "thread_scheduler_data"
    _type_libokl4_name = ""

    def _set_base_priority(self, base_priority_):
        """Set base_priority and flag this type as modified"""
        self._base_priority =  base_priority_
        self._dirty = True

    base_priority = property(lambda self: self._base_priority, _set_base_priority)

    def _set_current_timeslice(self, current_timeslice_):
        """Set current_timeslice and flag this type as modified"""
        self._current_timeslice =  current_timeslice_
        self._dirty = True

    current_timeslice = property(lambda self: self._current_timeslice, _set_current_timeslice)

    def _set_priority(self, priority_):
        """Set priority and flag this type as modified"""
        self._priority =  priority_
        self._dirty = True

    priority = property(lambda self: self._priority, _set_priority)

    def _set_started(self, started_):
        """Set started and flag this type as modified"""
        self._started =  started_
        self._dirty = True

    started = property(lambda self: self._started, _set_started)

    def _set_suspend_count(self, suspend_count_):
        """Set suspend_count and flag this type as modified"""
        self._suspend_count =  suspend_count_
        self._dirty = True

    suspend_count = property(lambda self: self._suspend_count, _set_suspend_count)

    def _set_tasklock_val(self, tasklock_val_):
        """Set tasklock_val and flag this type as modified"""
        self._tasklock_val =  tasklock_val_
        self._dirty = True

    tasklock_val = property(lambda self: self._tasklock_val, _set_tasklock_val)

    def _set_tasklocked(self, tasklocked_):
        """Set tasklocked and flag this type as modified"""
        self._tasklocked =  tasklocked_
        self._dirty = True

    tasklocked = property(lambda self: self._tasklocked, _set_tasklocked)

    def _set_timeslice_length(self, timeslice_length_):
        """Set timeslice_length and flag this type as modified"""
        self._timeslice_length =  timeslice_length_
        self._dirty = True

    timeslice_length = property(lambda self: self._timeslice_length, _set_timeslice_length)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.base_priority, 4, addr + 0)
        image.patch(symbol, self.current_timeslice, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.donating_to)
        self.donators_list_entry.patch(image, symbol, addr + 12)
        self.held_syncpoints.patch(image, symbol, addr + 20)
        self.list_entry.patch(image, symbol, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 36, self.pause_mthread)
        image.patch(symbol, self.priority, 4, addr + 40)
        image.patch(symbol, self.started, 4, addr + 44)
        image.patch(symbol, self.suspend_count, 4, addr + 48)
        image.patch(symbol, self.tasklock_val, 4, addr + 52)
        image.patch(symbol, self.tasklocked, 4, addr + 56)
        image.patch(symbol, self.timeslice_length, 4, addr + 60)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.base_priority,
                name + '.base_priority', False)
        string += self._field_to_string(self.current_timeslice,
                name + '.current_timeslice', False)
        string += self._field_to_string(self.donating_to,
                name + '.donating_to', True)
        string += self._field_to_string(self.donators_list_entry,
                name + '.donators_list_entry', False)
        string += self._field_to_string(self.held_syncpoints,
                name + '.held_syncpoints', False)
        string += self._field_to_string(self.list_entry,
                name + '.list_entry', False)
        string += self._field_to_string(self.pause_mthread,
                name + '.pause_mthread', True)
        string += self._field_to_string(self.priority,
                name + '.priority', False)
        string += self._field_to_string(self.started,
                name + '.started', False)
        string += self._field_to_string(self.suspend_count,
                name + '.suspend_count', False)
        string += self._field_to_string(self.tasklock_val,
                name + '.tasklock_val', False)
        string += self._field_to_string(self.tasklocked,
                name + '.tasklocked', False)
        string += self._field_to_string(self.timeslice_length,
                name + '.timeslice_length', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.base_priority))
        data.append(self._pack(4, self.current_timeslice))
        self._pointer_to_data(data, 4, self.donating_to)
        data.append(self.donators_list_entry.to_data())
        data.append(self.held_syncpoints.to_data())
        data.append(self.list_entry.to_data())
        self._pointer_to_data(data, 4, self.pause_mthread)
        data.append(self._pack(4, self.priority))
        data.append(self._pack(4, self.started))
        data.append(self._pack(4, self.suspend_count))
        data.append(self._pack(4, self.tasklock_val))
        data.append(self._pack(4, self.tasklocked))
        data.append(self._pack(4, self.timeslice_length))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.donators_list_entry.get_phys_relocs(base_offset + self.get_offset_of('donators_list_entry')))
        relocs.extend(self.held_syncpoints.get_phys_relocs(base_offset + self.get_offset_of('held_syncpoints')))
        relocs.extend(self.list_entry.get_phys_relocs(base_offset + self.get_offset_of('list_entry')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.donating_to is not None:
            return True
        if self.donators_list_entry.dirty:
            return True
        if self.held_syncpoints.dirty:
            return True
        if self.list_entry.dirty:
            return True
        if self.pause_mthread is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_inheritance_type(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long inheritance_type_t;
#define INHERITANCE_TYPE_INHERITANCE ((inheritance_type_t)0x0UL)
#define INHERITANCE_TYPE_NONE ((inheritance_type_t)0x1UL)

    """

    INHERITANCE_TYPE_INHERITANCE = 0
    INHERITANCE_TYPE_NONE = 1

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "inheritance_type"
    _type_libokl4_name = "inheritance_type"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_asid_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t asid_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "asid_t"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_mmu_map_arch_context(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct mmu_map_arch_context {
    word_t *subtree;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "subtree" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.subtree = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "mmu_map_arch_context"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.subtree)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.subtree,
                name + '.subtree', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.subtree)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.subtree is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_mmu_context(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct mmu_context {
    struct objmanager_object_header header;
    struct {
        struct buff_area_freelist_entry *free_head;
        struct buff_area_freelist_entry *freelist;
        word_t max_buffer_size;
        word_t num_buffers;
        word_t num_uninitialised;
        word_t phys;
        word_t size;
        struct syncpoint syncpoint;
        word_t vaddr;
    } buff_area;
    struct {
        word_t badge;
        struct mpointer handler;
    } exception;
    struct {
        bool allowed;
    } intlock;
    struct {
        struct kdb_object *info;
    } kdb;
    struct mmu_data mmu;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "buff_area" : {'offset': 8},
        "exception" : {'offset': 64},
        "intlock" : {'offset': 92},
        "kdb" : {'offset': 96},
        "mmu" : {'offset': 100},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_59(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "free_head" : {'offset': 0},
                "freelist" : {'offset': 4},
                "max_buffer_size" : {'offset': 8},
                "num_buffers" : {'offset': 12},
                "num_uninitialised" : {'offset': 16},
                "phys" : {'phys_reloc': 0, 'offset': 20},
                "size" : {'offset': 24},
                "syncpoint" : {'offset': 28},
                "vaddr" : {'offset': 52},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.free_head = None
                self.freelist = None
                self._max_buffer_size = 0
                self._num_buffers = 0
                self._num_uninitialised = 0
                self._phys = 0
                self._size = 0

                this_addr = None if address is None else self._address + 28
                self.syncpoint = OKL4_syncpoint(this_addr, self)
                self._vaddr = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.syncpoint.set_address(address + 28)

            _type_size = 56
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_max_buffer_size(self, max_buffer_size_):
                """Set max_buffer_size and flag this type as modified"""
                self._max_buffer_size =  max_buffer_size_
                self._dirty = True

            max_buffer_size = property(lambda self: self._max_buffer_size, _set_max_buffer_size)

            def _set_num_buffers(self, num_buffers_):
                """Set num_buffers and flag this type as modified"""
                self._num_buffers =  num_buffers_
                self._dirty = True

            num_buffers = property(lambda self: self._num_buffers, _set_num_buffers)

            def _set_num_uninitialised(self, num_uninitialised_):
                """Set num_uninitialised and flag this type as modified"""
                self._num_uninitialised =  num_uninitialised_
                self._dirty = True

            num_uninitialised = property(lambda self: self._num_uninitialised, _set_num_uninitialised)

            def _set_phys(self, phys_):
                """Set phys and flag this type as modified"""
                self._phys =  phys_
                self._dirty = True

            phys = property(lambda self: self._phys, _set_phys)

            def _set_size(self, size_):
                """Set size and flag this type as modified"""
                self._size =  size_
                self._dirty = True

            size = property(lambda self: self._size, _set_size)

            def _set_vaddr(self, vaddr_):
                """Set vaddr and flag this type as modified"""
                self._vaddr =  vaddr_
                self._dirty = True

            vaddr = property(lambda self: self._vaddr, _set_vaddr)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.free_head)
                self._pointer_patch(image, symbol, 4, addr + 4, self.freelist)
                image.patch(symbol, self.max_buffer_size, 4, addr + 8)
                image.patch(symbol, self.num_buffers, 4, addr + 12)
                image.patch(symbol, self.num_uninitialised, 4, addr + 16)
                image.patch(symbol, self.phys, 4, addr + 20)
                image.patch(symbol, self.size, 4, addr + 24)
                self.syncpoint.patch(image, symbol, addr + 28)
                image.patch(symbol, self.vaddr, 4, addr + 52)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.free_head,
                        name + '.free_head', True)
                string += self._field_to_string(self.freelist,
                        name + '.freelist', True)
                string += self._field_to_string(self.max_buffer_size,
                        name + '.max_buffer_size', False)
                string += self._field_to_string(self.num_buffers,
                        name + '.num_buffers', False)
                string += self._field_to_string(self.num_uninitialised,
                        name + '.num_uninitialised', False)
                string += self._field_to_string(self.phys,
                        name + '.phys', False)
                string += self._field_to_string(self.size,
                        name + '.size', False)
                string += self._field_to_string(self.syncpoint,
                        name + '.syncpoint', False)
                string += self._field_to_string(self.vaddr,
                        name + '.vaddr', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.free_head)
                self._pointer_to_data(data, 4, self.freelist)
                data.append(self._pack(4, self.max_buffer_size))
                data.append(self._pack(4, self.num_buffers))
                data.append(self._pack(4, self.num_uninitialised))
                data.append(self._pack(4, self.phys))
                data.append(self._pack(4, self.size))
                data.append(self.syncpoint.to_data())
                data.append(self._pack(4, self.vaddr))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.syncpoint.get_phys_relocs(base_offset + self.get_offset_of('syncpoint')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.free_head is not None:
                    return True
                if self.freelist is not None:
                    return True
                if self.syncpoint.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.buff_area = OKL4_AnonymousType_59(this_addr, self)

        class OKL4_AnonymousType_60(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "badge" : {'offset': 0},
                "handler" : {'offset': 4},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._badge = 0

                this_addr = None if address is None else self._address + 4
                self.handler = OKL4_mpointer(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.handler.set_address(address + 4)

            _type_size = 28
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_badge(self, badge_):
                """Set badge and flag this type as modified"""
                self._badge =  badge_
                self._dirty = True

            badge = property(lambda self: self._badge, _set_badge)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.badge, 4, addr + 0)
                self.handler.patch(image, symbol, addr + 4)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.badge,
                        name + '.badge', False)
                string += self._field_to_string(self.handler,
                        name + '.handler', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.badge))
                data.append(self.handler.to_data())

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.handler.get_phys_relocs(base_offset + self.get_offset_of('handler')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.handler.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 64
        self.exception = OKL4_AnonymousType_60(this_addr, self)

        class OKL4_AnonymousType_61(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "allowed" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._allowed = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_allowed(self, allowed_):
                """Set allowed and flag this type as modified"""
                self._allowed =  allowed_
                self._dirty = True

            allowed = property(lambda self: self._allowed, _set_allowed)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.allowed, 4, addr + 0)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.allowed,
                        name + '.allowed', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.allowed))

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 92
        self.intlock = OKL4_AnonymousType_61(this_addr, self)

        class OKL4_AnonymousType_62(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 96
        self.kdb = OKL4_AnonymousType_62(this_addr, self)

        this_addr = None if address is None else self._address + 100
        self.mmu = OKL4_mmu_data(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.buff_area.set_address(address + 8)
        self.exception.set_address(address + 64)
        self.intlock.set_address(address + 92)
        self.kdb.set_address(address + 96)
        self.mmu.set_address(address + 100)

    _type_size = 128
    _type_alignment = 4
    _type_name = "mmu_context"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.buff_area.patch(image, symbol, addr + 8)
        self.exception.patch(image, symbol, addr + 64)
        self.intlock.patch(image, symbol, addr + 92)
        self.kdb.patch(image, symbol, addr + 96)
        self.mmu.patch(image, symbol, addr + 100)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.buff_area,
                name + '.buff_area', False)
        string += self._field_to_string(self.exception,
                name + '.exception', False)
        string += self._field_to_string(self.intlock,
                name + '.intlock', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)
        string += self._field_to_string(self.mmu,
                name + '.mmu', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.buff_area.to_data())
        data.append(self.exception.to_data())
        data.append(self.intlock.to_data())
        data.append(self.kdb.to_data())
        data.append(self.mmu.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.buff_area.get_phys_relocs(base_offset + self.get_offset_of('buff_area')))
        relocs.extend(self.exception.get_phys_relocs(base_offset + self.get_offset_of('exception')))
        relocs.extend(self.intlock.get_phys_relocs(base_offset + self.get_offset_of('intlock')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        relocs.extend(self.mmu.get_phys_relocs(base_offset + self.get_offset_of('mmu')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.buff_area.dirty:
            return True
        if self.exception.dirty:
            return True
        if self.intlock.dirty:
            return True
        if self.kdb.dirty:
            return True
        if self.mmu.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_page_perms(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long page_perms_t;
#define PAGE_PERMS_NONE ((page_perms_t)0x0UL)
#define PAGE_PERMS_X ((page_perms_t)0x1UL)
#define PAGE_PERMS_W ((page_perms_t)0x2UL)
#define PAGE_PERMS_WX ((page_perms_t)0x3UL)
#define PAGE_PERMS_R ((page_perms_t)0x4UL)
#define PAGE_PERMS_RX ((page_perms_t)0x5UL)
#define PAGE_PERMS_RW ((page_perms_t)0x6UL)
#define PAGE_PERMS_RWX ((page_perms_t)0x7UL)
#define PAGE_PERMS_KDEVICE ((page_perms_t)0x8UL)
#define PAGE_PERMS_KRWX_URX ((page_perms_t)0x9UL)
#define PAGE_PERMS_KRX_UNONE ((page_perms_t)0xaUL)
#define PAGE_PERMS_KRW_UNONE ((page_perms_t)0xbUL)
#define PAGE_PERMS_KRW_UR ((page_perms_t)0xcUL)
#define PAGE_PERMS_KRW_URW ((page_perms_t)0xdUL)
#define PAGE_PERMS_KRX_URX ((page_perms_t)0xeUL)
#define PAGE_PERMS_KR_UNONE ((page_perms_t)0xfUL)

    """

    PAGE_PERMS_NONE = 0
    PAGE_PERMS_X = 1
    PAGE_PERMS_W = 2
    PAGE_PERMS_WX = 3
    PAGE_PERMS_R = 4
    PAGE_PERMS_RX = 5
    PAGE_PERMS_RW = 6
    PAGE_PERMS_RWX = 7
    PAGE_PERMS_KDEVICE = 8
    PAGE_PERMS_KRWX_URX = 9
    PAGE_PERMS_KRX_UNONE = 10
    PAGE_PERMS_KRW_UNONE = 11
    PAGE_PERMS_KRW_UR = 12
    PAGE_PERMS_KRW_URW = 13
    PAGE_PERMS_KRX_URX = 14
    PAGE_PERMS_KR_UNONE = 15

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "page_perms"
    _type_libokl4_name = "page_perms"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_cache_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t cache_attr_t;
#define CACHE_ATTR_HW_WRITEBACK ((cache_attr_t)0x0UL)
#define CACHE_ATTR_HW_UNCACHED ((cache_attr_t)0x1UL)
#define CACHE_ATTR_HW_WRITETHROUGH ((cache_attr_t)0x2UL)
#define CACHE_ATTR_HW_STRONG ((cache_attr_t)0x3UL)
#define CACHE_ATTR_HW_DEVICE_SHARED ((cache_attr_t)0x4UL)
#define CACHE_ATTR_HW_WRITETHROUGH_SHARED ((cache_attr_t)0x5UL)
#define CACHE_ATTR_HW_WRITEBACK_SHARED ((cache_attr_t)0x6UL)
#define CACHE_ATTR_HW_UNCACHED_SHARED ((cache_attr_t)0x7UL)
#define CACHE_ATTR_HW_WRITEBACK_ALLOC ((cache_attr_t)0x8UL)
#define CACHE_ATTR_HW_WRITEBACK_ALLOC_SHARED ((cache_attr_t)0x9UL)
#define CACHE_ATTR_HW_DEVICE ((cache_attr_t)0xaUL)
#define CACHE_ATTR_HW_OUTER_ONLY ((cache_attr_t)0xbUL)
#define CACHE_ATTR_HW_OUTER_ONLY_SHARED ((cache_attr_t)0xcUL)
#define CACHE_ATTR_MAX ((cache_attr_t)0xcUL)
#define CACHE_ATTR_WRITECOMBINE ((cache_attr_t)0x2UL)
#define CACHE_ATTR_DEFAULT ((cache_attr_t)0x0UL)
#define CACHE_ATTR_DEVICESHARED ((cache_attr_t)0x4UL)
#define CACHE_ATTR_UNCACHED ((cache_attr_t)0x1UL)
#define CACHE_ATTR_TRACEBUFFER ((cache_attr_t)0x0UL)
#define CACHE_ATTR_WRITETHROUGH ((cache_attr_t)0x2UL)
#define CACHE_ATTR_DEVICENONSHARED ((cache_attr_t)0xaUL)
#define CACHE_ATTR_DEVICE ((cache_attr_t)0xaUL)
#define CACHE_ATTR_STRONG ((cache_attr_t)0x3UL)

    """

    CACHE_ATTR_HW_WRITEBACK = 0
    CACHE_ATTR_HW_UNCACHED = 1
    CACHE_ATTR_HW_WRITETHROUGH = 2
    CACHE_ATTR_HW_STRONG = 3
    CACHE_ATTR_HW_DEVICE_SHARED = 4
    CACHE_ATTR_HW_WRITETHROUGH_SHARED = 5
    CACHE_ATTR_HW_WRITEBACK_SHARED = 6
    CACHE_ATTR_HW_UNCACHED_SHARED = 7
    CACHE_ATTR_HW_WRITEBACK_ALLOC = 8
    CACHE_ATTR_HW_WRITEBACK_ALLOC_SHARED = 9
    CACHE_ATTR_HW_DEVICE = 10
    CACHE_ATTR_HW_OUTER_ONLY = 11
    CACHE_ATTR_HW_OUTER_ONLY_SHARED = 12
    CACHE_ATTR_MAX = 12
    CACHE_ATTR_WRITECOMBINE = 2
    CACHE_ATTR_DEFAULT = 0
    CACHE_ATTR_DEVICESHARED = 4
    CACHE_ATTR_UNCACHED = 1
    CACHE_ATTR_TRACEBUFFER = 0
    CACHE_ATTR_WRITETHROUGH = 2
    CACHE_ATTR_DEVICENONSHARED = 10
    CACHE_ATTR_DEVICE = 10
    CACHE_ATTR_STRONG = 3

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cache_attr"
    _type_libokl4_name = "page_cache"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_cache_mask(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef word_t cache_mask_t;
#define CACHE_MASK_HW_WRITEBACK ((cache_mask_t)0x1UL)
#define CACHE_MASK_HW_UNCACHED ((cache_mask_t)0x2UL)
#define CACHE_MASK_HW_WRITETHROUGH ((cache_mask_t)0x4UL)
#define CACHE_MASK_HW_STRONG ((cache_mask_t)0x8UL)
#define CACHE_MASK_HW_DEVICE_SHARED ((cache_mask_t)0x10UL)
#define CACHE_MASK_HW_WRITETHROUGH_SHARED ((cache_mask_t)0x20UL)
#define CACHE_MASK_HW_WRITEBACK_SHARED ((cache_mask_t)0x40UL)
#define CACHE_MASK_HW_UNCACHED_SHARED ((cache_mask_t)0x80UL)
#define CACHE_MASK_HW_WRITEBACK_ALLOC ((cache_mask_t)0x100UL)
#define CACHE_MASK_HW_WRITEBACK_ALLOC_SHARED ((cache_mask_t)0x200UL)
#define CACHE_MASK_HW_DEVICE ((cache_mask_t)0x400UL)
#define CACHE_MASK_HW_OUTER_ONLY ((cache_mask_t)0x800UL)
#define CACHE_MASK_HW_OUTER_ONLY_SHARED ((cache_mask_t)0x1000UL)
#define CACHE_MASK_WRITECOMBINE ((cache_mask_t)0x4UL)
#define CACHE_MASK_DEFAULT ((cache_mask_t)0x1UL)
#define CACHE_MASK_DEVICESHARED ((cache_mask_t)0x10UL)
#define CACHE_MASK_UNCACHED ((cache_mask_t)0x2UL)
#define CACHE_MASK_TRACEBUFFER ((cache_mask_t)0x1UL)
#define CACHE_MASK_WRITETHROUGH ((cache_mask_t)0x4UL)
#define CACHE_MASK_DEVICENONSHARED ((cache_mask_t)0x400UL)
#define CACHE_MASK_DEVICE ((cache_mask_t)0x400UL)
#define CACHE_MASK_STRONG ((cache_mask_t)0x8UL)

    """

    CACHE_MASK_HW_WRITEBACK = 1
    CACHE_MASK_HW_UNCACHED = 2
    CACHE_MASK_HW_WRITETHROUGH = 4
    CACHE_MASK_HW_STRONG = 8
    CACHE_MASK_HW_DEVICE_SHARED = 16
    CACHE_MASK_HW_WRITETHROUGH_SHARED = 32
    CACHE_MASK_HW_WRITEBACK_SHARED = 64
    CACHE_MASK_HW_UNCACHED_SHARED = 128
    CACHE_MASK_HW_WRITEBACK_ALLOC = 256
    CACHE_MASK_HW_WRITEBACK_ALLOC_SHARED = 512
    CACHE_MASK_HW_DEVICE = 1024
    CACHE_MASK_HW_OUTER_ONLY = 2048
    CACHE_MASK_HW_OUTER_ONLY_SHARED = 4096
    CACHE_MASK_WRITECOMBINE = 4
    CACHE_MASK_DEFAULT = 1
    CACHE_MASK_DEVICESHARED = 16
    CACHE_MASK_UNCACHED = 2
    CACHE_MASK_TRACEBUFFER = 1
    CACHE_MASK_WRITETHROUGH = 4
    CACHE_MASK_DEVICENONSHARED = 1024
    CACHE_MASK_DEVICE = 1024
    CACHE_MASK_STRONG = 8

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cache_mask"
    _type_libokl4_name = "cache_mask"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_hw_cache_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long hw_cache_attr_t;
#define HW_CACHE_ATTR_OUTER_ONLY ((hw_cache_attr_t)0x38UL)
#define HW_CACHE_ATTR_WRITEBACK ((hw_cache_attr_t)0x6UL)
#define HW_CACHE_ATTR_UNCACHED_SHARED ((hw_cache_attr_t)0x9UL)
#define HW_CACHE_ATTR_UNCACHED ((hw_cache_attr_t)0x8UL)
#define HW_CACHE_ATTR_DEVICE_SHARED ((hw_cache_attr_t)0x2UL)
#define HW_CACHE_ATTR_WRITEBACK_ALLOC_SHARED ((hw_cache_attr_t)0xfUL)
#define HW_CACHE_ATTR_OUTER_ONLY_SHARED ((hw_cache_attr_t)0x39UL)
#define HW_CACHE_ATTR_WRITETHROUGH ((hw_cache_attr_t)0x4UL)
#define HW_CACHE_ATTR_WRITETHROUGH_SHARED ((hw_cache_attr_t)0x5UL)
#define HW_CACHE_ATTR_DEVICE ((hw_cache_attr_t)0x10UL)
#define HW_CACHE_ATTR_STRONG ((hw_cache_attr_t)0x0UL)
#define HW_CACHE_ATTR_WRITEBACK_SHARED ((hw_cache_attr_t)0x7UL)
#define HW_CACHE_ATTR_WRITEBACK_ALLOC ((hw_cache_attr_t)0xeUL)
#define HW_CACHE_ATTR_MAX ((hw_cache_attr_t)0x39UL)
#define HW_CACHE_ATTR_INVALID ((hw_cache_attr_t)0xffffffffUL)

    """

    HW_CACHE_ATTR_OUTER_ONLY = 56
    HW_CACHE_ATTR_WRITEBACK = 6
    HW_CACHE_ATTR_UNCACHED_SHARED = 9
    HW_CACHE_ATTR_UNCACHED = 8
    HW_CACHE_ATTR_DEVICE_SHARED = 2
    HW_CACHE_ATTR_WRITEBACK_ALLOC_SHARED = 15
    HW_CACHE_ATTR_OUTER_ONLY_SHARED = 57
    HW_CACHE_ATTR_WRITETHROUGH = 4
    HW_CACHE_ATTR_WRITETHROUGH_SHARED = 5
    HW_CACHE_ATTR_DEVICE = 16
    HW_CACHE_ATTR_STRONG = 0
    HW_CACHE_ATTR_WRITEBACK_SHARED = 7
    HW_CACHE_ATTR_WRITEBACK_ALLOC = 14
    HW_CACHE_ATTR_MAX = 57
    HW_CACHE_ATTR_INVALID = 4294967295

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "hw_cache_attr"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_page_attribute(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef uint32_t page_attribute_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "page_attribute"
    _type_libokl4_name = "page_attribute"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_mmu_data(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct mmu_data {
    asid_t asid;
    word_t first_used_vaddr;
    word_t *pgtable;
    word_t pgtable_phys;
    struct mmu_segment *segment_array;
    word_t segment_count;
    word_t thread_reference_count;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "asid" : {'offset': 0},
        "first_used_vaddr" : {'offset': 4},
        "pgtable" : {'offset': 8},
        "pgtable_phys" : {'phys_reloc': 0, 'offset': 12},
        "segment_array" : {'offset': 16},
        "segment_count" : {'offset': 20},
        "thread_reference_count" : {'offset': 24},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._asid = 0
        self._first_used_vaddr = 4294967295
        self.pgtable = None
        self._pgtable_phys = lambda: 0
        self.segment_array = None
        self._segment_count = 0
        self._thread_reference_count = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 28
    _type_alignment = 4
    _type_name = "mmu_data"
    _type_libokl4_name = ""

    def _set_asid(self, asid_):
        """Set asid and flag this type as modified"""
        self._asid =  asid_
        self._dirty = True

    asid = property(lambda self: self._asid, _set_asid)

    def _set_first_used_vaddr(self, first_used_vaddr_):
        """Set first_used_vaddr and flag this type as modified"""
        self._first_used_vaddr =  first_used_vaddr_
        self._dirty = True

    first_used_vaddr = property(lambda self: self._first_used_vaddr, _set_first_used_vaddr)

    def _set_pgtable_phys(self, pgtable_phys_):
        """Set pgtable_phys and flag this type as modified"""
        self._pgtable_phys =  pgtable_phys_
        self._dirty = True

    pgtable_phys = property(lambda self: self._pgtable_phys, _set_pgtable_phys)

    def _set_segment_count(self, segment_count_):
        """Set segment_count and flag this type as modified"""
        self._segment_count =  segment_count_
        self._dirty = True

    segment_count = property(lambda self: self._segment_count, _set_segment_count)

    def _set_thread_reference_count(self, thread_reference_count_):
        """Set thread_reference_count and flag this type as modified"""
        self._thread_reference_count =  thread_reference_count_
        self._dirty = True

    thread_reference_count = property(lambda self: self._thread_reference_count, _set_thread_reference_count)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.asid, 4, addr + 0)
        image.patch(symbol, self.first_used_vaddr, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.pgtable)
        image.patch(symbol, self.pgtable_phys(), 4, addr + 12)
        self._pointer_patch(image, symbol, 4, addr + 12, self.segment_array)
        image.patch(symbol, self.segment_count, 4, addr + 16)
        image.patch(symbol, self.thread_reference_count, 4, addr + 20)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.asid,
                name + '.asid', False)
        string += self._field_to_string(self.first_used_vaddr,
                name + '.first_used_vaddr', False)
        string += self._field_to_string(self.pgtable,
                name + '.pgtable', True)
        string += self._field_to_string(self.pgtable_phys,
                name + '.pgtable_phys', False)
        string += self._field_to_string(self.segment_array,
                name + '.segment_array', True)
        string += self._field_to_string(self.segment_count,
                name + '.segment_count', False)
        string += self._field_to_string(self.thread_reference_count,
                name + '.thread_reference_count', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.asid))
        data.append(self._pack(4, self.first_used_vaddr))
        self._pointer_to_data(data, 4, self.pgtable)
        data.append(self._pack(4, self.pgtable_phys()))
        self._pointer_to_data(data, 4, self.segment_array)
        data.append(self._pack(4, self.segment_count))
        data.append(self._pack(4, self.thread_reference_count))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.pgtable is not None:
            return True
        if self.segment_array is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_mmu_thread_data(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct mmu_thread_data {
    struct mmu_map_arch_context arch;
    mmu_thread_op_t current_op;
    union mmu_thread_op_data op;
    struct mmu_context *mmu_context;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "arch" : {'offset': 0},
        "current_op" : {'offset': 4},
        "op" : {'offset': 8},
        "mmu_context" : {'offset': 52},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.arch = OKL4_mmu_map_arch_context(this_addr, self)
        self._current_op = 0

        class OKL4_AnonymousType_63(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "map" : {},
                "flush" : {},
                "unmap_segment" : {},
                "lookup_attr" : {},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                class OKL4_AnonymousType_64(ElfweaverType):
                    """Implement an anonymous structure."""

                    # Field property list.  The keys are used to detect places where a
                    # renamed field has been missed.  The value describes various
                    # field properties.
                    _plist = {
                        "mmu_mpointer" : {'offset': 0},
                        "page_attr" : {'offset': 24},
                        "phys" : {'phys_reloc': 0, 'offset': 28},
                        "segment_index" : {'offset': 32},
                        "size" : {'offset': 36},
                        "vaddr" : {'offset': 40},
                    }

                    def __init__(self, address, back_ptr = None, phys_addr = None):
                        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                        this_addr = None if address is None else self._address + 0
                        self.mmu_mpointer = OKL4_mpointer(this_addr, self)
                        self._page_attr = 0
                        self._phys = 0
                        self._segment_index = 0
                        self._size = 0
                        self._vaddr = 0

                    def set_address(self, address, phys_addr = None):
                        """Set the virtual and physical address of the object."""

                        ElfweaverType.set_address(self, address, phys_addr)

                        self.mmu_mpointer.set_address(address + 0)

                    _type_size = 44
                    _type_alignment = 4
                    _type_name = ""
                    _type_libokl4_name = ""

                    def _set_page_attr(self, page_attr_):
                        """Set page_attr and flag this type as modified"""
                        self._page_attr =  page_attr_
                        self._dirty = True

                    page_attr = property(lambda self: self._page_attr, _set_page_attr)

                    def _set_phys(self, phys_):
                        """Set phys and flag this type as modified"""
                        self._phys =  phys_
                        self._dirty = True

                    phys = property(lambda self: self._phys, _set_phys)

                    def _set_segment_index(self, segment_index_):
                        """Set segment_index and flag this type as modified"""
                        self._segment_index =  segment_index_
                        self._dirty = True

                    segment_index = property(lambda self: self._segment_index, _set_segment_index)

                    def _set_size(self, size_):
                        """Set size and flag this type as modified"""
                        self._size =  size_
                        self._dirty = True

                    size = property(lambda self: self._size, _set_size)

                    def _set_vaddr(self, vaddr_):
                        """Set vaddr and flag this type as modified"""
                        self._vaddr =  vaddr_
                        self._dirty = True

                    vaddr = property(lambda self: self._vaddr, _set_vaddr)

                    def patch(self, image, symbol, addr = 0):
                        """Patch the data in this type at symbol + addr."""

                        self.mmu_mpointer.patch(image, symbol, addr + 0)
                        image.patch(symbol, self.page_attr, 4, addr + 24)
                        image.patch(symbol, self.phys, 4, addr + 28)
                        image.patch(symbol, self.segment_index, 4, addr + 32)
                        image.patch(symbol, self.size, 4, addr + 36)
                        image.patch(symbol, self.vaddr, 4, addr + 40)

                    def to_string(self, name = ''):
                        """Generate a human-readable form of the object."""

                        string = name + ' - ' + str(self) + '\n'

                        string += self._field_to_string(self.mmu_mpointer,
                                name + '.mmu_mpointer', False)
                        string += self._field_to_string(self.page_attr,
                                name + '.page_attr', False)
                        string += self._field_to_string(self.phys,
                                name + '.phys', False)
                        string += self._field_to_string(self.segment_index,
                                name + '.segment_index', False)
                        string += self._field_to_string(self.size,
                                name + '.size', False)
                        string += self._field_to_string(self.vaddr,
                                name + '.vaddr', False)

                        return string

                    def to_data(self):
                        """Convert the object into binary form."""

                        data = []

                        data.append(self.mmu_mpointer.to_data())
                        data.append(self._pack(4, self.page_attr))
                        data.append(self._pack(4, self.phys))
                        data.append(self._pack(4, self.segment_index))
                        data.append(self._pack(4, self.size))
                        data.append(self._pack(4, self.vaddr))

                        return ''.join(data)

                    def get_phys_relocs(self, base_offset=0):
                        relocs = self._get_local_phys_reloc(base_offset)
                        relocs.extend(self.mmu_mpointer.get_phys_relocs(base_offset + self.get_offset_of('mmu_mpointer')))
                        return relocs


                    def _get_dirty(self):
                        """Check if any element of this type has been modified."""
                        if self._dirty:
                            return True

                        if self.mmu_mpointer.dirty:
                            return True

                        return False
                    dirty = property(_get_dirty)



                this_addr = None if address is None else self._address + 0
                self.map = OKL4_AnonymousType_64(this_addr, self)

                class OKL4_AnonymousType_65(ElfweaverType):
                    """Implement an anonymous structure."""

                    # Field property list.  The keys are used to detect places where a
                    # renamed field has been missed.  The value describes various
                    # field properties.
                    _plist = {
                        "mpointer" : {'offset': 0},
                        "size" : {'offset': 24},
                        "vaddr" : {'offset': 28},
                    }

                    def __init__(self, address, back_ptr = None, phys_addr = None):
                        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                        this_addr = None if address is None else self._address + 0
                        self.mpointer = OKL4_mpointer(this_addr, self)
                        self._size = 0
                        self._vaddr = 0

                    def set_address(self, address, phys_addr = None):
                        """Set the virtual and physical address of the object."""

                        ElfweaverType.set_address(self, address, phys_addr)

                        self.mpointer.set_address(address + 0)

                    _type_size = 32
                    _type_alignment = 4
                    _type_name = ""
                    _type_libokl4_name = ""

                    def _set_size(self, size_):
                        """Set size and flag this type as modified"""
                        self._size =  size_
                        self._dirty = True

                    size = property(lambda self: self._size, _set_size)

                    def _set_vaddr(self, vaddr_):
                        """Set vaddr and flag this type as modified"""
                        self._vaddr =  vaddr_
                        self._dirty = True

                    vaddr = property(lambda self: self._vaddr, _set_vaddr)

                    def patch(self, image, symbol, addr = 0):
                        """Patch the data in this type at symbol + addr."""

                        self.mpointer.patch(image, symbol, addr + 0)
                        image.patch(symbol, self.size, 4, addr + 24)
                        image.patch(symbol, self.vaddr, 4, addr + 28)

                    def to_string(self, name = ''):
                        """Generate a human-readable form of the object."""

                        string = name + ' - ' + str(self) + '\n'

                        string += self._field_to_string(self.mpointer,
                                name + '.mpointer', False)
                        string += self._field_to_string(self.size,
                                name + '.size', False)
                        string += self._field_to_string(self.vaddr,
                                name + '.vaddr', False)

                        return string

                    def to_data(self):
                        """Convert the object into binary form."""

                        data = []

                        data.append(self.mpointer.to_data())
                        data.append(self._pack(4, self.size))
                        data.append(self._pack(4, self.vaddr))

                        return ''.join(data)

                    def get_phys_relocs(self, base_offset=0):
                        relocs = self._get_local_phys_reloc(base_offset)
                        relocs.extend(self.mpointer.get_phys_relocs(base_offset + self.get_offset_of('mpointer')))
                        return relocs


                    def _get_dirty(self):
                        """Check if any element of this type has been modified."""
                        if self._dirty:
                            return True

                        if self.mpointer.dirty:
                            return True

                        return False
                    dirty = property(_get_dirty)



                this_addr = None if address is None else self._address + 0
                self.flush = OKL4_AnonymousType_65(this_addr, self)

                class OKL4_AnonymousType_66(ElfweaverType):
                    """Implement an anonymous structure."""

                    # Field property list.  The keys are used to detect places where a
                    # renamed field has been missed.  The value describes various
                    # field properties.
                    _plist = {
                        "mmu_mpointer" : {'offset': 0},
                        "segment_index" : {'offset': 24},
                        "vaddr" : {'offset': 28},
                    }

                    def __init__(self, address, back_ptr = None, phys_addr = None):
                        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                        this_addr = None if address is None else self._address + 0
                        self.mmu_mpointer = OKL4_mpointer(this_addr, self)
                        self._segment_index = 0
                        self._vaddr = 0

                    def set_address(self, address, phys_addr = None):
                        """Set the virtual and physical address of the object."""

                        ElfweaverType.set_address(self, address, phys_addr)

                        self.mmu_mpointer.set_address(address + 0)

                    _type_size = 32
                    _type_alignment = 4
                    _type_name = ""
                    _type_libokl4_name = ""

                    def _set_segment_index(self, segment_index_):
                        """Set segment_index and flag this type as modified"""
                        self._segment_index =  segment_index_
                        self._dirty = True

                    segment_index = property(lambda self: self._segment_index, _set_segment_index)

                    def _set_vaddr(self, vaddr_):
                        """Set vaddr and flag this type as modified"""
                        self._vaddr =  vaddr_
                        self._dirty = True

                    vaddr = property(lambda self: self._vaddr, _set_vaddr)

                    def patch(self, image, symbol, addr = 0):
                        """Patch the data in this type at symbol + addr."""

                        self.mmu_mpointer.patch(image, symbol, addr + 0)
                        image.patch(symbol, self.segment_index, 4, addr + 24)
                        image.patch(symbol, self.vaddr, 4, addr + 28)

                    def to_string(self, name = ''):
                        """Generate a human-readable form of the object."""

                        string = name + ' - ' + str(self) + '\n'

                        string += self._field_to_string(self.mmu_mpointer,
                                name + '.mmu_mpointer', False)
                        string += self._field_to_string(self.segment_index,
                                name + '.segment_index', False)
                        string += self._field_to_string(self.vaddr,
                                name + '.vaddr', False)

                        return string

                    def to_data(self):
                        """Convert the object into binary form."""

                        data = []

                        data.append(self.mmu_mpointer.to_data())
                        data.append(self._pack(4, self.segment_index))
                        data.append(self._pack(4, self.vaddr))

                        return ''.join(data)

                    def get_phys_relocs(self, base_offset=0):
                        relocs = self._get_local_phys_reloc(base_offset)
                        relocs.extend(self.mmu_mpointer.get_phys_relocs(base_offset + self.get_offset_of('mmu_mpointer')))
                        return relocs


                    def _get_dirty(self):
                        """Check if any element of this type has been modified."""
                        if self._dirty:
                            return True

                        if self.mmu_mpointer.dirty:
                            return True

                        return False
                    dirty = property(_get_dirty)



                this_addr = None if address is None else self._address + 0
                self.unmap_segment = OKL4_AnonymousType_66(this_addr, self)

                class OKL4_AnonymousType_67(ElfweaverType):
                    """Implement an anonymous structure."""

                    # Field property list.  The keys are used to detect places where a
                    # renamed field has been missed.  The value describes various
                    # field properties.
                    _plist = {
                        "attr" : {'offset': 0},
                        "mpointer" : {'offset': 4},
                        "size" : {'offset': 28},
                        "vaddr" : {'offset': 32},
                    }

                    def __init__(self, address, back_ptr = None, phys_addr = None):
                        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                        self._attr = 0

                        this_addr = None if address is None else self._address + 4
                        self.mpointer = OKL4_mpointer(this_addr, self)
                        self._size = 0
                        self._vaddr = 0

                    def set_address(self, address, phys_addr = None):
                        """Set the virtual and physical address of the object."""

                        ElfweaverType.set_address(self, address, phys_addr)

                        self.mpointer.set_address(address + 4)

                    _type_size = 36
                    _type_alignment = 4
                    _type_name = ""
                    _type_libokl4_name = ""

                    def _set_attr(self, attr_):
                        """Set attr and flag this type as modified"""
                        self._attr =  attr_
                        self._dirty = True

                    attr = property(lambda self: self._attr, _set_attr)

                    def _set_size(self, size_):
                        """Set size and flag this type as modified"""
                        self._size =  size_
                        self._dirty = True

                    size = property(lambda self: self._size, _set_size)

                    def _set_vaddr(self, vaddr_):
                        """Set vaddr and flag this type as modified"""
                        self._vaddr =  vaddr_
                        self._dirty = True

                    vaddr = property(lambda self: self._vaddr, _set_vaddr)

                    def patch(self, image, symbol, addr = 0):
                        """Patch the data in this type at symbol + addr."""

                        image.patch(symbol, self.attr, 4, addr + 0)
                        self.mpointer.patch(image, symbol, addr + 4)
                        image.patch(symbol, self.size, 4, addr + 28)
                        image.patch(symbol, self.vaddr, 4, addr + 32)

                    def to_string(self, name = ''):
                        """Generate a human-readable form of the object."""

                        string = name + ' - ' + str(self) + '\n'

                        string += self._field_to_string(self.attr,
                                name + '.attr', False)
                        string += self._field_to_string(self.mpointer,
                                name + '.mpointer', False)
                        string += self._field_to_string(self.size,
                                name + '.size', False)
                        string += self._field_to_string(self.vaddr,
                                name + '.vaddr', False)

                        return string

                    def to_data(self):
                        """Convert the object into binary form."""

                        data = []

                        data.append(self._pack(4, self.attr))
                        data.append(self.mpointer.to_data())
                        data.append(self._pack(4, self.size))
                        data.append(self._pack(4, self.vaddr))

                        return ''.join(data)

                    def get_phys_relocs(self, base_offset=0):
                        relocs = self._get_local_phys_reloc(base_offset)
                        relocs.extend(self.mpointer.get_phys_relocs(base_offset + self.get_offset_of('mpointer')))
                        return relocs


                    def _get_dirty(self):
                        """Check if any element of this type has been modified."""
                        if self._dirty:
                            return True

                        if self.mpointer.dirty:
                            return True

                        return False
                    dirty = property(_get_dirty)



                this_addr = None if address is None else self._address + 0
                self.lookup_attr = OKL4_AnonymousType_67(this_addr, self)

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.map.set_address(address + 0)
                self.flush.set_address(address + 0)
                self.unmap_segment.set_address(address + 0)
                self.lookup_attr.set_address(address + 0)

            _type_size = 44
            _type_alignment = 4
            _type_name = "mmu_thread_op_data"
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                pass

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.map,
                        name + '.map', False)
                string += self._field_to_string(self.flush,
                        name + '.flush', False)
                string += self._field_to_string(self.unmap_segment,
                        name + '.unmap_segment', False)
                string += self._field_to_string(self.lookup_attr,
                        name + '.lookup_attr', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                count = 0
                field_size = 0
                if self.map.dirty:
                    count += 1
                    field_size = 44
                    data.append(self.map.to_data())
                if self.flush.dirty:
                    count += 1
                    field_size = 32
                    data.append(self.flush.to_data())
                if self.unmap_segment.dirty:
                    count += 1
                    field_size = 32
                    data.append(self.unmap_segment.to_data())
                if self.lookup_attr.dirty:
                    count += 1
                    field_size = 36
                    data.append(self.lookup_attr.to_data())
                if count > 1:
                    raise ElfweaverTypeException('More than one entry in the union value has been set')
                bytes_left = 44 - field_size
                for val in (8, 4, 2, 1):
                    while bytes_left >= val:
                        data.append(self._pack(val, 0))
                        bytes_left -= val

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.op = OKL4_AnonymousType_63(this_addr, self)
        self.mmu_context = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.arch.set_address(address + 0)
        self.op.set_address(address + 8)

    _type_size = 56
    _type_alignment = 4
    _type_name = "mmu_thread_data"
    _type_libokl4_name = ""

    def _set_current_op(self, current_op_):
        """Set current_op and flag this type as modified"""
        self._current_op =  current_op_
        self._dirty = True

    current_op = property(lambda self: self._current_op, _set_current_op)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.arch.patch(image, symbol, addr + 0)
        image.patch(symbol, self.current_op, 4, addr + 4)
        self.op.patch(image, symbol, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 52, self.mmu_context)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.arch,
                name + '.arch', False)
        string += self._field_to_string(self.current_op,
                name + '.current_op', False)
        string += self._field_to_string(self.op,
                name + '.op', False)
        string += self._field_to_string(self.mmu_context,
                name + '.mmu_context', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.arch.to_data())
        data.append(self._pack(4, self.current_op))
        data.append(self.op.to_data())
        self._pointer_to_data(data, 4, self.mmu_context)

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.arch.get_phys_relocs(base_offset + self.get_offset_of('arch')))
        relocs.extend(self.op.get_phys_relocs(base_offset + self.get_offset_of('op')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.arch.dirty:
            return True
        if self.op.dirty:
            return True
        if self.mmu_context is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_mmu_thread_op(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long mmu_thread_op_t;
#define MMU_THREAD_OP_NONE ((mmu_thread_op_t)0x0UL)
#define MMU_THREAD_OP_MAP ((mmu_thread_op_t)0x1UL)
#define MMU_THREAD_OP_FLUSH ((mmu_thread_op_t)0x2UL)
#define MMU_THREAD_OP_UNMAP_SEGMENT ((mmu_thread_op_t)0x3UL)
#define MMU_THREAD_OP_LOOKUP_ATTR ((mmu_thread_op_t)0x4UL)

    """

    MMU_THREAD_OP_NONE = 0
    MMU_THREAD_OP_MAP = 1
    MMU_THREAD_OP_FLUSH = 2
    MMU_THREAD_OP_UNMAP_SEGMENT = 3
    MMU_THREAD_OP_LOOKUP_ATTR = 4

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "mmu_thread_op"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_mmu_segment(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct mmu_segment {
    mmu_segment_state_t ref_count;
    struct mpointer segment_mpointer;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "ref_count" : {'offset': 0},
        "segment_mpointer" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._ref_count = 0

        this_addr = None if address is None else self._address + 4
        self.segment_mpointer = OKL4_mpointer(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.segment_mpointer.set_address(address + 4)

    _type_size = 28
    _type_alignment = 4
    _type_name = "mmu_segment"
    _type_libokl4_name = ""

    def _set_ref_count(self, ref_count_):
        """Set ref_count and flag this type as modified"""
        self._ref_count =  ref_count_
        self._dirty = True

    ref_count = property(lambda self: self._ref_count, _set_ref_count)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.ref_count, 4, addr + 0)
        self.segment_mpointer.patch(image, symbol, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.ref_count,
                name + '.ref_count', False)
        string += self._field_to_string(self.segment_mpointer,
                name + '.segment_mpointer', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.ref_count))
        data.append(self.segment_mpointer.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.segment_mpointer.get_phys_relocs(base_offset + self.get_offset_of('segment_mpointer')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.segment_mpointer.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_mmu_segment_state(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef sword_t mmu_segment_state_t;
#define MMU_SEGMENT_STATE_INVALID ((mmu_segment_state_t)0xffffffffUL)
#define MMU_SEGMENT_STATE_PENDING_DETACH ((mmu_segment_state_t)0x0UL)
#define MMU_SEGMENT_STATE_MAX ((mmu_segment_state_t)0x7fffffffUL)

    """

    MMU_SEGMENT_STATE_INVALID = 4294967295
    MMU_SEGMENT_STATE_PENDING_DETACH = 0
    MMU_SEGMENT_STATE_MAX = 2147483647

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "mmu_segment_state"
    _type_libokl4_name = ""

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_mmu_thread_op_data(ElfweaverType):
    """
    Implement a python class that represents the C type:

union mmu_thread_op_data {
    struct {
        struct mpointer mmu_mpointer;
        word_t page_attr;
        word_t phys;
        word_t segment_index;
        word_t size;
        word_t vaddr;
    } map;
    struct {
        struct mpointer mpointer;
        word_t size;
        word_t vaddr;
    } flush;
    struct {
        struct mpointer mmu_mpointer;
        word_t segment_index;
        word_t vaddr;
    } unmap_segment;
    struct {
        word_t attr;
        struct mpointer mpointer;
        word_t size;
        word_t vaddr;
    } lookup_attr;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "map" : {},
        "flush" : {},
        "unmap_segment" : {},
        "lookup_attr" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        class OKL4_AnonymousType_68(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "mmu_mpointer" : {'offset': 0},
                "page_attr" : {'offset': 24},
                "phys" : {'phys_reloc': 0, 'offset': 28},
                "segment_index" : {'offset': 32},
                "size" : {'offset': 36},
                "vaddr" : {'offset': 40},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.mmu_mpointer = OKL4_mpointer(this_addr, self)
                self._page_attr = 0
                self._phys = 0
                self._segment_index = 0
                self._size = 0
                self._vaddr = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.mmu_mpointer.set_address(address + 0)

            _type_size = 44
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_page_attr(self, page_attr_):
                """Set page_attr and flag this type as modified"""
                self._page_attr =  page_attr_
                self._dirty = True

            page_attr = property(lambda self: self._page_attr, _set_page_attr)

            def _set_phys(self, phys_):
                """Set phys and flag this type as modified"""
                self._phys =  phys_
                self._dirty = True

            phys = property(lambda self: self._phys, _set_phys)

            def _set_segment_index(self, segment_index_):
                """Set segment_index and flag this type as modified"""
                self._segment_index =  segment_index_
                self._dirty = True

            segment_index = property(lambda self: self._segment_index, _set_segment_index)

            def _set_size(self, size_):
                """Set size and flag this type as modified"""
                self._size =  size_
                self._dirty = True

            size = property(lambda self: self._size, _set_size)

            def _set_vaddr(self, vaddr_):
                """Set vaddr and flag this type as modified"""
                self._vaddr =  vaddr_
                self._dirty = True

            vaddr = property(lambda self: self._vaddr, _set_vaddr)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.mmu_mpointer.patch(image, symbol, addr + 0)
                image.patch(symbol, self.page_attr, 4, addr + 24)
                image.patch(symbol, self.phys, 4, addr + 28)
                image.patch(symbol, self.segment_index, 4, addr + 32)
                image.patch(symbol, self.size, 4, addr + 36)
                image.patch(symbol, self.vaddr, 4, addr + 40)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.mmu_mpointer,
                        name + '.mmu_mpointer', False)
                string += self._field_to_string(self.page_attr,
                        name + '.page_attr', False)
                string += self._field_to_string(self.phys,
                        name + '.phys', False)
                string += self._field_to_string(self.segment_index,
                        name + '.segment_index', False)
                string += self._field_to_string(self.size,
                        name + '.size', False)
                string += self._field_to_string(self.vaddr,
                        name + '.vaddr', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.mmu_mpointer.to_data())
                data.append(self._pack(4, self.page_attr))
                data.append(self._pack(4, self.phys))
                data.append(self._pack(4, self.segment_index))
                data.append(self._pack(4, self.size))
                data.append(self._pack(4, self.vaddr))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.mmu_mpointer.get_phys_relocs(base_offset + self.get_offset_of('mmu_mpointer')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.mmu_mpointer.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.map = OKL4_AnonymousType_68(this_addr, self)

        class OKL4_AnonymousType_69(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "mpointer" : {'offset': 0},
                "size" : {'offset': 24},
                "vaddr" : {'offset': 28},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.mpointer = OKL4_mpointer(this_addr, self)
                self._size = 0
                self._vaddr = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.mpointer.set_address(address + 0)

            _type_size = 32
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_size(self, size_):
                """Set size and flag this type as modified"""
                self._size =  size_
                self._dirty = True

            size = property(lambda self: self._size, _set_size)

            def _set_vaddr(self, vaddr_):
                """Set vaddr and flag this type as modified"""
                self._vaddr =  vaddr_
                self._dirty = True

            vaddr = property(lambda self: self._vaddr, _set_vaddr)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.mpointer.patch(image, symbol, addr + 0)
                image.patch(symbol, self.size, 4, addr + 24)
                image.patch(symbol, self.vaddr, 4, addr + 28)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.mpointer,
                        name + '.mpointer', False)
                string += self._field_to_string(self.size,
                        name + '.size', False)
                string += self._field_to_string(self.vaddr,
                        name + '.vaddr', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.mpointer.to_data())
                data.append(self._pack(4, self.size))
                data.append(self._pack(4, self.vaddr))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.mpointer.get_phys_relocs(base_offset + self.get_offset_of('mpointer')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.mpointer.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.flush = OKL4_AnonymousType_69(this_addr, self)

        class OKL4_AnonymousType_70(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "mmu_mpointer" : {'offset': 0},
                "segment_index" : {'offset': 24},
                "vaddr" : {'offset': 28},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)


                this_addr = None if address is None else self._address + 0
                self.mmu_mpointer = OKL4_mpointer(this_addr, self)
                self._segment_index = 0
                self._vaddr = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.mmu_mpointer.set_address(address + 0)

            _type_size = 32
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_segment_index(self, segment_index_):
                """Set segment_index and flag this type as modified"""
                self._segment_index =  segment_index_
                self._dirty = True

            segment_index = property(lambda self: self._segment_index, _set_segment_index)

            def _set_vaddr(self, vaddr_):
                """Set vaddr and flag this type as modified"""
                self._vaddr =  vaddr_
                self._dirty = True

            vaddr = property(lambda self: self._vaddr, _set_vaddr)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self.mmu_mpointer.patch(image, symbol, addr + 0)
                image.patch(symbol, self.segment_index, 4, addr + 24)
                image.patch(symbol, self.vaddr, 4, addr + 28)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.mmu_mpointer,
                        name + '.mmu_mpointer', False)
                string += self._field_to_string(self.segment_index,
                        name + '.segment_index', False)
                string += self._field_to_string(self.vaddr,
                        name + '.vaddr', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self.mmu_mpointer.to_data())
                data.append(self._pack(4, self.segment_index))
                data.append(self._pack(4, self.vaddr))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.mmu_mpointer.get_phys_relocs(base_offset + self.get_offset_of('mmu_mpointer')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.mmu_mpointer.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.unmap_segment = OKL4_AnonymousType_70(this_addr, self)

        class OKL4_AnonymousType_71(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "attr" : {'offset': 0},
                "mpointer" : {'offset': 4},
                "size" : {'offset': 28},
                "vaddr" : {'offset': 32},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self._attr = 0

                this_addr = None if address is None else self._address + 4
                self.mpointer = OKL4_mpointer(this_addr, self)
                self._size = 0
                self._vaddr = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.mpointer.set_address(address + 4)

            _type_size = 36
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_attr(self, attr_):
                """Set attr and flag this type as modified"""
                self._attr =  attr_
                self._dirty = True

            attr = property(lambda self: self._attr, _set_attr)

            def _set_size(self, size_):
                """Set size and flag this type as modified"""
                self._size =  size_
                self._dirty = True

            size = property(lambda self: self._size, _set_size)

            def _set_vaddr(self, vaddr_):
                """Set vaddr and flag this type as modified"""
                self._vaddr =  vaddr_
                self._dirty = True

            vaddr = property(lambda self: self._vaddr, _set_vaddr)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                image.patch(symbol, self.attr, 4, addr + 0)
                self.mpointer.patch(image, symbol, addr + 4)
                image.patch(symbol, self.size, 4, addr + 28)
                image.patch(symbol, self.vaddr, 4, addr + 32)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.attr,
                        name + '.attr', False)
                string += self._field_to_string(self.mpointer,
                        name + '.mpointer', False)
                string += self._field_to_string(self.size,
                        name + '.size', False)
                string += self._field_to_string(self.vaddr,
                        name + '.vaddr', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                data.append(self._pack(4, self.attr))
                data.append(self.mpointer.to_data())
                data.append(self._pack(4, self.size))
                data.append(self._pack(4, self.vaddr))

                return ''.join(data)

            def get_phys_relocs(self, base_offset=0):
                relocs = self._get_local_phys_reloc(base_offset)
                relocs.extend(self.mpointer.get_phys_relocs(base_offset + self.get_offset_of('mpointer')))
                return relocs


            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.mpointer.dirty:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.lookup_attr = OKL4_AnonymousType_71(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.map.set_address(address + 0)
        self.flush.set_address(address + 0)
        self.unmap_segment.set_address(address + 0)
        self.lookup_attr.set_address(address + 0)

    _type_size = 44
    _type_alignment = 4
    _type_name = "mmu_thread_op_data"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        pass

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.map,
                name + '.map', False)
        string += self._field_to_string(self.flush,
                name + '.flush', False)
        string += self._field_to_string(self.unmap_segment,
                name + '.unmap_segment', False)
        string += self._field_to_string(self.lookup_attr,
                name + '.lookup_attr', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        count = 0
        field_size = 0
        if self.map.dirty:
            count += 1
            field_size = 44
            data.append(self.map.to_data())
        if self.flush.dirty:
            count += 1
            field_size = 32
            data.append(self.flush.to_data())
        if self.unmap_segment.dirty:
            count += 1
            field_size = 32
            data.append(self.unmap_segment.to_data())
        if self.lookup_attr.dirty:
            count += 1
            field_size = 36
            data.append(self.lookup_attr.to_data())
        if count > 1:
            raise ElfweaverTypeException('More than one entry in the union value has been set')
        bytes_left = 44 - field_size
        for val in (8, 4, 2, 1):
            while bytes_left >= val:
                data.append(self._pack(val, 0))
                bytes_left -= val

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_cpureg_callback_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "cpureg_callback_t"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_registers_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct registers registers_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "r0" : {},
        "r1" : {},
        "r2" : {},
        "r3" : {},
        "r4" : {},
        "r5" : {},
        "r6" : {},
        "r7" : {},
        "r8" : {},
        "r9" : {},
        "r10" : {},
        "r11" : {},
        "r12" : {},
        "r13" : {},
        "r14" : {},
        "r15" : {},
        "cpsr" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._r0 = 0
        self._r1 = 0
        self._r2 = 0
        self._r3 = 0
        self._r4 = 0
        self._r5 = 0
        self._r6 = 0
        self._r7 = 0
        self._r8 = 0
        self._r9 = 0
        self._r10 = 0
        self._r11 = 0
        self._r12 = 0
        self._r13 = 0
        self._r14 = 0
        self._r15 = 0
        self._cpsr = 16

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 68
    _type_alignment = 4
    _type_name = "registers_t"
    _type_libokl4_name = "cpu_registers_t"

    def _set_r0(self, r0_):
        """Set r0 and flag this type as modified"""
        self._r0 =  r0_
        self._dirty = True

    r0 = property(lambda self: self._r0, _set_r0)

    def _set_r1(self, r1_):
        """Set r1 and flag this type as modified"""
        self._r1 =  r1_
        self._dirty = True

    r1 = property(lambda self: self._r1, _set_r1)

    def _set_r2(self, r2_):
        """Set r2 and flag this type as modified"""
        self._r2 =  r2_
        self._dirty = True

    r2 = property(lambda self: self._r2, _set_r2)

    def _set_r3(self, r3_):
        """Set r3 and flag this type as modified"""
        self._r3 =  r3_
        self._dirty = True

    r3 = property(lambda self: self._r3, _set_r3)

    def _set_r4(self, r4_):
        """Set r4 and flag this type as modified"""
        self._r4 =  r4_
        self._dirty = True

    r4 = property(lambda self: self._r4, _set_r4)

    def _set_r5(self, r5_):
        """Set r5 and flag this type as modified"""
        self._r5 =  r5_
        self._dirty = True

    r5 = property(lambda self: self._r5, _set_r5)

    def _set_r6(self, r6_):
        """Set r6 and flag this type as modified"""
        self._r6 =  r6_
        self._dirty = True

    r6 = property(lambda self: self._r6, _set_r6)

    def _set_r7(self, r7_):
        """Set r7 and flag this type as modified"""
        self._r7 =  r7_
        self._dirty = True

    r7 = property(lambda self: self._r7, _set_r7)

    def _set_r8(self, r8_):
        """Set r8 and flag this type as modified"""
        self._r8 =  r8_
        self._dirty = True

    r8 = property(lambda self: self._r8, _set_r8)

    def _set_r9(self, r9_):
        """Set r9 and flag this type as modified"""
        self._r9 =  r9_
        self._dirty = True

    r9 = property(lambda self: self._r9, _set_r9)

    def _set_r10(self, r10_):
        """Set r10 and flag this type as modified"""
        self._r10 =  r10_
        self._dirty = True

    r10 = property(lambda self: self._r10, _set_r10)

    def _set_r11(self, r11_):
        """Set r11 and flag this type as modified"""
        self._r11 =  r11_
        self._dirty = True

    r11 = property(lambda self: self._r11, _set_r11)

    def _set_r12(self, r12_):
        """Set r12 and flag this type as modified"""
        self._r12 =  r12_
        self._dirty = True

    r12 = property(lambda self: self._r12, _set_r12)

    def _set_r13(self, r13_):
        """Set r13 and flag this type as modified"""
        self._r13 =  r13_
        self._dirty = True

    r13 = property(lambda self: self._r13, _set_r13)

    def _set_r14(self, r14_):
        """Set r14 and flag this type as modified"""
        self._r14 =  r14_
        self._dirty = True

    r14 = property(lambda self: self._r14, _set_r14)

    def _set_r15(self, r15_):
        """Set r15 and flag this type as modified"""
        self._r15 =  r15_
        self._dirty = True

    r15 = property(lambda self: self._r15, _set_r15)

    def _set_cpsr(self, cpsr_):
        """Set cpsr and flag this type as modified"""
        self._cpsr =  cpsr_
        self._dirty = True

    cpsr = property(lambda self: self._cpsr, _set_cpsr)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.r0, 4, addr + 0)
        image.patch(symbol, self.r1, 4, addr + 4)
        image.patch(symbol, self.r2, 4, addr + 8)
        image.patch(symbol, self.r3, 4, addr + 12)
        image.patch(symbol, self.r4, 4, addr + 16)
        image.patch(symbol, self.r5, 4, addr + 20)
        image.patch(symbol, self.r6, 4, addr + 24)
        image.patch(symbol, self.r7, 4, addr + 28)
        image.patch(symbol, self.r8, 4, addr + 32)
        image.patch(symbol, self.r9, 4, addr + 36)
        image.patch(symbol, self.r10, 4, addr + 40)
        image.patch(symbol, self.r11, 4, addr + 44)
        image.patch(symbol, self.r12, 4, addr + 48)
        image.patch(symbol, self.r13, 4, addr + 52)
        image.patch(symbol, self.r14, 4, addr + 56)
        image.patch(symbol, self.r15, 4, addr + 60)
        image.patch(symbol, self.cpsr, 4, addr + 64)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.r0,
                name + '.r0', False)
        string += self._field_to_string(self.r1,
                name + '.r1', False)
        string += self._field_to_string(self.r2,
                name + '.r2', False)
        string += self._field_to_string(self.r3,
                name + '.r3', False)
        string += self._field_to_string(self.r4,
                name + '.r4', False)
        string += self._field_to_string(self.r5,
                name + '.r5', False)
        string += self._field_to_string(self.r6,
                name + '.r6', False)
        string += self._field_to_string(self.r7,
                name + '.r7', False)
        string += self._field_to_string(self.r8,
                name + '.r8', False)
        string += self._field_to_string(self.r9,
                name + '.r9', False)
        string += self._field_to_string(self.r10,
                name + '.r10', False)
        string += self._field_to_string(self.r11,
                name + '.r11', False)
        string += self._field_to_string(self.r12,
                name + '.r12', False)
        string += self._field_to_string(self.r13,
                name + '.r13', False)
        string += self._field_to_string(self.r14,
                name + '.r14', False)
        string += self._field_to_string(self.r15,
                name + '.r15', False)
        string += self._field_to_string(self.cpsr,
                name + '.cpsr', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.r0))
        data.append(self._pack(4, self.r1))
        data.append(self._pack(4, self.r2))
        data.append(self._pack(4, self.r3))
        data.append(self._pack(4, self.r4))
        data.append(self._pack(4, self.r5))
        data.append(self._pack(4, self.r6))
        data.append(self._pack(4, self.r7))
        data.append(self._pack(4, self.r8))
        data.append(self._pack(4, self.r9))
        data.append(self._pack(4, self.r10))
        data.append(self._pack(4, self.r11))
        data.append(self._pack(4, self.r12))
        data.append(self._pack(4, self.r13))
        data.append(self._pack(4, self.r14))
        data.append(self._pack(4, self.r15))
        data.append(self._pack(4, self.cpsr))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_intlock_control(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct intlock_control {
    struct objmanager_object_header header;
    struct {
        struct kdb_object *info;
    } kdb;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kdb" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.header = OKL4_objmanager_object_header(this_addr, self)

        class OKL4_AnonymousType_72(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "info" : {'offset': 0},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.info = None

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)


            _type_size = 4
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                self._pointer_patch(image, symbol, 4, addr + 0, self.info)

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.info,
                        name + '.info', True)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                self._pointer_to_data(data, 4, self.info)

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True

                if self.info is not None:
                    return True

                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 8
        self.kdb = OKL4_AnonymousType_72(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.header.set_address(address + 0)
        self.kdb.set_address(address + 8)

    _type_size = 12
    _type_alignment = 4
    _type_name = "intlock_control"
    _type_libokl4_name = ""

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.header.patch(image, symbol, addr + 0)
        self.kdb.patch(image, symbol, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', False)
        string += self._field_to_string(self.kdb,
                name + '.kdb', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.header.to_data())
        data.append(self.kdb.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.header.get_phys_relocs(base_offset + self.get_offset_of('header')))
        relocs.extend(self.kdb.get_phys_relocs(base_offset + self.get_offset_of('kdb')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header.dirty:
            return True
        if self.kdb.dirty:
            return True

        return False
    dirty = property(_get_dirty)



# Syscall definitions
class Syscall_IDs(object):
    """
    System call numbers to names
    """
    name_list = (
        "_okl4_sys_abort",
        "_okl4_sys_barrier_create",
        "_okl4_sys_barrier_wait",
        "_okl4_sys_cache_flush",
        "_okl4_sys_cache_flush_range",
        "_okl4_sys_cap_copy",
        "_okl4_sys_cap_revoke",
        "_okl4_sys_cap_revoke_aliases",
        "_okl4_sys_cpureg_get_registers",
        "_okl4_sys_cpureg_get_spip",
        "_okl4_sys_cpureg_set_registers",
        "_okl4_sys_cpureg_set_spip",
        "_okl4_sys_critsect_enter",
        "_okl4_sys_critsect_leave",
        "_okl4_sys_domain_add_segment",
        "_okl4_sys_domain_create",
        "_okl4_sys_exception_set_mmu_handler",
        "_okl4_sys_exception_set_thread_handler",
        "_okl4_sys_hybrid_condvar_broadcast",
        "_okl4_sys_hybrid_condvar_signal",
        "_okl4_sys_hybrid_condvar_wait",
        "_okl4_sys_hybrid_mutex_create",
        "_okl4_sys_hybrid_mutex_lock",
        "_okl4_sys_hybrid_mutex_unlock",
        "_okl4_sys_interrupt_ack",
        "_okl4_sys_interrupt_ack_and_wait",
        "_okl4_sys_interrupt_register",
        "_okl4_sys_interrupt_unregister",
        "_okl4_sys_interrupt_wait",
        "_okl4_sys_ipc_call",
        "_okl4_sys_ipc_notify_select",
        "_okl4_sys_ipc_receive",
        "_okl4_sys_ipc_reply",
        "_okl4_sys_ipc_replywait",
        "_okl4_sys_ipc_send",
        "_okl4_sys_ipc_wait",
        "_okl4_sys_kdb_interact",
        "_okl4_sys_kdb_set_object_name",
        "_okl4_sys_message_queue_create",
        "_okl4_sys_message_queue_get_status",
        "_okl4_sys_message_queue_notify_deregister",
        "_okl4_sys_message_queue_notify_register",
        "_okl4_sys_message_queue_receive_any",
        "_okl4_sys_message_queue_receive_cap",
        "_okl4_sys_message_queue_receive_inline",
        "_okl4_sys_message_queue_receive_inplace",
        "_okl4_sys_message_queue_receive_standard",
        "_okl4_sys_message_queue_send_cap",
        "_okl4_sys_message_queue_send_inline",
        "_okl4_sys_message_queue_send_inplace",
        "_okl4_sys_message_queue_send_standard",
        "_okl4_sys_message_queue_set_buffer",
        "_okl4_sys_mmu_activate",
        "_okl4_sys_mmu_attach_segment",
        "_okl4_sys_mmu_buffer_alloc",
        "_okl4_sys_mmu_buffer_area_init",
        "_okl4_sys_mmu_buffer_area_map_page",
        "_okl4_sys_mmu_buffer_free",
        "_okl4_sys_mmu_context_create",
        "_okl4_sys_mmu_detach_segment",
        "_okl4_sys_mmu_flush_range",
        "_okl4_sys_mmu_lookup_access_range",
        "_okl4_sys_mmu_lookup_page",
        "_okl4_sys_mmu_map_page",
        "_okl4_sys_mmu_unmap_page",
        "_okl4_sys_mmu_update_page_attrs",
        "_okl4_sys_mmu_update_page_perms",
        "_okl4_sys_mutex_condvar_broadcast",
        "_okl4_sys_mutex_condvar_signal",
        "_okl4_sys_mutex_condvar_wait",
        "_okl4_sys_mutex_create",
        "_okl4_sys_mutex_lock",
        "_okl4_sys_mutex_unlock",
        "_okl4_sys_notify_bits_get",
        "_okl4_sys_notify_bits_set",
        "_okl4_sys_notify_poll",
        "_okl4_sys_notify_send",
        "_okl4_sys_notify_send_wait",
        "_okl4_sys_notify_wait",
        "_okl4_sys_object_delete",
        "_okl4_sys_performance_null_syscall",
        "_okl4_sys_platform_control",
        "_okl4_sys_priority_get",
        "_okl4_sys_priority_get_effective",
        "_okl4_sys_priority_set",
        "_okl4_sys_processor_control",
        "_okl4_sys_sched_profiling_disable",
        "_okl4_sys_sched_profiling_enable",
        "_okl4_sys_segment_create",
        "_okl4_sys_semaphore_create",
        "_okl4_sys_semaphore_down",
        "_okl4_sys_semaphore_getvalue",
        "_okl4_sys_semaphore_up",
        "_okl4_sys_set_alt_tls_pointer",
        "_okl4_sys_suspend",
        "_okl4_sys_suspend_self",
        "_okl4_sys_switch_table_call",
        "_okl4_sys_switch_table_create",
        "_okl4_sys_switch_table_exit",
        "_okl4_sys_switch_table_get_entry",
        "_okl4_sys_switch_table_legacy_call",
        "_okl4_sys_switch_table_legacy_return",
        "_okl4_sys_switch_table_return",
        "_okl4_sys_switch_table_set_entry",
        "_okl4_sys_thread_alloc_frame",
        "_okl4_sys_thread_create",
        "_okl4_sys_thread_get_quanta",
        "_okl4_sys_thread_prof_setval",
        "_okl4_sys_thread_reset_quanta",
        "_okl4_sys_thread_start",
        "_okl4_sys_timeslice_length_set",
        "_okl4_sys_tls_get_pointer",
        "_okl4_sys_tls_get_pointer_of",
        "_okl4_sys_tls_set_pointer",
        "_okl4_sys_tracebuffer_notify_register",
        "_okl4_sys_tracebuffer_set_empty",
        "_okl4_sys_tracebuffer_set_mask",
        "_okl4_sys_tracebuffer_switch",
        "_okl4_sys_unsuspend",
        "_okl4_sys_yield",
    )

# Libokl4 object definitions

class OKL4_time(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef okl4_uint64_t okl4_time_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 8
    _type_name = "time"
    _type_libokl4_name = "time"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 8, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(8, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracebuffer_ref_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef okl4_word_t okl4_tracebuffer_ref_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "tracebuffer_ref_t"
    _type_libokl4_name = "tracebuffer_ref_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracepoint_mask_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef okl4_uint32_t okl4_tracepoint_mask_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "tracepoint_mask_t"
    _type_libokl4_name = "tracepoint_mask_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_schedparam_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct okl4_schedparam okl4_schedparam_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "priority" : {},
        "timeslice" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._priority = 0
        self._timeslice = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "schedparam_t"
    _type_libokl4_name = "schedparam_t"

    def _set_priority(self, priority_):
        """Set priority and flag this type as modified"""
        self._priority =  priority_
        self._dirty = True

    priority = property(lambda self: self._priority, _set_priority)

    def _set_timeslice(self, timeslice_):
        """Set timeslice and flag this type as modified"""
        self._timeslice =  timeslice_
        self._dirty = True

    timeslice = property(lambda self: self._timeslice, _set_timeslice)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.priority, 4, addr + 0)
        image.patch(symbol, self.timeslice, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.priority,
                name + '.priority', False)
        string += self._field_to_string(self.timeslice,
                name + '.timeslice', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.priority))
        data.append(self._pack(4, self.timeslice))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_extension(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct okl4_pd okl4_extension;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "address_space" : {},
        "attach_array_size" : {},
        "attached_realms" : {},
        "domain" : {},
        "domain_type" : {},
        "ext_list" : {},
        "id" : {},
        "is_extension" : {},
        "kswitch" : {},
        "mmu" : {},
        "pd_attach_array" : {},
        "pd_list" : {},
        "private_realm" : {},
        "private_realm_allocated" : {},
        "private_realm_inline" : {},
        "threads" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.address_space = None
        self._attach_array_size = 0
        self._attached_realms = 0

        this_addr = None if address is None else self._address + 12
        self.domain = OKL4_kdomain(this_addr, self)
        self._domain_type = 0

        this_addr = None if address is None else self._address + 20
        self.ext_list = OKL4_list_head_t(this_addr, self)
        self._id = 0
        self._is_extension = 0

        this_addr = None if address is None else self._address + 36
        self.kswitch = OKL4_kswitch(this_addr, self)

        this_addr = None if address is None else self._address + 44
        self.mmu = OKL4_kmmu(this_addr, self)
        self.pd_attach_array = None

        this_addr = None if address is None else self._address + 52
        self.pd_list = OKL4_list_head_t(this_addr, self)
        self.private_realm = None
        self._private_realm_allocated = 0

        this_addr = None if address is None else self._address + 68
        self.private_realm_inline = OKL4_realm(this_addr, self)

        this_addr = None if address is None else self._address + 120
        self.threads = OKL4_list_head_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.domain.set_address(address + 12)
        self.ext_list.set_address(address + 20)
        self.kswitch.set_address(address + 36)
        self.mmu.set_address(address + 44)
        self.pd_list.set_address(address + 52)
        self.private_realm_inline.set_address(address + 68)
        self.threads.set_address(address + 120)

    _type_size = 128
    _type_alignment = 4
    _type_name = "extension"
    _type_libokl4_name = "extension"

    def _set_attach_array_size(self, attach_array_size_):
        """Set attach_array_size and flag this type as modified"""
        self._attach_array_size =  attach_array_size_
        self._dirty = True

    attach_array_size = property(lambda self: self._attach_array_size, _set_attach_array_size)

    def _set_attached_realms(self, attached_realms_):
        """Set attached_realms and flag this type as modified"""
        self._attached_realms =  attached_realms_
        self._dirty = True

    attached_realms = property(lambda self: self._attached_realms, _set_attached_realms)

    def _set_domain_type(self, domain_type_):
        """Set domain_type and flag this type as modified"""
        self._domain_type =  domain_type_
        self._dirty = True

    domain_type = property(lambda self: self._domain_type, _set_domain_type)

    def _set_id(self, id_):
        """Set id and flag this type as modified"""
        self._id =  id_
        self._dirty = True

    id = property(lambda self: self._id, _set_id)

    def _set_is_extension(self, is_extension_):
        """Set is_extension and flag this type as modified"""
        self._is_extension =  is_extension_
        self._dirty = True

    is_extension = property(lambda self: self._is_extension, _set_is_extension)

    def _set_private_realm_allocated(self, private_realm_allocated_):
        """Set private_realm_allocated and flag this type as modified"""
        self._private_realm_allocated =  private_realm_allocated_
        self._dirty = True

    private_realm_allocated = property(lambda self: self._private_realm_allocated, _set_private_realm_allocated)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.address_space)
        image.patch(symbol, self.attach_array_size, 4, addr + 4)
        image.patch(symbol, self.attached_realms, 4, addr + 8)
        self.domain.patch(image, symbol, addr + 12)
        image.patch(symbol, self.domain_type, 4, addr + 16)
        self.ext_list.patch(image, symbol, addr + 20)
        image.patch(symbol, self.id, 4, addr + 28)
        image.patch(symbol, self.is_extension, 4, addr + 32)
        self.kswitch.patch(image, symbol, addr + 36)
        self.mmu.patch(image, symbol, addr + 44)
        self._pointer_patch(image, symbol, 4, addr + 48, self.pd_attach_array)
        self.pd_list.patch(image, symbol, addr + 52)
        self._pointer_patch(image, symbol, 4, addr + 60, self.private_realm)
        image.patch(symbol, self.private_realm_allocated, 4, addr + 64)
        self.private_realm_inline.patch(image, symbol, addr + 68)
        self.threads.patch(image, symbol, addr + 120)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.address_space,
                name + '.address_space', True)
        string += self._field_to_string(self.attach_array_size,
                name + '.attach_array_size', False)
        string += self._field_to_string(self.attached_realms,
                name + '.attached_realms', False)
        string += self._field_to_string(self.domain,
                name + '.domain', False)
        string += self._field_to_string(self.domain_type,
                name + '.domain_type', False)
        string += self._field_to_string(self.ext_list,
                name + '.ext_list', False)
        string += self._field_to_string(self.id,
                name + '.id', False)
        string += self._field_to_string(self.is_extension,
                name + '.is_extension', False)
        string += self._field_to_string(self.kswitch,
                name + '.kswitch', False)
        string += self._field_to_string(self.mmu,
                name + '.mmu', False)
        string += self._field_to_string(self.pd_attach_array,
                name + '.pd_attach_array', True)
        string += self._field_to_string(self.pd_list,
                name + '.pd_list', False)
        string += self._field_to_string(self.private_realm,
                name + '.private_realm', True)
        string += self._field_to_string(self.private_realm_allocated,
                name + '.private_realm_allocated', False)
        string += self._field_to_string(self.private_realm_inline,
                name + '.private_realm_inline', False)
        string += self._field_to_string(self.threads,
                name + '.threads', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.address_space)
        data.append(self._pack(4, self.attach_array_size))
        data.append(self._pack(4, self.attached_realms))
        data.append(self.domain.to_data())
        data.append(self._pack(4, self.domain_type))
        data.append(self.ext_list.to_data())
        data.append(self._pack(4, self.id))
        data.append(self._pack(4, self.is_extension))
        data.append(self.kswitch.to_data())
        data.append(self.mmu.to_data())
        self._pointer_to_data(data, 4, self.pd_attach_array)
        data.append(self.pd_list.to_data())
        self._pointer_to_data(data, 4, self.private_realm)
        data.append(self._pack(4, self.private_realm_allocated))
        data.append(self.private_realm_inline.to_data())
        data.append(self.threads.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.address_space is not None:
            return True
        if self.domain.dirty:
            return True
        if self.ext_list.dirty:
            return True
        if self.kswitch.dirty:
            return True
        if self.mmu.dirty:
            return True
        if self.pd_attach_array is not None:
            return True
        if self.pd_list.dirty:
            return True
        if self.private_realm is not None:
            return True
        if self.private_realm_inline.dirty:
            return True
        if self.threads.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_extension_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct okl4_pd okl4_extension_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "address_space" : {},
        "attach_array_size" : {},
        "attached_realms" : {},
        "domain" : {},
        "domain_type" : {},
        "ext_list" : {},
        "id" : {},
        "is_extension" : {},
        "kswitch" : {},
        "mmu" : {},
        "pd_attach_array" : {},
        "pd_list" : {},
        "private_realm" : {},
        "private_realm_allocated" : {},
        "private_realm_inline" : {},
        "threads" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.address_space = None
        self._attach_array_size = 0
        self._attached_realms = 0

        this_addr = None if address is None else self._address + 12
        self.domain = OKL4_kdomain(this_addr, self)
        self._domain_type = 0

        this_addr = None if address is None else self._address + 20
        self.ext_list = OKL4_list_head_t(this_addr, self)
        self._id = 0
        self._is_extension = 0

        this_addr = None if address is None else self._address + 36
        self.kswitch = OKL4_kswitch(this_addr, self)

        this_addr = None if address is None else self._address + 44
        self.mmu = OKL4_kmmu(this_addr, self)
        self.pd_attach_array = None

        this_addr = None if address is None else self._address + 52
        self.pd_list = OKL4_list_head_t(this_addr, self)
        self.private_realm = None
        self._private_realm_allocated = 0

        this_addr = None if address is None else self._address + 68
        self.private_realm_inline = OKL4_realm(this_addr, self)

        this_addr = None if address is None else self._address + 120
        self.threads = OKL4_list_head_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.domain.set_address(address + 12)
        self.ext_list.set_address(address + 20)
        self.kswitch.set_address(address + 36)
        self.mmu.set_address(address + 44)
        self.pd_list.set_address(address + 52)
        self.private_realm_inline.set_address(address + 68)
        self.threads.set_address(address + 120)

    _type_size = 128
    _type_alignment = 4
    _type_name = "extension_t"
    _type_libokl4_name = "extension_t"

    def _set_attach_array_size(self, attach_array_size_):
        """Set attach_array_size and flag this type as modified"""
        self._attach_array_size =  attach_array_size_
        self._dirty = True

    attach_array_size = property(lambda self: self._attach_array_size, _set_attach_array_size)

    def _set_attached_realms(self, attached_realms_):
        """Set attached_realms and flag this type as modified"""
        self._attached_realms =  attached_realms_
        self._dirty = True

    attached_realms = property(lambda self: self._attached_realms, _set_attached_realms)

    def _set_domain_type(self, domain_type_):
        """Set domain_type and flag this type as modified"""
        self._domain_type =  domain_type_
        self._dirty = True

    domain_type = property(lambda self: self._domain_type, _set_domain_type)

    def _set_id(self, id_):
        """Set id and flag this type as modified"""
        self._id =  id_
        self._dirty = True

    id = property(lambda self: self._id, _set_id)

    def _set_is_extension(self, is_extension_):
        """Set is_extension and flag this type as modified"""
        self._is_extension =  is_extension_
        self._dirty = True

    is_extension = property(lambda self: self._is_extension, _set_is_extension)

    def _set_private_realm_allocated(self, private_realm_allocated_):
        """Set private_realm_allocated and flag this type as modified"""
        self._private_realm_allocated =  private_realm_allocated_
        self._dirty = True

    private_realm_allocated = property(lambda self: self._private_realm_allocated, _set_private_realm_allocated)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.address_space)
        image.patch(symbol, self.attach_array_size, 4, addr + 4)
        image.patch(symbol, self.attached_realms, 4, addr + 8)
        self.domain.patch(image, symbol, addr + 12)
        image.patch(symbol, self.domain_type, 4, addr + 16)
        self.ext_list.patch(image, symbol, addr + 20)
        image.patch(symbol, self.id, 4, addr + 28)
        image.patch(symbol, self.is_extension, 4, addr + 32)
        self.kswitch.patch(image, symbol, addr + 36)
        self.mmu.patch(image, symbol, addr + 44)
        self._pointer_patch(image, symbol, 4, addr + 48, self.pd_attach_array)
        self.pd_list.patch(image, symbol, addr + 52)
        self._pointer_patch(image, symbol, 4, addr + 60, self.private_realm)
        image.patch(symbol, self.private_realm_allocated, 4, addr + 64)
        self.private_realm_inline.patch(image, symbol, addr + 68)
        self.threads.patch(image, symbol, addr + 120)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.address_space,
                name + '.address_space', True)
        string += self._field_to_string(self.attach_array_size,
                name + '.attach_array_size', False)
        string += self._field_to_string(self.attached_realms,
                name + '.attached_realms', False)
        string += self._field_to_string(self.domain,
                name + '.domain', False)
        string += self._field_to_string(self.domain_type,
                name + '.domain_type', False)
        string += self._field_to_string(self.ext_list,
                name + '.ext_list', False)
        string += self._field_to_string(self.id,
                name + '.id', False)
        string += self._field_to_string(self.is_extension,
                name + '.is_extension', False)
        string += self._field_to_string(self.kswitch,
                name + '.kswitch', False)
        string += self._field_to_string(self.mmu,
                name + '.mmu', False)
        string += self._field_to_string(self.pd_attach_array,
                name + '.pd_attach_array', True)
        string += self._field_to_string(self.pd_list,
                name + '.pd_list', False)
        string += self._field_to_string(self.private_realm,
                name + '.private_realm', True)
        string += self._field_to_string(self.private_realm_allocated,
                name + '.private_realm_allocated', False)
        string += self._field_to_string(self.private_realm_inline,
                name + '.private_realm_inline', False)
        string += self._field_to_string(self.threads,
                name + '.threads', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.address_space)
        data.append(self._pack(4, self.attach_array_size))
        data.append(self._pack(4, self.attached_realms))
        data.append(self.domain.to_data())
        data.append(self._pack(4, self.domain_type))
        data.append(self.ext_list.to_data())
        data.append(self._pack(4, self.id))
        data.append(self._pack(4, self.is_extension))
        data.append(self.kswitch.to_data())
        data.append(self.mmu.to_data())
        self._pointer_to_data(data, 4, self.pd_attach_array)
        data.append(self.pd_list.to_data())
        self._pointer_to_data(data, 4, self.private_realm)
        data.append(self._pack(4, self.private_realm_allocated))
        data.append(self.private_realm_inline.to_data())
        data.append(self.threads.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.address_space is not None:
            return True
        if self.domain.dirty:
            return True
        if self.ext_list.dirty:
            return True
        if self.kswitch.dirty:
            return True
        if self.mmu.dirty:
            return True
        if self.pd_attach_array is not None:
            return True
        if self.pd_list.dirty:
            return True
        if self.private_realm is not None:
            return True
        if self.private_realm_inline.dirty:
            return True
        if self.threads.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_pd_attach_item_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct _okl4_pd_attach_item _okl4_pd_attach_item_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "ext" : {},
        "ext_list_entry" : {},
        "in_use" : {},
        "pd" : {},
        "pd_list_entry" : {},
        "token" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.ext = None

        this_addr = None if address is None else self._address + 4
        self.ext_list_entry = OKL4_list_entry(this_addr, self)
        self._in_use = 0
        self.pd = None

        this_addr = None if address is None else self._address + 20
        self.pd_list_entry = OKL4_list_entry(this_addr, self)

        this_addr = None if address is None else self._address + 28
        self.token = OKL4_extension_token(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.ext_list_entry.set_address(address + 4)
        self.pd_list_entry.set_address(address + 20)
        self.token.set_address(address + 28)

    _type_size = 32
    _type_alignment = 4
    _type_name = "pd_attach_item_t"
    _type_libokl4_name = "pd_attach_item_t"

    def _set_in_use(self, in_use_):
        """Set in_use and flag this type as modified"""
        self._in_use =  in_use_
        self._dirty = True

    in_use = property(lambda self: self._in_use, _set_in_use)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.ext)
        self.ext_list_entry.patch(image, symbol, addr + 4)
        image.patch(symbol, self.in_use, 4, addr + 12)
        self._pointer_patch(image, symbol, 4, addr + 16, self.pd)
        self.pd_list_entry.patch(image, symbol, addr + 20)
        self.token.patch(image, symbol, addr + 28)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.ext,
                name + '.ext', True)
        string += self._field_to_string(self.ext_list_entry,
                name + '.ext_list_entry', False)
        string += self._field_to_string(self.in_use,
                name + '.in_use', False)
        string += self._field_to_string(self.pd,
                name + '.pd', True)
        string += self._field_to_string(self.pd_list_entry,
                name + '.pd_list_entry', False)
        string += self._field_to_string(self.token,
                name + '.token', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.ext)
        data.append(self.ext_list_entry.to_data())
        data.append(self._pack(4, self.in_use))
        self._pointer_to_data(data, 4, self.pd)
        data.append(self.pd_list_entry.to_data())
        data.append(self.token.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.ext is not None:
            return True
        if self.ext_list_entry.dirty:
            return True
        if self.pd is not None:
            return True
        if self.pd_list_entry.dirty:
            return True
        if self.token.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_async_receive_any_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct okl4_message_queue_receive_any_union okl4_async_receive_any_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "payload" : {},
        "tag" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        class OKL4_AnonymousType_73(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "inline_data" : {},
                "inplace" : {},
                "payload_size" : {},
                "capability" : {},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.inline_data = [None] * 2

                this_addr = None if address is None else self._address + 0
                self.inplace = OKL4_message_queue_receive_any_inplace(this_addr, self)
                self._payload_size = 0
                self._capability = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.inplace.set_address(address + 0)

            _type_size = 12
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_payload_size(self, payload_size_):
                """Set payload_size and flag this type as modified"""
                self._payload_size =  payload_size_
                self._dirty = True

            payload_size = property(lambda self: self._payload_size, _set_payload_size)

            def _set_capability(self, capability_):
                """Set capability and flag this type as modified"""
                self._capability =  capability_
                self._dirty = True

            capability = property(lambda self: self._capability, _set_capability)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                pass

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.inline_data,
                        name + '.inline_data', False)
                string += self._field_to_string(self.inplace,
                        name + '.inplace', False)
                string += self._field_to_string(self.payload_size,
                        name + '.payload_size', False)
                string += self._field_to_string(self.capability,
                        name + '.capability', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                count = 0
                field_size = 0
                dirty_test = False
                dirty_test = self._array_dirty_test(self.inline_data)
                if dirty_test:
                    count += 1
                    field_size = 8
                    for item in self.inline_data:
                        data.append(self._pack(4, item))
                if self.inplace.dirty:
                    count += 1
                    field_size = 12
                    data.append(self.inplace.to_data())
                dirty_test = False
                if dirty_test:
                    count += 1
                    field_size = 4
                    data.append(self._pack(4, self.payload_size))
                dirty_test = False
                if dirty_test:
                    count += 1
                    field_size = 4
                    data.append(self._pack(4, self.capability))
                if count > 1:
                    raise ElfweaverTypeException('More than one entry in the union value has been set')
                bytes_left = 12 - field_size
                for val in (8, 4, 2, 1):
                    while bytes_left >= val:
                        data.append(self._pack(val, 0))
                        bytes_left -= val

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.payload = OKL4_AnonymousType_73(this_addr, self)
        self._tag = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.payload.set_address(address + 0)

    _type_size = 16
    _type_alignment = 4
    _type_name = "async_receive_any_t"
    _type_libokl4_name = "async_receive_any_t"

    def _set_tag(self, tag_):
        """Set tag and flag this type as modified"""
        self._tag =  tag_
        self._dirty = True

    tag = property(lambda self: self._tag, _set_tag)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.payload.patch(image, symbol, addr + 0)
        image.patch(symbol, self.tag, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.payload,
                name + '.payload', False)
        string += self._field_to_string(self.tag,
                name + '.tag', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.payload.to_data())
        data.append(self._pack(4, self.tag))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.payload.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_payload_type_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef okl4_word_t okl4_message_payload_type_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "message_payload_type_t"
    _type_libokl4_name = "message_payload_type_t"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_extension_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct okl4_pd_attr okl4_extension_attr;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "address_space" : {},
        "attach_array" : {},
        "attach_array_size" : {},
        "domain" : {},
        "fault_handler" : {},
        "intlock_cap" : {},
        "is_extension" : {},
        "num_extension_entries" : {},
        "private_realm" : {},
        "return_stub_ip" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.address_space = None
        self.attach_array = None
        self._attach_array_size = 0
        self.domain = None
        self.fault_handler = None
        self._intlock_cap = 0
        self._is_extension = 0
        self._num_extension_entries = 0
        self.private_realm = None
        self._return_stub_ip = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 40
    _type_alignment = 4
    _type_name = "extension_attr"
    _type_libokl4_name = "extension_attr"

    def _set_attach_array_size(self, attach_array_size_):
        """Set attach_array_size and flag this type as modified"""
        self._attach_array_size =  attach_array_size_
        self._dirty = True

    attach_array_size = property(lambda self: self._attach_array_size, _set_attach_array_size)

    def _set_intlock_cap(self, intlock_cap_):
        """Set intlock_cap and flag this type as modified"""
        self._intlock_cap =  intlock_cap_
        self._dirty = True

    intlock_cap = property(lambda self: self._intlock_cap, _set_intlock_cap)

    def _set_is_extension(self, is_extension_):
        """Set is_extension and flag this type as modified"""
        self._is_extension =  is_extension_
        self._dirty = True

    is_extension = property(lambda self: self._is_extension, _set_is_extension)

    def _set_num_extension_entries(self, num_extension_entries_):
        """Set num_extension_entries and flag this type as modified"""
        self._num_extension_entries =  num_extension_entries_
        self._dirty = True

    num_extension_entries = property(lambda self: self._num_extension_entries, _set_num_extension_entries)

    def _set_return_stub_ip(self, return_stub_ip_):
        """Set return_stub_ip and flag this type as modified"""
        self._return_stub_ip =  return_stub_ip_
        self._dirty = True

    return_stub_ip = property(lambda self: self._return_stub_ip, _set_return_stub_ip)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.address_space)
        self._pointer_patch(image, symbol, 4, addr + 4, self.attach_array)
        image.patch(symbol, self.attach_array_size, 4, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 12, self.domain)
        self._pointer_patch(image, symbol, 4, addr + 16, self.fault_handler)
        image.patch(symbol, self.intlock_cap, 4, addr + 20)
        image.patch(symbol, self.is_extension, 4, addr + 24)
        image.patch(symbol, self.num_extension_entries, 4, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 32, self.private_realm)
        image.patch(symbol, self.return_stub_ip, 4, addr + 36)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.address_space,
                name + '.address_space', True)
        string += self._field_to_string(self.attach_array,
                name + '.attach_array', True)
        string += self._field_to_string(self.attach_array_size,
                name + '.attach_array_size', False)
        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.fault_handler,
                name + '.fault_handler', True)
        string += self._field_to_string(self.intlock_cap,
                name + '.intlock_cap', False)
        string += self._field_to_string(self.is_extension,
                name + '.is_extension', False)
        string += self._field_to_string(self.num_extension_entries,
                name + '.num_extension_entries', False)
        string += self._field_to_string(self.private_realm,
                name + '.private_realm', True)
        string += self._field_to_string(self.return_stub_ip,
                name + '.return_stub_ip', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.address_space)
        self._pointer_to_data(data, 4, self.attach_array)
        data.append(self._pack(4, self.attach_array_size))
        self._pointer_to_data(data, 4, self.domain)
        self._pointer_to_data(data, 4, self.fault_handler)
        data.append(self._pack(4, self.intlock_cap))
        data.append(self._pack(4, self.is_extension))
        data.append(self._pack(4, self.num_extension_entries))
        self._pointer_to_data(data, 4, self.private_realm)
        data.append(self._pack(4, self.return_stub_ip))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.address_space is not None:
            return True
        if self.attach_array is not None:
            return True
        if self.domain is not None:
            return True
        if self.fault_handler is not None:
            return True
        if self.private_realm is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_extension_attr_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct okl4_pd_attr okl4_extension_attr_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "address_space" : {},
        "attach_array" : {},
        "attach_array_size" : {},
        "domain" : {},
        "fault_handler" : {},
        "intlock_cap" : {},
        "is_extension" : {},
        "num_extension_entries" : {},
        "private_realm" : {},
        "return_stub_ip" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.address_space = None
        self.attach_array = None
        self._attach_array_size = 0
        self.domain = None
        self.fault_handler = None
        self._intlock_cap = 0
        self._is_extension = 0
        self._num_extension_entries = 0
        self.private_realm = None
        self._return_stub_ip = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 40
    _type_alignment = 4
    _type_name = "extension_attr_t"
    _type_libokl4_name = "extension_attr_t"

    def _set_attach_array_size(self, attach_array_size_):
        """Set attach_array_size and flag this type as modified"""
        self._attach_array_size =  attach_array_size_
        self._dirty = True

    attach_array_size = property(lambda self: self._attach_array_size, _set_attach_array_size)

    def _set_intlock_cap(self, intlock_cap_):
        """Set intlock_cap and flag this type as modified"""
        self._intlock_cap =  intlock_cap_
        self._dirty = True

    intlock_cap = property(lambda self: self._intlock_cap, _set_intlock_cap)

    def _set_is_extension(self, is_extension_):
        """Set is_extension and flag this type as modified"""
        self._is_extension =  is_extension_
        self._dirty = True

    is_extension = property(lambda self: self._is_extension, _set_is_extension)

    def _set_num_extension_entries(self, num_extension_entries_):
        """Set num_extension_entries and flag this type as modified"""
        self._num_extension_entries =  num_extension_entries_
        self._dirty = True

    num_extension_entries = property(lambda self: self._num_extension_entries, _set_num_extension_entries)

    def _set_return_stub_ip(self, return_stub_ip_):
        """Set return_stub_ip and flag this type as modified"""
        self._return_stub_ip =  return_stub_ip_
        self._dirty = True

    return_stub_ip = property(lambda self: self._return_stub_ip, _set_return_stub_ip)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.address_space)
        self._pointer_patch(image, symbol, 4, addr + 4, self.attach_array)
        image.patch(symbol, self.attach_array_size, 4, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 12, self.domain)
        self._pointer_patch(image, symbol, 4, addr + 16, self.fault_handler)
        image.patch(symbol, self.intlock_cap, 4, addr + 20)
        image.patch(symbol, self.is_extension, 4, addr + 24)
        image.patch(symbol, self.num_extension_entries, 4, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 32, self.private_realm)
        image.patch(symbol, self.return_stub_ip, 4, addr + 36)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.address_space,
                name + '.address_space', True)
        string += self._field_to_string(self.attach_array,
                name + '.attach_array', True)
        string += self._field_to_string(self.attach_array_size,
                name + '.attach_array_size', False)
        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.fault_handler,
                name + '.fault_handler', True)
        string += self._field_to_string(self.intlock_cap,
                name + '.intlock_cap', False)
        string += self._field_to_string(self.is_extension,
                name + '.is_extension', False)
        string += self._field_to_string(self.num_extension_entries,
                name + '.num_extension_entries', False)
        string += self._field_to_string(self.private_realm,
                name + '.private_realm', True)
        string += self._field_to_string(self.return_stub_ip,
                name + '.return_stub_ip', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.address_space)
        self._pointer_to_data(data, 4, self.attach_array)
        data.append(self._pack(4, self.attach_array_size))
        self._pointer_to_data(data, 4, self.domain)
        self._pointer_to_data(data, 4, self.fault_handler)
        data.append(self._pack(4, self.intlock_cap))
        data.append(self._pack(4, self.is_extension))
        data.append(self._pack(4, self.num_extension_entries))
        self._pointer_to_data(data, 4, self.private_realm)
        data.append(self._pack(4, self.return_stub_ip))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.address_space is not None:
            return True
        if self.attach_array is not None:
            return True
        if self.domain is not None:
            return True
        if self.fault_handler is not None:
            return True
        if self.private_realm is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_ksegment(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct okl4_env_segment okl4_ksegment;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "cap_id" : {},
        "base" : {},
        "size" : {},
        "rwx" : {},
        "ksegment_list" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._cap_id = 0
        self._base = 0
        self._size = 0
        self._rwx = 0

        this_addr = None if address is None else self._address + 16
        self.ksegment_list = OKL4_list_entry_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.ksegment_list.set_address(address + 16)

    _type_size = 24
    _type_alignment = 4
    _type_name = "ksegment"
    _type_libokl4_name = "ksegment"

    def _set_cap_id(self, cap_id_):
        """Set cap_id and flag this type as modified"""
        self._cap_id =  cap_id_
        self._dirty = True

    cap_id = property(lambda self: self._cap_id, _set_cap_id)

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_rwx(self, rwx_):
        """Set rwx and flag this type as modified"""
        self._rwx =  rwx_
        self._dirty = True

    rwx = property(lambda self: self._rwx, _set_rwx)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.cap_id, 4, addr + 0)
        image.patch(symbol, self.base, 4, addr + 4)
        image.patch(symbol, self.size, 4, addr + 8)
        image.patch(symbol, self.rwx, 4, addr + 12)
        self.ksegment_list.patch(image, symbol, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.cap_id,
                name + '.cap_id', False)
        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.rwx,
                name + '.rwx', False)
        string += self._field_to_string(self.ksegment_list,
                name + '.ksegment_list', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.cap_id))
        data.append(self._pack(4, self.base))
        data.append(self._pack(4, self.size))
        data.append(self._pack(4, self.rwx))
        data.append(self.ksegment_list.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.ksegment_list.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_ksegment_t(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef struct okl4_env_segment okl4_ksegment_t;

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "cap_id" : {},
        "base" : {},
        "size" : {},
        "rwx" : {},
        "ksegment_list" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._cap_id = 0
        self._base = 0
        self._size = 0
        self._rwx = 0

        this_addr = None if address is None else self._address + 16
        self.ksegment_list = OKL4_list_entry_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.ksegment_list.set_address(address + 16)

    _type_size = 24
    _type_alignment = 4
    _type_name = "ksegment_t"
    _type_libokl4_name = "ksegment_t"

    def _set_cap_id(self, cap_id_):
        """Set cap_id and flag this type as modified"""
        self._cap_id =  cap_id_
        self._dirty = True

    cap_id = property(lambda self: self._cap_id, _set_cap_id)

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_rwx(self, rwx_):
        """Set rwx and flag this type as modified"""
        self._rwx =  rwx_
        self._dirty = True

    rwx = property(lambda self: self._rwx, _set_rwx)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.cap_id, 4, addr + 0)
        image.patch(symbol, self.base, 4, addr + 4)
        image.patch(symbol, self.size, 4, addr + 8)
        image.patch(symbol, self.rwx, 4, addr + 12)
        self.ksegment_list.patch(image, symbol, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.cap_id,
                name + '.cap_id', False)
        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.rwx,
                name + '.rwx', False)
        string += self._field_to_string(self.ksegment_list,
                name + '.ksegment_list', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.cap_id))
        data.append(self._pack(4, self.base))
        data.append(self._pack(4, self.size))
        data.append(self._pack(4, self.rwx))
        data.append(self.ksegment_list.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.ksegment_list.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_mem_alloc_source(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long _okl4_mem_alloc_source_t;
#define _OKL4_MEM_ALLOC_SOURCE_NONE ((_okl4_mem_alloc_source_t)0x0UL)
#define _OKL4_MEM_ALLOC_SOURCE_PHYSPOOL ((_okl4_mem_alloc_source_t)0x1UL)
#define _OKL4_MEM_ALLOC_SOURCE_USER ((_okl4_mem_alloc_source_t)0x2UL)
#define _OKL4_MEM_ALLOC_SOURCE_FILESYSTEM ((_okl4_mem_alloc_source_t)0x3UL)

    """

    _OKL4_MEM_ALLOC_SOURCE_NONE = 0
    _OKL4_MEM_ALLOC_SOURCE_PHYSPOOL = 1
    _OKL4_MEM_ALLOC_SOURCE_USER = 2
    _OKL4_MEM_ALLOC_SOURCE_FILESYSTEM = 3

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "mem_alloc_source"
    _type_libokl4_name = "mem_alloc_source"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_time_mode(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long okl4_time_mode_t;
#define OKL4_TIME_MODE_RELATIVE ((okl4_time_mode_t)0x0UL)
#define OKL4_TIME_MODE_ABSOLUTE ((okl4_time_mode_t)0x1UL)

    """

    OKL4_TIME_MODE_RELATIVE = 0
    OKL4_TIME_MODE_ABSOLUTE = 1

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "time_mode"
    _type_libokl4_name = "time_mode"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_file_perms(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long okl4_file_perms_t;
#define OKL4_FILE_PERMS_NONE ((okl4_file_perms_t)0x0UL)
#define OKL4_FILE_PERMS_X ((okl4_file_perms_t)0x1UL)
#define OKL4_FILE_PERMS_W ((okl4_file_perms_t)0x2UL)
#define OKL4_FILE_PERMS_WX ((okl4_file_perms_t)0x3UL)
#define OKL4_FILE_PERMS_R ((okl4_file_perms_t)0x4UL)
#define OKL4_FILE_PERMS_RX ((okl4_file_perms_t)0x5UL)
#define OKL4_FILE_PERMS_RW ((okl4_file_perms_t)0x6UL)
#define OKL4_FILE_PERMS_RWX ((okl4_file_perms_t)0x7UL)

    """

    OKL4_FILE_PERMS_NONE = 0
    OKL4_FILE_PERMS_X = 1
    OKL4_FILE_PERMS_W = 2
    OKL4_FILE_PERMS_WX = 3
    OKL4_FILE_PERMS_R = 4
    OKL4_FILE_PERMS_RX = 5
    OKL4_FILE_PERMS_RW = 6
    OKL4_FILE_PERMS_RWX = 7

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "file_perms"
    _type_libokl4_name = "file_perms"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_message_queue_receive_any_union_tag(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef unsigned long okl4_message_queue_receive_any_union_tag_t;
#define OKL4_MESSAGE_QUEUE_RECEIVE_ANY_UNION_TAG_INLINE_DATA ((okl4_message_queue_receive_any_union_tag_t)0x0UL)
#define OKL4_MESSAGE_QUEUE_RECEIVE_ANY_UNION_TAG_INPLACE ((okl4_message_queue_receive_any_union_tag_t)0x1UL)
#define OKL4_MESSAGE_QUEUE_RECEIVE_ANY_UNION_TAG_PAYLOAD_SIZE ((okl4_message_queue_receive_any_union_tag_t)0x2UL)
#define OKL4_MESSAGE_QUEUE_RECEIVE_ANY_UNION_TAG_CAPABILITY ((okl4_message_queue_receive_any_union_tag_t)0x3UL)

    """

    OKL4_MESSAGE_QUEUE_RECEIVE_ANY_UNION_TAG_INLINE_DATA = 0
    OKL4_MESSAGE_QUEUE_RECEIVE_ANY_UNION_TAG_INPLACE = 1
    OKL4_MESSAGE_QUEUE_RECEIVE_ANY_UNION_TAG_PAYLOAD_SIZE = 2
    OKL4_MESSAGE_QUEUE_RECEIVE_ANY_UNION_TAG_CAPABILITY = 3

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "message_queue_receive_any_union_tag"
    _type_libokl4_name = "message_queue_receive_any_union_tag"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_memsection_update_op(ElfweaverType):
    """
    Implement a python class that represents the C type:

typedef okl4_word_t _okl4_memsection_update_op_t;
#define _OKL4_MEMSECTION_UPDATE_OP_PERMS ((_okl4_memsection_update_op_t)0x1UL)
#define _OKL4_MEMSECTION_UPDATE_OP_ATTRS ((_okl4_memsection_update_op_t)0x2UL)

    """

    _OKL4_MEMSECTION_UPDATE_OP_PERMS = 1
    _OKL4_MEMSECTION_UPDATE_OP_ATTRS = 2

    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._value = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "memsection_update_op"
    _type_libokl4_name = "memsection_update_op"

    def _set_value(self, value_):
        """Set value and flag this type as modified"""
        self._value =  value_
        self._dirty = True

    value = property(lambda self: self._value, _set_value)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.value, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.value))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_iterate_handler(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "iterate_handler"
    _type_libokl4_name = "iterate_handler"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_fault_handler(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "fault_handler"
    _type_libokl4_name = "fault_handler"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_delete_handler(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "delete_handler"
    _type_libokl4_name = "delete_handler"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_lookup_handler(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "lookup_handler"
    _type_libokl4_name = "lookup_handler"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_clock_callback_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "clock_callback_t"
    _type_libokl4_name = "clock_callback_t"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_thread_func_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "thread_func_t"
    _type_libokl4_name = "thread_func_t"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_pthread_start_routine_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "pthread_start_routine_t"
    _type_libokl4_name = "pthread_start_routine_t"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kthread_func_t(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "value" : {},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.value = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "kthread_func_t"
    _type_libokl4_name = "kthread_func_t"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.value)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.value,
                name + '.value', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.value)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.value is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_address_space_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_address_space_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t first_chunk;
    okl4_word_t first_reserved_chunk;
    okl4_word_t num_chunks;
    okl4_word_t num_reserved_chunks;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "first_chunk" : {'offset': 0},
        "first_reserved_chunk" : {'offset': 4},
        "num_chunks" : {'offset': 8},
        "num_reserved_chunks" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._first_chunk = 0
        self._first_reserved_chunk = 0
        self._num_chunks = 0
        self._num_reserved_chunks = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "address_space_attr"
    _type_libokl4_name = "address_space_attr"

    def _set_first_chunk(self, first_chunk_):
        """Set first_chunk and flag this type as modified"""
        self._first_chunk =  first_chunk_
        self._dirty = True

    first_chunk = property(lambda self: self._first_chunk, _set_first_chunk)

    def _set_first_reserved_chunk(self, first_reserved_chunk_):
        """Set first_reserved_chunk and flag this type as modified"""
        self._first_reserved_chunk =  first_reserved_chunk_
        self._dirty = True

    first_reserved_chunk = property(lambda self: self._first_reserved_chunk, _set_first_reserved_chunk)

    def _set_num_chunks(self, num_chunks_):
        """Set num_chunks and flag this type as modified"""
        self._num_chunks =  num_chunks_
        self._dirty = True

    num_chunks = property(lambda self: self._num_chunks, _set_num_chunks)

    def _set_num_reserved_chunks(self, num_reserved_chunks_):
        """Set num_reserved_chunks and flag this type as modified"""
        self._num_reserved_chunks =  num_reserved_chunks_
        self._dirty = True

    num_reserved_chunks = property(lambda self: self._num_reserved_chunks, _set_num_reserved_chunks)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.first_chunk, 4, addr + 0)
        image.patch(symbol, self.first_reserved_chunk, 4, addr + 4)
        image.patch(symbol, self.num_chunks, 4, addr + 8)
        image.patch(symbol, self.num_reserved_chunks, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.first_chunk,
                name + '.first_chunk', False)
        string += self._field_to_string(self.first_reserved_chunk,
                name + '.first_reserved_chunk', False)
        string += self._field_to_string(self.num_chunks,
                name + '.num_chunks', False)
        string += self._field_to_string(self.num_reserved_chunks,
                name + '.num_reserved_chunks', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.first_chunk))
        data.append(self._pack(4, self.first_reserved_chunk))
        data.append(self._pack(4, self.num_chunks))
        data.append(self._pack(4, self.num_reserved_chunks))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_memsection_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_memsection_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t size;
    struct okl4_realm *realm;
    okl4_word_t virt_addr;
    okl4_word_t alignment;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "size" : {'offset': 0},
        "realm" : {'offset': 4},
        "virt_addr" : {'offset': 8},
        "alignment" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._size = 0
        self.realm = None
        self._virt_addr = 0
        self._alignment = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "memsection_attr"
    _type_libokl4_name = "memsection_attr"

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_virt_addr(self, virt_addr_):
        """Set virt_addr and flag this type as modified"""
        self._virt_addr =  virt_addr_
        self._dirty = True

    virt_addr = property(lambda self: self._virt_addr, _set_virt_addr)

    def _set_alignment(self, alignment_):
        """Set alignment and flag this type as modified"""
        self._alignment =  alignment_
        self._dirty = True

    alignment = property(lambda self: self._alignment, _set_alignment)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.size, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.realm)
        image.patch(symbol, self.virt_addr, 4, addr + 8)
        image.patch(symbol, self.alignment, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.realm,
                name + '.realm', True)
        string += self._field_to_string(self.virt_addr,
                name + '.virt_addr', False)
        string += self._field_to_string(self.alignment,
                name + '.alignment', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.size))
        self._pointer_to_data(data, 4, self.realm)
        data.append(self._pack(4, self.virt_addr))
        data.append(self._pack(4, self.alignment))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.realm is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kdomain_cap_copy_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kdomain_cap_copy_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct okl4_kdomain *destdomain;
    okl4_rights_t rights;
    okl4_kcap_t srccap;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "destdomain" : {'offset': 0},
        "rights" : {'offset': 4},
        "srccap" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.destdomain = None
        self._rights = 0
        self._srccap = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "kdomain_cap_copy_attr"
    _type_libokl4_name = "kdomain_cap_copy_attr"

    def _set_rights(self, rights_):
        """Set rights and flag this type as modified"""
        self._rights =  rights_
        self._dirty = True

    rights = property(lambda self: self._rights, _set_rights)

    def _set_srccap(self, srccap_):
        """Set srccap and flag this type as modified"""
        self._srccap =  srccap_
        self._dirty = True

    srccap = property(lambda self: self._srccap, _set_srccap)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.destdomain)
        image.patch(symbol, self.rights, 4, addr + 4)
        image.patch(symbol, self.srccap, 4, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.destdomain,
                name + '.destdomain', True)
        string += self._field_to_string(self.rights,
                name + '.rights', False)
        string += self._field_to_string(self.srccap,
                name + '.srccap', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.destdomain)
        data.append(self._pack(4, self.rights))
        data.append(self._pack(4, self.srccap))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.destdomain is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kdomain_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kdomain_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct okl4_kdomain *domain;
    okl4_word_t max_prio;
    okl4_word_t numentries;
    okl4_word_t reply_cap_table_entries;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "domain" : {'offset': 0},
        "max_prio" : {'offset': 4},
        "numentries" : {'offset': 8},
        "reply_cap_table_entries" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.domain = None
        self._max_prio = 0
        self._numentries = 0
        self._reply_cap_table_entries = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "kdomain_attr"
    _type_libokl4_name = "kdomain_attr"

    def _set_max_prio(self, max_prio_):
        """Set max_prio and flag this type as modified"""
        self._max_prio =  max_prio_
        self._dirty = True

    max_prio = property(lambda self: self._max_prio, _set_max_prio)

    def _set_numentries(self, numentries_):
        """Set numentries and flag this type as modified"""
        self._numentries =  numentries_
        self._dirty = True

    numentries = property(lambda self: self._numentries, _set_numentries)

    def _set_reply_cap_table_entries(self, reply_cap_table_entries_):
        """Set reply_cap_table_entries and flag this type as modified"""
        self._reply_cap_table_entries =  reply_cap_table_entries_
        self._dirty = True

    reply_cap_table_entries = property(lambda self: self._reply_cap_table_entries, _set_reply_cap_table_entries)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.domain)
        image.patch(symbol, self.max_prio, 4, addr + 4)
        image.patch(symbol, self.numentries, 4, addr + 8)
        image.patch(symbol, self.reply_cap_table_entries, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.max_prio,
                name + '.max_prio', False)
        string += self._field_to_string(self.numentries,
                name + '.numentries', False)
        string += self._field_to_string(self.reply_cap_table_entries,
                name + '.reply_cap_table_entries', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.domain)
        data.append(self._pack(4, self.max_prio))
        data.append(self._pack(4, self.numentries))
        data.append(self._pack(4, self.reply_cap_table_entries))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.domain is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_interrupt_register_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_interrupt_register_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct okl4_kthread *handler;
    okl4_interrupt_soc_token_t token;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "handler" : {'offset': 0},
        "token" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.handler = None
        self._token = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "interrupt_register_attr"
    _type_libokl4_name = "interrupt_register_attr"

    def _set_token(self, token_):
        """Set token and flag this type as modified"""
        self._token =  token_
        self._dirty = True

    token = property(lambda self: self._token, _set_token)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.handler)
        image.patch(symbol, self.token, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.handler,
                name + '.handler', True)
        string += self._field_to_string(self.token,
                name + '.token', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.handler)
        data.append(self._pack(4, self.token))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.handler is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_cache_control_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_cache_control_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct okl4_kmmu *kmmu;
    _okl4_cache_ops_t operation;
    struct okl4_virtmem_item *range;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "kmmu" : {'offset': 0},
        "operation" : {'offset': 4},
        "range" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.kmmu = None
        self._operation = 0
        self.range = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "cache_control_attr"
    _type_libokl4_name = "cache_control_attr"

    def _set_operation(self, operation_):
        """Set operation and flag this type as modified"""
        self._operation =  operation_
        self._dirty = True

    operation = property(lambda self: self._operation, _set_operation)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.kmmu)
        image.patch(symbol, self.operation, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.range)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.kmmu,
                name + '.kmmu', True)
        string += self._field_to_string(self.operation,
                name + '.operation', False)
        string += self._field_to_string(self.range,
                name + '.range', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.kmmu)
        data.append(self._pack(4, self.operation))
        self._pointer_to_data(data, 4, self.range)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.kmmu is not None:
            return True
        if self.range is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kswitch_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kswitch_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct okl4_kdomain *domain;
    okl4_bool_t intlock;
    struct okl4_kmmu *mmu;
    okl4_word_t num_entries;
    okl4_word_t return_stub_ip;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "domain" : {'offset': 0},
        "intlock" : {'offset': 4},
        "mmu" : {'offset': 8},
        "num_entries" : {'offset': 12},
        "return_stub_ip" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.domain = None
        self._intlock = 0
        self.mmu = None
        self._num_entries = 0
        self._return_stub_ip = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 20
    _type_alignment = 4
    _type_name = "kswitch_attr"
    _type_libokl4_name = "kswitch_attr"

    def _set_intlock(self, intlock_):
        """Set intlock and flag this type as modified"""
        self._intlock =  intlock_
        self._dirty = True

    intlock = property(lambda self: self._intlock, _set_intlock)

    def _set_num_entries(self, num_entries_):
        """Set num_entries and flag this type as modified"""
        self._num_entries =  num_entries_
        self._dirty = True

    num_entries = property(lambda self: self._num_entries, _set_num_entries)

    def _set_return_stub_ip(self, return_stub_ip_):
        """Set return_stub_ip and flag this type as modified"""
        self._return_stub_ip =  return_stub_ip_
        self._dirty = True

    return_stub_ip = property(lambda self: self._return_stub_ip, _set_return_stub_ip)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.domain)
        image.patch(symbol, self.intlock, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.mmu)
        image.patch(symbol, self.num_entries, 4, addr + 12)
        image.patch(symbol, self.return_stub_ip, 4, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.intlock,
                name + '.intlock', False)
        string += self._field_to_string(self.mmu,
                name + '.mmu', True)
        string += self._field_to_string(self.num_entries,
                name + '.num_entries', False)
        string += self._field_to_string(self.return_stub_ip,
                name + '.return_stub_ip', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.domain)
        data.append(self._pack(4, self.intlock))
        self._pointer_to_data(data, 4, self.mmu)
        data.append(self._pack(4, self.num_entries))
        data.append(self._pack(4, self.return_stub_ip))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.domain is not None:
            return True
        if self.mmu is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_critical_section_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_critical_section_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    void *__empty;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "__empty" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.__empty = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "critical_section_attr"
    _type_libokl4_name = "critical_section_attr"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.__empty)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.__empty,
                name + '.__empty', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.__empty)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.__empty is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kthread_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kthread_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t alt_tls_pointer;
    struct okl4_kdomain *domain;
    okl4_word_t exception_badge;
    struct okl4_kthread *exception_handler;
    okl4_word_t exec_mode;
    struct okl4_kmmu *mmucontext;
    okl4_priority_t priority;
    okl4_word_t sp;
    void (*start_func)(void);
    okl4_word_t timeslicelength;
    okl4_word_t tls_pointer;
    struct okl4_virtmem_pool *tls_pool;
    okl4_word_t tls_size;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "alt_tls_pointer" : {'offset': 0},
        "domain" : {'offset': 4},
        "exception_badge" : {'offset': 8},
        "exception_handler" : {'offset': 12},
        "exec_mode" : {'offset': 16},
        "mmucontext" : {'offset': 20},
        "priority" : {'offset': 24},
        "sp" : {'offset': 28},
        "start_func" : {'offset': 32},
        "timeslicelength" : {'offset': 36},
        "tls_pointer" : {'offset': 40},
        "tls_pool" : {'offset': 44},
        "tls_size" : {'offset': 48},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._alt_tls_pointer = 0
        self.domain = None
        self._exception_badge = 0
        self.exception_handler = None
        self._exec_mode = 0
        self.mmucontext = None
        self._priority = 0
        self._sp = 0
        self.start_func = None
        self._timeslicelength = 0
        self._tls_pointer = 0
        self.tls_pool = None
        self._tls_size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 52
    _type_alignment = 4
    _type_name = "kthread_attr"
    _type_libokl4_name = "kthread_attr"

    def _set_alt_tls_pointer(self, alt_tls_pointer_):
        """Set alt_tls_pointer and flag this type as modified"""
        self._alt_tls_pointer =  alt_tls_pointer_
        self._dirty = True

    alt_tls_pointer = property(lambda self: self._alt_tls_pointer, _set_alt_tls_pointer)

    def _set_exception_badge(self, exception_badge_):
        """Set exception_badge and flag this type as modified"""
        self._exception_badge =  exception_badge_
        self._dirty = True

    exception_badge = property(lambda self: self._exception_badge, _set_exception_badge)

    def _set_exec_mode(self, exec_mode_):
        """Set exec_mode and flag this type as modified"""
        self._exec_mode =  exec_mode_
        self._dirty = True

    exec_mode = property(lambda self: self._exec_mode, _set_exec_mode)

    def _set_priority(self, priority_):
        """Set priority and flag this type as modified"""
        self._priority =  priority_
        self._dirty = True

    priority = property(lambda self: self._priority, _set_priority)

    def _set_sp(self, sp_):
        """Set sp and flag this type as modified"""
        self._sp =  sp_
        self._dirty = True

    sp = property(lambda self: self._sp, _set_sp)

    def _set_timeslicelength(self, timeslicelength_):
        """Set timeslicelength and flag this type as modified"""
        self._timeslicelength =  timeslicelength_
        self._dirty = True

    timeslicelength = property(lambda self: self._timeslicelength, _set_timeslicelength)

    def _set_tls_pointer(self, tls_pointer_):
        """Set tls_pointer and flag this type as modified"""
        self._tls_pointer =  tls_pointer_
        self._dirty = True

    tls_pointer = property(lambda self: self._tls_pointer, _set_tls_pointer)

    def _set_tls_size(self, tls_size_):
        """Set tls_size and flag this type as modified"""
        self._tls_size =  tls_size_
        self._dirty = True

    tls_size = property(lambda self: self._tls_size, _set_tls_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.alt_tls_pointer, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.domain)
        image.patch(symbol, self.exception_badge, 4, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 12, self.exception_handler)
        image.patch(symbol, self.exec_mode, 4, addr + 16)
        self._pointer_patch(image, symbol, 4, addr + 20, self.mmucontext)
        image.patch(symbol, self.priority, 4, addr + 24)
        image.patch(symbol, self.sp, 4, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 32, self.start_func)
        image.patch(symbol, self.timeslicelength, 4, addr + 36)
        image.patch(symbol, self.tls_pointer, 4, addr + 40)
        self._pointer_patch(image, symbol, 4, addr + 44, self.tls_pool)
        image.patch(symbol, self.tls_size, 4, addr + 48)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.alt_tls_pointer,
                name + '.alt_tls_pointer', False)
        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.exception_badge,
                name + '.exception_badge', False)
        string += self._field_to_string(self.exception_handler,
                name + '.exception_handler', True)
        string += self._field_to_string(self.exec_mode,
                name + '.exec_mode', False)
        string += self._field_to_string(self.mmucontext,
                name + '.mmucontext', True)
        string += self._field_to_string(self.priority,
                name + '.priority', False)
        string += self._field_to_string(self.sp,
                name + '.sp', False)
        string += self._field_to_string(self.start_func,
                name + '.start_func', True)
        string += self._field_to_string(self.timeslicelength,
                name + '.timeslicelength', False)
        string += self._field_to_string(self.tls_pointer,
                name + '.tls_pointer', False)
        string += self._field_to_string(self.tls_pool,
                name + '.tls_pool', True)
        string += self._field_to_string(self.tls_size,
                name + '.tls_size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.alt_tls_pointer))
        self._pointer_to_data(data, 4, self.domain)
        data.append(self._pack(4, self.exception_badge))
        self._pointer_to_data(data, 4, self.exception_handler)
        data.append(self._pack(4, self.exec_mode))
        self._pointer_to_data(data, 4, self.mmucontext)
        data.append(self._pack(4, self.priority))
        data.append(self._pack(4, self.sp))
        self._pointer_to_data(data, 4, self.start_func)
        data.append(self._pack(4, self.timeslicelength))
        data.append(self._pack(4, self.tls_pointer))
        self._pointer_to_data(data, 4, self.tls_pool)
        data.append(self._pack(4, self.tls_size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.domain is not None:
            return True
        if self.exception_handler is not None:
            return True
        if self.mmucontext is not None:
            return True
        if self.start_func is not None:
            return True
        if self.tls_pool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_thread_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_thread_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t argument;
    okl4_word_t detached;
    struct okl4_kdomain *domain;
    okl4_word_t (*entry_point)(okl4_word_t arg);
    okl4_word_t exec_mode;
    int ext_context;
    struct okl4_kmmu *mmucontext;
    char name[12];
    okl4_priority_t priority;
    okl4_word_t stackaddr;
    struct okl4_virtmem_pool *stackpool;
    okl4_word_t stacksize;
    okl4_word_t timeslice;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "argument" : {'offset': 0},
        "detached" : {'offset': 4},
        "domain" : {'offset': 8},
        "entry_point" : {'offset': 12},
        "exec_mode" : {'offset': 16},
        "ext_context" : {'offset': 20},
        "mmucontext" : {'offset': 24},
        "name" : {'offset': 28},
        "priority" : {'offset': 40},
        "stackaddr" : {'offset': 44},
        "stackpool" : {'offset': 48},
        "stacksize" : {'offset': 52},
        "timeslice" : {'offset': 56},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._argument = 0
        self._detached = 0
        self.domain = None
        self.entry_point = None
        self._exec_mode = 0
        self._ext_context = 0
        self.mmucontext = None
        self.name = [None] * 12
        self._priority = 0
        self._stackaddr = 0
        self.stackpool = None
        self._stacksize = 0
        self._timeslice = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 60
    _type_alignment = 4
    _type_name = "thread_attr"
    _type_libokl4_name = "thread_attr"

    def _set_argument(self, argument_):
        """Set argument and flag this type as modified"""
        self._argument =  argument_
        self._dirty = True

    argument = property(lambda self: self._argument, _set_argument)

    def _set_detached(self, detached_):
        """Set detached and flag this type as modified"""
        self._detached =  detached_
        self._dirty = True

    detached = property(lambda self: self._detached, _set_detached)

    def _set_exec_mode(self, exec_mode_):
        """Set exec_mode and flag this type as modified"""
        self._exec_mode =  exec_mode_
        self._dirty = True

    exec_mode = property(lambda self: self._exec_mode, _set_exec_mode)

    def _set_ext_context(self, ext_context_):
        """Set ext_context and flag this type as modified"""
        self._ext_context =  ext_context_
        self._dirty = True

    ext_context = property(lambda self: self._ext_context, _set_ext_context)

    def _set_priority(self, priority_):
        """Set priority and flag this type as modified"""
        self._priority =  priority_
        self._dirty = True

    priority = property(lambda self: self._priority, _set_priority)

    def _set_stackaddr(self, stackaddr_):
        """Set stackaddr and flag this type as modified"""
        self._stackaddr =  stackaddr_
        self._dirty = True

    stackaddr = property(lambda self: self._stackaddr, _set_stackaddr)

    def _set_stacksize(self, stacksize_):
        """Set stacksize and flag this type as modified"""
        self._stacksize =  stacksize_
        self._dirty = True

    stacksize = property(lambda self: self._stacksize, _set_stacksize)

    def _set_timeslice(self, timeslice_):
        """Set timeslice and flag this type as modified"""
        self._timeslice =  timeslice_
        self._dirty = True

    timeslice = property(lambda self: self._timeslice, _set_timeslice)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.argument, 4, addr + 0)
        image.patch(symbol, self.detached, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.domain)
        self._pointer_patch(image, symbol, 4, addr + 12, self.entry_point)
        image.patch(symbol, self.exec_mode, 4, addr + 16)
        image.patch(symbol, self.ext_context, 4, addr + 20)
        self._pointer_patch(image, symbol, 4, addr + 24, self.mmucontext)
        for i, item in enumerate(self.name):
            value = 0 if item is None else item
            image.patch(symbol, value, 1, addr + i * 1 + 28)
        image.patch(symbol, self.priority, 4, addr + 40)
        image.patch(symbol, self.stackaddr, 4, addr + 44)
        self._pointer_patch(image, symbol, 4, addr + 48, self.stackpool)
        image.patch(symbol, self.stacksize, 4, addr + 52)
        image.patch(symbol, self.timeslice, 4, addr + 56)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.argument,
                name + '.argument', False)
        string += self._field_to_string(self.detached,
                name + '.detached', False)
        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.entry_point,
                name + '.entry_point', True)
        string += self._field_to_string(self.exec_mode,
                name + '.exec_mode', False)
        string += self._field_to_string(self.ext_context,
                name + '.ext_context', False)
        string += self._field_to_string(self.mmucontext,
                name + '.mmucontext', True)
        string += self._field_to_string(self.name,
                name + '.name', False)
        string += self._field_to_string(self.priority,
                name + '.priority', False)
        string += self._field_to_string(self.stackaddr,
                name + '.stackaddr', False)
        string += self._field_to_string(self.stackpool,
                name + '.stackpool', True)
        string += self._field_to_string(self.stacksize,
                name + '.stacksize', False)
        string += self._field_to_string(self.timeslice,
                name + '.timeslice', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.argument))
        data.append(self._pack(4, self.detached))
        self._pointer_to_data(data, 4, self.domain)
        self._pointer_to_data(data, 4, self.entry_point)
        data.append(self._pack(4, self.exec_mode))
        data.append(self._pack(4, self.ext_context))
        self._pointer_to_data(data, 4, self.mmucontext)
        for item in self.name:
            data.append(self._pack(1, item))
        data.append(self._pack(4, self.priority))
        data.append(self._pack(4, self.stackaddr))
        self._pointer_to_data(data, 4, self.stackpool)
        data.append(self._pack(4, self.stacksize))
        data.append(self._pack(4, self.timeslice))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.domain is not None:
            return True
        if self.entry_point is not None:
            return True
        if self.mmucontext is not None:
            return True
        if self._array_dirty_test(self.name):
            return True
        if self.stackpool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_semaphore_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_semaphore_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    void *__empty;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "__empty" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.__empty = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "semaphore_attr"
    _type_libokl4_name = "semaphore_attr"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.__empty)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.__empty,
                name + '.__empty', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.__empty)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.__empty is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_file_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_file_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct okl4_physmem_pagepool *physpool;
    struct okl4_realm *realm;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "physpool" : {'offset': 0},
        "realm" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.physpool = None
        self.realm = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "file_attr"
    _type_libokl4_name = "file_attr"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.physpool)
        self._pointer_patch(image, symbol, 4, addr + 4, self.realm)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.realm,
                name + '.realm', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.physpool)
        self._pointer_to_data(data, 4, self.realm)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.physpool is not None:
            return True
        if self.realm is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_file_stat(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_file_stat {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t size;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "size" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "file_stat"
    _type_libokl4_name = "file_stat"

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.size, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.size,
                name + '.size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_memsection_elf_dso_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_memsection_elf_dso_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_string_t filename;
    struct okl4_physmem_pagepool *physpool;
    okl4_bool_t preload;
    struct okl4_realm *realm;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "filename" : {'offset': 0},
        "physpool" : {'offset': 4},
        "preload" : {'offset': 8},
        "realm" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.filename = None
        self.physpool = None
        self._preload = 0
        self.realm = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "memsection_elf_dso_attr"
    _type_libokl4_name = "memsection_elf_dso_attr"

    def _set_preload(self, preload_):
        """Set preload and flag this type as modified"""
        self._preload =  preload_
        self._dirty = True

    preload = property(lambda self: self._preload, _set_preload)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.filename)
        self._pointer_patch(image, symbol, 4, addr + 4, self.physpool)
        image.patch(symbol, self.preload, 4, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 12, self.realm)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.filename,
                name + '.filename', False)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.preload,
                name + '.preload', False)
        string += self._field_to_string(self.realm,
                name + '.realm', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.filename)
        self._pointer_to_data(data, 4, self.physpool)
        data.append(self._pack(4, self.preload))
        self._pointer_to_data(data, 4, self.realm)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.filename is not None:
            return True
        if self.physpool is not None:
            return True
        if self.realm is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_plugin_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_plugin_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_string_t filename;
    struct okl4_physmem_pagepool *physpool;
    okl4_bool_t preload;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "filename" : {'offset': 0},
        "physpool" : {'offset': 4},
        "preload" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.filename = None
        self.physpool = None
        self._preload = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "plugin_attr"
    _type_libokl4_name = "plugin_attr"

    def _set_preload(self, preload_):
        """Set preload and flag this type as modified"""
        self._preload =  preload_
        self._dirty = True

    preload = property(lambda self: self._preload, _set_preload)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.filename)
        self._pointer_patch(image, symbol, 4, addr + 4, self.physpool)
        image.patch(symbol, self.preload, 4, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.filename,
                name + '.filename', False)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.preload,
                name + '.preload', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.filename)
        self._pointer_to_data(data, 4, self.physpool)
        data.append(self._pack(4, self.preload))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.filename is not None:
            return True
        if self.physpool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_program_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_program_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t exec_mode;
    struct okl4_kthread *fault_handler;
    okl4_string_t filename;
    struct okl4_pd_attr *pd_attr;
    struct okl4_physmem_pagepool *physpool;
    okl4_bool_t preload;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "exec_mode" : {'offset': 0},
        "fault_handler" : {'offset': 4},
        "filename" : {'offset': 8},
        "pd_attr" : {'offset': 12},
        "physpool" : {'offset': 16},
        "preload" : {'offset': 20},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._exec_mode = 0
        self.fault_handler = None
        self.filename = None
        self.pd_attr = None
        self.physpool = None
        self._preload = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 24
    _type_alignment = 4
    _type_name = "program_attr"
    _type_libokl4_name = "program_attr"

    def _set_exec_mode(self, exec_mode_):
        """Set exec_mode and flag this type as modified"""
        self._exec_mode =  exec_mode_
        self._dirty = True

    exec_mode = property(lambda self: self._exec_mode, _set_exec_mode)

    def _set_preload(self, preload_):
        """Set preload and flag this type as modified"""
        self._preload =  preload_
        self._dirty = True

    preload = property(lambda self: self._preload, _set_preload)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.exec_mode, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.fault_handler)
        self._pointer_patch(image, symbol, 4, addr + 8, self.filename)
        self._pointer_patch(image, symbol, 4, addr + 12, self.pd_attr)
        self._pointer_patch(image, symbol, 4, addr + 16, self.physpool)
        image.patch(symbol, self.preload, 4, addr + 20)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.exec_mode,
                name + '.exec_mode', False)
        string += self._field_to_string(self.fault_handler,
                name + '.fault_handler', True)
        string += self._field_to_string(self.filename,
                name + '.filename', False)
        string += self._field_to_string(self.pd_attr,
                name + '.pd_attr', True)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.preload,
                name + '.preload', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.exec_mode))
        self._pointer_to_data(data, 4, self.fault_handler)
        self._pointer_to_data(data, 4, self.filename)
        self._pointer_to_data(data, 4, self.pd_attr)
        self._pointer_to_data(data, 4, self.physpool)
        data.append(self._pack(4, self.preload))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.fault_handler is not None:
            return True
        if self.filename is not None:
            return True
        if self.pd_attr is not None:
            return True
        if self.physpool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kmmu_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kmmu_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct okl4_kdomain *domain;
    okl4_word_t exception_badge;
    struct okl4_kthread *exception_handler;
    okl4_kcap_t intlock_cap;
    okl4_word_t numsegments;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "domain" : {'offset': 0},
        "exception_badge" : {'offset': 4},
        "exception_handler" : {'offset': 8},
        "intlock_cap" : {'offset': 12},
        "numsegments" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.domain = None
        self._exception_badge = 0
        self.exception_handler = None
        self._intlock_cap = 0
        self._numsegments = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 20
    _type_alignment = 4
    _type_name = "kmmu_attr"
    _type_libokl4_name = "kmmu_attr"

    def _set_exception_badge(self, exception_badge_):
        """Set exception_badge and flag this type as modified"""
        self._exception_badge =  exception_badge_
        self._dirty = True

    exception_badge = property(lambda self: self._exception_badge, _set_exception_badge)

    def _set_intlock_cap(self, intlock_cap_):
        """Set intlock_cap and flag this type as modified"""
        self._intlock_cap =  intlock_cap_
        self._dirty = True

    intlock_cap = property(lambda self: self._intlock_cap, _set_intlock_cap)

    def _set_numsegments(self, numsegments_):
        """Set numsegments and flag this type as modified"""
        self._numsegments =  numsegments_
        self._dirty = True

    numsegments = property(lambda self: self._numsegments, _set_numsegments)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.domain)
        image.patch(symbol, self.exception_badge, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.exception_handler)
        image.patch(symbol, self.intlock_cap, 4, addr + 12)
        image.patch(symbol, self.numsegments, 4, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.exception_badge,
                name + '.exception_badge', False)
        string += self._field_to_string(self.exception_handler,
                name + '.exception_handler', True)
        string += self._field_to_string(self.intlock_cap,
                name + '.intlock_cap', False)
        string += self._field_to_string(self.numsegments,
                name + '.numsegments', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.domain)
        data.append(self._pack(4, self.exception_badge))
        self._pointer_to_data(data, 4, self.exception_handler)
        data.append(self._pack(4, self.intlock_cap))
        data.append(self._pack(4, self.numsegments))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.domain is not None:
            return True
        if self.exception_handler is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kmmu_map_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kmmu_map_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t numpages;
    okl4_word_t offset;
    okl4_word_t page_cache;
    okl4_word_t page_perms;
    okl4_word_t pagesize;
    okl4_word_t segment;
    okl4_word_t virt;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "numpages" : {'offset': 0},
        "offset" : {'offset': 4},
        "page_cache" : {'offset': 8},
        "page_perms" : {'offset': 12},
        "pagesize" : {'offset': 16},
        "segment" : {'offset': 20},
        "virt" : {'offset': 24},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._numpages = 0
        self._offset = 0
        self._page_cache = 0
        self._page_perms = 0
        self._pagesize = 0
        self._segment = 0
        self._virt = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 28
    _type_alignment = 4
    _type_name = "kmmu_map_attr"
    _type_libokl4_name = "kmmu_map_attr"

    def _set_numpages(self, numpages_):
        """Set numpages and flag this type as modified"""
        self._numpages =  numpages_
        self._dirty = True

    numpages = property(lambda self: self._numpages, _set_numpages)

    def _set_offset(self, offset_):
        """Set offset and flag this type as modified"""
        self._offset =  offset_
        self._dirty = True

    offset = property(lambda self: self._offset, _set_offset)

    def _set_page_cache(self, page_cache_):
        """Set page_cache and flag this type as modified"""
        self._page_cache =  page_cache_
        self._dirty = True

    page_cache = property(lambda self: self._page_cache, _set_page_cache)

    def _set_page_perms(self, page_perms_):
        """Set page_perms and flag this type as modified"""
        self._page_perms =  page_perms_
        self._dirty = True

    page_perms = property(lambda self: self._page_perms, _set_page_perms)

    def _set_pagesize(self, pagesize_):
        """Set pagesize and flag this type as modified"""
        self._pagesize =  pagesize_
        self._dirty = True

    pagesize = property(lambda self: self._pagesize, _set_pagesize)

    def _set_segment(self, segment_):
        """Set segment and flag this type as modified"""
        self._segment =  segment_
        self._dirty = True

    segment = property(lambda self: self._segment, _set_segment)

    def _set_virt(self, virt_):
        """Set virt and flag this type as modified"""
        self._virt =  virt_
        self._dirty = True

    virt = property(lambda self: self._virt, _set_virt)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.numpages, 4, addr + 0)
        image.patch(symbol, self.offset, 4, addr + 4)
        image.patch(symbol, self.page_cache, 4, addr + 8)
        image.patch(symbol, self.page_perms, 4, addr + 12)
        image.patch(symbol, self.pagesize, 4, addr + 16)
        image.patch(symbol, self.segment, 4, addr + 20)
        image.patch(symbol, self.virt, 4, addr + 24)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.numpages,
                name + '.numpages', False)
        string += self._field_to_string(self.offset,
                name + '.offset', False)
        string += self._field_to_string(self.page_cache,
                name + '.page_cache', False)
        string += self._field_to_string(self.page_perms,
                name + '.page_perms', False)
        string += self._field_to_string(self.pagesize,
                name + '.pagesize', False)
        string += self._field_to_string(self.segment,
                name + '.segment', False)
        string += self._field_to_string(self.virt,
                name + '.virt', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.numpages))
        data.append(self._pack(4, self.offset))
        data.append(self._pack(4, self.page_cache))
        data.append(self._pack(4, self.page_perms))
        data.append(self._pack(4, self.pagesize))
        data.append(self._pack(4, self.segment))
        data.append(self._pack(4, self.virt))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracepoint_entry_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_tracepoint_entry_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_tracebuffer_ref_t buffer;
    struct okl4_tracepoint_entry **entry;
    okl4_uint64_t *timestamp;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "buffer" : {'offset': 0},
        "entry" : {'offset': 4},
        "timestamp" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._buffer = 0
        self.entry = None
        self.timestamp = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "tracepoint_entry_attr"
    _type_libokl4_name = "tracepoint_entry_attr"

    def _set_buffer(self, buffer_):
        """Set buffer and flag this type as modified"""
        self._buffer =  buffer_
        self._dirty = True

    buffer = property(lambda self: self._buffer, _set_buffer)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.buffer, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.entry)
        self._pointer_patch(image, symbol, 4, addr + 8, self.timestamp)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.buffer,
                name + '.buffer', False)
        string += self._field_to_string(self.entry,
                name + '.entry', True)
        string += self._field_to_string(self.timestamp,
                name + '.timestamp', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.buffer))
        self._pointer_to_data(data, 4, self.entry)
        self._pointer_to_data(data, 4, self.timestamp)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.entry is not None:
            return True
        if self.timestamp is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_tracebuffer_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_tracebuffer_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct _okl4_tracebuffer_header *header;
    okl4_kcap_t kcap;
    okl4_tracepoint_mask_t log_mask;
    okl4_kcap_t thread;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "header" : {'offset': 0},
        "kcap" : {'offset': 4},
        "log_mask" : {'offset': 8},
        "thread" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.header = None
        self._kcap = 0
        self._log_mask = 0
        self._thread = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "tracebuffer_attr"
    _type_libokl4_name = "tracebuffer_attr"

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def _set_log_mask(self, log_mask_):
        """Set log_mask and flag this type as modified"""
        self._log_mask =  log_mask_
        self._dirty = True

    log_mask = property(lambda self: self._log_mask, _set_log_mask)

    def _set_thread(self, thread_):
        """Set thread and flag this type as modified"""
        self._thread =  thread_
        self._dirty = True

    thread = property(lambda self: self._thread, _set_thread)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.header)
        image.patch(symbol, self.kcap, 4, addr + 4)
        image.patch(symbol, self.log_mask, 4, addr + 8)
        image.patch(symbol, self.thread, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.header,
                name + '.header', True)
        string += self._field_to_string(self.kcap,
                name + '.kcap', False)
        string += self._field_to_string(self.log_mask,
                name + '.log_mask', False)
        string += self._field_to_string(self.thread,
                name + '.thread', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.header)
        data.append(self._pack(4, self.kcap))
        data.append(self._pack(4, self.log_mask))
        data.append(self._pack(4, self.thread))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_queue_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_message_queue_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t kcap;
    struct okl4_kmmu *kmmu;
    okl4_word_t max_messages;
    okl4_word_t quota;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "kcap" : {'offset': 0},
        "kmmu" : {'offset': 4},
        "max_messages" : {'offset': 8},
        "quota" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._kcap = 0
        self.kmmu = None
        self._max_messages = 0
        self._quota = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "message_queue_attr"
    _type_libokl4_name = "message_queue_attr"

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def _set_max_messages(self, max_messages_):
        """Set max_messages and flag this type as modified"""
        self._max_messages =  max_messages_
        self._dirty = True

    max_messages = property(lambda self: self._max_messages, _set_max_messages)

    def _set_quota(self, quota_):
        """Set quota and flag this type as modified"""
        self._quota =  quota_
        self._dirty = True

    quota = property(lambda self: self._quota, _set_quota)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.kcap, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.kmmu)
        image.patch(symbol, self.max_messages, 4, addr + 8)
        image.patch(symbol, self.quota, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.kcap,
                name + '.kcap', False)
        string += self._field_to_string(self.kmmu,
                name + '.kmmu', True)
        string += self._field_to_string(self.max_messages,
                name + '.max_messages', False)
        string += self._field_to_string(self.quota,
                name + '.quota', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.kcap))
        self._pointer_to_data(data, 4, self.kmmu)
        data.append(self._pack(4, self.max_messages))
        data.append(self._pack(4, self.quota))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.kmmu is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_payload_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_message_payload_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t *inline_words;
    okl4_word_t *inplace_buff;
    okl4_word_t inplace_buff_size;
    okl4_word_t inplace_payload_size;
    okl4_rights_t kcap_rights;
    okl4_kcap_t kcapid;
    okl4_message_payload_type_t receive_type;
    okl4_message_payload_type_t send_type;
    void *standard_buff;
    okl4_word_t standard_buff_size;
    okl4_word_t standard_payload_size;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "inline_words" : {'offset': 0},
        "inplace_buff" : {'offset': 4},
        "inplace_buff_size" : {'offset': 8},
        "inplace_payload_size" : {'offset': 12},
        "kcap_rights" : {'offset': 16},
        "kcapid" : {'offset': 20},
        "receive_type" : {'offset': 24},
        "send_type" : {'offset': 28},
        "standard_buff" : {'offset': 32},
        "standard_buff_size" : {'offset': 36},
        "standard_payload_size" : {'offset': 40},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.inline_words = None
        self.inplace_buff = None
        self._inplace_buff_size = 0
        self._inplace_payload_size = 0
        self._kcap_rights = 0
        self._kcapid = 0
        self._receive_type = 0
        self._send_type = 0
        self.standard_buff = None
        self._standard_buff_size = 0
        self._standard_payload_size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 44
    _type_alignment = 4
    _type_name = "message_payload_attr"
    _type_libokl4_name = "message_payload_attr"

    def _set_inplace_buff_size(self, inplace_buff_size_):
        """Set inplace_buff_size and flag this type as modified"""
        self._inplace_buff_size =  inplace_buff_size_
        self._dirty = True

    inplace_buff_size = property(lambda self: self._inplace_buff_size, _set_inplace_buff_size)

    def _set_inplace_payload_size(self, inplace_payload_size_):
        """Set inplace_payload_size and flag this type as modified"""
        self._inplace_payload_size =  inplace_payload_size_
        self._dirty = True

    inplace_payload_size = property(lambda self: self._inplace_payload_size, _set_inplace_payload_size)

    def _set_kcap_rights(self, kcap_rights_):
        """Set kcap_rights and flag this type as modified"""
        self._kcap_rights =  kcap_rights_
        self._dirty = True

    kcap_rights = property(lambda self: self._kcap_rights, _set_kcap_rights)

    def _set_kcapid(self, kcapid_):
        """Set kcapid and flag this type as modified"""
        self._kcapid =  kcapid_
        self._dirty = True

    kcapid = property(lambda self: self._kcapid, _set_kcapid)

    def _set_receive_type(self, receive_type_):
        """Set receive_type and flag this type as modified"""
        self._receive_type =  receive_type_
        self._dirty = True

    receive_type = property(lambda self: self._receive_type, _set_receive_type)

    def _set_send_type(self, send_type_):
        """Set send_type and flag this type as modified"""
        self._send_type =  send_type_
        self._dirty = True

    send_type = property(lambda self: self._send_type, _set_send_type)

    def _set_standard_buff_size(self, standard_buff_size_):
        """Set standard_buff_size and flag this type as modified"""
        self._standard_buff_size =  standard_buff_size_
        self._dirty = True

    standard_buff_size = property(lambda self: self._standard_buff_size, _set_standard_buff_size)

    def _set_standard_payload_size(self, standard_payload_size_):
        """Set standard_payload_size and flag this type as modified"""
        self._standard_payload_size =  standard_payload_size_
        self._dirty = True

    standard_payload_size = property(lambda self: self._standard_payload_size, _set_standard_payload_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.inline_words)
        self._pointer_patch(image, symbol, 4, addr + 4, self.inplace_buff)
        image.patch(symbol, self.inplace_buff_size, 4, addr + 8)
        image.patch(symbol, self.inplace_payload_size, 4, addr + 12)
        image.patch(symbol, self.kcap_rights, 4, addr + 16)
        image.patch(symbol, self.kcapid, 4, addr + 20)
        image.patch(symbol, self.receive_type, 4, addr + 24)
        image.patch(symbol, self.send_type, 4, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 32, self.standard_buff)
        image.patch(symbol, self.standard_buff_size, 4, addr + 36)
        image.patch(symbol, self.standard_payload_size, 4, addr + 40)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.inline_words,
                name + '.inline_words', True)
        string += self._field_to_string(self.inplace_buff,
                name + '.inplace_buff', True)
        string += self._field_to_string(self.inplace_buff_size,
                name + '.inplace_buff_size', False)
        string += self._field_to_string(self.inplace_payload_size,
                name + '.inplace_payload_size', False)
        string += self._field_to_string(self.kcap_rights,
                name + '.kcap_rights', False)
        string += self._field_to_string(self.kcapid,
                name + '.kcapid', False)
        string += self._field_to_string(self.receive_type,
                name + '.receive_type', False)
        string += self._field_to_string(self.send_type,
                name + '.send_type', False)
        string += self._field_to_string(self.standard_buff,
                name + '.standard_buff', True)
        string += self._field_to_string(self.standard_buff_size,
                name + '.standard_buff_size', False)
        string += self._field_to_string(self.standard_payload_size,
                name + '.standard_payload_size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.inline_words)
        self._pointer_to_data(data, 4, self.inplace_buff)
        data.append(self._pack(4, self.inplace_buff_size))
        data.append(self._pack(4, self.inplace_payload_size))
        data.append(self._pack(4, self.kcap_rights))
        data.append(self._pack(4, self.kcapid))
        data.append(self._pack(4, self.receive_type))
        data.append(self._pack(4, self.send_type))
        self._pointer_to_data(data, 4, self.standard_buff)
        data.append(self._pack(4, self.standard_buff_size))
        data.append(self._pack(4, self.standard_payload_size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.inline_words is not None:
            return True
        if self.inplace_buff is not None:
            return True
        if self.standard_buff is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_buffer_area_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_buffer_area_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t base;
    struct okl4_kmmu *kmmu;
    okl4_word_t max_buffer_size;
    struct okl4_realm *realm;
    okl4_word_t size;
    okl4_bool_t use_allocation;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "base" : {'offset': 0},
        "kmmu" : {'offset': 4},
        "max_buffer_size" : {'offset': 8},
        "realm" : {'offset': 12},
        "size" : {'offset': 16},
        "use_allocation" : {'offset': 20},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._base = 0
        self.kmmu = None
        self._max_buffer_size = 0
        self.realm = None
        self._size = 0
        self._use_allocation = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 24
    _type_alignment = 4
    _type_name = "buffer_area_attr"
    _type_libokl4_name = "buffer_area_attr"

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_max_buffer_size(self, max_buffer_size_):
        """Set max_buffer_size and flag this type as modified"""
        self._max_buffer_size =  max_buffer_size_
        self._dirty = True

    max_buffer_size = property(lambda self: self._max_buffer_size, _set_max_buffer_size)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_use_allocation(self, use_allocation_):
        """Set use_allocation and flag this type as modified"""
        self._use_allocation =  use_allocation_
        self._dirty = True

    use_allocation = property(lambda self: self._use_allocation, _set_use_allocation)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.base, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.kmmu)
        image.patch(symbol, self.max_buffer_size, 4, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 12, self.realm)
        image.patch(symbol, self.size, 4, addr + 16)
        image.patch(symbol, self.use_allocation, 4, addr + 20)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.kmmu,
                name + '.kmmu', True)
        string += self._field_to_string(self.max_buffer_size,
                name + '.max_buffer_size', False)
        string += self._field_to_string(self.realm,
                name + '.realm', True)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.use_allocation,
                name + '.use_allocation', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.base))
        self._pointer_to_data(data, 4, self.kmmu)
        data.append(self._pack(4, self.max_buffer_size))
        self._pointer_to_data(data, 4, self.realm)
        data.append(self._pack(4, self.size))
        data.append(self._pack(4, self.use_allocation))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.kmmu is not None:
            return True
        if self.realm is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_memsection_contiguous_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memsection_contiguous_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t size;
    struct okl4_realm *realm;
    okl4_word_t virt_addr;
    okl4_word_t alignment;
    okl4_bool_t user_map;
    struct _okl4_mapping_attributes mapping_attributes;
    okl4_bool_t one_to_one;
    okl4_word_t phys_addr;
    struct okl4_physmem_item *physmem_item;
    struct okl4_physmem_segpool *physpool;
    okl4_bool_t preload;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "size" : {'offset': 0},
        "realm" : {'offset': 4},
        "virt_addr" : {'offset': 8},
        "alignment" : {'offset': 12},
        "user_map" : {'offset': 16},
        "mapping_attributes" : {'offset': 20},
        "one_to_one" : {'offset': 28},
        "phys_addr" : {'offset': 32},
        "physmem_item" : {'offset': 36},
        "physpool" : {'offset': 40},
        "preload" : {'offset': 44},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._size = 0
        self.realm = None
        self._virt_addr = 0
        self._alignment = 0
        self._user_map = 0

        this_addr = None if address is None else self._address + 20
        self.mapping_attributes = OKL4_mapping_attributes(this_addr, self)
        self._one_to_one = 0
        self._phys_addr = 0
        self.physmem_item = None
        self.physpool = None
        self._preload = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.mapping_attributes.set_address(address + 20)

    _type_size = 48
    _type_alignment = 4
    _type_name = "memsection_contiguous_attr"
    _type_libokl4_name = "memsection_contiguous_attr"

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_virt_addr(self, virt_addr_):
        """Set virt_addr and flag this type as modified"""
        self._virt_addr =  virt_addr_
        self._dirty = True

    virt_addr = property(lambda self: self._virt_addr, _set_virt_addr)

    def _set_alignment(self, alignment_):
        """Set alignment and flag this type as modified"""
        self._alignment =  alignment_
        self._dirty = True

    alignment = property(lambda self: self._alignment, _set_alignment)

    def _set_user_map(self, user_map_):
        """Set user_map and flag this type as modified"""
        self._user_map =  user_map_
        self._dirty = True

    user_map = property(lambda self: self._user_map, _set_user_map)

    def _set_one_to_one(self, one_to_one_):
        """Set one_to_one and flag this type as modified"""
        self._one_to_one =  one_to_one_
        self._dirty = True

    one_to_one = property(lambda self: self._one_to_one, _set_one_to_one)

    def _set_phys_addr(self, phys_addr_):
        """Set phys_addr and flag this type as modified"""
        self._phys_addr =  phys_addr_
        self._dirty = True

    phys_addr = property(lambda self: self._phys_addr, _set_phys_addr)

    def _set_preload(self, preload_):
        """Set preload and flag this type as modified"""
        self._preload =  preload_
        self._dirty = True

    preload = property(lambda self: self._preload, _set_preload)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.size, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.realm)
        image.patch(symbol, self.virt_addr, 4, addr + 8)
        image.patch(symbol, self.alignment, 4, addr + 12)
        image.patch(symbol, self.user_map, 4, addr + 16)
        self.mapping_attributes.patch(image, symbol, addr + 20)
        image.patch(symbol, self.one_to_one, 4, addr + 28)
        image.patch(symbol, self.phys_addr, 4, addr + 32)
        self._pointer_patch(image, symbol, 4, addr + 36, self.physmem_item)
        self._pointer_patch(image, symbol, 4, addr + 40, self.physpool)
        image.patch(symbol, self.preload, 4, addr + 44)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.realm,
                name + '.realm', True)
        string += self._field_to_string(self.virt_addr,
                name + '.virt_addr', False)
        string += self._field_to_string(self.alignment,
                name + '.alignment', False)
        string += self._field_to_string(self.user_map,
                name + '.user_map', False)
        string += self._field_to_string(self.mapping_attributes,
                name + '.mapping_attributes', False)
        string += self._field_to_string(self.one_to_one,
                name + '.one_to_one', False)
        string += self._field_to_string(self.phys_addr,
                name + '.phys_addr', False)
        string += self._field_to_string(self.physmem_item,
                name + '.physmem_item', True)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.preload,
                name + '.preload', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.size))
        self._pointer_to_data(data, 4, self.realm)
        data.append(self._pack(4, self.virt_addr))
        data.append(self._pack(4, self.alignment))
        data.append(self._pack(4, self.user_map))
        data.append(self.mapping_attributes.to_data())
        data.append(self._pack(4, self.one_to_one))
        data.append(self._pack(4, self.phys_addr))
        self._pointer_to_data(data, 4, self.physmem_item)
        self._pointer_to_data(data, 4, self.physpool)
        data.append(self._pack(4, self.preload))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.mapping_attributes.get_phys_relocs(base_offset + self.get_offset_of('mapping_attributes')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.realm is not None:
            return True
        if self.mapping_attributes.dirty:
            return True
        if self.physmem_item is not None:
            return True
        if self.physpool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_memsection_paged_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memsection_paged_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t size;
    struct okl4_realm *realm;
    okl4_word_t virt_addr;
    okl4_word_t alignment;
    struct _okl4_mapping_attributes mapping_attributes;
    okl4_word_t num_pages;
    okl4_word_t page_size;
    struct okl4_physmem_pagepool *physpool;
    okl4_bool_t prepaged;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "size" : {'offset': 0},
        "realm" : {'offset': 4},
        "virt_addr" : {'offset': 8},
        "alignment" : {'offset': 12},
        "mapping_attributes" : {'offset': 16},
        "num_pages" : {'offset': 24},
        "page_size" : {'offset': 28},
        "physpool" : {'offset': 32},
        "prepaged" : {'offset': 36},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._size = 0
        self.realm = None
        self._virt_addr = 0
        self._alignment = 0

        this_addr = None if address is None else self._address + 16
        self.mapping_attributes = OKL4_mapping_attributes(this_addr, self)
        self._num_pages = 0
        self._page_size = 0
        self.physpool = None
        self._prepaged = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.mapping_attributes.set_address(address + 16)

    _type_size = 40
    _type_alignment = 4
    _type_name = "memsection_paged_attr"
    _type_libokl4_name = "memsection_paged_attr"

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_virt_addr(self, virt_addr_):
        """Set virt_addr and flag this type as modified"""
        self._virt_addr =  virt_addr_
        self._dirty = True

    virt_addr = property(lambda self: self._virt_addr, _set_virt_addr)

    def _set_alignment(self, alignment_):
        """Set alignment and flag this type as modified"""
        self._alignment =  alignment_
        self._dirty = True

    alignment = property(lambda self: self._alignment, _set_alignment)

    def _set_num_pages(self, num_pages_):
        """Set num_pages and flag this type as modified"""
        self._num_pages =  num_pages_
        self._dirty = True

    num_pages = property(lambda self: self._num_pages, _set_num_pages)

    def _set_page_size(self, page_size_):
        """Set page_size and flag this type as modified"""
        self._page_size =  page_size_
        self._dirty = True

    page_size = property(lambda self: self._page_size, _set_page_size)

    def _set_prepaged(self, prepaged_):
        """Set prepaged and flag this type as modified"""
        self._prepaged =  prepaged_
        self._dirty = True

    prepaged = property(lambda self: self._prepaged, _set_prepaged)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.size, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.realm)
        image.patch(symbol, self.virt_addr, 4, addr + 8)
        image.patch(symbol, self.alignment, 4, addr + 12)
        self.mapping_attributes.patch(image, symbol, addr + 16)
        image.patch(symbol, self.num_pages, 4, addr + 24)
        image.patch(symbol, self.page_size, 4, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 32, self.physpool)
        image.patch(symbol, self.prepaged, 4, addr + 36)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.realm,
                name + '.realm', True)
        string += self._field_to_string(self.virt_addr,
                name + '.virt_addr', False)
        string += self._field_to_string(self.alignment,
                name + '.alignment', False)
        string += self._field_to_string(self.mapping_attributes,
                name + '.mapping_attributes', False)
        string += self._field_to_string(self.num_pages,
                name + '.num_pages', False)
        string += self._field_to_string(self.page_size,
                name + '.page_size', False)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.prepaged,
                name + '.prepaged', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.size))
        self._pointer_to_data(data, 4, self.realm)
        data.append(self._pack(4, self.virt_addr))
        data.append(self._pack(4, self.alignment))
        data.append(self.mapping_attributes.to_data())
        data.append(self._pack(4, self.num_pages))
        data.append(self._pack(4, self.page_size))
        self._pointer_to_data(data, 4, self.physpool)
        data.append(self._pack(4, self.prepaged))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.mapping_attributes.get_phys_relocs(base_offset + self.get_offset_of('mapping_attributes')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.realm is not None:
            return True
        if self.mapping_attributes.dirty:
            return True
        if self.physpool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_memsection_update_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memsection_update_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t cache_attributes;
    _okl4_memsection_update_op_t control;
    okl4_word_t permissions;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "cache_attributes" : {'offset': 0},
        "control" : {'offset': 4},
        "permissions" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._cache_attributes = 0
        self._control = 0
        self._permissions = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "memsection_update_attr"
    _type_libokl4_name = "memsection_update_attr"

    def _set_cache_attributes(self, cache_attributes_):
        """Set cache_attributes and flag this type as modified"""
        self._cache_attributes =  cache_attributes_
        self._dirty = True

    cache_attributes = property(lambda self: self._cache_attributes, _set_cache_attributes)

    def _set_control(self, control_):
        """Set control and flag this type as modified"""
        self._control =  control_
        self._dirty = True

    control = property(lambda self: self._control, _set_control)

    def _set_permissions(self, permissions_):
        """Set permissions and flag this type as modified"""
        self._permissions =  permissions_
        self._dirty = True

    permissions = property(lambda self: self._permissions, _set_permissions)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.cache_attributes, 4, addr + 0)
        image.patch(symbol, self.control, 4, addr + 4)
        image.patch(symbol, self.permissions, 4, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.cache_attributes,
                name + '.cache_attributes', False)
        string += self._field_to_string(self.control,
                name + '.control', False)
        string += self._field_to_string(self.permissions,
                name + '.permissions', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.cache_attributes))
        data.append(self._pack(4, self.control))
        data.append(self._pack(4, self.permissions))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_memsection_fragmented_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memsection_fragmented_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t size;
    struct okl4_realm *realm;
    okl4_word_t virt_addr;
    okl4_word_t alignment;
    okl4_word_t num_fragments;
    struct okl4_physmem_segpool *physpool;
    okl4_bool_t preload;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "size" : {'offset': 0},
        "realm" : {'offset': 4},
        "virt_addr" : {'offset': 8},
        "alignment" : {'offset': 12},
        "num_fragments" : {'offset': 16},
        "physpool" : {'offset': 20},
        "preload" : {'offset': 24},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._size = 0
        self.realm = None
        self._virt_addr = 0
        self._alignment = 0
        self._num_fragments = 0
        self.physpool = None
        self._preload = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 28
    _type_alignment = 4
    _type_name = "memsection_fragmented_attr"
    _type_libokl4_name = "memsection_fragmented_attr"

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_virt_addr(self, virt_addr_):
        """Set virt_addr and flag this type as modified"""
        self._virt_addr =  virt_addr_
        self._dirty = True

    virt_addr = property(lambda self: self._virt_addr, _set_virt_addr)

    def _set_alignment(self, alignment_):
        """Set alignment and flag this type as modified"""
        self._alignment =  alignment_
        self._dirty = True

    alignment = property(lambda self: self._alignment, _set_alignment)

    def _set_num_fragments(self, num_fragments_):
        """Set num_fragments and flag this type as modified"""
        self._num_fragments =  num_fragments_
        self._dirty = True

    num_fragments = property(lambda self: self._num_fragments, _set_num_fragments)

    def _set_preload(self, preload_):
        """Set preload and flag this type as modified"""
        self._preload =  preload_
        self._dirty = True

    preload = property(lambda self: self._preload, _set_preload)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.size, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.realm)
        image.patch(symbol, self.virt_addr, 4, addr + 8)
        image.patch(symbol, self.alignment, 4, addr + 12)
        image.patch(symbol, self.num_fragments, 4, addr + 16)
        self._pointer_patch(image, symbol, 4, addr + 20, self.physpool)
        image.patch(symbol, self.preload, 4, addr + 24)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.realm,
                name + '.realm', True)
        string += self._field_to_string(self.virt_addr,
                name + '.virt_addr', False)
        string += self._field_to_string(self.alignment,
                name + '.alignment', False)
        string += self._field_to_string(self.num_fragments,
                name + '.num_fragments', False)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.preload,
                name + '.preload', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.size))
        self._pointer_to_data(data, 4, self.realm)
        data.append(self._pack(4, self.virt_addr))
        data.append(self._pack(4, self.alignment))
        data.append(self._pack(4, self.num_fragments))
        self._pointer_to_data(data, 4, self.physpool)
        data.append(self._pack(4, self.preload))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.realm is not None:
            return True
        if self.physpool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_tls_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_tls_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t altpointer;
    okl4_word_t pointer;
    struct okl4_virtmem_pool *pool;
    okl4_word_t size;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "altpointer" : {'offset': 0},
        "pointer" : {'offset': 4},
        "pool" : {'offset': 8},
        "size" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._altpointer = 0
        self._pointer = 0
        self.pool = None
        self._size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "tls_attr"
    _type_libokl4_name = "tls_attr"

    def _set_altpointer(self, altpointer_):
        """Set altpointer and flag this type as modified"""
        self._altpointer =  altpointer_
        self._dirty = True

    altpointer = property(lambda self: self._altpointer, _set_altpointer)

    def _set_pointer(self, pointer_):
        """Set pointer and flag this type as modified"""
        self._pointer =  pointer_
        self._dirty = True

    pointer = property(lambda self: self._pointer, _set_pointer)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.altpointer, 4, addr + 0)
        image.patch(symbol, self.pointer, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.pool)
        image.patch(symbol, self.size, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.altpointer,
                name + '.altpointer', False)
        string += self._field_to_string(self.pointer,
                name + '.pointer', False)
        string += self._field_to_string(self.pool,
                name + '.pool', True)
        string += self._field_to_string(self.size,
                name + '.size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.altpointer))
        data.append(self._pack(4, self.pointer))
        self._pointer_to_data(data, 4, self.pool)
        data.append(self._pack(4, self.size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.pool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_alloc_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_alloc_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t alignment;
    okl4_word_t alignment_offset;
    okl4_bool_t allocate_item;
    okl4_word_t base;
    okl4_word_t size;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "alignment" : {'offset': 0},
        "alignment_offset" : {'offset': 4},
        "allocate_item" : {'offset': 8},
        "base" : {'offset': 12},
        "size" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._alignment = 0
        self._alignment_offset = 0
        self._allocate_item = 0
        self._base = 0
        self._size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 20
    _type_alignment = 4
    _type_name = "alloc_attr"
    _type_libokl4_name = "alloc_attr"

    def _set_alignment(self, alignment_):
        """Set alignment and flag this type as modified"""
        self._alignment =  alignment_
        self._dirty = True

    alignment = property(lambda self: self._alignment, _set_alignment)

    def _set_alignment_offset(self, alignment_offset_):
        """Set alignment_offset and flag this type as modified"""
        self._alignment_offset =  alignment_offset_
        self._dirty = True

    alignment_offset = property(lambda self: self._alignment_offset, _set_alignment_offset)

    def _set_allocate_item(self, allocate_item_):
        """Set allocate_item and flag this type as modified"""
        self._allocate_item =  allocate_item_
        self._dirty = True

    allocate_item = property(lambda self: self._allocate_item, _set_allocate_item)

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.alignment, 4, addr + 0)
        image.patch(symbol, self.alignment_offset, 4, addr + 4)
        image.patch(symbol, self.allocate_item, 4, addr + 8)
        image.patch(symbol, self.base, 4, addr + 12)
        image.patch(symbol, self.size, 4, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.alignment,
                name + '.alignment', False)
        string += self._field_to_string(self.alignment_offset,
                name + '.alignment_offset', False)
        string += self._field_to_string(self.allocate_item,
                name + '.allocate_item', False)
        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.size,
                name + '.size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.alignment))
        data.append(self._pack(4, self.alignment_offset))
        data.append(self._pack(4, self.allocate_item))
        data.append(self._pack(4, self.base))
        data.append(self._pack(4, self.size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_mutex_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_mutex_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_inheritance_type_t inheritance_type;
    okl4_word_t is_counted;
    okl4_word_t is_hybrid;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "inheritance_type" : {'offset': 0},
        "is_counted" : {'offset': 4},
        "is_hybrid" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._inheritance_type = 0
        self._is_counted = 0
        self._is_hybrid = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "mutex_attr"
    _type_libokl4_name = "mutex_attr"

    def _set_inheritance_type(self, inheritance_type_):
        """Set inheritance_type and flag this type as modified"""
        self._inheritance_type =  inheritance_type_
        self._dirty = True

    inheritance_type = property(lambda self: self._inheritance_type, _set_inheritance_type)

    def _set_is_counted(self, is_counted_):
        """Set is_counted and flag this type as modified"""
        self._is_counted =  is_counted_
        self._dirty = True

    is_counted = property(lambda self: self._is_counted, _set_is_counted)

    def _set_is_hybrid(self, is_hybrid_):
        """Set is_hybrid and flag this type as modified"""
        self._is_hybrid =  is_hybrid_
        self._dirty = True

    is_hybrid = property(lambda self: self._is_hybrid, _set_is_hybrid)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.inheritance_type, 4, addr + 0)
        image.patch(symbol, self.is_counted, 4, addr + 4)
        image.patch(symbol, self.is_hybrid, 4, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.inheritance_type,
                name + '.inheritance_type', False)
        string += self._field_to_string(self.is_counted,
                name + '.is_counted', False)
        string += self._field_to_string(self.is_hybrid,
                name + '.is_hybrid', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.inheritance_type))
        data.append(self._pack(4, self.is_counted))
        data.append(self._pack(4, self.is_hybrid))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_pd_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_pd_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct _okl4_address_space *address_space;
    void *attach_array;
    okl4_word_t attach_array_size;
    struct okl4_kdomain *domain;
    struct okl4_kthread *fault_handler;
    okl4_kcap_t intlock_cap;
    okl4_bool_t is_extension;
    okl4_word_t num_extension_entries;
    struct okl4_realm *private_realm;
    okl4_word_t return_stub_ip;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "address_space" : {'offset': 0},
        "attach_array" : {'offset': 4},
        "attach_array_size" : {'offset': 8},
        "domain" : {'offset': 12},
        "fault_handler" : {'offset': 16},
        "intlock_cap" : {'offset': 20},
        "is_extension" : {'offset': 24},
        "num_extension_entries" : {'offset': 28},
        "private_realm" : {'offset': 32},
        "return_stub_ip" : {'offset': 36},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.address_space = None
        self.attach_array = None
        self._attach_array_size = 0
        self.domain = None
        self.fault_handler = None
        self._intlock_cap = 0
        self._is_extension = 0
        self._num_extension_entries = 0
        self.private_realm = None
        self._return_stub_ip = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 40
    _type_alignment = 4
    _type_name = "pd_attr"
    _type_libokl4_name = "pd_attr"

    def _set_attach_array_size(self, attach_array_size_):
        """Set attach_array_size and flag this type as modified"""
        self._attach_array_size =  attach_array_size_
        self._dirty = True

    attach_array_size = property(lambda self: self._attach_array_size, _set_attach_array_size)

    def _set_intlock_cap(self, intlock_cap_):
        """Set intlock_cap and flag this type as modified"""
        self._intlock_cap =  intlock_cap_
        self._dirty = True

    intlock_cap = property(lambda self: self._intlock_cap, _set_intlock_cap)

    def _set_is_extension(self, is_extension_):
        """Set is_extension and flag this type as modified"""
        self._is_extension =  is_extension_
        self._dirty = True

    is_extension = property(lambda self: self._is_extension, _set_is_extension)

    def _set_num_extension_entries(self, num_extension_entries_):
        """Set num_extension_entries and flag this type as modified"""
        self._num_extension_entries =  num_extension_entries_
        self._dirty = True

    num_extension_entries = property(lambda self: self._num_extension_entries, _set_num_extension_entries)

    def _set_return_stub_ip(self, return_stub_ip_):
        """Set return_stub_ip and flag this type as modified"""
        self._return_stub_ip =  return_stub_ip_
        self._dirty = True

    return_stub_ip = property(lambda self: self._return_stub_ip, _set_return_stub_ip)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.address_space)
        self._pointer_patch(image, symbol, 4, addr + 4, self.attach_array)
        image.patch(symbol, self.attach_array_size, 4, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 12, self.domain)
        self._pointer_patch(image, symbol, 4, addr + 16, self.fault_handler)
        image.patch(symbol, self.intlock_cap, 4, addr + 20)
        image.patch(symbol, self.is_extension, 4, addr + 24)
        image.patch(symbol, self.num_extension_entries, 4, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 32, self.private_realm)
        image.patch(symbol, self.return_stub_ip, 4, addr + 36)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.address_space,
                name + '.address_space', True)
        string += self._field_to_string(self.attach_array,
                name + '.attach_array', True)
        string += self._field_to_string(self.attach_array_size,
                name + '.attach_array_size', False)
        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.fault_handler,
                name + '.fault_handler', True)
        string += self._field_to_string(self.intlock_cap,
                name + '.intlock_cap', False)
        string += self._field_to_string(self.is_extension,
                name + '.is_extension', False)
        string += self._field_to_string(self.num_extension_entries,
                name + '.num_extension_entries', False)
        string += self._field_to_string(self.private_realm,
                name + '.private_realm', True)
        string += self._field_to_string(self.return_stub_ip,
                name + '.return_stub_ip', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.address_space)
        self._pointer_to_data(data, 4, self.attach_array)
        data.append(self._pack(4, self.attach_array_size))
        self._pointer_to_data(data, 4, self.domain)
        self._pointer_to_data(data, 4, self.fault_handler)
        data.append(self._pack(4, self.intlock_cap))
        data.append(self._pack(4, self.is_extension))
        data.append(self._pack(4, self.num_extension_entries))
        self._pointer_to_data(data, 4, self.private_realm)
        data.append(self._pack(4, self.return_stub_ip))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.address_space is not None:
            return True
        if self.attach_array is not None:
            return True
        if self.domain is not None:
            return True
        if self.fault_handler is not None:
            return True
        if self.private_realm is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_memalloc_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memalloc_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    void *__empty;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "__empty" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.__empty = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "memalloc_attr"
    _type_libokl4_name = "memalloc_attr"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.__empty)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.__empty,
                name + '.__empty', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.__empty)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.__empty is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_realm_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_realm_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct _okl4_address_space *address_space;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "address_space" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.address_space = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "realm_attr"
    _type_libokl4_name = "realm_attr"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.address_space)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.address_space,
                name + '.address_space', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.address_space)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.address_space is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_realm_attach_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_realm_attach_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t permissions;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "permissions" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._permissions = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "realm_attach_attr"
    _type_libokl4_name = "realm_attach_attr"

    def _set_permissions(self, permissions_):
        """Set permissions and flag this type as modified"""
        self._permissions =  permissions_
        self._dirty = True

    permissions = property(lambda self: self._permissions, _set_permissions)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.permissions, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.permissions,
                name + '.permissions', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.permissions))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_virtmem_pool_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_virtmem_pool_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    struct okl4_virtmem_pool *parent;
    struct okl4_alloc_attr range_attr;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "parent" : {'offset': 0},
        "range_attr" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.parent = None

        this_addr = None if address is None else self._address + 4
        self.range_attr = OKL4_alloc_attr(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.range_attr.set_address(address + 4)

    _type_size = 24
    _type_alignment = 4
    _type_name = "virtmem_pool_attr"
    _type_libokl4_name = "virtmem_pool_attr"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.parent)
        self.range_attr.patch(image, symbol, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.parent,
                name + '.parent', True)
        string += self._field_to_string(self.range_attr,
                name + '.range_attr', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.parent)
        data.append(self.range_attr.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.range_attr.get_phys_relocs(base_offset + self.get_offset_of('range_attr')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.parent is not None:
            return True
        if self.range_attr.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_physmem_pool_attr(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_physmem_pool_attr {
#if !defined(NDEBUG)
    okl4_word_t magic;
#endif
    okl4_word_t pagebits;
    struct okl4_physmem_segpool *parent;
    struct okl4_physmem_item phys;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "pagebits" : {'offset': 0},
        "parent" : {'offset': 4},
        "phys" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._pagebits = 0
        self.parent = None

        this_addr = None if address is None else self._address + 8
        self.phys = OKL4_physmem_item(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.phys.set_address(address + 8)

    _type_size = 44
    _type_alignment = 4
    _type_name = "physmem_pool_attr"
    _type_libokl4_name = "physmem_pool_attr"

    def _set_pagebits(self, pagebits_):
        """Set pagebits and flag this type as modified"""
        self._pagebits =  pagebits_
        self._dirty = True

    pagebits = property(lambda self: self._pagebits, _set_pagebits)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.pagebits, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.parent)
        self.phys.patch(image, symbol, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.pagebits,
                name + '.pagebits', False)
        string += self._field_to_string(self.parent,
                name + '.parent', True)
        string += self._field_to_string(self.phys,
                name + '.phys', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.pagebits))
        self._pointer_to_data(data, 4, self.parent)
        data.append(self.phys.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.phys.get_phys_relocs(base_offset + self.get_offset_of('phys')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.parent is not None:
            return True
        if self.phys.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_memsection(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memsection {
    struct okl4_memsection *alloc_next;
    okl4_word_t avail_after;
    okl4_word_t avail_before;
    okl4_word_t base;
    struct _okl4_chunk *chunk;
    okl4_error_t (*delete_handler)(okl4_memsection_t *memsection);
    okl4_error_t (*fault_handler)(okl4_memsection_t *memsection, okl4_word_t virt_addr);
    okl4_bool_t is_tainted;
    okl4_word_t (*iterate_handler)(okl4_memsection_t *memsection, okl4_mapping_t *mapping, void **next);
    okl4_error_t (*lookup_handler)(okl4_memsection_t *memsection, okl4_word_t virt_addr, okl4_mapping_t *mapping);
    struct okl4_memsection *lookup_next;
    struct okl4_memsection *own_next;
    struct okl4_realm *realm;
    okl4_word_t size;
    struct okl4_memsection *super;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "alloc_next" : {'offset': 0},
        "avail_after" : {'offset': 4},
        "avail_before" : {'offset': 8},
        "base" : {'offset': 12},
        "chunk" : {'offset': 16},
        "delete_handler" : {'offset': 20},
        "fault_handler" : {'offset': 24},
        "is_tainted" : {'offset': 28},
        "iterate_handler" : {'offset': 32},
        "lookup_handler" : {'offset': 36},
        "lookup_next" : {'offset': 40},
        "own_next" : {'offset': 44},
        "realm" : {'offset': 48},
        "size" : {'offset': 52},
        "super" : {'offset': 56},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.alloc_next = None
        self._avail_after = 0
        self._avail_before = 0
        self._base = 0
        self.chunk = None
        self.delete_handler = None
        self.fault_handler = None
        self._is_tainted = 0
        self.iterate_handler = None
        self.lookup_handler = None
        self.lookup_next = None
        self.own_next = None
        self.realm = None
        self._size = 0
        self.super = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 60
    _type_alignment = 4
    _type_name = "memsection"
    _type_libokl4_name = "memsection"

    def _set_avail_after(self, avail_after_):
        """Set avail_after and flag this type as modified"""
        self._avail_after =  avail_after_
        self._dirty = True

    avail_after = property(lambda self: self._avail_after, _set_avail_after)

    def _set_avail_before(self, avail_before_):
        """Set avail_before and flag this type as modified"""
        self._avail_before =  avail_before_
        self._dirty = True

    avail_before = property(lambda self: self._avail_before, _set_avail_before)

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_is_tainted(self, is_tainted_):
        """Set is_tainted and flag this type as modified"""
        self._is_tainted =  is_tainted_
        self._dirty = True

    is_tainted = property(lambda self: self._is_tainted, _set_is_tainted)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.alloc_next)
        image.patch(symbol, self.avail_after, 4, addr + 4)
        image.patch(symbol, self.avail_before, 4, addr + 8)
        image.patch(symbol, self.base, 4, addr + 12)
        self._pointer_patch(image, symbol, 4, addr + 16, self.chunk)
        self._pointer_patch(image, symbol, 4, addr + 20, self.delete_handler)
        self._pointer_patch(image, symbol, 4, addr + 24, self.fault_handler)
        image.patch(symbol, self.is_tainted, 4, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 32, self.iterate_handler)
        self._pointer_patch(image, symbol, 4, addr + 36, self.lookup_handler)
        self._pointer_patch(image, symbol, 4, addr + 40, self.lookup_next)
        self._pointer_patch(image, symbol, 4, addr + 44, self.own_next)
        self._pointer_patch(image, symbol, 4, addr + 48, self.realm)
        image.patch(symbol, self.size, 4, addr + 52)
        self._pointer_patch(image, symbol, 4, addr + 56, self.super)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.alloc_next,
                name + '.alloc_next', True)
        string += self._field_to_string(self.avail_after,
                name + '.avail_after', False)
        string += self._field_to_string(self.avail_before,
                name + '.avail_before', False)
        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.chunk,
                name + '.chunk', True)
        string += self._field_to_string(self.delete_handler,
                name + '.delete_handler', True)
        string += self._field_to_string(self.fault_handler,
                name + '.fault_handler', True)
        string += self._field_to_string(self.is_tainted,
                name + '.is_tainted', False)
        string += self._field_to_string(self.iterate_handler,
                name + '.iterate_handler', True)
        string += self._field_to_string(self.lookup_handler,
                name + '.lookup_handler', True)
        string += self._field_to_string(self.lookup_next,
                name + '.lookup_next', True)
        string += self._field_to_string(self.own_next,
                name + '.own_next', True)
        string += self._field_to_string(self.realm,
                name + '.realm', True)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.super,
                name + '.super', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.alloc_next)
        data.append(self._pack(4, self.avail_after))
        data.append(self._pack(4, self.avail_before))
        data.append(self._pack(4, self.base))
        self._pointer_to_data(data, 4, self.chunk)
        self._pointer_to_data(data, 4, self.delete_handler)
        self._pointer_to_data(data, 4, self.fault_handler)
        data.append(self._pack(4, self.is_tainted))
        self._pointer_to_data(data, 4, self.iterate_handler)
        self._pointer_to_data(data, 4, self.lookup_handler)
        self._pointer_to_data(data, 4, self.lookup_next)
        self._pointer_to_data(data, 4, self.own_next)
        self._pointer_to_data(data, 4, self.realm)
        data.append(self._pack(4, self.size))
        self._pointer_to_data(data, 4, self.super)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.alloc_next is not None:
            return True
        if self.chunk is not None:
            return True
        if self.delete_handler is not None:
            return True
        if self.fault_handler is not None:
            return True
        if self.iterate_handler is not None:
            return True
        if self.lookup_handler is not None:
            return True
        if self.lookup_next is not None:
            return True
        if self.own_next is not None:
            return True
        if self.realm is not None:
            return True
        if self.super is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_chunk(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_chunk {
    struct okl4_memsection *memsection;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "memsection" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.memsection = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "chunk"
    _type_libokl4_name = "chunk"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.memsection)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.memsection,
                name + '.memsection', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.memsection)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.memsection is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_address_space(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_address_space {
    okl4_word_t first_chunk;
    okl4_word_t first_reserved_chunk;
    okl4_word_t num_chunks;
    okl4_word_t num_reserved_chunks;
    struct okl4_pd *pds[96];
    struct okl4_realm *realms;
    struct okl4_memsection *taint_list;
    struct _okl4_chunk chunks[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "first_chunk" : {'offset': 0},
        "first_reserved_chunk" : {'offset': 4},
        "num_chunks" : {'offset': 8},
        "num_reserved_chunks" : {'offset': 12},
        "pds" : {'offset': 16},
        "realms" : {'offset': 400},
        "taint_list" : {'offset': 404},
        "chunks" : {'offset': 408},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._first_chunk = 0
        self._first_reserved_chunk = 0
        self._num_chunks = 0
        self._num_reserved_chunks = 0
        self.pds = [None] * 96
        self.realms = None
        self.taint_list = None
        if address is None:
            self.chunks = [OKL4_chunk(None, self)
                    for i in range(0, 0)]
        else:
            self.chunks = [OKL4_chunk(self._address + 408 + i * 4, self)
                    for i in range(0, 0)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        for (i, obj) in enumerate(self.chunks):
            obj.set_address(address + 408 + i * 4)

    def get_size(self):
        """Return the size in bytes of the type."""
        return 412 + ((len(self.chunks) - 1) * 4)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "address_space"
    _type_libokl4_name = "address_space"

    def _set_first_chunk(self, first_chunk_):
        """Set first_chunk and flag this type as modified"""
        self._first_chunk =  first_chunk_
        self._dirty = True

    first_chunk = property(lambda self: self._first_chunk, _set_first_chunk)

    def _set_first_reserved_chunk(self, first_reserved_chunk_):
        """Set first_reserved_chunk and flag this type as modified"""
        self._first_reserved_chunk =  first_reserved_chunk_
        self._dirty = True

    first_reserved_chunk = property(lambda self: self._first_reserved_chunk, _set_first_reserved_chunk)

    def _set_num_chunks(self, num_chunks_):
        """Set num_chunks and flag this type as modified"""
        self._num_chunks =  num_chunks_
        self._dirty = True

    num_chunks = property(lambda self: self._num_chunks, _set_num_chunks)

    def _set_num_reserved_chunks(self, num_reserved_chunks_):
        """Set num_reserved_chunks and flag this type as modified"""
        self._num_reserved_chunks =  num_reserved_chunks_
        self._dirty = True

    num_reserved_chunks = property(lambda self: self._num_reserved_chunks, _set_num_reserved_chunks)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.first_chunk, 4, addr + 0)
        image.patch(symbol, self.first_reserved_chunk, 4, addr + 4)
        image.patch(symbol, self.num_chunks, 4, addr + 8)
        image.patch(symbol, self.num_reserved_chunks, 4, addr + 12)
        for i, item in enumerate(self.pds):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 16)
        self._pointer_patch(image, symbol, 4, addr + 400, self.realms)
        self._pointer_patch(image, symbol, 4, addr + 404, self.taint_list)
        for i, item in enumerate(self.chunks):
            item.patch(image, symbol, addr + i * 4 + 408)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.first_chunk,
                name + '.first_chunk', False)
        string += self._field_to_string(self.first_reserved_chunk,
                name + '.first_reserved_chunk', False)
        string += self._field_to_string(self.num_chunks,
                name + '.num_chunks', False)
        string += self._field_to_string(self.num_reserved_chunks,
                name + '.num_reserved_chunks', False)
        string += self._field_to_string(self.pds,
                name + '.pds', False)
        string += self._field_to_string(self.realms,
                name + '.realms', True)
        string += self._field_to_string(self.taint_list,
                name + '.taint_list', True)
        string += self._field_to_string(self.chunks,
                name + '.chunks', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.first_chunk))
        data.append(self._pack(4, self.first_reserved_chunk))
        data.append(self._pack(4, self.num_chunks))
        data.append(self._pack(4, self.num_reserved_chunks))
        for item in self.pds:
            if item is not None:
                data.append(self._pack(4, item.get_address()))
            else:
                data.append(self._pack(4, 0))
        self._pointer_to_data(data, 4, self.realms)
        self._pointer_to_data(data, 4, self.taint_list)
        for item in self.chunks:
            data.append(item.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.pds):
            return True
        if self.realms is not None:
            return True
        if self.taint_list is not None:
            return True
        if self._array_dirty_test(self.chunks):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_bitmap_item(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_bitmap_item {
    okl4_word_t unit;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "unit" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._unit = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "bitmap_item"
    _type_libokl4_name = "bitmap_item"

    def _set_unit(self, unit_):
        """Set unit and flag this type as modified"""
        self._unit =  unit_
        self._dirty = True

    unit = property(lambda self: self._unit, _set_unit)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.unit, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.unit,
                name + '.unit', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.unit))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_bitmap_allocator(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_bitmap_allocator {
    okl4_word_t base;
    okl4_word_t pos_guess;
    okl4_word_t size;
    okl4_word_t data[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "base" : {'offset': 0},
        "pos_guess" : {'offset': 4},
        "size" : {'offset': 8},
        "data" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._base = 0
        self._pos_guess = 0
        self._size = 0
        self.data = [None] * 1

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 4
    _type_name = "bitmap_allocator"
    _type_libokl4_name = "bitmap_allocator"

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_pos_guess(self, pos_guess_):
        """Set pos_guess and flag this type as modified"""
        self._pos_guess =  pos_guess_
        self._dirty = True

    pos_guess = property(lambda self: self._pos_guess, _set_pos_guess)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.base, 4, addr + 0)
        image.patch(symbol, self.pos_guess, 4, addr + 4)
        image.patch(symbol, self.size, 4, addr + 8)
        for i, item in enumerate(self.data):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.pos_guess,
                name + '.pos_guess', False)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.data,
                name + '.data', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.base))
        data.append(self._pack(4, self.pos_guess))
        data.append(self._pack(4, self.size))
        for item in self.data:
            data.append(self._pack(4, item))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.data):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_pd(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_pd {
    struct _okl4_address_space *address_space;
    okl4_word_t attach_array_size;
    okl4_word_t attached_realms;
    struct okl4_kdomain domain;
    okl4_word_t domain_type;
    _okl4_list_head_t ext_list;
    okl4_word_t id;
    okl4_bool_t is_extension;
    struct okl4_kswitch kswitch;
    struct okl4_kmmu mmu;
    struct _okl4_pd_attach_item *pd_attach_array;
    _okl4_list_head_t pd_list;
    struct okl4_realm *private_realm;
    okl4_bool_t private_realm_allocated;
    struct okl4_realm private_realm_inline;
    _okl4_list_head_t threads;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "address_space" : {'offset': 0},
        "attach_array_size" : {'offset': 4},
        "attached_realms" : {'offset': 8},
        "domain" : {'offset': 12},
        "domain_type" : {'offset': 16},
        "ext_list" : {'offset': 20},
        "id" : {'offset': 28},
        "is_extension" : {'offset': 32},
        "kswitch" : {'offset': 36},
        "mmu" : {'offset': 44},
        "pd_attach_array" : {'offset': 48},
        "pd_list" : {'offset': 52},
        "private_realm" : {'offset': 60},
        "private_realm_allocated" : {'offset': 64},
        "private_realm_inline" : {'offset': 68},
        "threads" : {'offset': 120},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.address_space = None
        self._attach_array_size = 0
        self._attached_realms = 0

        this_addr = None if address is None else self._address + 12
        self.domain = OKL4_kdomain(this_addr, self)
        self._domain_type = 0

        this_addr = None if address is None else self._address + 20
        self.ext_list = OKL4_list_head_t(this_addr, self)
        self._id = 0
        self._is_extension = 0

        this_addr = None if address is None else self._address + 36
        self.kswitch = OKL4_kswitch(this_addr, self)

        this_addr = None if address is None else self._address + 44
        self.mmu = OKL4_kmmu(this_addr, self)
        self.pd_attach_array = None

        this_addr = None if address is None else self._address + 52
        self.pd_list = OKL4_list_head_t(this_addr, self)
        self.private_realm = None
        self._private_realm_allocated = 0

        this_addr = None if address is None else self._address + 68
        self.private_realm_inline = OKL4_realm(this_addr, self)

        this_addr = None if address is None else self._address + 120
        self.threads = OKL4_list_head_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.domain.set_address(address + 12)
        self.ext_list.set_address(address + 20)
        self.kswitch.set_address(address + 36)
        self.mmu.set_address(address + 44)
        self.pd_list.set_address(address + 52)
        self.private_realm_inline.set_address(address + 68)
        self.threads.set_address(address + 120)

    _type_size = 128
    _type_alignment = 4
    _type_name = "pd"
    _type_libokl4_name = "pd"

    def _set_attach_array_size(self, attach_array_size_):
        """Set attach_array_size and flag this type as modified"""
        self._attach_array_size =  attach_array_size_
        self._dirty = True

    attach_array_size = property(lambda self: self._attach_array_size, _set_attach_array_size)

    def _set_attached_realms(self, attached_realms_):
        """Set attached_realms and flag this type as modified"""
        self._attached_realms =  attached_realms_
        self._dirty = True

    attached_realms = property(lambda self: self._attached_realms, _set_attached_realms)

    def _set_domain_type(self, domain_type_):
        """Set domain_type and flag this type as modified"""
        self._domain_type =  domain_type_
        self._dirty = True

    domain_type = property(lambda self: self._domain_type, _set_domain_type)

    def _set_id(self, id_):
        """Set id and flag this type as modified"""
        self._id =  id_
        self._dirty = True

    id = property(lambda self: self._id, _set_id)

    def _set_is_extension(self, is_extension_):
        """Set is_extension and flag this type as modified"""
        self._is_extension =  is_extension_
        self._dirty = True

    is_extension = property(lambda self: self._is_extension, _set_is_extension)

    def _set_private_realm_allocated(self, private_realm_allocated_):
        """Set private_realm_allocated and flag this type as modified"""
        self._private_realm_allocated =  private_realm_allocated_
        self._dirty = True

    private_realm_allocated = property(lambda self: self._private_realm_allocated, _set_private_realm_allocated)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.address_space)
        image.patch(symbol, self.attach_array_size, 4, addr + 4)
        image.patch(symbol, self.attached_realms, 4, addr + 8)
        self.domain.patch(image, symbol, addr + 12)
        image.patch(symbol, self.domain_type, 4, addr + 16)
        self.ext_list.patch(image, symbol, addr + 20)
        image.patch(symbol, self.id, 4, addr + 28)
        image.patch(symbol, self.is_extension, 4, addr + 32)
        self.kswitch.patch(image, symbol, addr + 36)
        self.mmu.patch(image, symbol, addr + 44)
        self._pointer_patch(image, symbol, 4, addr + 48, self.pd_attach_array)
        self.pd_list.patch(image, symbol, addr + 52)
        self._pointer_patch(image, symbol, 4, addr + 60, self.private_realm)
        image.patch(symbol, self.private_realm_allocated, 4, addr + 64)
        self.private_realm_inline.patch(image, symbol, addr + 68)
        self.threads.patch(image, symbol, addr + 120)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.address_space,
                name + '.address_space', True)
        string += self._field_to_string(self.attach_array_size,
                name + '.attach_array_size', False)
        string += self._field_to_string(self.attached_realms,
                name + '.attached_realms', False)
        string += self._field_to_string(self.domain,
                name + '.domain', False)
        string += self._field_to_string(self.domain_type,
                name + '.domain_type', False)
        string += self._field_to_string(self.ext_list,
                name + '.ext_list', False)
        string += self._field_to_string(self.id,
                name + '.id', False)
        string += self._field_to_string(self.is_extension,
                name + '.is_extension', False)
        string += self._field_to_string(self.kswitch,
                name + '.kswitch', False)
        string += self._field_to_string(self.mmu,
                name + '.mmu', False)
        string += self._field_to_string(self.pd_attach_array,
                name + '.pd_attach_array', True)
        string += self._field_to_string(self.pd_list,
                name + '.pd_list', False)
        string += self._field_to_string(self.private_realm,
                name + '.private_realm', True)
        string += self._field_to_string(self.private_realm_allocated,
                name + '.private_realm_allocated', False)
        string += self._field_to_string(self.private_realm_inline,
                name + '.private_realm_inline', False)
        string += self._field_to_string(self.threads,
                name + '.threads', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.address_space)
        data.append(self._pack(4, self.attach_array_size))
        data.append(self._pack(4, self.attached_realms))
        data.append(self.domain.to_data())
        data.append(self._pack(4, self.domain_type))
        data.append(self.ext_list.to_data())
        data.append(self._pack(4, self.id))
        data.append(self._pack(4, self.is_extension))
        data.append(self.kswitch.to_data())
        data.append(self.mmu.to_data())
        self._pointer_to_data(data, 4, self.pd_attach_array)
        data.append(self.pd_list.to_data())
        self._pointer_to_data(data, 4, self.private_realm)
        data.append(self._pack(4, self.private_realm_allocated))
        data.append(self.private_realm_inline.to_data())
        data.append(self.threads.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.domain.get_phys_relocs(base_offset + self.get_offset_of('domain')))
        relocs.extend(self.ext_list.get_phys_relocs(base_offset + self.get_offset_of('ext_list')))
        relocs.extend(self.kswitch.get_phys_relocs(base_offset + self.get_offset_of('kswitch')))
        relocs.extend(self.mmu.get_phys_relocs(base_offset + self.get_offset_of('mmu')))
        relocs.extend(self.pd_list.get_phys_relocs(base_offset + self.get_offset_of('pd_list')))
        relocs.extend(self.private_realm_inline.get_phys_relocs(base_offset + self.get_offset_of('private_realm_inline')))
        relocs.extend(self.threads.get_phys_relocs(base_offset + self.get_offset_of('threads')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.address_space is not None:
            return True
        if self.domain.dirty:
            return True
        if self.ext_list.dirty:
            return True
        if self.kswitch.dirty:
            return True
        if self.mmu.dirty:
            return True
        if self.pd_attach_array is not None:
            return True
        if self.pd_list.dirty:
            return True
        if self.private_realm is not None:
            return True
        if self.private_realm_inline.dirty:
            return True
        if self.threads.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kdomain(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kdomain {
    okl4_kcap_t kcap;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "kcap" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._kcap = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "kdomain"
    _type_libokl4_name = "kdomain"

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.kcap, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.kcap,
                name + '.kcap', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.kcap))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_env_segment(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_env_segment {
    okl4_kcap_t cap_id;
    okl4_word_t base;
    okl4_word_t size;
    okl4_word_t rwx;
    _okl4_list_entry_t ksegment_list;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "cap_id" : {'offset': 0},
        "base" : {'offset': 4},
        "size" : {'offset': 8},
        "rwx" : {'offset': 12},
        "ksegment_list" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._cap_id = 0
        self._base = 0
        self._size = 0
        self._rwx = 0

        this_addr = None if address is None else self._address + 16
        self.ksegment_list = OKL4_list_entry_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.ksegment_list.set_address(address + 16)

    _type_size = 24
    _type_alignment = 4
    _type_name = "env_segment"
    _type_libokl4_name = "env_segment"

    def _set_cap_id(self, cap_id_):
        """Set cap_id and flag this type as modified"""
        self._cap_id =  cap_id_
        self._dirty = True

    cap_id = property(lambda self: self._cap_id, _set_cap_id)

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_rwx(self, rwx_):
        """Set rwx and flag this type as modified"""
        self._rwx =  rwx_
        self._dirty = True

    rwx = property(lambda self: self._rwx, _set_rwx)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.cap_id, 4, addr + 0)
        image.patch(symbol, self.base, 4, addr + 4)
        image.patch(symbol, self.size, 4, addr + 8)
        image.patch(symbol, self.rwx, 4, addr + 12)
        self.ksegment_list.patch(image, symbol, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.cap_id,
                name + '.cap_id', False)
        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.rwx,
                name + '.rwx', False)
        string += self._field_to_string(self.ksegment_list,
                name + '.ksegment_list', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.cap_id))
        data.append(self._pack(4, self.base))
        data.append(self._pack(4, self.size))
        data.append(self._pack(4, self.rwx))
        data.append(self.ksegment_list.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.ksegment_list.get_phys_relocs(base_offset + self.get_offset_of('ksegment_list')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.ksegment_list.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_tracebuffer_buffer_header(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_tracebuffer_buffer_header {
    okl4_uint64_t timestamp;
    okl4_word_t wrap;
    okl4_word_t size;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "timestamp" : {'offset': 0},
        "wrap" : {'offset': 8},
        "size" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._timestamp = 0
        self._wrap = 0
        self._size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 16
    _type_alignment = 8
    _type_name = "tracebuffer_buffer_header"
    _type_libokl4_name = "tracebuffer_buffer_header"

    def _set_timestamp(self, timestamp_):
        """Set timestamp and flag this type as modified"""
        self._timestamp =  timestamp_
        self._dirty = True

    timestamp = property(lambda self: self._timestamp, _set_timestamp)

    def _set_wrap(self, wrap_):
        """Set wrap and flag this type as modified"""
        self._wrap =  wrap_
        self._dirty = True

    wrap = property(lambda self: self._wrap, _set_wrap)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.timestamp, 8, addr + 0)
        image.patch(symbol, self.wrap, 4, addr + 8)
        image.patch(symbol, self.size, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.timestamp,
                name + '.timestamp', False)
        string += self._field_to_string(self.wrap,
                name + '.wrap', False)
        string += self._field_to_string(self.size,
                name + '.size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(8, self.timestamp))
        data.append(self._pack(4, self.wrap))
        data.append(self._pack(4, self.size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_env(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_env {
    okl4_word_t env_hdr;
    struct _okl4_env_item env_item[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "env_hdr" : {'offset': 0},
        "env_item" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._env_hdr = 0
        if address is None:
            self.env_item = [OKL4_env_item(None, self)
                    for i in range(0, 0)]
        else:
            self.env_item = [OKL4_env_item(self._address + 4 + i * 8, self)
                    for i in range(0, 0)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        for (i, obj) in enumerate(self.env_item):
            obj.set_address(address + 4 + i * 8)

    def get_size(self):
        """Return the size in bytes of the type."""
        return 12 + ((len(self.env_item) - 1) * 8)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "env"
    _type_libokl4_name = "env"

    def _set_env_hdr(self, env_hdr_):
        """Set env_hdr and flag this type as modified"""
        self._env_hdr =  env_hdr_
        self._dirty = True

    env_hdr = property(lambda self: self._env_hdr, _set_env_hdr)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.env_hdr, 4, addr + 0)
        for i, item in enumerate(self.env_item):
            item.patch(image, symbol, addr + i * 8 + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.env_hdr,
                name + '.env_hdr', False)
        string += self._field_to_string(self.env_item,
                name + '.env_item', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.env_hdr))
        for item in self.env_item:
            data.append(item.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.env_item):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_okl4_interrupt(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_interrupt {
    okl4_kcap_t kcap;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "kcap" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._kcap = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "okl4_interrupt"
    _type_libokl4_name = "interrupt"

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.kcap, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.kcap,
                name + '.kcap', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.kcap))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_env_args(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_env_args {
    okl4_word_t argc;
    unsigned char *argv;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "argc" : {'offset': 0},
        "argv" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._argc = 0
        self.argv = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "env_args"
    _type_libokl4_name = "env_args"

    def _set_argc(self, argc_):
        """Set argc and flag this type as modified"""
        self._argc =  argc_
        self._dirty = True

    argc = property(lambda self: self._argc, _set_argc)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.argc, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.argv)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.argc,
                name + '.argc', False)
        string += self._field_to_string(self.argv,
                name + '.argv', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.argc))
        self._pointer_to_data(data, 4, self.argv)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.argv is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_env_interrupt_list(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_env_interrupt_list {
    okl4_word_t num_entries;
    struct okl4_env_interrupt_handle entries[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "num_entries" : {'offset': 0},
        "entries" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._num_entries = 0
        if address is None:
            self.entries = [OKL4_env_interrupt_handle(None, self)
                    for i in range(0, 0)]
        else:
            self.entries = [OKL4_env_interrupt_handle(self._address + 4 + i * 8, self)
                    for i in range(0, 0)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        for (i, obj) in enumerate(self.entries):
            obj.set_address(address + 4 + i * 8)

    def get_size(self):
        """Return the size in bytes of the type."""
        return 12 + ((len(self.entries) - 1) * 8)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "env_interrupt_list"
    _type_libokl4_name = "env_interrupt_list"

    def _set_num_entries(self, num_entries_):
        """Set num_entries and flag this type as modified"""
        self._num_entries =  num_entries_
        self._dirty = True

    num_entries = property(lambda self: self._num_entries, _set_num_entries)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.num_entries, 4, addr + 0)
        for i, item in enumerate(self.entries):
            item.patch(image, symbol, addr + i * 8 + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.num_entries,
                name + '.num_entries', False)
        string += self._field_to_string(self.entries,
                name + '.entries', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.num_entries))
        for item in self.entries:
            data.append(item.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.entries):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_env_interrupt_handle(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_env_interrupt_handle {
    okl4_interrupt_soc_descriptor_t descriptor;
    struct okl4_interrupt interrupt;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "descriptor" : {'offset': 0},
        "interrupt" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._descriptor = 0

        this_addr = None if address is None else self._address + 4
        self.interrupt = OKL4_okl4_interrupt(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.interrupt.set_address(address + 4)

    _type_size = 8
    _type_alignment = 4
    _type_name = "env_interrupt_handle"
    _type_libokl4_name = "env_interrupt_handle"

    def _set_descriptor(self, descriptor_):
        """Set descriptor and flag this type as modified"""
        self._descriptor =  descriptor_
        self._dirty = True

    descriptor = property(lambda self: self._descriptor, _set_descriptor)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.descriptor, 4, addr + 0)
        self.interrupt.patch(image, symbol, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.descriptor,
                name + '.descriptor', False)
        string += self._field_to_string(self.interrupt,
                name + '.interrupt', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.descriptor))
        data.append(self.interrupt.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.interrupt.get_phys_relocs(base_offset + self.get_offset_of('interrupt')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.interrupt.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_env_interrupt_device_map(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_env_interrupt_device_map {
    okl4_word_t num_entries;
    okl4_interrupt_soc_descriptor_t entries[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "num_entries" : {'offset': 0},
        "entries" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._num_entries = 0
        self.entries = [None] * 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    def get_size(self):
        """Return the size in bytes of the type."""
        return 8 + ((len(self.entries) - 1) * 4)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "env_interrupt_device_map"
    _type_libokl4_name = "env_interrupt_device_map"

    def _set_num_entries(self, num_entries_):
        """Set num_entries and flag this type as modified"""
        self._num_entries =  num_entries_
        self._dirty = True

    num_entries = property(lambda self: self._num_entries, _set_num_entries)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.num_entries, 4, addr + 0)
        for i, item in enumerate(self.entries):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.num_entries,
                name + '.num_entries', False)
        string += self._field_to_string(self.entries,
                name + '.entries', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.num_entries))
        for item in self.entries:
            data.append(self._pack(4, item))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.entries):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kswitch(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kswitch {
    struct okl4_kdomain domain;
    okl4_kcap_t kcap;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "domain" : {'offset': 0},
        "kcap" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.domain = OKL4_kdomain(this_addr, self)
        self._kcap = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.domain.set_address(address + 0)

    _type_size = 8
    _type_alignment = 4
    _type_name = "kswitch"
    _type_libokl4_name = "kswitch"

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.domain.patch(image, symbol, addr + 0)
        image.patch(symbol, self.kcap, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.domain,
                name + '.domain', False)
        string += self._field_to_string(self.kcap,
                name + '.kcap', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.domain.to_data())
        data.append(self._pack(4, self.kcap))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.domain.get_phys_relocs(base_offset + self.get_offset_of('domain')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.domain.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_clock(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 0
    _type_alignment = 1
    _type_name = "clock"
    _type_libokl4_name = "clock"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        pass

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'


        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []



        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_condlock(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_condlock {
    struct okl4_mutex mutex;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "mutex" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.mutex = OKL4_okl4_mutex(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.mutex.set_address(address + 0)

    _type_size = 20
    _type_alignment = 4
    _type_name = "condlock"
    _type_libokl4_name = "condlock"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.mutex.patch(image, symbol, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.mutex,
                name + '.mutex', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.mutex.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.mutex.get_phys_relocs(base_offset + self.get_offset_of('mutex')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.mutex.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_condvar(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_condvar {
    okl4_atomic_word_t mutex;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "mutex" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.mutex = OKL4_atomic_word_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.mutex.set_address(address + 0)

    _type_size = 4
    _type_alignment = 4
    _type_name = "condvar"
    _type_libokl4_name = "condvar"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.mutex.patch(image, symbol, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.mutex,
                name + '.mutex', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.mutex.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.mutex.get_phys_relocs(base_offset + self.get_offset_of('mutex')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.mutex.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_okl4_thread(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_thread {
    okl4_error_t exit_status;
    okl4_word_t exit_value;
    struct okl4_kthread kthread;
    struct okl4_schedparam schedparam;
    okl4_word_t stackaddr;
    struct okl4_virtmem_pool *stackpool;
    struct okl4_virtmem_item stackpool_item;
    struct okl4_semaphore wait_semaphore;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "exit_status" : {'offset': 0},
        "exit_value" : {'offset': 4},
        "kthread" : {'offset': 8},
        "schedparam" : {'offset': 68},
        "stackaddr" : {'offset': 76},
        "stackpool" : {'offset': 80},
        "stackpool_item" : {'offset': 84},
        "wait_semaphore" : {'offset': 108},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._exit_status = 0
        self._exit_value = 0

        this_addr = None if address is None else self._address + 8
        self.kthread = OKL4_kthread(this_addr, self)

        this_addr = None if address is None else self._address + 68
        self.schedparam = OKL4_schedparam(this_addr, self)
        self._stackaddr = 0
        self.stackpool = None

        this_addr = None if address is None else self._address + 84
        self.stackpool_item = OKL4_virtmem_item(this_addr, self)

        this_addr = None if address is None else self._address + 108
        self.wait_semaphore = OKL4_okl4_semaphore(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.kthread.set_address(address + 8)
        self.schedparam.set_address(address + 68)
        self.stackpool_item.set_address(address + 84)
        self.wait_semaphore.set_address(address + 108)

    _type_size = 112
    _type_alignment = 4
    _type_name = "okl4_thread"
    _type_libokl4_name = "thread"

    def _set_exit_status(self, exit_status_):
        """Set exit_status and flag this type as modified"""
        self._exit_status =  exit_status_
        self._dirty = True

    exit_status = property(lambda self: self._exit_status, _set_exit_status)

    def _set_exit_value(self, exit_value_):
        """Set exit_value and flag this type as modified"""
        self._exit_value =  exit_value_
        self._dirty = True

    exit_value = property(lambda self: self._exit_value, _set_exit_value)

    def _set_stackaddr(self, stackaddr_):
        """Set stackaddr and flag this type as modified"""
        self._stackaddr =  stackaddr_
        self._dirty = True

    stackaddr = property(lambda self: self._stackaddr, _set_stackaddr)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.exit_status, 4, addr + 0)
        image.patch(symbol, self.exit_value, 4, addr + 4)
        self.kthread.patch(image, symbol, addr + 8)
        self.schedparam.patch(image, symbol, addr + 68)
        image.patch(symbol, self.stackaddr, 4, addr + 76)
        self._pointer_patch(image, symbol, 4, addr + 80, self.stackpool)
        self.stackpool_item.patch(image, symbol, addr + 84)
        self.wait_semaphore.patch(image, symbol, addr + 108)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.exit_status,
                name + '.exit_status', False)
        string += self._field_to_string(self.exit_value,
                name + '.exit_value', False)
        string += self._field_to_string(self.kthread,
                name + '.kthread', False)
        string += self._field_to_string(self.schedparam,
                name + '.schedparam', False)
        string += self._field_to_string(self.stackaddr,
                name + '.stackaddr', False)
        string += self._field_to_string(self.stackpool,
                name + '.stackpool', True)
        string += self._field_to_string(self.stackpool_item,
                name + '.stackpool_item', False)
        string += self._field_to_string(self.wait_semaphore,
                name + '.wait_semaphore', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.exit_status))
        data.append(self._pack(4, self.exit_value))
        data.append(self.kthread.to_data())
        data.append(self.schedparam.to_data())
        data.append(self._pack(4, self.stackaddr))
        self._pointer_to_data(data, 4, self.stackpool)
        data.append(self.stackpool_item.to_data())
        data.append(self.wait_semaphore.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.kthread.get_phys_relocs(base_offset + self.get_offset_of('kthread')))
        relocs.extend(self.schedparam.get_phys_relocs(base_offset + self.get_offset_of('schedparam')))
        relocs.extend(self.stackpool_item.get_phys_relocs(base_offset + self.get_offset_of('stackpool_item')))
        relocs.extend(self.wait_semaphore.get_phys_relocs(base_offset + self.get_offset_of('wait_semaphore')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.kthread.dirty:
            return True
        if self.schedparam.dirty:
            return True
        if self.stackpool is not None:
            return True
        if self.stackpool_item.dirty:
            return True
        if self.wait_semaphore.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_okl4_semaphore(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_semaphore {
    okl4_kcap_t id;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "id" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._id = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "okl4_semaphore"
    _type_libokl4_name = "semaphore"

    def _set_id(self, id_):
        """Set id and flag this type as modified"""
        self._id =  id_
        self._dirty = True

    id = property(lambda self: self._id, _set_id)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.id, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.id,
                name + '.id', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.id))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_file(ElfweaverType):
    """
    Implement a python class that represents the C type:


    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 0
    _type_alignment = 1
    _type_name = "file"
    _type_libokl4_name = "file"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        pass

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'


        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []



        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_memsection_elf_dso(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_memsection_elf_dso {
    struct okl4_memsection super;
    struct okl4_file *file;
    okl4_word_t num_pages;
    okl4_word_t page_index;
    struct okl4_mem_alloc *pages;
    struct okl4_physmem_pagepool *physpool;
    okl4_bool_t physpool_created;
    Elf32_Util util;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "super" : {'offset': 0},
        "file" : {'offset': 60},
        "num_pages" : {'offset': 64},
        "page_index" : {'offset': 68},
        "pages" : {'offset': 72},
        "physpool" : {'offset': 76},
        "physpool_created" : {'offset': 80},
        "util" : {'offset': 84},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.super = OKL4_memsection(this_addr, self)
        self.file = None
        self._num_pages = 0
        self._page_index = 0
        self.pages = None
        self.physpool = None
        self._physpool_created = 0
        self._util = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.super.set_address(address + 0)

    _type_size = 164
    _type_alignment = 4
    _type_name = "memsection_elf_dso"
    _type_libokl4_name = "memsection_elf_dso"

    def _set_num_pages(self, num_pages_):
        """Set num_pages and flag this type as modified"""
        self._num_pages =  num_pages_
        self._dirty = True

    num_pages = property(lambda self: self._num_pages, _set_num_pages)

    def _set_page_index(self, page_index_):
        """Set page_index and flag this type as modified"""
        self._page_index =  page_index_
        self._dirty = True

    page_index = property(lambda self: self._page_index, _set_page_index)

    def _set_physpool_created(self, physpool_created_):
        """Set physpool_created and flag this type as modified"""
        self._physpool_created =  physpool_created_
        self._dirty = True

    physpool_created = property(lambda self: self._physpool_created, _set_physpool_created)

    def _set_util(self, util_):
        """Set util and flag this type as modified"""
        self._util =  util_
        self._dirty = True

    util = property(lambda self: self._util, _set_util)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.super.patch(image, symbol, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 60, self.file)
        image.patch(symbol, self.num_pages, 4, addr + 64)
        image.patch(symbol, self.page_index, 4, addr + 68)
        self._pointer_patch(image, symbol, 4, addr + 72, self.pages)
        self._pointer_patch(image, symbol, 4, addr + 76, self.physpool)
        image.patch(symbol, self.physpool_created, 4, addr + 80)
        image.patch(symbol, self.util, 80, addr + 84)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.super,
                name + '.super', False)
        string += self._field_to_string(self.file,
                name + '.file', True)
        string += self._field_to_string(self.num_pages,
                name + '.num_pages', False)
        string += self._field_to_string(self.page_index,
                name + '.page_index', False)
        string += self._field_to_string(self.pages,
                name + '.pages', True)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.physpool_created,
                name + '.physpool_created', False)
        string += self._field_to_string(self.util,
                name + '.util', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.super.to_data())
        self._pointer_to_data(data, 4, self.file)
        data.append(self._pack(4, self.num_pages))
        data.append(self._pack(4, self.page_index))
        self._pointer_to_data(data, 4, self.pages)
        self._pointer_to_data(data, 4, self.physpool)
        data.append(self._pack(4, self.physpool_created))
        data.append(self._pack(80, self.util))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.super.get_phys_relocs(base_offset + self.get_offset_of('super')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.super.dirty:
            return True
        if self.file is not None:
            return True
        if self.pages is not None:
            return True
        if self.physpool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_mem_alloc(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_mem_alloc {
    struct _okl4_mapping mapping;
    _okl4_mem_alloc_source_t source;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "mapping" : {'offset': 0},
        "source" : {'offset': 52},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.mapping = OKL4_mapping(this_addr, self)
        self._source = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.mapping.set_address(address + 0)

    _type_size = 56
    _type_alignment = 4
    _type_name = "mem_alloc"
    _type_libokl4_name = "mem_alloc"

    def _set_source(self, source_):
        """Set source and flag this type as modified"""
        self._source =  source_
        self._dirty = True

    source = property(lambda self: self._source, _set_source)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.mapping.patch(image, symbol, addr + 0)
        image.patch(symbol, self.source, 4, addr + 52)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.mapping,
                name + '.mapping', False)
        string += self._field_to_string(self.source,
                name + '.source', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.mapping.to_data())
        data.append(self._pack(4, self.source))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.mapping.get_phys_relocs(base_offset + self.get_offset_of('mapping')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.mapping.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_plugin(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_plugin {
    struct _okl4_memsection_elf_dso elf_dso;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "elf_dso" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.elf_dso = OKL4_memsection_elf_dso(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.elf_dso.set_address(address + 0)

    _type_size = 164
    _type_alignment = 4
    _type_name = "plugin"
    _type_libokl4_name = "plugin"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.elf_dso.patch(image, symbol, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.elf_dso,
                name + '.elf_dso', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.elf_dso.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.elf_dso.get_phys_relocs(base_offset + self.get_offset_of('elf_dso')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.elf_dso.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_program(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_program {
    struct okl4_pd pd;
    struct _okl4_memsection_elf_dso elf_dso;
    struct okl4_pd_thread main_thread;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "pd" : {'offset': 0},
        "elf_dso" : {'offset': 128},
        "main_thread" : {'offset': 292},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.pd = OKL4_pd(this_addr, self)

        this_addr = None if address is None else self._address + 128
        self.elf_dso = OKL4_memsection_elf_dso(this_addr, self)

        this_addr = None if address is None else self._address + 292
        self.main_thread = OKL4_pd_thread(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.pd.set_address(address + 0)
        self.elf_dso.set_address(address + 128)
        self.main_thread.set_address(address + 292)

    _type_size = 492
    _type_alignment = 4
    _type_name = "program"
    _type_libokl4_name = "program"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.pd.patch(image, symbol, addr + 0)
        self.elf_dso.patch(image, symbol, addr + 128)
        self.main_thread.patch(image, symbol, addr + 292)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.pd,
                name + '.pd', False)
        string += self._field_to_string(self.elf_dso,
                name + '.elf_dso', False)
        string += self._field_to_string(self.main_thread,
                name + '.main_thread', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.pd.to_data())
        data.append(self.elf_dso.to_data())
        data.append(self.main_thread.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.pd.get_phys_relocs(base_offset + self.get_offset_of('pd')))
        relocs.extend(self.elf_dso.get_phys_relocs(base_offset + self.get_offset_of('elf_dso')))
        relocs.extend(self.main_thread.get_phys_relocs(base_offset + self.get_offset_of('main_thread')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.pd.dirty:
            return True
        if self.elf_dso.dirty:
            return True
        if self.main_thread.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_env_mqs(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_env_mqs {
    okl4_word_t count;
    struct _okl4_env_one_mq elements[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "count" : {'offset': 0},
        "elements" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._count = 0
        if address is None:
            self.elements = [OKL4_env_one_mq(None, self)
                    for i in range(0, 0)]
        else:
            self.elements = [OKL4_env_one_mq(self._address + 4 + i * 88, self)
                    for i in range(0, 0)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        for (i, obj) in enumerate(self.elements):
            obj.set_address(address + 4 + i * 88)

    def get_size(self):
        """Return the size in bytes of the type."""
        return 92 + ((len(self.elements) - 1) * 88)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "env_mqs"
    _type_libokl4_name = "env_mqs"

    def _set_count(self, count_):
        """Set count and flag this type as modified"""
        self._count =  count_
        self._dirty = True

    count = property(lambda self: self._count, _set_count)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.count, 4, addr + 0)
        for i, item in enumerate(self.elements):
            item.patch(image, symbol, addr + i * 88 + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.count,
                name + '.count', False)
        string += self._field_to_string(self.elements,
                name + '.elements', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.count))
        for item in self.elements:
            data.append(item.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.elements):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_env_one_mq(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_env_one_mq {
    okl4_byte_t path[80];
    okl4_kcap_t mq;
    okl4_kcap_t mmu;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "path" : {'offset': 0},
        "mq" : {'offset': 80},
        "mmu" : {'offset': 84},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.path = [None] * 80
        self._mq = 0
        self._mmu = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 88
    _type_alignment = 4
    _type_name = "env_one_mq"
    _type_libokl4_name = "env_one_mq"

    def _set_mq(self, mq_):
        """Set mq and flag this type as modified"""
        self._mq =  mq_
        self._dirty = True

    mq = property(lambda self: self._mq, _set_mq)

    def _set_mmu(self, mmu_):
        """Set mmu and flag this type as modified"""
        self._mmu =  mmu_
        self._dirty = True

    mmu = property(lambda self: self._mmu, _set_mmu)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        for i, item in enumerate(self.path):
            value = 0 if item is None else item
            image.patch(symbol, value, 1, addr + i * 1 + 0)
        image.patch(symbol, self.mq, 4, addr + 80)
        image.patch(symbol, self.mmu, 4, addr + 84)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.path,
                name + '.path', False)
        string += self._field_to_string(self.mq,
                name + '.mq', False)
        string += self._field_to_string(self.mmu,
                name + '.mmu', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        for item in self.path:
            data.append(self._pack(1, item))
        data.append(self._pack(4, self.mq))
        data.append(self._pack(4, self.mmu))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.path):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_kmmu(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kmmu {
    okl4_kcap_t kcap;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "kcap" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._kcap = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "kmmu"
    _type_libokl4_name = "kmmu"

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.kcap, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.kcap,
                name + '.kcap', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.kcap))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_kthread(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_kthread {
    struct okl4_kdomain *domain;
    okl4_word_t exception_badge;
    struct okl4_kthread *exception_handler;
    okl4_word_t exec_mode;
    okl4_kcap_t kcap;
    struct okl4_kmmu *mmucontext;
    okl4_word_t sp;
    struct okl4_virtmem_item tls_item;
    struct okl4_virtmem_pool *tls_pool;
    okl4_word_t tls_tag;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "domain" : {'offset': 0},
        "exception_badge" : {'offset': 4},
        "exception_handler" : {'offset': 8},
        "exec_mode" : {'offset': 12},
        "kcap" : {'offset': 16},
        "mmucontext" : {'offset': 20},
        "sp" : {'offset': 24},
        "tls_item" : {'offset': 28},
        "tls_pool" : {'offset': 52},
        "tls_tag" : {'offset': 56},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.domain = None
        self._exception_badge = 0
        self.exception_handler = None
        self._exec_mode = 0
        self._kcap = 0
        self.mmucontext = None
        self._sp = 0

        this_addr = None if address is None else self._address + 28
        self.tls_item = OKL4_virtmem_item(this_addr, self)
        self.tls_pool = None
        self._tls_tag = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.tls_item.set_address(address + 28)

    _type_size = 60
    _type_alignment = 4
    _type_name = "kthread"
    _type_libokl4_name = "kthread"

    def _set_exception_badge(self, exception_badge_):
        """Set exception_badge and flag this type as modified"""
        self._exception_badge =  exception_badge_
        self._dirty = True

    exception_badge = property(lambda self: self._exception_badge, _set_exception_badge)

    def _set_exec_mode(self, exec_mode_):
        """Set exec_mode and flag this type as modified"""
        self._exec_mode =  exec_mode_
        self._dirty = True

    exec_mode = property(lambda self: self._exec_mode, _set_exec_mode)

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def _set_sp(self, sp_):
        """Set sp and flag this type as modified"""
        self._sp =  sp_
        self._dirty = True

    sp = property(lambda self: self._sp, _set_sp)

    def _set_tls_tag(self, tls_tag_):
        """Set tls_tag and flag this type as modified"""
        self._tls_tag =  tls_tag_
        self._dirty = True

    tls_tag = property(lambda self: self._tls_tag, _set_tls_tag)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.domain)
        image.patch(symbol, self.exception_badge, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.exception_handler)
        image.patch(symbol, self.exec_mode, 4, addr + 12)
        image.patch(symbol, self.kcap, 4, addr + 16)
        self._pointer_patch(image, symbol, 4, addr + 20, self.mmucontext)
        image.patch(symbol, self.sp, 4, addr + 24)
        self.tls_item.patch(image, symbol, addr + 28)
        self._pointer_patch(image, symbol, 4, addr + 52, self.tls_pool)
        image.patch(symbol, self.tls_tag, 4, addr + 56)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.domain,
                name + '.domain', True)
        string += self._field_to_string(self.exception_badge,
                name + '.exception_badge', False)
        string += self._field_to_string(self.exception_handler,
                name + '.exception_handler', True)
        string += self._field_to_string(self.exec_mode,
                name + '.exec_mode', False)
        string += self._field_to_string(self.kcap,
                name + '.kcap', False)
        string += self._field_to_string(self.mmucontext,
                name + '.mmucontext', True)
        string += self._field_to_string(self.sp,
                name + '.sp', False)
        string += self._field_to_string(self.tls_item,
                name + '.tls_item', False)
        string += self._field_to_string(self.tls_pool,
                name + '.tls_pool', True)
        string += self._field_to_string(self.tls_tag,
                name + '.tls_tag', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.domain)
        data.append(self._pack(4, self.exception_badge))
        self._pointer_to_data(data, 4, self.exception_handler)
        data.append(self._pack(4, self.exec_mode))
        data.append(self._pack(4, self.kcap))
        self._pointer_to_data(data, 4, self.mmucontext)
        data.append(self._pack(4, self.sp))
        data.append(self.tls_item.to_data())
        self._pointer_to_data(data, 4, self.tls_pool)
        data.append(self._pack(4, self.tls_tag))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.tls_item.get_phys_relocs(base_offset + self.get_offset_of('tls_item')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.domain is not None:
            return True
        if self.exception_handler is not None:
            return True
        if self.mmucontext is not None:
            return True
        if self.tls_item.dirty:
            return True
        if self.tls_pool is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_machine_info(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_machine_info {
    okl4_word_t l1_cache_line_size;
    okl4_word_t l2_cache_line_size;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "l1_cache_line_size" : {'offset': 0},
        "l2_cache_line_size" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._l1_cache_line_size = 0
        self._l2_cache_line_size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "machine_info"
    _type_libokl4_name = "machine_info"

    def _set_l1_cache_line_size(self, l1_cache_line_size_):
        """Set l1_cache_line_size and flag this type as modified"""
        self._l1_cache_line_size =  l1_cache_line_size_
        self._dirty = True

    l1_cache_line_size = property(lambda self: self._l1_cache_line_size, _set_l1_cache_line_size)

    def _set_l2_cache_line_size(self, l2_cache_line_size_):
        """Set l2_cache_line_size and flag this type as modified"""
        self._l2_cache_line_size =  l2_cache_line_size_
        self._dirty = True

    l2_cache_line_size = property(lambda self: self._l2_cache_line_size, _set_l2_cache_line_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.l1_cache_line_size, 4, addr + 0)
        image.patch(symbol, self.l2_cache_line_size, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.l1_cache_line_size,
                name + '.l1_cache_line_size', False)
        string += self._field_to_string(self.l2_cache_line_size,
                name + '.l2_cache_line_size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.l1_cache_line_size))
        data.append(self._pack(4, self.l2_cache_line_size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_extension_token(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_extension_token {
    okl4_kcap_t kswitch_kcap;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "kswitch_kcap" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._kswitch_kcap = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "extension_token"
    _type_libokl4_name = "extension_token"

    def _set_kswitch_kcap(self, kswitch_kcap_):
        """Set kswitch_kcap and flag this type as modified"""
        self._kswitch_kcap =  kswitch_kcap_
        self._dirty = True

    kswitch_kcap = property(lambda self: self._kswitch_kcap, _set_kswitch_kcap)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.kswitch_kcap, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.kswitch_kcap,
                name + '.kswitch_kcap', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.kswitch_kcap))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_extension_entry_token(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_extension_entry_token {
    okl4_word_t entry_index;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "entry_index" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._entry_index = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "extension_entry_token"
    _type_libokl4_name = "extension_entry_token"

    def _set_entry_index(self, entry_index_):
        """Set entry_index and flag this type as modified"""
        self._entry_index =  entry_index_
        self._dirty = True

    entry_index = property(lambda self: self._entry_index, _set_entry_index)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.entry_index, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.entry_index,
                name + '.entry_index', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.entry_index))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_tracebuffer(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_tracebuffer {
    okl4_tracebuffer_ref_t grabbed_buffer;
    okl4_word_t grabbed_index;
    struct _okl4_tracebuffer_header *header;
    okl4_kcap_t kcap;
    okl4_tracebuffer_ref_t next_buffer;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "grabbed_buffer" : {'offset': 0},
        "grabbed_index" : {'offset': 4},
        "header" : {'offset': 8},
        "kcap" : {'offset': 12},
        "next_buffer" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._grabbed_buffer = 0
        self._grabbed_index = 0
        self.header = None
        self._kcap = 0
        self._next_buffer = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 20
    _type_alignment = 4
    _type_name = "tracebuffer"
    _type_libokl4_name = "tracebuffer"

    def _set_grabbed_buffer(self, grabbed_buffer_):
        """Set grabbed_buffer and flag this type as modified"""
        self._grabbed_buffer =  grabbed_buffer_
        self._dirty = True

    grabbed_buffer = property(lambda self: self._grabbed_buffer, _set_grabbed_buffer)

    def _set_grabbed_index(self, grabbed_index_):
        """Set grabbed_index and flag this type as modified"""
        self._grabbed_index =  grabbed_index_
        self._dirty = True

    grabbed_index = property(lambda self: self._grabbed_index, _set_grabbed_index)

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def _set_next_buffer(self, next_buffer_):
        """Set next_buffer and flag this type as modified"""
        self._next_buffer =  next_buffer_
        self._dirty = True

    next_buffer = property(lambda self: self._next_buffer, _set_next_buffer)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.grabbed_buffer, 4, addr + 0)
        image.patch(symbol, self.grabbed_index, 4, addr + 4)
        self._pointer_patch(image, symbol, 4, addr + 8, self.header)
        image.patch(symbol, self.kcap, 4, addr + 12)
        image.patch(symbol, self.next_buffer, 4, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.grabbed_buffer,
                name + '.grabbed_buffer', False)
        string += self._field_to_string(self.grabbed_index,
                name + '.grabbed_index', False)
        string += self._field_to_string(self.header,
                name + '.header', True)
        string += self._field_to_string(self.kcap,
                name + '.kcap', False)
        string += self._field_to_string(self.next_buffer,
                name + '.next_buffer', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.grabbed_buffer))
        data.append(self._pack(4, self.grabbed_index))
        self._pointer_to_data(data, 4, self.header)
        data.append(self._pack(4, self.kcap))
        data.append(self._pack(4, self.next_buffer))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.header is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_elffile(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_elffile {
    okl4_word_t num_segments;
    struct okl4_elfsegment segments[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "num_segments" : {'offset': 0},
        "segments" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._num_segments = 0
        if address is None:
            self.segments = [OKL4_elfsegment(None, self)
                    for i in range(0, 0)]
        else:
            self.segments = [OKL4_elfsegment(self._address + 4 + i * 8, self)
                    for i in range(0, 0)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        for (i, obj) in enumerate(self.segments):
            obj.set_address(address + 4 + i * 8)

    def get_size(self):
        """Return the size in bytes of the type."""
        return 12 + ((len(self.segments) - 1) * 8)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "elffile"
    _type_libokl4_name = "elffile"

    def _set_num_segments(self, num_segments_):
        """Set num_segments and flag this type as modified"""
        self._num_segments =  num_segments_
        self._dirty = True

    num_segments = property(lambda self: self._num_segments, _set_num_segments)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.num_segments, 4, addr + 0)
        for i, item in enumerate(self.segments):
            item.patch(image, symbol, addr + i * 8 + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.num_segments,
                name + '.num_segments', False)
        string += self._field_to_string(self.segments,
                name + '.segments', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.num_segments))
        for item in self.segments:
            data.append(item.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.segments):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_buffer_area(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_buffer_area {
    okl4_word_t base;
    struct okl4_kmmu *kmmu;
    okl4_word_t max_buffer_size;
    struct okl4_realm *realm;
    okl4_word_t size;
    struct okl4_memsection_contiguous super;
    okl4_bool_t use_allocation;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "base" : {'offset': 0},
        "kmmu" : {'offset': 4},
        "max_buffer_size" : {'offset': 8},
        "realm" : {'offset': 12},
        "size" : {'offset': 16},
        "super" : {'offset': 20},
        "use_allocation" : {'offset': 148},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._base = 0
        self.kmmu = None
        self._max_buffer_size = 0
        self.realm = None
        self._size = 0

        this_addr = None if address is None else self._address + 20
        self.super = OKL4_memsection_contiguous(this_addr, self)
        self._use_allocation = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.super.set_address(address + 20)

    _type_size = 152
    _type_alignment = 4
    _type_name = "buffer_area"
    _type_libokl4_name = "buffer_area"

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_max_buffer_size(self, max_buffer_size_):
        """Set max_buffer_size and flag this type as modified"""
        self._max_buffer_size =  max_buffer_size_
        self._dirty = True

    max_buffer_size = property(lambda self: self._max_buffer_size, _set_max_buffer_size)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_use_allocation(self, use_allocation_):
        """Set use_allocation and flag this type as modified"""
        self._use_allocation =  use_allocation_
        self._dirty = True

    use_allocation = property(lambda self: self._use_allocation, _set_use_allocation)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.base, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.kmmu)
        image.patch(symbol, self.max_buffer_size, 4, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 12, self.realm)
        image.patch(symbol, self.size, 4, addr + 16)
        self.super.patch(image, symbol, addr + 20)
        image.patch(symbol, self.use_allocation, 4, addr + 148)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.kmmu,
                name + '.kmmu', True)
        string += self._field_to_string(self.max_buffer_size,
                name + '.max_buffer_size', False)
        string += self._field_to_string(self.realm,
                name + '.realm', True)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.super,
                name + '.super', False)
        string += self._field_to_string(self.use_allocation,
                name + '.use_allocation', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.base))
        self._pointer_to_data(data, 4, self.kmmu)
        data.append(self._pack(4, self.max_buffer_size))
        self._pointer_to_data(data, 4, self.realm)
        data.append(self._pack(4, self.size))
        data.append(self.super.to_data())
        data.append(self._pack(4, self.use_allocation))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.super.get_phys_relocs(base_offset + self.get_offset_of('super')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.kmmu is not None:
            return True
        if self.realm is not None:
            return True
        if self.super.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_elfsegment(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_elfsegment {
    okl4_word_t flags;
    struct okl4_memsection_contiguous *memsection;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "flags" : {'offset': 0},
        "memsection" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._flags = 0
        self.memsection = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "elfsegment"
    _type_libokl4_name = "elfsegment"

    def _set_flags(self, flags_):
        """Set flags and flag this type as modified"""
        self._flags =  flags_
        self._dirty = True

    flags = property(lambda self: self._flags, _set_flags)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.flags, 4, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 4, self.memsection)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.flags,
                name + '.flags', False)
        string += self._field_to_string(self.memsection,
                name + '.memsection', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.flags))
        self._pointer_to_data(data, 4, self.memsection)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.memsection is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_okl4_message_queue(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_message_queue {
    okl4_kcap_t kcap;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "kcap" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._kcap = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "okl4_message_queue"
    _type_libokl4_name = "message_queue"

    def _set_kcap(self, kcap_):
        """Set kcap and flag this type as modified"""
        self._kcap =  kcap_
        self._dirty = True

    kcap = property(lambda self: self._kcap, _set_kcap)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.kcap, 4, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.kcap,
                name + '.kcap', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.kcap))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_message_payload(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_message_payload {
    struct _okl4_message_payload_capability capability;
    struct _okl4_message_payload_inline inline_words;
    struct _okl4_message_payload_inplace inplace;
    okl4_message_payload_type_t receive_type;
    okl4_message_payload_type_t received_type;
    okl4_message_payload_type_t send_type;
    struct _okl4_message_payload_standard standard;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "capability" : {'offset': 0},
        "inline_words" : {'offset': 8},
        "inplace" : {'offset': 12},
        "receive_type" : {'offset': 24},
        "received_type" : {'offset': 28},
        "send_type" : {'offset': 32},
        "standard" : {'offset': 36},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.capability = OKL4_message_payload_capability(this_addr, self)

        this_addr = None if address is None else self._address + 8
        self.inline_words = OKL4_message_payload_inline(this_addr, self)

        this_addr = None if address is None else self._address + 12
        self.inplace = OKL4_message_payload_inplace(this_addr, self)
        self._receive_type = 0
        self._received_type = 0
        self._send_type = 0

        this_addr = None if address is None else self._address + 36
        self.standard = OKL4_message_payload_standard(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.capability.set_address(address + 0)
        self.inline_words.set_address(address + 8)
        self.inplace.set_address(address + 12)
        self.standard.set_address(address + 36)

    _type_size = 48
    _type_alignment = 4
    _type_name = "message_payload"
    _type_libokl4_name = "message_payload"

    def _set_receive_type(self, receive_type_):
        """Set receive_type and flag this type as modified"""
        self._receive_type =  receive_type_
        self._dirty = True

    receive_type = property(lambda self: self._receive_type, _set_receive_type)

    def _set_received_type(self, received_type_):
        """Set received_type and flag this type as modified"""
        self._received_type =  received_type_
        self._dirty = True

    received_type = property(lambda self: self._received_type, _set_received_type)

    def _set_send_type(self, send_type_):
        """Set send_type and flag this type as modified"""
        self._send_type =  send_type_
        self._dirty = True

    send_type = property(lambda self: self._send_type, _set_send_type)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.capability.patch(image, symbol, addr + 0)
        self.inline_words.patch(image, symbol, addr + 8)
        self.inplace.patch(image, symbol, addr + 12)
        image.patch(symbol, self.receive_type, 4, addr + 24)
        image.patch(symbol, self.received_type, 4, addr + 28)
        image.patch(symbol, self.send_type, 4, addr + 32)
        self.standard.patch(image, symbol, addr + 36)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.capability,
                name + '.capability', False)
        string += self._field_to_string(self.inline_words,
                name + '.inline_words', False)
        string += self._field_to_string(self.inplace,
                name + '.inplace', False)
        string += self._field_to_string(self.receive_type,
                name + '.receive_type', False)
        string += self._field_to_string(self.received_type,
                name + '.received_type', False)
        string += self._field_to_string(self.send_type,
                name + '.send_type', False)
        string += self._field_to_string(self.standard,
                name + '.standard', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.capability.to_data())
        data.append(self.inline_words.to_data())
        data.append(self.inplace.to_data())
        data.append(self._pack(4, self.receive_type))
        data.append(self._pack(4, self.received_type))
        data.append(self._pack(4, self.send_type))
        data.append(self.standard.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.capability.get_phys_relocs(base_offset + self.get_offset_of('capability')))
        relocs.extend(self.inline_words.get_phys_relocs(base_offset + self.get_offset_of('inline_words')))
        relocs.extend(self.inplace.get_phys_relocs(base_offset + self.get_offset_of('inplace')))
        relocs.extend(self.standard.get_phys_relocs(base_offset + self.get_offset_of('standard')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.capability.dirty:
            return True
        if self.inline_words.dirty:
            return True
        if self.inplace.dirty:
            return True
        if self.standard.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_memsection_paged(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memsection_paged {
    struct okl4_memsection parent;
    okl4_word_t num_pages;
    okl4_word_t page_size;
    struct okl4_physmem_pagepool *physpool;
    struct okl4_memsection *super;
    struct _okl4_physmem_alloc pages[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "parent" : {'offset': 0},
        "num_pages" : {'offset': 60},
        "page_size" : {'offset': 64},
        "physpool" : {'offset': 68},
        "super" : {'offset': 72},
        "pages" : {'offset': 76},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.parent = OKL4_memsection(this_addr, self)
        self._num_pages = 0
        self._page_size = 0
        self.physpool = None
        self.super = None
        if address is None:
            self.pages = [OKL4_physmem_alloc(None, self)
                    for i in range(0, 0)]
        else:
            self.pages = [OKL4_physmem_alloc(self._address + 76 + i * 48, self)
                    for i in range(0, 0)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.parent.set_address(address + 0)
        for (i, obj) in enumerate(self.pages):
            obj.set_address(address + 76 + i * 48)

    def get_size(self):
        """Return the size in bytes of the type."""
        return 124 + ((len(self.pages) - 1) * 48)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "memsection_paged"
    _type_libokl4_name = "memsection_paged"

    def _set_num_pages(self, num_pages_):
        """Set num_pages and flag this type as modified"""
        self._num_pages =  num_pages_
        self._dirty = True

    num_pages = property(lambda self: self._num_pages, _set_num_pages)

    def _set_page_size(self, page_size_):
        """Set page_size and flag this type as modified"""
        self._page_size =  page_size_
        self._dirty = True

    page_size = property(lambda self: self._page_size, _set_page_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.parent.patch(image, symbol, addr + 0)
        image.patch(symbol, self.num_pages, 4, addr + 60)
        image.patch(symbol, self.page_size, 4, addr + 64)
        self._pointer_patch(image, symbol, 4, addr + 68, self.physpool)
        self._pointer_patch(image, symbol, 4, addr + 72, self.super)
        for i, item in enumerate(self.pages):
            item.patch(image, symbol, addr + i * 48 + 76)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.parent,
                name + '.parent', False)
        string += self._field_to_string(self.num_pages,
                name + '.num_pages', False)
        string += self._field_to_string(self.page_size,
                name + '.page_size', False)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.super,
                name + '.super', True)
        string += self._field_to_string(self.pages,
                name + '.pages', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.parent.to_data())
        data.append(self._pack(4, self.num_pages))
        data.append(self._pack(4, self.page_size))
        self._pointer_to_data(data, 4, self.physpool)
        self._pointer_to_data(data, 4, self.super)
        for item in self.pages:
            data.append(item.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.parent.get_phys_relocs(base_offset + self.get_offset_of('parent')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.parent.dirty:
            return True
        if self.physpool is not None:
            return True
        if self.super is not None:
            return True
        if self._array_dirty_test(self.pages):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_mapping(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_mapping {
    struct _okl4_mapping_attributes attributes;
    struct okl4_physmem_item phys;
    okl4_word_t size;
    okl4_word_t virt;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "attributes" : {'offset': 0},
        "phys" : {'offset': 8},
        "size" : {'offset': 44},
        "virt" : {'offset': 48},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.attributes = OKL4_mapping_attributes(this_addr, self)

        this_addr = None if address is None else self._address + 8
        self.phys = OKL4_physmem_item(this_addr, self)
        self._size = 0
        self._virt = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.attributes.set_address(address + 0)
        self.phys.set_address(address + 8)

    _type_size = 52
    _type_alignment = 4
    _type_name = "mapping"
    _type_libokl4_name = "mapping"

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_virt(self, virt_):
        """Set virt and flag this type as modified"""
        self._virt =  virt_
        self._dirty = True

    virt = property(lambda self: self._virt, _set_virt)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.attributes.patch(image, symbol, addr + 0)
        self.phys.patch(image, symbol, addr + 8)
        image.patch(symbol, self.size, 4, addr + 44)
        image.patch(symbol, self.virt, 4, addr + 48)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.attributes,
                name + '.attributes', False)
        string += self._field_to_string(self.phys,
                name + '.phys', False)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.virt,
                name + '.virt', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.attributes.to_data())
        data.append(self.phys.to_data())
        data.append(self._pack(4, self.size))
        data.append(self._pack(4, self.virt))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.attributes.get_phys_relocs(base_offset + self.get_offset_of('attributes')))
        relocs.extend(self.phys.get_phys_relocs(base_offset + self.get_offset_of('phys')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.attributes.dirty:
            return True
        if self.phys.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_memsection_contiguous(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memsection_contiguous {
    struct okl4_memsection parent;
    struct _okl4_mapping mapping;
    struct okl4_physmem_segpool *physpool;
    struct okl4_memsection *super;
    okl4_bool_t user_map;
    okl4_bool_t user_physmem_item;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "parent" : {'offset': 0},
        "mapping" : {'offset': 60},
        "physpool" : {'offset': 112},
        "super" : {'offset': 116},
        "user_map" : {'offset': 120},
        "user_physmem_item" : {'offset': 124},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.parent = OKL4_memsection(this_addr, self)

        this_addr = None if address is None else self._address + 60
        self.mapping = OKL4_mapping(this_addr, self)
        self.physpool = None
        self.super = None
        self._user_map = 0
        self._user_physmem_item = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.parent.set_address(address + 0)
        self.mapping.set_address(address + 60)

    _type_size = 128
    _type_alignment = 4
    _type_name = "memsection_contiguous"
    _type_libokl4_name = "memsection_contiguous"

    def _set_user_map(self, user_map_):
        """Set user_map and flag this type as modified"""
        self._user_map =  user_map_
        self._dirty = True

    user_map = property(lambda self: self._user_map, _set_user_map)

    def _set_user_physmem_item(self, user_physmem_item_):
        """Set user_physmem_item and flag this type as modified"""
        self._user_physmem_item =  user_physmem_item_
        self._dirty = True

    user_physmem_item = property(lambda self: self._user_physmem_item, _set_user_physmem_item)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.parent.patch(image, symbol, addr + 0)
        self.mapping.patch(image, symbol, addr + 60)
        self._pointer_patch(image, symbol, 4, addr + 112, self.physpool)
        self._pointer_patch(image, symbol, 4, addr + 116, self.super)
        image.patch(symbol, self.user_map, 4, addr + 120)
        image.patch(symbol, self.user_physmem_item, 4, addr + 124)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.parent,
                name + '.parent', False)
        string += self._field_to_string(self.mapping,
                name + '.mapping', False)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.super,
                name + '.super', True)
        string += self._field_to_string(self.user_map,
                name + '.user_map', False)
        string += self._field_to_string(self.user_physmem_item,
                name + '.user_physmem_item', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.parent.to_data())
        data.append(self.mapping.to_data())
        self._pointer_to_data(data, 4, self.physpool)
        self._pointer_to_data(data, 4, self.super)
        data.append(self._pack(4, self.user_map))
        data.append(self._pack(4, self.user_physmem_item))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.parent.get_phys_relocs(base_offset + self.get_offset_of('parent')))
        relocs.extend(self.mapping.get_phys_relocs(base_offset + self.get_offset_of('mapping')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.parent.dirty:
            return True
        if self.mapping.dirty:
            return True
        if self.physpool is not None:
            return True
        if self.super is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_memsection_fragmented(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_memsection_fragmented {
    struct okl4_memsection parent;
    okl4_word_t max_fragments;
    okl4_word_t num_fragments;
    struct okl4_physmem_segpool *physpool;
    struct okl4_memsection *super;
    struct _okl4_mapping fragments[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "parent" : {'offset': 0},
        "max_fragments" : {'offset': 60},
        "num_fragments" : {'offset': 64},
        "physpool" : {'offset': 68},
        "super" : {'offset': 72},
        "fragments" : {'offset': 76},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.parent = OKL4_memsection(this_addr, self)
        self._max_fragments = 0
        self._num_fragments = 0
        self.physpool = None
        self.super = None
        if address is None:
            self.fragments = [OKL4_mapping(None, self)
                    for i in range(0, 0)]
        else:
            self.fragments = [OKL4_mapping(self._address + 76 + i * 52, self)
                    for i in range(0, 0)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.parent.set_address(address + 0)
        for (i, obj) in enumerate(self.fragments):
            obj.set_address(address + 76 + i * 52)

    def get_size(self):
        """Return the size in bytes of the type."""
        return 128 + ((len(self.fragments) - 1) * 52)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "memsection_fragmented"
    _type_libokl4_name = "memsection_fragmented"

    def _set_max_fragments(self, max_fragments_):
        """Set max_fragments and flag this type as modified"""
        self._max_fragments =  max_fragments_
        self._dirty = True

    max_fragments = property(lambda self: self._max_fragments, _set_max_fragments)

    def _set_num_fragments(self, num_fragments_):
        """Set num_fragments and flag this type as modified"""
        self._num_fragments =  num_fragments_
        self._dirty = True

    num_fragments = property(lambda self: self._num_fragments, _set_num_fragments)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.parent.patch(image, symbol, addr + 0)
        image.patch(symbol, self.max_fragments, 4, addr + 60)
        image.patch(symbol, self.num_fragments, 4, addr + 64)
        self._pointer_patch(image, symbol, 4, addr + 68, self.physpool)
        self._pointer_patch(image, symbol, 4, addr + 72, self.super)
        for i, item in enumerate(self.fragments):
            item.patch(image, symbol, addr + i * 52 + 76)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.parent,
                name + '.parent', False)
        string += self._field_to_string(self.max_fragments,
                name + '.max_fragments', False)
        string += self._field_to_string(self.num_fragments,
                name + '.num_fragments', False)
        string += self._field_to_string(self.physpool,
                name + '.physpool', True)
        string += self._field_to_string(self.super,
                name + '.super', True)
        string += self._field_to_string(self.fragments,
                name + '.fragments', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.parent.to_data())
        data.append(self._pack(4, self.max_fragments))
        data.append(self._pack(4, self.num_fragments))
        self._pointer_to_data(data, 4, self.physpool)
        self._pointer_to_data(data, 4, self.super)
        for item in self.fragments:
            data.append(item.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.parent.get_phys_relocs(base_offset + self.get_offset_of('parent')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.parent.dirty:
            return True
        if self.physpool is not None:
            return True
        if self.super is not None:
            return True
        if self._array_dirty_test(self.fragments):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_mapping_attributes(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_mapping_attributes {
    okl4_word_t cache_attributes;
    okl4_word_t permissions;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "cache_attributes" : {'offset': 0},
        "permissions" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._cache_attributes = 0
        self._permissions = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "mapping_attributes"
    _type_libokl4_name = "mapping_attributes"

    def _set_cache_attributes(self, cache_attributes_):
        """Set cache_attributes and flag this type as modified"""
        self._cache_attributes =  cache_attributes_
        self._dirty = True

    cache_attributes = property(lambda self: self._cache_attributes, _set_cache_attributes)

    def _set_permissions(self, permissions_):
        """Set permissions and flag this type as modified"""
        self._permissions =  permissions_
        self._dirty = True

    permissions = property(lambda self: self._permissions, _set_permissions)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.cache_attributes, 4, addr + 0)
        image.patch(symbol, self.permissions, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.cache_attributes,
                name + '.cache_attributes', False)
        string += self._field_to_string(self.permissions,
                name + '.permissions', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.cache_attributes))
        data.append(self._pack(4, self.permissions))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_okl4_mutex(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_mutex {
    okl4_word_t count;
    okl4_hybrid_user_status_t hybrid_user_status;
    okl4_kcap_t id;
    okl4_word_t is_counted;
    okl4_word_t is_hybrid;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "count" : {'offset': 0},
        "hybrid_user_status" : {'offset': 4},
        "id" : {'offset': 8},
        "is_counted" : {'offset': 12},
        "is_hybrid" : {'offset': 16},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._count = 0
        self._hybrid_user_status = 0
        self._id = 0
        self._is_counted = 0
        self._is_hybrid = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 20
    _type_alignment = 4
    _type_name = "okl4_mutex"
    _type_libokl4_name = "mutex"

    def _set_count(self, count_):
        """Set count and flag this type as modified"""
        self._count =  count_
        self._dirty = True

    count = property(lambda self: self._count, _set_count)

    def _set_hybrid_user_status(self, hybrid_user_status_):
        """Set hybrid_user_status and flag this type as modified"""
        self._hybrid_user_status =  hybrid_user_status_
        self._dirty = True

    hybrid_user_status = property(lambda self: self._hybrid_user_status, _set_hybrid_user_status)

    def _set_id(self, id_):
        """Set id and flag this type as modified"""
        self._id =  id_
        self._dirty = True

    id = property(lambda self: self._id, _set_id)

    def _set_is_counted(self, is_counted_):
        """Set is_counted and flag this type as modified"""
        self._is_counted =  is_counted_
        self._dirty = True

    is_counted = property(lambda self: self._is_counted, _set_is_counted)

    def _set_is_hybrid(self, is_hybrid_):
        """Set is_hybrid and flag this type as modified"""
        self._is_hybrid =  is_hybrid_
        self._dirty = True

    is_hybrid = property(lambda self: self._is_hybrid, _set_is_hybrid)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.count, 4, addr + 0)
        image.patch(symbol, self.hybrid_user_status, 4, addr + 4)
        image.patch(symbol, self.id, 4, addr + 8)
        image.patch(symbol, self.is_counted, 4, addr + 12)
        image.patch(symbol, self.is_hybrid, 4, addr + 16)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.count,
                name + '.count', False)
        string += self._field_to_string(self.hybrid_user_status,
                name + '.hybrid_user_status', False)
        string += self._field_to_string(self.id,
                name + '.id', False)
        string += self._field_to_string(self.is_counted,
                name + '.is_counted', False)
        string += self._field_to_string(self.is_hybrid,
                name + '.is_hybrid', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.count))
        data.append(self._pack(4, self.hybrid_user_status))
        data.append(self._pack(4, self.id))
        data.append(self._pack(4, self.is_counted))
        data.append(self._pack(4, self.is_hybrid))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_env_segment_table(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_env_segment_table {
    okl4_word_t num_segments;
    struct okl4_env_segment segments[1];
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "num_segments" : {'offset': 0},
        "segments" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._num_segments = 0
        if address is None:
            self.segments = [OKL4_env_segment(None, self)
                    for i in range(0, 0)]
        else:
            self.segments = [OKL4_env_segment(self._address + 4 + i * 24, self)
                    for i in range(0, 0)]

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        for (i, obj) in enumerate(self.segments):
            obj.set_address(address + 4 + i * 24)

    def get_size(self):
        """Return the size in bytes of the type."""
        return 28 + ((len(self.segments) - 1) * 24)

    _type_size = property(get_size)
    _type_alignment = 4
    _type_name = "env_segment_table"
    _type_libokl4_name = "env_segment_table"

    def _set_num_segments(self, num_segments_):
        """Set num_segments and flag this type as modified"""
        self._num_segments =  num_segments_
        self._dirty = True

    num_segments = property(lambda self: self._num_segments, _set_num_segments)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.num_segments, 4, addr + 0)
        for i, item in enumerate(self.segments):
            item.patch(image, symbol, addr + i * 24 + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.num_segments,
                name + '.num_segments', False)
        string += self._field_to_string(self.segments,
                name + '.segments', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.num_segments))
        for item in self.segments:
            data.append(item.to_data())

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self._array_dirty_test(self.segments):
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_realm(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_realm {
    struct _okl4_address_space *address_space;
    struct okl4_memsection *alloc;
    okl4_word_t attached_pds_R[3];
    okl4_word_t attached_pds_W[3];
    okl4_word_t attached_pds_X[3];
    struct okl4_memsection *memsections;
    struct okl4_realm *next_realm;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "address_space" : {'offset': 0},
        "alloc" : {'offset': 4},
        "attached_pds_R" : {'offset': 8},
        "attached_pds_W" : {'offset': 20},
        "attached_pds_X" : {'offset': 32},
        "memsections" : {'offset': 44},
        "next_realm" : {'offset': 48},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.address_space = None
        self.alloc = None
        self.attached_pds_R = [None] * 3
        self.attached_pds_W = [None] * 3
        self.attached_pds_X = [None] * 3
        self.memsections = None
        self.next_realm = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 52
    _type_alignment = 4
    _type_name = "realm"
    _type_libokl4_name = "realm"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.address_space)
        self._pointer_patch(image, symbol, 4, addr + 4, self.alloc)
        for i, item in enumerate(self.attached_pds_R):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 8)
        for i, item in enumerate(self.attached_pds_W):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 20)
        for i, item in enumerate(self.attached_pds_X):
            value = 0 if item is None else item
            image.patch(symbol, value, 4, addr + i * 4 + 32)
        self._pointer_patch(image, symbol, 4, addr + 44, self.memsections)
        self._pointer_patch(image, symbol, 4, addr + 48, self.next_realm)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.address_space,
                name + '.address_space', True)
        string += self._field_to_string(self.alloc,
                name + '.alloc', True)
        string += self._field_to_string(self.attached_pds_R,
                name + '.attached_pds_R', False)
        string += self._field_to_string(self.attached_pds_W,
                name + '.attached_pds_W', False)
        string += self._field_to_string(self.attached_pds_X,
                name + '.attached_pds_X', False)
        string += self._field_to_string(self.memsections,
                name + '.memsections', True)
        string += self._field_to_string(self.next_realm,
                name + '.next_realm', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.address_space)
        self._pointer_to_data(data, 4, self.alloc)
        for item in self.attached_pds_R:
            data.append(self._pack(4, item))
        for item in self.attached_pds_W:
            data.append(self._pack(4, item))
        for item in self.attached_pds_X:
            data.append(self._pack(4, item))
        self._pointer_to_data(data, 4, self.memsections)
        self._pointer_to_data(data, 4, self.next_realm)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.address_space is not None:
            return True
        if self.alloc is not None:
            return True
        if self._array_dirty_test(self.attached_pds_R):
            return True
        if self._array_dirty_test(self.attached_pds_W):
            return True
        if self._array_dirty_test(self.attached_pds_X):
            return True
        if self.memsections is not None:
            return True
        if self.next_realm is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_pd_thread(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_pd_thread {
    struct okl4_kthread obj;
    okl4_word_t flags;
    struct okl4_memsection_contiguous stack_ms;
    _okl4_list_entry_t entry;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "obj" : {'offset': 0},
        "flags" : {'offset': 60},
        "stack_ms" : {'offset': 64},
        "entry" : {'offset': 192},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.obj = OKL4_kthread(this_addr, self)
        self._flags = 0

        this_addr = None if address is None else self._address + 64
        self.stack_ms = OKL4_memsection_contiguous(this_addr, self)

        this_addr = None if address is None else self._address + 192
        self.entry = OKL4_list_entry_t(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.obj.set_address(address + 0)
        self.stack_ms.set_address(address + 64)
        self.entry.set_address(address + 192)

    _type_size = 200
    _type_alignment = 4
    _type_name = "pd_thread"
    _type_libokl4_name = "pd_thread"

    def _set_flags(self, flags_):
        """Set flags and flag this type as modified"""
        self._flags =  flags_
        self._dirty = True

    flags = property(lambda self: self._flags, _set_flags)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.obj.patch(image, symbol, addr + 0)
        image.patch(symbol, self.flags, 4, addr + 60)
        self.stack_ms.patch(image, symbol, addr + 64)
        self.entry.patch(image, symbol, addr + 192)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.obj,
                name + '.obj', False)
        string += self._field_to_string(self.flags,
                name + '.flags', False)
        string += self._field_to_string(self.stack_ms,
                name + '.stack_ms', False)
        string += self._field_to_string(self.entry,
                name + '.entry', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.obj.to_data())
        data.append(self._pack(4, self.flags))
        data.append(self.stack_ms.to_data())
        data.append(self.entry.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.obj.get_phys_relocs(base_offset + self.get_offset_of('obj')))
        relocs.extend(self.stack_ms.get_phys_relocs(base_offset + self.get_offset_of('stack_ms')))
        relocs.extend(self.entry.get_phys_relocs(base_offset + self.get_offset_of('entry')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.obj.dirty:
            return True
        if self.stack_ms.dirty:
            return True
        if self.entry.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_physmem_segpool(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_physmem_segpool {
    struct okl4_range_allocator allocator;
    okl4_word_t pagebits;
    struct okl4_range_allocator *parent;
    struct okl4_physmem_item phys;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "allocator" : {'offset': 0},
        "pagebits" : {'offset': 32},
        "parent" : {'offset': 36},
        "phys" : {'offset': 40},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.allocator = OKL4_range_allocator(this_addr, self)
        self._pagebits = 0
        self.parent = None

        this_addr = None if address is None else self._address + 40
        self.phys = OKL4_physmem_item(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.allocator.set_address(address + 0)
        self.phys.set_address(address + 40)

    _type_size = 76
    _type_alignment = 4
    _type_name = "physmem_segpool"
    _type_libokl4_name = "physmem_segpool"

    def _set_pagebits(self, pagebits_):
        """Set pagebits and flag this type as modified"""
        self._pagebits =  pagebits_
        self._dirty = True

    pagebits = property(lambda self: self._pagebits, _set_pagebits)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.allocator.patch(image, symbol, addr + 0)
        image.patch(symbol, self.pagebits, 4, addr + 32)
        self._pointer_patch(image, symbol, 4, addr + 36, self.parent)
        self.phys.patch(image, symbol, addr + 40)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.allocator,
                name + '.allocator', False)
        string += self._field_to_string(self.pagebits,
                name + '.pagebits', False)
        string += self._field_to_string(self.parent,
                name + '.parent', True)
        string += self._field_to_string(self.phys,
                name + '.phys', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.allocator.to_data())
        data.append(self._pack(4, self.pagebits))
        self._pointer_to_data(data, 4, self.parent)
        data.append(self.phys.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.allocator.get_phys_relocs(base_offset + self.get_offset_of('allocator')))
        relocs.extend(self.phys.get_phys_relocs(base_offset + self.get_offset_of('phys')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.allocator.dirty:
            return True
        if self.parent is not None:
            return True
        if self.phys.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_physmem_pagepool(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_physmem_pagepool {
    struct okl4_physmem_item phys;
    okl4_word_t pagebits;
    struct okl4_range_allocator *parent;
    struct okl4_bitmap_allocator allocator;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "phys" : {'offset': 0},
        "pagebits" : {'offset': 36},
        "parent" : {'offset': 40},
        "allocator" : {'offset': 44},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.phys = OKL4_physmem_item(this_addr, self)
        self._pagebits = 0
        self.parent = None

        this_addr = None if address is None else self._address + 44
        self.allocator = OKL4_bitmap_allocator(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.phys.set_address(address + 0)
        self.allocator.set_address(address + 44)

    _type_size = 60
    _type_alignment = 4
    _type_name = "physmem_pagepool"
    _type_libokl4_name = "physmem_pagepool"

    def _set_pagebits(self, pagebits_):
        """Set pagebits and flag this type as modified"""
        self._pagebits =  pagebits_
        self._dirty = True

    pagebits = property(lambda self: self._pagebits, _set_pagebits)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.phys.patch(image, symbol, addr + 0)
        image.patch(symbol, self.pagebits, 4, addr + 36)
        self._pointer_patch(image, symbol, 4, addr + 40, self.parent)
        self.allocator.patch(image, symbol, addr + 44)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.phys,
                name + '.phys', False)
        string += self._field_to_string(self.pagebits,
                name + '.pagebits', False)
        string += self._field_to_string(self.parent,
                name + '.parent', True)
        string += self._field_to_string(self.allocator,
                name + '.allocator', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.phys.to_data())
        data.append(self._pack(4, self.pagebits))
        self._pointer_to_data(data, 4, self.parent)
        data.append(self.allocator.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.phys.get_phys_relocs(base_offset + self.get_offset_of('phys')))
        relocs.extend(self.allocator.get_phys_relocs(base_offset + self.get_offset_of('allocator')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.phys.dirty:
            return True
        if self.parent is not None:
            return True
        if self.allocator.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_range_allocator(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_range_allocator {
    _okl4_list_head_t free_list;
    struct okl4_range_item head;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "free_list" : {'offset': 0},
        "head" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.free_list = OKL4_list_head_t(this_addr, self)

        this_addr = None if address is None else self._address + 8
        self.head = OKL4_range_item(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.free_list.set_address(address + 0)
        self.head.set_address(address + 8)

    _type_size = 32
    _type_alignment = 4
    _type_name = "range_allocator"
    _type_libokl4_name = "range_allocator"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.free_list.patch(image, symbol, addr + 0)
        self.head.patch(image, symbol, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.free_list,
                name + '.free_list', False)
        string += self._field_to_string(self.head,
                name + '.head', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.free_list.to_data())
        data.append(self.head.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.free_list.get_phys_relocs(base_offset + self.get_offset_of('free_list')))
        relocs.extend(self.head.get_phys_relocs(base_offset + self.get_offset_of('head')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.free_list.dirty:
            return True
        if self.head.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_virtmem_item(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_virtmem_item {
    struct okl4_range_item range;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "range" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.range = OKL4_range_item(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.range.set_address(address + 0)

    _type_size = 24
    _type_alignment = 4
    _type_name = "virtmem_item"
    _type_libokl4_name = "virtmem_item"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.range.patch(image, symbol, addr + 0)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.range,
                name + '.range', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.range.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.range.get_phys_relocs(base_offset + self.get_offset_of('range')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.range.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_physmem_item(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_physmem_item {
    okl4_word_t alignment;
    okl4_word_t paddr;
    okl4_word_t segment;
    struct okl4_range_item range;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "alignment" : {'offset': 0},
        "paddr" : {'phys_reloc': 0, 'offset': 4},
        "segment" : {'offset': 8},
        "range" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._alignment = 0
        self._paddr = 0
        self._segment = 0

        this_addr = None if address is None else self._address + 12
        self.range = OKL4_range_item(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.range.set_address(address + 12)

    _type_size = 36
    _type_alignment = 4
    _type_name = "physmem_item"
    _type_libokl4_name = "physmem_item"

    def _set_alignment(self, alignment_):
        """Set alignment and flag this type as modified"""
        self._alignment =  alignment_
        self._dirty = True

    alignment = property(lambda self: self._alignment, _set_alignment)

    def _set_paddr(self, paddr_):
        """Set paddr and flag this type as modified"""
        self._paddr =  paddr_
        self._dirty = True

    paddr = property(lambda self: self._paddr, _set_paddr)

    def _set_segment(self, segment_):
        """Set segment and flag this type as modified"""
        self._segment =  segment_
        self._dirty = True

    segment = property(lambda self: self._segment, _set_segment)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.alignment, 4, addr + 0)
        image.patch(symbol, self.paddr, 4, addr + 4)
        image.patch(symbol, self.segment, 4, addr + 8)
        self.range.patch(image, symbol, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.alignment,
                name + '.alignment', False)
        string += self._field_to_string(self.paddr,
                name + '.paddr', False)
        string += self._field_to_string(self.segment,
                name + '.segment', False)
        string += self._field_to_string(self.range,
                name + '.range', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.alignment))
        data.append(self._pack(4, self.paddr))
        data.append(self._pack(4, self.segment))
        data.append(self.range.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.range.get_phys_relocs(base_offset + self.get_offset_of('range')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.range.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_range_item(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_range_item {
    okl4_word_t base;
    okl4_word_t size;
    _okl4_list_entry_t free_list_entry;
    struct okl4_range_item *next;
    okl4_word_t total_size;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "base" : {'offset': 0},
        "size" : {'offset': 4},
        "free_list_entry" : {'offset': 8},
        "next" : {'offset': 16},
        "total_size" : {'offset': 20},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._base = 0
        self._size = 0

        this_addr = None if address is None else self._address + 8
        self.free_list_entry = OKL4_list_entry_t(this_addr, self)
        self.next = None
        self._total_size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.free_list_entry.set_address(address + 8)

    _type_size = 24
    _type_alignment = 4
    _type_name = "range_item"
    _type_libokl4_name = "range_item"

    def _set_base(self, base_):
        """Set base and flag this type as modified"""
        self._base =  base_
        self._dirty = True

    base = property(lambda self: self._base, _set_base)

    def _set_size(self, size_):
        """Set size and flag this type as modified"""
        self._size =  size_
        self._dirty = True

    size = property(lambda self: self._size, _set_size)

    def _set_total_size(self, total_size_):
        """Set total_size and flag this type as modified"""
        self._total_size =  total_size_
        self._dirty = True

    total_size = property(lambda self: self._total_size, _set_total_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.base, 4, addr + 0)
        image.patch(symbol, self.size, 4, addr + 4)
        self.free_list_entry.patch(image, symbol, addr + 8)
        self._pointer_patch(image, symbol, 4, addr + 16, self.next)
        image.patch(symbol, self.total_size, 4, addr + 20)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.base,
                name + '.base', False)
        string += self._field_to_string(self.size,
                name + '.size', False)
        string += self._field_to_string(self.free_list_entry,
                name + '.free_list_entry', False)
        string += self._field_to_string(self.next,
                name + '.next', True)
        string += self._field_to_string(self.total_size,
                name + '.total_size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.base))
        data.append(self._pack(4, self.size))
        data.append(self.free_list_entry.to_data())
        self._pointer_to_data(data, 4, self.next)
        data.append(self._pack(4, self.total_size))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.free_list_entry.get_phys_relocs(base_offset + self.get_offset_of('free_list_entry')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.free_list_entry.dirty:
            return True
        if self.next is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_virtmem_pool(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_virtmem_pool {
    struct okl4_range_allocator allocator;
    struct okl4_virtmem_pool *parent;
    struct okl4_virtmem_item virt;
};
    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "allocator" : {'offset': 0},
        "parent" : {'offset': 32},
        "virt" : {'offset': 36},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.allocator = OKL4_range_allocator(this_addr, self)
        self.parent = None

        this_addr = None if address is None else self._address + 36
        self.virt = OKL4_virtmem_item(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.allocator.set_address(address + 0)
        self.virt.set_address(address + 36)

    _type_size = 60
    _type_alignment = 4
    _type_name = "virtmem_pool"
    _type_libokl4_name = "virtmem_pool"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.allocator.patch(image, symbol, addr + 0)
        self._pointer_patch(image, symbol, 4, addr + 32, self.parent)
        self.virt.patch(image, symbol, addr + 36)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.allocator,
                name + '.allocator', False)
        string += self._field_to_string(self.parent,
                name + '.parent', True)
        string += self._field_to_string(self.virt,
                name + '.virt', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.allocator.to_data())
        self._pointer_to_data(data, 4, self.parent)
        data.append(self.virt.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.allocator.get_phys_relocs(base_offset + self.get_offset_of('allocator')))
        relocs.extend(self.virt.get_phys_relocs(base_offset + self.get_offset_of('virt')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.allocator.dirty:
            return True
        if self.parent is not None:
            return True
        if self.virt.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_physmem_alloc(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_physmem_alloc {
    struct _okl4_mapping_attributes map_attrs;
    struct okl4_physmem_item phys;
    _okl4_mem_alloc_source_t source;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "map_attrs" : {'offset': 0},
        "phys" : {'offset': 8},
        "source" : {'offset': 44},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        this_addr = None if address is None else self._address + 0
        self.map_attrs = OKL4_mapping_attributes(this_addr, self)

        this_addr = None if address is None else self._address + 8
        self.phys = OKL4_physmem_item(this_addr, self)
        self._source = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.map_attrs.set_address(address + 0)
        self.phys.set_address(address + 8)

    _type_size = 48
    _type_alignment = 4
    _type_name = "physmem_alloc"
    _type_libokl4_name = "physmem_alloc"

    def _set_source(self, source_):
        """Set source and flag this type as modified"""
        self._source =  source_
        self._dirty = True

    source = property(lambda self: self._source, _set_source)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.map_attrs.patch(image, symbol, addr + 0)
        self.phys.patch(image, symbol, addr + 8)
        image.patch(symbol, self.source, 4, addr + 44)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.map_attrs,
                name + '.map_attrs', False)
        string += self._field_to_string(self.phys,
                name + '.phys', False)
        string += self._field_to_string(self.source,
                name + '.source', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.map_attrs.to_data())
        data.append(self.phys.to_data())
        data.append(self._pack(4, self.source))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.map_attrs.get_phys_relocs(base_offset + self.get_offset_of('map_attrs')))
        relocs.extend(self.phys.get_phys_relocs(base_offset + self.get_offset_of('phys')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.map_attrs.dirty:
            return True
        if self.phys.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_env_item(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_env_item {
    unsigned char *name;
    void *item;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "name" : {'offset': 0},
        "item" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.name = None
        self.item = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "env_item"
    _type_libokl4_name = "env_item"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.name)
        self._pointer_patch(image, symbol, 4, addr + 4, self.item)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.name,
                name + '.name', True)
        string += self._field_to_string(self.item,
                name + '.item', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.name)
        self._pointer_to_data(data, 4, self.item)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.name is not None:
            return True
        if self.item is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_schedparam(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_schedparam {
    okl4_priority_t priority;
    okl4_word_t timeslice;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "priority" : {'offset': 0},
        "timeslice" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._priority = 0
        self._timeslice = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "schedparam"
    _type_libokl4_name = "schedparam"

    def _set_priority(self, priority_):
        """Set priority and flag this type as modified"""
        self._priority =  priority_
        self._dirty = True

    priority = property(lambda self: self._priority, _set_priority)

    def _set_timeslice(self, timeslice_):
        """Set timeslice and flag this type as modified"""
        self._timeslice =  timeslice_
        self._dirty = True

    timeslice = property(lambda self: self._timeslice, _set_timeslice)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.priority, 4, addr + 0)
        image.patch(symbol, self.timeslice, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.priority,
                name + '.priority', False)
        string += self._field_to_string(self.timeslice,
                name + '.timeslice', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.priority))
        data.append(self._pack(4, self.timeslice))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_pd_attach_item(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_pd_attach_item {
    struct okl4_pd *ext;
    struct _okl4_list_entry ext_list_entry;
    okl4_bool_t in_use;
    struct okl4_pd *pd;
    struct _okl4_list_entry pd_list_entry;
    struct okl4_extension_token token;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "ext" : {'offset': 0},
        "ext_list_entry" : {'offset': 4},
        "in_use" : {'offset': 12},
        "pd" : {'offset': 16},
        "pd_list_entry" : {'offset': 20},
        "token" : {'offset': 28},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.ext = None

        this_addr = None if address is None else self._address + 4
        self.ext_list_entry = OKL4_list_entry(this_addr, self)
        self._in_use = 0
        self.pd = None

        this_addr = None if address is None else self._address + 20
        self.pd_list_entry = OKL4_list_entry(this_addr, self)

        this_addr = None if address is None else self._address + 28
        self.token = OKL4_extension_token(this_addr, self)

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.ext_list_entry.set_address(address + 4)
        self.pd_list_entry.set_address(address + 20)
        self.token.set_address(address + 28)

    _type_size = 32
    _type_alignment = 4
    _type_name = "pd_attach_item"
    _type_libokl4_name = "pd_attach_item"

    def _set_in_use(self, in_use_):
        """Set in_use and flag this type as modified"""
        self._in_use =  in_use_
        self._dirty = True

    in_use = property(lambda self: self._in_use, _set_in_use)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.ext)
        self.ext_list_entry.patch(image, symbol, addr + 4)
        image.patch(symbol, self.in_use, 4, addr + 12)
        self._pointer_patch(image, symbol, 4, addr + 16, self.pd)
        self.pd_list_entry.patch(image, symbol, addr + 20)
        self.token.patch(image, symbol, addr + 28)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.ext,
                name + '.ext', True)
        string += self._field_to_string(self.ext_list_entry,
                name + '.ext_list_entry', False)
        string += self._field_to_string(self.in_use,
                name + '.in_use', False)
        string += self._field_to_string(self.pd,
                name + '.pd', True)
        string += self._field_to_string(self.pd_list_entry,
                name + '.pd_list_entry', False)
        string += self._field_to_string(self.token,
                name + '.token', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.ext)
        data.append(self.ext_list_entry.to_data())
        data.append(self._pack(4, self.in_use))
        self._pointer_to_data(data, 4, self.pd)
        data.append(self.pd_list_entry.to_data())
        data.append(self.token.to_data())

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.ext_list_entry.get_phys_relocs(base_offset + self.get_offset_of('ext_list_entry')))
        relocs.extend(self.pd_list_entry.get_phys_relocs(base_offset + self.get_offset_of('pd_list_entry')))
        relocs.extend(self.token.get_phys_relocs(base_offset + self.get_offset_of('token')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.ext is not None:
            return True
        if self.ext_list_entry.dirty:
            return True
        if self.pd is not None:
            return True
        if self.pd_list_entry.dirty:
            return True
        if self.token.dirty:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_payload_inplace(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_message_payload_inplace {
    okl4_word_t *buff;
    okl4_word_t buff_size;
    okl4_word_t payload_size;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "buff" : {'offset': 0},
        "buff_size" : {'offset': 4},
        "payload_size" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.buff = None
        self._buff_size = 0
        self._payload_size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "message_payload_inplace"
    _type_libokl4_name = "message_payload_inplace"

    def _set_buff_size(self, buff_size_):
        """Set buff_size and flag this type as modified"""
        self._buff_size =  buff_size_
        self._dirty = True

    buff_size = property(lambda self: self._buff_size, _set_buff_size)

    def _set_payload_size(self, payload_size_):
        """Set payload_size and flag this type as modified"""
        self._payload_size =  payload_size_
        self._dirty = True

    payload_size = property(lambda self: self._payload_size, _set_payload_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.buff)
        image.patch(symbol, self.buff_size, 4, addr + 4)
        image.patch(symbol, self.payload_size, 4, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.buff,
                name + '.buff', True)
        string += self._field_to_string(self.buff_size,
                name + '.buff_size', False)
        string += self._field_to_string(self.payload_size,
                name + '.payload_size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.buff)
        data.append(self._pack(4, self.buff_size))
        data.append(self._pack(4, self.payload_size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.buff is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_queue_receive_any_inplace(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_message_queue_receive_any_inplace {
    okl4_word_t *buff;
    okl4_word_t buff_size;
    okl4_word_t payload_size;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "buff" : {'offset': 0},
        "buff_size" : {'offset': 4},
        "payload_size" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.buff = None
        self._buff_size = 0
        self._payload_size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "message_queue_receive_any_inplace"
    _type_libokl4_name = "message_queue_receive_any_inplace"

    def _set_buff_size(self, buff_size_):
        """Set buff_size and flag this type as modified"""
        self._buff_size =  buff_size_
        self._dirty = True

    buff_size = property(lambda self: self._buff_size, _set_buff_size)

    def _set_payload_size(self, payload_size_):
        """Set payload_size and flag this type as modified"""
        self._payload_size =  payload_size_
        self._dirty = True

    payload_size = property(lambda self: self._payload_size, _set_payload_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.buff)
        image.patch(symbol, self.buff_size, 4, addr + 4)
        image.patch(symbol, self.payload_size, 4, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.buff,
                name + '.buff', True)
        string += self._field_to_string(self.buff_size,
                name + '.buff_size', False)
        string += self._field_to_string(self.payload_size,
                name + '.payload_size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.buff)
        data.append(self._pack(4, self.buff_size))
        data.append(self._pack(4, self.payload_size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.buff is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_payload_capability(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_message_payload_capability {
    okl4_rights_t kcap_rights;
    okl4_kcap_t kcapid;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "kcap_rights" : {'offset': 0},
        "kcapid" : {'offset': 4},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self._kcap_rights = 0
        self._kcapid = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 8
    _type_alignment = 4
    _type_name = "message_payload_capability"
    _type_libokl4_name = "message_payload_capability"

    def _set_kcap_rights(self, kcap_rights_):
        """Set kcap_rights and flag this type as modified"""
        self._kcap_rights =  kcap_rights_
        self._dirty = True

    kcap_rights = property(lambda self: self._kcap_rights, _set_kcap_rights)

    def _set_kcapid(self, kcapid_):
        """Set kcapid and flag this type as modified"""
        self._kcapid =  kcapid_
        self._dirty = True

    kcapid = property(lambda self: self._kcapid, _set_kcapid)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        image.patch(symbol, self.kcap_rights, 4, addr + 0)
        image.patch(symbol, self.kcapid, 4, addr + 4)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.kcap_rights,
                name + '.kcap_rights', False)
        string += self._field_to_string(self.kcapid,
                name + '.kcapid', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self._pack(4, self.kcap_rights))
        data.append(self._pack(4, self.kcapid))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True


        return False
    dirty = property(_get_dirty)


class OKL4_message_payload_inline(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_message_payload_inline {
    okl4_word_t *data;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "data" : {'offset': 0},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.data = None

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 4
    _type_alignment = 4
    _type_name = "message_payload_inline"
    _type_libokl4_name = "message_payload_inline"

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.data)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.data,
                name + '.data', True)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.data)

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.data is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_payload_standard(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct _okl4_message_payload_standard {
    void *buff;
    okl4_word_t buff_size;
    okl4_word_t payload_size;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "buff" : {'offset': 0},
        "buff_size" : {'offset': 4},
        "payload_size" : {'offset': 8},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)

        self.buff = None
        self._buff_size = 0
        self._payload_size = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)


    _type_size = 12
    _type_alignment = 4
    _type_name = "message_payload_standard"
    _type_libokl4_name = "message_payload_standard"

    def _set_buff_size(self, buff_size_):
        """Set buff_size and flag this type as modified"""
        self._buff_size =  buff_size_
        self._dirty = True

    buff_size = property(lambda self: self._buff_size, _set_buff_size)

    def _set_payload_size(self, payload_size_):
        """Set payload_size and flag this type as modified"""
        self._payload_size =  payload_size_
        self._dirty = True

    payload_size = property(lambda self: self._payload_size, _set_payload_size)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self._pointer_patch(image, symbol, 4, addr + 0, self.buff)
        image.patch(symbol, self.buff_size, 4, addr + 4)
        image.patch(symbol, self.payload_size, 4, addr + 8)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.buff,
                name + '.buff', True)
        string += self._field_to_string(self.buff_size,
                name + '.buff_size', False)
        string += self._field_to_string(self.payload_size,
                name + '.payload_size', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        self._pointer_to_data(data, 4, self.buff)
        data.append(self._pack(4, self.buff_size))
        data.append(self._pack(4, self.payload_size))

        return ''.join(data)



    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.buff is not None:
            return True

        return False
    dirty = property(_get_dirty)


class OKL4_message_queue_receive_any_union(ElfweaverType):
    """
    Implement a python class that represents the C type:

struct okl4_message_queue_receive_any_union {
    union {
        okl4_word_t inline_data[2];
        struct okl4_message_queue_receive_any_inplace inplace;
        okl4_word_t payload_size;
        okl4_kcap_t capability;
    } payload;
    okl4_message_queue_receive_any_union_tag_t tag;
};

    """


    # Field property list.  The keys are used to detect places where a
    # renamed field has been missed.  The value describes various
    # field properties.
    _plist = {
        "payload" : {'offset': 0},
        "tag" : {'offset': 12},
    }

    def __init__(self, address, back_ptr = None, phys_addr = None):
        ElfweaverType.__init__(self, address, back_ptr, phys_addr)


        class OKL4_AnonymousType_74(ElfweaverType):
            """Implement an anonymous structure."""

            # Field property list.  The keys are used to detect places where a
            # renamed field has been missed.  The value describes various
            # field properties.
            _plist = {
                "inline_data" : {},
                "inplace" : {},
                "payload_size" : {},
                "capability" : {},
            }

            def __init__(self, address, back_ptr = None, phys_addr = None):
                ElfweaverType.__init__(self, address, back_ptr, phys_addr)

                self.inline_data = [None] * 2

                this_addr = None if address is None else self._address + 0
                self.inplace = OKL4_message_queue_receive_any_inplace(this_addr, self)
                self._payload_size = 0
                self._capability = 0

            def set_address(self, address, phys_addr = None):
                """Set the virtual and physical address of the object."""

                ElfweaverType.set_address(self, address, phys_addr)

                self.inplace.set_address(address + 0)

            _type_size = 12
            _type_alignment = 4
            _type_name = ""
            _type_libokl4_name = ""

            def _set_payload_size(self, payload_size_):
                """Set payload_size and flag this type as modified"""
                self._payload_size =  payload_size_
                self._dirty = True

            payload_size = property(lambda self: self._payload_size, _set_payload_size)

            def _set_capability(self, capability_):
                """Set capability and flag this type as modified"""
                self._capability =  capability_
                self._dirty = True

            capability = property(lambda self: self._capability, _set_capability)

            def patch(self, image, symbol, addr = 0):
                """Patch the data in this type at symbol + addr."""

                pass

            def to_string(self, name = ''):
                """Generate a human-readable form of the object."""

                string = name + ' - ' + str(self) + '\n'

                string += self._field_to_string(self.inline_data,
                        name + '.inline_data', False)
                string += self._field_to_string(self.inplace,
                        name + '.inplace', False)
                string += self._field_to_string(self.payload_size,
                        name + '.payload_size', False)
                string += self._field_to_string(self.capability,
                        name + '.capability', False)

                return string

            def to_data(self):
                """Convert the object into binary form."""

                data = []

                count = 0
                field_size = 0
                dirty_test = False
                dirty_test = self._array_dirty_test(self.inline_data)
                if dirty_test:
                    count += 1
                    field_size = 8
                    for item in self.inline_data:
                        data.append(self._pack(4, item))
                if self.inplace.dirty:
                    count += 1
                    field_size = 12
                    data.append(self.inplace.to_data())
                dirty_test = False
                if dirty_test:
                    count += 1
                    field_size = 4
                    data.append(self._pack(4, self.payload_size))
                dirty_test = False
                if dirty_test:
                    count += 1
                    field_size = 4
                    data.append(self._pack(4, self.capability))
                if count > 1:
                    raise ElfweaverTypeException('More than one entry in the union value has been set')
                bytes_left = 12 - field_size
                for val in (8, 4, 2, 1):
                    while bytes_left >= val:
                        data.append(self._pack(val, 0))
                        bytes_left -= val

                return ''.join(data)



            def _get_dirty(self):
                """Check if any element of this type has been modified."""
                if self._dirty:
                    return True


                return False
            dirty = property(_get_dirty)



        this_addr = None if address is None else self._address + 0
        self.payload = OKL4_AnonymousType_74(this_addr, self)
        self._tag = 0

    def set_address(self, address, phys_addr = None):
        """Set the virtual and physical address of the object."""

        ElfweaverType.set_address(self, address, phys_addr)

        self.payload.set_address(address + 0)

    _type_size = 16
    _type_alignment = 4
    _type_name = "message_queue_receive_any_union"
    _type_libokl4_name = "message_queue_receive_any_union"

    def _set_tag(self, tag_):
        """Set tag and flag this type as modified"""
        self._tag =  tag_
        self._dirty = True

    tag = property(lambda self: self._tag, _set_tag)

    def patch(self, image, symbol, addr = 0):
        """Patch the data in this type at symbol + addr."""

        self.payload.patch(image, symbol, addr + 0)
        image.patch(symbol, self.tag, 4, addr + 12)

    def to_string(self, name = ''):
        """Generate a human-readable form of the object."""

        string = name + ' - ' + str(self) + '\n'

        string += self._field_to_string(self.payload,
                name + '.payload', False)
        string += self._field_to_string(self.tag,
                name + '.tag', False)

        return string

    def to_data(self):
        """Convert the object into binary form."""

        data = []

        data.append(self.payload.to_data())
        data.append(self._pack(4, self.tag))

        return ''.join(data)

    def get_phys_relocs(self, base_offset=0):
        relocs = self._get_local_phys_reloc(base_offset)
        relocs.extend(self.payload.get_phys_relocs(base_offset + self.get_offset_of('payload')))
        return relocs


    def _get_dirty(self):
        """Check if any element of this type has been modified."""
        if self._dirty:
            return True

        if self.payload.dirty:
            return True

        return False
    dirty = property(_get_dirty)



# Type information
class TypeAttributes(object):
    """Provide information about a generated type."""
    def __init__(self, name, type_class, size, alignment):
        self.name = name
        self.type_class = type_class
        self.size = size
        self.alignment = alignment

# A dictionary of types available to the kernel.
kernel_types = {
        "bool" :
                TypeAttributes("bool", OKL4_bool, 4, 4),
        "unsigned_long" :
                TypeAttributes("unsigned_long", OKL4_unsigned_long, 4, 4),
        "signed_long" :
                TypeAttributes("signed_long", OKL4_signed_long, 4, 4),
        "unsigned" :
                TypeAttributes("unsigned", OKL4_unsigned, 4, 4),
        "int" :
                TypeAttributes("int", OKL4_int, 4, 4),
        "signed_char" :
                TypeAttributes("signed_char", OKL4_signed_char, 1, 1),
        "unsigned_char" :
                TypeAttributes("unsigned_char", OKL4_unsigned_char, 1, 1),
        "char_ptr" :
                TypeAttributes("char_ptr", OKL4_char_ptr, 4, 4),
        "void_ptr" :
                TypeAttributes("void_ptr", OKL4_void_ptr, 4, 4),
        "padding_t" :
                TypeAttributes("padding_t", OKL4_padding_t, 1, 1),
        "word_t" :
                TypeAttributes("word_t", OKL4_word_t, 4, 4),
        "sword_t" :
                TypeAttributes("sword_t", OKL4_sword_t, 4, 4),
        "int_t" :
                TypeAttributes("int_t", OKL4_int_t, 4, 4),
        "byte_t" :
                TypeAttributes("byte_t", OKL4_byte_t, 1, 1),
        "sbyte_t" :
                TypeAttributes("sbyte_t", OKL4_sbyte_t, 1, 1),
        "string_t" :
                TypeAttributes("string_t", OKL4_string_t, 4, 4),
        "int16_t" :
                TypeAttributes("int16_t", OKL4_int16_t, 2, 2),
        "uint16_t" :
                TypeAttributes("uint16_t", OKL4_uint16_t, 2, 2),
        "int32_t" :
                TypeAttributes("int32_t", OKL4_int32_t, 4, 4),
        "uint32_t" :
                TypeAttributes("uint32_t", OKL4_uint32_t, 4, 4),
        "int64_t" :
                TypeAttributes("int64_t", OKL4_int64_t, 8, 8),
        "uint64_t" :
                TypeAttributes("uint64_t", OKL4_uint64_t, 8, 8),
        "registers" :
                TypeAttributes("registers", OKL4_registers, 68, 4),
        "interrupt_type_t" :
                TypeAttributes("interrupt_type_t", OKL4_interrupt_type_t, 4, 4),
        "cpu_mode" :
                TypeAttributes("cpu_mode", OKL4_cpu_mode, 4, 4),
        "atomic_plain_word_t" :
                TypeAttributes("atomic_plain_word_t", OKL4_atomic_plain_word_t, 4, 4),
        "atomic_word" :
                TypeAttributes("atomic_word", OKL4_atomic_word, 4, 4),
        "atomic_word_t" :
                TypeAttributes("atomic_word_t", OKL4_atomic_word_t, 4, 4),
        "designator_t" :
                TypeAttributes("designator_t", OKL4_designator_t, 4, 4),
        "mpointer" :
                TypeAttributes("mpointer", OKL4_mpointer, 24, 4),
        "objmanager_object_header" :
                TypeAttributes("objmanager_object_header", OKL4_objmanager_object_header, 8, 4),
        "objtype" :
                TypeAttributes("objtype", OKL4_objtype, 4, 4),
        "rights_t" :
                TypeAttributes("rights_t", OKL4_rights_t, 4, 4),
        "unwind" :
                TypeAttributes("unwind", OKL4_unwind, 4, 4),
        "domain" :
                TypeAttributes("domain", OKL4_domain, 72, 4),
        "cap" :
                TypeAttributes("cap", OKL4_cap, 32, 4),
        "obj_alloc_header" :
                TypeAttributes("obj_alloc_header", OKL4_obj_alloc_header, 24, 4),
        "obj_alloc_block_header" :
                TypeAttributes("obj_alloc_block_header", OKL4_obj_alloc_block_header, 12, 4),
        "phys_attachment" :
                TypeAttributes("phys_attachment", OKL4_phys_attachment, 24, 4),
        "attach_status" :
                TypeAttributes("attach_status", OKL4_attach_status, 4, 4),
        "node" :
                TypeAttributes("node", OKL4_node, 8, 4),
        "segment" :
                TypeAttributes("segment", OKL4_segment, 64, 4),
        "segment_flags" :
                TypeAttributes("segment_flags", OKL4_segment_flags, 4, 4),
        "mutex" :
                TypeAttributes("mutex", OKL4_mutex, 76, 4),
        "hybrid_mutex" :
                TypeAttributes("hybrid_mutex", OKL4_hybrid_mutex, 68, 4),
        "hybrid_user_status" :
                TypeAttributes("hybrid_user_status", OKL4_hybrid_user_status, 4, 4),
        "barrier" :
                TypeAttributes("barrier", OKL4_barrier, 44, 4),
        "reply_cap_t" :
                TypeAttributes("reply_cap_t", OKL4_reply_cap_t, 4, 4),
        "ipc_return_callback_function_t" :
                TypeAttributes("ipc_return_callback_function_t", OKL4_ipc_return_callback_function_t, 4, 4),
        "reply_token" :
                TypeAttributes("reply_token", OKL4_reply_token, 20, 4),
        "ipc_transferred" :
                TypeAttributes("ipc_transferred", OKL4_ipc_transferred, 4, 4),
        "tls_thread_data" :
                TypeAttributes("tls_thread_data", OKL4_tls_thread_data, 4, 4),
        "profile_control" :
                TypeAttributes("profile_control", OKL4_profile_control, 12, 4),
        "tracebuffer_control" :
                TypeAttributes("tracebuffer_control", OKL4_tracebuffer_control, 12, 4),
        "tracepoint_entry" :
                TypeAttributes("tracepoint_entry", OKL4_tracepoint_entry, 16, 4),
        "tracepoint_id" :
                TypeAttributes("tracepoint_id", OKL4_tracepoint_id, 4, 4),
        "tracepoint_info" :
                TypeAttributes("tracepoint_info", OKL4_tracepoint_info, 4, 4),
        "tracepoint_event" :
                TypeAttributes("tracepoint_event", OKL4_tracepoint_event, 4, 4),
        "tracepoint_major" :
                TypeAttributes("tracepoint_major", OKL4_tracepoint_major, 4, 4),
        "tracepoint_minor" :
                TypeAttributes("tracepoint_minor", OKL4_tracepoint_minor, 4, 4),
        "tracebuffer_header" :
                TypeAttributes("tracebuffer_header", OKL4_tracebuffer_header, 72, 8),
        "interrupt_notify_return_callback_function_t" :
                TypeAttributes("interrupt_notify_return_callback_function_t", OKL4_interrupt_notify_return_callback_function_t, 4, 4),
        "platform_control" :
                TypeAttributes("platform_control", OKL4_platform_control, 12, 4),
        "soc_error_t" :
                TypeAttributes("soc_error_t", OKL4_soc_error_t, 4, 4),
        "interrupt_soc_descriptor_t" :
                TypeAttributes("interrupt_soc_descriptor_t", OKL4_interrupt_soc_descriptor_t, 4, 4),
        "interrupt" :
                TypeAttributes("interrupt", OKL4_interrupt, 16, 4),
        "interrupt_soc_token_t" :
                TypeAttributes("interrupt_soc_token_t", OKL4_interrupt_soc_token_t, 4, 4),
        "exception_data" :
                TypeAttributes("exception_data", OKL4_exception_data, 20, 4),
        "exc_class" :
                TypeAttributes("exc_class", OKL4_exc_class, 4, 4),
        "cache_type" :
                TypeAttributes("cache_type", OKL4_cache_type, 4, 4),
        "cache_action" :
                TypeAttributes("cache_action", OKL4_cache_action, 4, 4),
        "cache_ops_t" :
                TypeAttributes("cache_ops_t", OKL4_cache_ops_t, 4, 4),
        "switch_table" :
                TypeAttributes("switch_table", OKL4_switch_table, 36, 4),
        "entry_point_info" :
                TypeAttributes("entry_point_info", OKL4_entry_point_info, 8, 4),
        "switch_table_data" :
                TypeAttributes("switch_table_data", OKL4_switch_table_data, 24, 4),
        "message_queue" :
                TypeAttributes("message_queue", OKL4_message_queue, 112, 4),
        "async_message_t" :
                TypeAttributes("async_message_t", OKL4_async_message_t, 32, 4),
        "async_message" :
                TypeAttributes("async_message", OKL4_async_message, 32, 4),
        "async_message_tag" :
                TypeAttributes("async_message_tag", OKL4_async_message_tag, 4, 4),
        "message_queue_thread_shared" :
                TypeAttributes("message_queue_thread_shared", OKL4_message_queue_thread_shared, 92, 4),
        "msgq_post_receive_callback_t" :
                TypeAttributes("msgq_post_receive_callback_t", OKL4_msgq_post_receive_callback_t, 4, 4),
        "async_msg_buffer" :
                TypeAttributes("async_msg_buffer", OKL4_async_msg_buffer, 16, 4),
        "buff_area_freelist_entry" :
                TypeAttributes("buff_area_freelist_entry", OKL4_buff_area_freelist_entry, 4, 4),
        "async_message_payload_capability" :
                TypeAttributes("async_message_payload_capability", OKL4_async_message_payload_capability, 28, 4),
        "kdb_key_t" :
                TypeAttributes("kdb_key_t", OKL4_kdb_key_t, 4, 4),
        "kdb_object" :
                TypeAttributes("kdb_object", OKL4_kdb_object, 28, 4),
        "semaphore" :
                TypeAttributes("semaphore", OKL4_semaphore, 40, 4),
        "notify_list_entry" :
                TypeAttributes("notify_list_entry", OKL4_notify_list_entry, 16, 4),
        "notify_list" :
                TypeAttributes("notify_list", OKL4_notify_list, 8, 4),
        "processor_control" :
                TypeAttributes("processor_control", OKL4_processor_control, 12, 4),
        "critical_section" :
                TypeAttributes("critical_section", OKL4_critical_section, 12, 4),
        "error_t" :
                TypeAttributes("error_t", OKL4_error_t, 4, 4),
        "global" :
                TypeAttributes("global", OKL4_global, 20, 4),
        "restart_function_t" :
                TypeAttributes("restart_function_t", OKL4_restart_function_t, 4, 4),
        "pause_callback_t" :
                TypeAttributes("pause_callback_t", OKL4_pause_callback_t, 4, 4),
        "list_entry_t" :
                TypeAttributes("list_entry_t", OKL4_list_entry_t, 8, 4),
        "list_head_t" :
                TypeAttributes("list_head_t", OKL4_list_head_t, 8, 4),
        "list_entry" :
                TypeAttributes("list_entry", OKL4_list_entry, 8, 4),
        "cpu_local" :
                TypeAttributes("cpu_local", OKL4_cpu_local, 4, 4),
        "phys_reloc" :
                TypeAttributes("phys_reloc", OKL4_phys_reloc, 4, 4),
        "phys_relocation" :
                TypeAttributes("phys_relocation", OKL4_phys_relocation, 8, 4),
        "thread" :
                TypeAttributes("thread", OKL4_thread, 1104, 4),
        "syncpoint" :
                TypeAttributes("syncpoint", OKL4_syncpoint, 24, 4),
        "suspend_count_t" :
                TypeAttributes("suspend_count_t", OKL4_suspend_count_t, 4, 4),
        "priority_t" :
                TypeAttributes("priority_t", OKL4_priority_t, 4, 4),
        "cpu_id_t" :
                TypeAttributes("cpu_id_t", OKL4_cpu_id_t, 4, 4),
        "seize_opaque" :
                TypeAttributes("seize_opaque", OKL4_seize_opaque, 4, 4),
        "seize_opaque_t" :
                TypeAttributes("seize_opaque_t", OKL4_seize_opaque_t, 4, 4),
        "scheduler_queue" :
                TypeAttributes("scheduler_queue", OKL4_scheduler_queue, 2092, 4),
        "thread_scheduler_data" :
                TypeAttributes("thread_scheduler_data", OKL4_thread_scheduler_data, 64, 4),
        "inheritance_type" :
                TypeAttributes("inheritance_type", OKL4_inheritance_type, 4, 4),
        "asid_t" :
                TypeAttributes("asid_t", OKL4_asid_t, 4, 4),
        "mmu_map_arch_context" :
                TypeAttributes("mmu_map_arch_context", OKL4_mmu_map_arch_context, 4, 4),
        "mmu_context" :
                TypeAttributes("mmu_context", OKL4_mmu_context, 128, 4),
        "page_perms" :
                TypeAttributes("page_perms", OKL4_page_perms, 4, 4),
        "cache_attr" :
                TypeAttributes("cache_attr", OKL4_cache_attr, 4, 4),
        "cache_mask" :
                TypeAttributes("cache_mask", OKL4_cache_mask, 4, 4),
        "hw_cache_attr" :
                TypeAttributes("hw_cache_attr", OKL4_hw_cache_attr, 4, 4),
        "page_attribute" :
                TypeAttributes("page_attribute", OKL4_page_attribute, 4, 4),
        "mmu_data" :
                TypeAttributes("mmu_data", OKL4_mmu_data, 28, 4),
        "mmu_thread_data" :
                TypeAttributes("mmu_thread_data", OKL4_mmu_thread_data, 56, 4),
        "mmu_thread_op" :
                TypeAttributes("mmu_thread_op", OKL4_mmu_thread_op, 4, 4),
        "mmu_segment" :
                TypeAttributes("mmu_segment", OKL4_mmu_segment, 28, 4),
        "mmu_segment_state" :
                TypeAttributes("mmu_segment_state", OKL4_mmu_segment_state, 4, 4),
        "mmu_thread_op_data" :
                TypeAttributes("mmu_thread_op_data", OKL4_mmu_thread_op_data, 44, 4),
        "cpureg_callback_t" :
                TypeAttributes("cpureg_callback_t", OKL4_cpureg_callback_t, 4, 4),
        "registers_t" :
                TypeAttributes("registers_t", OKL4_registers_t, 68, 4),
        "intlock_control" :
                TypeAttributes("intlock_control", OKL4_intlock_control, 12, 4),
        }

# A dictionary of kernel objects.
kernel_objects = {
        "domain" :
                TypeAttributes("domain", OKL4_domain, 72, 4),
        "segment" :
                TypeAttributes("segment", OKL4_segment, 64, 4),
        "mutex" :
                TypeAttributes("mutex", OKL4_mutex, 76, 4),
        "hybrid_mutex" :
                TypeAttributes("hybrid_mutex", OKL4_hybrid_mutex, 68, 4),
        "barrier" :
                TypeAttributes("barrier", OKL4_barrier, 44, 4),
        "profile_control" :
                TypeAttributes("profile_control", OKL4_profile_control, 12, 4),
        "tracebuffer_control" :
                TypeAttributes("tracebuffer_control", OKL4_tracebuffer_control, 12, 4),
        "platform_control" :
                TypeAttributes("platform_control", OKL4_platform_control, 12, 4),
        "interrupt" :
                TypeAttributes("interrupt", OKL4_interrupt, 16, 4),
        "switch_table" :
                TypeAttributes("switch_table", OKL4_switch_table, 36, 4),
        "message_queue" :
                TypeAttributes("message_queue", OKL4_message_queue, 112, 4),
        "semaphore" :
                TypeAttributes("semaphore", OKL4_semaphore, 40, 4),
        "processor_control" :
                TypeAttributes("processor_control", OKL4_processor_control, 12, 4),
        "thread" :
                TypeAttributes("thread", OKL4_thread, 1104, 4),
        "mmu_context" :
                TypeAttributes("mmu_context", OKL4_mmu_context, 128, 4),
        "intlock_control" :
                TypeAttributes("intlock_control", OKL4_intlock_control, 12, 4),
        }

# A dictionary of types available to the user.
libokl4_types = {
        "time" :
                TypeAttributes("time", OKL4_time, 8, 8),
        "tracebuffer_ref_t" :
                TypeAttributes("tracebuffer_ref_t", OKL4_tracebuffer_ref_t, 4, 4),
        "tracepoint_mask_t" :
                TypeAttributes("tracepoint_mask_t", OKL4_tracepoint_mask_t, 4, 4),
        "schedparam_t" :
                TypeAttributes("schedparam_t", OKL4_schedparam_t, 8, 4),
        "extension" :
                TypeAttributes("extension", OKL4_extension, 128, 4),
        "extension_t" :
                TypeAttributes("extension_t", OKL4_extension_t, 128, 4),
        "pd_attach_item_t" :
                TypeAttributes("pd_attach_item_t", OKL4_pd_attach_item_t, 32, 4),
        "async_receive_any_t" :
                TypeAttributes("async_receive_any_t", OKL4_async_receive_any_t, 16, 4),
        "message_payload_type_t" :
                TypeAttributes("message_payload_type_t", OKL4_message_payload_type_t, 4, 4),
        "extension_attr" :
                TypeAttributes("extension_attr", OKL4_extension_attr, 40, 4),
        "extension_attr_t" :
                TypeAttributes("extension_attr_t", OKL4_extension_attr_t, 40, 4),
        "ksegment" :
                TypeAttributes("ksegment", OKL4_ksegment, 24, 4),
        "ksegment_t" :
                TypeAttributes("ksegment_t", OKL4_ksegment_t, 24, 4),
        "mem_alloc_source" :
                TypeAttributes("mem_alloc_source", OKL4_mem_alloc_source, 4, 4),
        "time_mode" :
                TypeAttributes("time_mode", OKL4_time_mode, 4, 4),
        "file_perms" :
                TypeAttributes("file_perms", OKL4_file_perms, 4, 4),
        "message_queue_receive_any_union_tag" :
                TypeAttributes("message_queue_receive_any_union_tag", OKL4_message_queue_receive_any_union_tag, 4, 4),
        "memsection_update_op" :
                TypeAttributes("memsection_update_op", OKL4_memsection_update_op, 4, 4),
        "iterate_handler" :
                TypeAttributes("iterate_handler", OKL4_iterate_handler, 4, 4),
        "fault_handler" :
                TypeAttributes("fault_handler", OKL4_fault_handler, 4, 4),
        "delete_handler" :
                TypeAttributes("delete_handler", OKL4_delete_handler, 4, 4),
        "lookup_handler" :
                TypeAttributes("lookup_handler", OKL4_lookup_handler, 4, 4),
        "clock_callback_t" :
                TypeAttributes("clock_callback_t", OKL4_clock_callback_t, 4, 4),
        "thread_func_t" :
                TypeAttributes("thread_func_t", OKL4_thread_func_t, 4, 4),
        "pthread_start_routine_t" :
                TypeAttributes("pthread_start_routine_t", OKL4_pthread_start_routine_t, 4, 4),
        "kthread_func_t" :
                TypeAttributes("kthread_func_t", OKL4_kthread_func_t, 4, 4),
        "address_space_attr" :
                TypeAttributes("address_space_attr", OKL4_address_space_attr, 16, 4),
        "memsection_attr" :
                TypeAttributes("memsection_attr", OKL4_memsection_attr, 16, 4),
        "kdomain_cap_copy_attr" :
                TypeAttributes("kdomain_cap_copy_attr", OKL4_kdomain_cap_copy_attr, 12, 4),
        "kdomain_attr" :
                TypeAttributes("kdomain_attr", OKL4_kdomain_attr, 16, 4),
        "interrupt_register_attr" :
                TypeAttributes("interrupt_register_attr", OKL4_interrupt_register_attr, 8, 4),
        "cache_control_attr" :
                TypeAttributes("cache_control_attr", OKL4_cache_control_attr, 12, 4),
        "kswitch_attr" :
                TypeAttributes("kswitch_attr", OKL4_kswitch_attr, 20, 4),
        "critical_section_attr" :
                TypeAttributes("critical_section_attr", OKL4_critical_section_attr, 4, 4),
        "kthread_attr" :
                TypeAttributes("kthread_attr", OKL4_kthread_attr, 52, 4),
        "thread_attr" :
                TypeAttributes("thread_attr", OKL4_thread_attr, 60, 4),
        "semaphore_attr" :
                TypeAttributes("semaphore_attr", OKL4_semaphore_attr, 4, 4),
        "file_attr" :
                TypeAttributes("file_attr", OKL4_file_attr, 8, 4),
        "file_stat" :
                TypeAttributes("file_stat", OKL4_file_stat, 4, 4),
        "memsection_elf_dso_attr" :
                TypeAttributes("memsection_elf_dso_attr", OKL4_memsection_elf_dso_attr, 16, 4),
        "plugin_attr" :
                TypeAttributes("plugin_attr", OKL4_plugin_attr, 12, 4),
        "program_attr" :
                TypeAttributes("program_attr", OKL4_program_attr, 24, 4),
        "kmmu_attr" :
                TypeAttributes("kmmu_attr", OKL4_kmmu_attr, 20, 4),
        "kmmu_map_attr" :
                TypeAttributes("kmmu_map_attr", OKL4_kmmu_map_attr, 28, 4),
        "tracepoint_entry_attr" :
                TypeAttributes("tracepoint_entry_attr", OKL4_tracepoint_entry_attr, 12, 4),
        "tracebuffer_attr" :
                TypeAttributes("tracebuffer_attr", OKL4_tracebuffer_attr, 16, 4),
        "message_queue_attr" :
                TypeAttributes("message_queue_attr", OKL4_message_queue_attr, 16, 4),
        "message_payload_attr" :
                TypeAttributes("message_payload_attr", OKL4_message_payload_attr, 44, 4),
        "buffer_area_attr" :
                TypeAttributes("buffer_area_attr", OKL4_buffer_area_attr, 24, 4),
        "memsection_contiguous_attr" :
                TypeAttributes("memsection_contiguous_attr", OKL4_memsection_contiguous_attr, 48, 4),
        "memsection_paged_attr" :
                TypeAttributes("memsection_paged_attr", OKL4_memsection_paged_attr, 40, 4),
        "memsection_update_attr" :
                TypeAttributes("memsection_update_attr", OKL4_memsection_update_attr, 12, 4),
        "memsection_fragmented_attr" :
                TypeAttributes("memsection_fragmented_attr", OKL4_memsection_fragmented_attr, 28, 4),
        "tls_attr" :
                TypeAttributes("tls_attr", OKL4_tls_attr, 16, 4),
        "alloc_attr" :
                TypeAttributes("alloc_attr", OKL4_alloc_attr, 20, 4),
        "mutex_attr" :
                TypeAttributes("mutex_attr", OKL4_mutex_attr, 12, 4),
        "pd_attr" :
                TypeAttributes("pd_attr", OKL4_pd_attr, 40, 4),
        "memalloc_attr" :
                TypeAttributes("memalloc_attr", OKL4_memalloc_attr, 4, 4),
        "realm_attr" :
                TypeAttributes("realm_attr", OKL4_realm_attr, 4, 4),
        "realm_attach_attr" :
                TypeAttributes("realm_attach_attr", OKL4_realm_attach_attr, 4, 4),
        "virtmem_pool_attr" :
                TypeAttributes("virtmem_pool_attr", OKL4_virtmem_pool_attr, 24, 4),
        "physmem_pool_attr" :
                TypeAttributes("physmem_pool_attr", OKL4_physmem_pool_attr, 44, 4),
        "memsection" :
                TypeAttributes("memsection", OKL4_memsection, 60, 4),
        "chunk" :
                TypeAttributes("chunk", OKL4_chunk, 4, 4),
        "address_space" :
                TypeAttributes("address_space", OKL4_address_space, 412, 4),
        "bitmap_item" :
                TypeAttributes("bitmap_item", OKL4_bitmap_item, 4, 4),
        "bitmap_allocator" :
                TypeAttributes("bitmap_allocator", OKL4_bitmap_allocator, 16, 4),
        "pd" :
                TypeAttributes("pd", OKL4_pd, 128, 4),
        "kdomain" :
                TypeAttributes("kdomain", OKL4_kdomain, 4, 4),
        "env_segment" :
                TypeAttributes("env_segment", OKL4_env_segment, 24, 4),
        "tracebuffer_buffer_header" :
                TypeAttributes("tracebuffer_buffer_header", OKL4_tracebuffer_buffer_header, 16, 8),
        "env" :
                TypeAttributes("env", OKL4_env, 12, 4),
        "okl4_interrupt" :
                TypeAttributes("okl4_interrupt", OKL4_okl4_interrupt, 4, 4),
        "env_args" :
                TypeAttributes("env_args", OKL4_env_args, 8, 4),
        "env_interrupt_list" :
                TypeAttributes("env_interrupt_list", OKL4_env_interrupt_list, 12, 4),
        "env_interrupt_handle" :
                TypeAttributes("env_interrupt_handle", OKL4_env_interrupt_handle, 8, 4),
        "env_interrupt_device_map" :
                TypeAttributes("env_interrupt_device_map", OKL4_env_interrupt_device_map, 8, 4),
        "kswitch" :
                TypeAttributes("kswitch", OKL4_kswitch, 8, 4),
        "clock" :
                TypeAttributes("clock", OKL4_clock, 0, 1),
        "condlock" :
                TypeAttributes("condlock", OKL4_condlock, 20, 4),
        "condvar" :
                TypeAttributes("condvar", OKL4_condvar, 4, 4),
        "okl4_thread" :
                TypeAttributes("okl4_thread", OKL4_okl4_thread, 112, 4),
        "okl4_semaphore" :
                TypeAttributes("okl4_semaphore", OKL4_okl4_semaphore, 4, 4),
        "file" :
                TypeAttributes("file", OKL4_file, 0, 1),
        "memsection_elf_dso" :
                TypeAttributes("memsection_elf_dso", OKL4_memsection_elf_dso, 164, 4),
        "mem_alloc" :
                TypeAttributes("mem_alloc", OKL4_mem_alloc, 56, 4),
        "plugin" :
                TypeAttributes("plugin", OKL4_plugin, 164, 4),
        "program" :
                TypeAttributes("program", OKL4_program, 492, 4),
        "env_mqs" :
                TypeAttributes("env_mqs", OKL4_env_mqs, 92, 4),
        "env_one_mq" :
                TypeAttributes("env_one_mq", OKL4_env_one_mq, 88, 4),
        "kmmu" :
                TypeAttributes("kmmu", OKL4_kmmu, 4, 4),
        "kthread" :
                TypeAttributes("kthread", OKL4_kthread, 60, 4),
        "machine_info" :
                TypeAttributes("machine_info", OKL4_machine_info, 8, 4),
        "extension_token" :
                TypeAttributes("extension_token", OKL4_extension_token, 4, 4),
        "extension_entry_token" :
                TypeAttributes("extension_entry_token", OKL4_extension_entry_token, 4, 4),
        "tracebuffer" :
                TypeAttributes("tracebuffer", OKL4_tracebuffer, 20, 4),
        "elffile" :
                TypeAttributes("elffile", OKL4_elffile, 12, 4),
        "buffer_area" :
                TypeAttributes("buffer_area", OKL4_buffer_area, 152, 4),
        "elfsegment" :
                TypeAttributes("elfsegment", OKL4_elfsegment, 8, 4),
        "okl4_message_queue" :
                TypeAttributes("okl4_message_queue", OKL4_okl4_message_queue, 4, 4),
        "message_payload" :
                TypeAttributes("message_payload", OKL4_message_payload, 48, 4),
        "memsection_paged" :
                TypeAttributes("memsection_paged", OKL4_memsection_paged, 124, 4),
        "mapping" :
                TypeAttributes("mapping", OKL4_mapping, 52, 4),
        "memsection_contiguous" :
                TypeAttributes("memsection_contiguous", OKL4_memsection_contiguous, 128, 4),
        "memsection_fragmented" :
                TypeAttributes("memsection_fragmented", OKL4_memsection_fragmented, 128, 4),
        "mapping_attributes" :
                TypeAttributes("mapping_attributes", OKL4_mapping_attributes, 8, 4),
        "okl4_mutex" :
                TypeAttributes("okl4_mutex", OKL4_okl4_mutex, 20, 4),
        "env_segment_table" :
                TypeAttributes("env_segment_table", OKL4_env_segment_table, 28, 4),
        "realm" :
                TypeAttributes("realm", OKL4_realm, 52, 4),
        "pd_thread" :
                TypeAttributes("pd_thread", OKL4_pd_thread, 200, 4),
        "physmem_segpool" :
                TypeAttributes("physmem_segpool", OKL4_physmem_segpool, 76, 4),
        "physmem_pagepool" :
                TypeAttributes("physmem_pagepool", OKL4_physmem_pagepool, 60, 4),
        "range_allocator" :
                TypeAttributes("range_allocator", OKL4_range_allocator, 32, 4),
        "virtmem_item" :
                TypeAttributes("virtmem_item", OKL4_virtmem_item, 24, 4),
        "physmem_item" :
                TypeAttributes("physmem_item", OKL4_physmem_item, 36, 4),
        "range_item" :
                TypeAttributes("range_item", OKL4_range_item, 24, 4),
        "virtmem_pool" :
                TypeAttributes("virtmem_pool", OKL4_virtmem_pool, 60, 4),
        "physmem_alloc" :
                TypeAttributes("physmem_alloc", OKL4_physmem_alloc, 48, 4),
        "env_item" :
                TypeAttributes("env_item", OKL4_env_item, 8, 4),
        "schedparam" :
                TypeAttributes("schedparam", OKL4_schedparam, 8, 4),
        "pd_attach_item" :
                TypeAttributes("pd_attach_item", OKL4_pd_attach_item, 32, 4),
        "message_payload_inplace" :
                TypeAttributes("message_payload_inplace", OKL4_message_payload_inplace, 12, 4),
        "message_queue_receive_any_inplace" :
                TypeAttributes("message_queue_receive_any_inplace", OKL4_message_queue_receive_any_inplace, 12, 4),
        "message_payload_capability" :
                TypeAttributes("message_payload_capability", OKL4_message_payload_capability, 8, 4),
        "message_payload_inline" :
                TypeAttributes("message_payload_inline", OKL4_message_payload_inline, 4, 4),
        "message_payload_standard" :
                TypeAttributes("message_payload_standard", OKL4_message_payload_standard, 12, 4),
        "message_queue_receive_any_union" :
                TypeAttributes("message_queue_receive_any_union", OKL4_message_queue_receive_any_union, 16, 4),
        }
