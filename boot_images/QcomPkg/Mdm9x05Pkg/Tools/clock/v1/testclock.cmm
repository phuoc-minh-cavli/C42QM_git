
;============================================================================
;
; *************** THIS SCRIPT WAS AUTOGENERATED ****************
;
; TARGET
;
;
; SCRIPT
;   TESTCLOCK.CMM
;
; GENERAL DESCRIPTION
;   This script can be used to route specific clocks to the clock test output.
;
; FUNCTIONS
;   N/A
;
;    Copyright (c) 2019 by QUALCOMM Technologies Inc.  All Rights Reserved.
;============================================================================

; Template inputs:
; &dbg_mux_max          ;; Total clock controllers
; &max_clks             ;; Max number of clocks in a clock controller
; \a_clock_str          ;; The GCC clock names array
; \a_clock_data         ;; The GCC clock addresses w/ same index as names


;-----------------------------------------------------------------------------
; Local variables
;-----------------------------------------------------------------------------

local &clk
local &clk_name
local &clk_state
local &clk_state_filter
local &clk_freq
local &clk_freq_str
local &header_printed
local &clk_test_mux
local &clk_test_sel
local &clk_reg
local &clk_reg_str
local &clk_reg_name
local &clk_reg_val
local &clk_reg_val_str
local &clk_reg_cbcr_type
local &state_change
local &clock_count
local &multiplier
local &tcxo_count
local &match
local &chipset_name
local &frq_measure_ctl_addr
local &frq_measure_status_addr
local &xo_div4_cbcr_addr

;
; ARGS script file, absolute path.
;
local &ARGS_SCRIPT_FILE
&ARGS_SCRIPT_FILE=os.ppf()

;
; ARGS history buffer dimensions: (32 * 512 ) = 16 KB/client.
;
local &ARGS_MAX_HIST_ENTRIES
local &ARGS_HIST_ENTRY_MAX_LEN
local &ARGS_HIST_ENTRY_LAST_IDX
&ARGS_MAX_HIST_ENTRIES=32.      ; Max number of history entries.
&ARGS_HIST_ENTRY_MAX_LEN=512.   ; Max length of history entry.
&ARGS_HIST_ENTRY_LAST_IDX=(&ARGS_HIST_ENTRY_MAX_LEN-1.)

; ARGS error scratchpad (used for "ON ERROR gosub" execution detection).
local &err

;
; ARGS client global variable names.
;
local &gvar_name_client_name      ; => char[128.] "args_client_name_<ID>"
local &gvar_name_area_name        ; => char[128.] "args_area_name_<ID>"
local &gvar_name_client_error     ; => char[64.]  "args_err_<ID>"

local &gvar_name_cmd_line         ; => char[512.] "args_cmd_line_<ID>"
local &gvar_name_read_idx         ; => int        "args_read_idx_<ID>

local &gvar_name_help_cmd         ; => char[64.]  "args_help_cmd_<ID>"
local &gvar_name_help_sub         ; => char[64.]  "args_help_sub_<ID>"
local &gvar_name_hist_cmd         ; => char[64.]  "args_hist_cmd_<ID>"
local &gvar_name_hist_sub         ; => char[64.]  "args_hist_sub_<ID>"

local &gvar_name_nonempty_cmds    ; => int (bool) "args_non_empty_cmds_<ID>"
local &gvar_name_nonempty_vals    ; => int (bool) "args_non_empty_vals_<ID>"
local &gvar_name_print_errors_en  ; => int (bool) "args_print_errors_en_<ID>"

local &gvar_name_hist_en          ; => int (bool) "args_hist_en_<ID>"
local &gvar_name_hist_tip_idx     ; => int        "args_hist_tip_idx_<ID>"
local &gvar_name_num_hist_entries ; => int        "args_num_hist_entries_<ID>"

local &gvar_name_hist_buf         ; => char[32.][512.] "args_hist_buf_<ID>"

;
; Declare/initialize a global monotonically increasing ARGS client counter.
;
global &args_client_count
if ("&args_client_count"=="")
(
  &args_client_count=0.
)

;
; Declare/initialize a global ARGS macro to hold the previous ARGS error type.
; This error type macro is common to all clients. Its content is returned when
; no client ID is provided to "get_error". The primary use-cases are to
; trouble-shoot client creation errors and invalid client ID errors.
;
global &args_latest_error
if ("&args_latest_error"=="")
(
  &args_latest_error="NO_ERROR"
)


;-----------------------------------------------------------------------------
; Initialize autogenerated constants
;-----------------------------------------------------------------------------

goto Init_Constants


Init_Constants:

; Chipset Name
&chipset_name="mdm9205"

; Generated Date
&gendate="1/19/2019"

; Access Mode
&access_mode="ezaxi"

; Debug Mux Strings
&dbg_mux_str_name=0.
&dbg_mux_str_access_mode=1.
&dbg_mux_str_max=2.

; Debug Mux Regs
&dbg_mux_reg_addr=0.
&dbg_mux_reg_mask=1.
&dbg_mux_reg_shft=2.
&dbg_mux_reg_enable_addr=3.
&dbg_mux_reg_enable_mask=4.
&dbg_mux_reg_parent_idx=5.
&dbg_mux_reg_parent_sel=6.
&dbg_mux_reg_div_val=7.
&dbg_mux_reg_div_hw_val=8.
&dbg_mux_reg_div_addr=9.
&dbg_mux_reg_div_shft=10.
&dbg_mux_reg_div_mask=11.
&dbg_mux_reg_num_clks=12.
&dbg_mux_reg_plltestpad=13.
&dbg_mux_reg_measure_ctl=14.
&dbg_mux_reg_measure_status=15.
&dbg_mux_reg_xo_div4_addr=16.
&dbg_mux_reg_max=17.

; Registers stored
&clk_reg_cbc=0.
&clk_reg_tc_mux=1.
&clk_reg_tc_sel=2.
&clk_reg_vote_bit=3.
&clk_reg_total_div=4.
&clk_reg_mux_input_en_addr=5.
&clk_reg_mux_input_en_mask=6.
&clk_reg_total=7.

; Registers stored
&clk_str_name=0
&clk_str_type=1
&clk_str_regname=2
&clk_str_aliases=3
&clk_str_total=4

&dbg_mux_apss_cc=0x0
&dbg_mux_gcc=0x1
&dbg_mux_mss_cc=0x2
&dbg_mux_mss_cc_q6=0x3
&dbg_mux_max=0x4
&dbg_mux_none=0x3ff

&max_clk_len=40.
&max_mux_len=10.
&max_clks=0x9c

v.new int[&dbg_mux_max][&dbg_mux_reg_max] \a_dbg_mux_data
v.new char[&dbg_mux_max][&dbg_mux_str_max][&max_mux_len] \a_dbg_mux_str

v.new char[&dbg_mux_max][&max_clks][&clk_str_total][&max_clk_len] \a_clock_str
v.new int[&dbg_mux_max][&max_clks][&clk_reg_total] \a_clock_data


v.new int[0x1] \vote_regs
v.a \vote_regs[0x0]=0x1800004


v.a \a_dbg_mux_str[&dbg_mux_apss_cc][&dbg_mux_str_name]="APSS_CC"
v.a \a_dbg_mux_str[&dbg_mux_apss_cc][&dbg_mux_str_access_mode]="az"
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_num_clks]=0x7
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_addr]=0xb01101c
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_mask]=0x38
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_shft]=0x3
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_enable_addr]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_enable_mask]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_parent_idx]=&dbg_mux_gcc
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_parent_sel]=0x16a
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_div_val]=0x1
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_div_hw_val]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_div_addr]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_div_shft]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_div_mask]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_plltestpad]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_measure_ctl]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_measure_status]=0x0
v.a \a_dbg_mux_data[&dbg_mux_apss_cc][&dbg_mux_reg_xo_div4_addr]=0x0

v.a \a_dbg_mux_str[&dbg_mux_gcc][&dbg_mux_str_name]="GCC"
v.a \a_dbg_mux_str[&dbg_mux_gcc][&dbg_mux_str_access_mode]="ezaxi"
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_num_clks]=0x9c
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_addr]=0x1874000
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_mask]=0x1ff
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_shft]=0x0
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_enable_addr]=0x1874000
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_enable_mask]=0x10000
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_parent_idx]=&dbg_mux_none
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_parent_sel]=&dbg_mux_none
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_val]=0x4
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_hw_val]=0x3
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_addr]=0x1874000
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_shft]=0xc
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_mask]=0xf000
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_plltestpad]=0x187400c
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_measure_ctl]=0x1874004
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_measure_status]=0x1874008
v.a \a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_xo_div4_addr]=0x1830034

v.a \a_dbg_mux_str[&dbg_mux_mss_cc][&dbg_mux_str_name]="MSS_CC"
v.a \a_dbg_mux_str[&dbg_mux_mss_cc][&dbg_mux_str_access_mode]="ezaxi"
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_num_clks]=0x33
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_addr]=0x4180078
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_mask]=0x7ff
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_shft]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_enable_addr]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_enable_mask]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_parent_idx]=&dbg_mux_gcc
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_parent_sel]=0x32
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_div_val]=0x1
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_div_hw_val]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_div_addr]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_div_shft]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_div_mask]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_plltestpad]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_measure_ctl]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_measure_status]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc][&dbg_mux_reg_xo_div4_addr]=0x0

v.a \a_dbg_mux_str[&dbg_mux_mss_cc_q6][&dbg_mux_str_name]="MSS_CC_Q6"
v.a \a_dbg_mux_str[&dbg_mux_mss_cc_q6][&dbg_mux_str_access_mode]="ezaxi"
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_num_clks]=0xb
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_addr]=0x4082010
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_mask]=0x1f
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_shft]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_enable_addr]=0x4082010
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_enable_mask]=0x40
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_parent_idx]=&dbg_mux_mss_cc
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_parent_sel]=0x17
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_div_val]=0x1
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_div_hw_val]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_div_addr]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_div_shft]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_div_mask]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_plltestpad]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_measure_ctl]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_measure_status]=0x0
v.a \a_dbg_mux_data[&dbg_mux_mss_cc_q6][&dbg_mux_reg_xo_div4_addr]=0x0




; APSS_CC Controller Clock Names
v.a \a_clock_str[&dbg_mux_apss_cc][0x0][&clk_str_name]="apcs_apc0_sysleaf_clk"
v.a \a_clock_str[&dbg_mux_apss_cc][0x0][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x0][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x0][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_apss_cc][0x0][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x0][&clk_reg_tc_mux]=&dbg_mux_apss_cc
v.a \a_clock_data[&dbg_mux_apss_cc][0x0][&clk_reg_tc_sel]=0x3
v.a \a_clock_data[&dbg_mux_apss_cc][0x0][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_apss_cc][0x0][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_apss_cc][0x0][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x0][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_apss_cc][0x1][&clk_str_name]="apcs_l2_dataram_clk"
v.a \a_clock_str[&dbg_mux_apss_cc][0x1][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x1][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x1][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_apss_cc][0x1][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x1][&clk_reg_tc_mux]=&dbg_mux_apss_cc
v.a \a_clock_data[&dbg_mux_apss_cc][0x1][&clk_reg_tc_sel]=0x2
v.a \a_clock_data[&dbg_mux_apss_cc][0x1][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_apss_cc][0x1][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_apss_cc][0x1][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x1][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_apss_cc][0x2][&clk_str_name]="apcs_pll_dtest"
v.a \a_clock_str[&dbg_mux_apss_cc][0x2][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x2][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x2][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_apss_cc][0x2][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x2][&clk_reg_tc_mux]=&dbg_mux_apss_cc
v.a \a_clock_data[&dbg_mux_apss_cc][0x2][&clk_reg_tc_sel]=0x5
v.a \a_clock_data[&dbg_mux_apss_cc][0x2][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_apss_cc][0x2][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_apss_cc][0x2][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x2][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_apss_cc][0x3][&clk_str_name]="apcs_pll_lock_detect"
v.a \a_clock_str[&dbg_mux_apss_cc][0x3][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x3][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x3][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_apss_cc][0x3][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x3][&clk_reg_tc_mux]=&dbg_mux_apss_cc
v.a \a_clock_data[&dbg_mux_apss_cc][0x3][&clk_reg_tc_sel]=0x4
v.a \a_clock_data[&dbg_mux_apss_cc][0x3][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_apss_cc][0x3][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_apss_cc][0x3][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x3][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_apss_cc][0x4][&clk_str_name]="apcs_sys_apcsahb_clk"
v.a \a_clock_str[&dbg_mux_apss_cc][0x4][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x4][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x4][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_apss_cc][0x4][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x4][&clk_reg_tc_mux]=&dbg_mux_apss_cc
v.a \a_clock_data[&dbg_mux_apss_cc][0x4][&clk_reg_tc_sel]=0x1
v.a \a_clock_data[&dbg_mux_apss_cc][0x4][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_apss_cc][0x4][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_apss_cc][0x4][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x4][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_apss_cc][0x5][&clk_str_name]="apcs_sys_apcsqsb_clk"
v.a \a_clock_str[&dbg_mux_apss_cc][0x5][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x5][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x5][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_apss_cc][0x5][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x5][&clk_reg_tc_mux]=&dbg_mux_apss_cc
v.a \a_clock_data[&dbg_mux_apss_cc][0x5][&clk_reg_tc_sel]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x5][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_apss_cc][0x5][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_apss_cc][0x5][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x5][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_apss_cc][0x6][&clk_str_name]="apss_cc_clk_src"
v.a \a_clock_str[&dbg_mux_apss_cc][0x6][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x6][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_apss_cc][0x6][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_apss_cc][0x6][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x6][&clk_reg_tc_mux]=&dbg_mux_apss_cc
v.a \a_clock_data[&dbg_mux_apss_cc][0x6][&clk_reg_tc_sel]=0x3
v.a \a_clock_data[&dbg_mux_apss_cc][0x6][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_apss_cc][0x6][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_apss_cc][0x6][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_apss_cc][0x6][&clk_reg_mux_input_en_mask]=0x0


; GCC Controller Clock Names
v.a \a_clock_str[&dbg_mux_gcc][0x0][&clk_str_name]="apss_gcc_dbg_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x0][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x0][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x0][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x0][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x0][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x0][&clk_reg_tc_sel]=0x16a
v.a \a_clock_data[&dbg_mux_gcc][0x0][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x0][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x0][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x0][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x1][&clk_str_name]="apss_gcc_ringosc_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x1][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x1][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x1][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x1][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x1][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x1][&clk_reg_tc_sel]=0x1d0
v.a \a_clock_data[&dbg_mux_gcc][0x1][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x1][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x1][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x1][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x2][&clk_str_name]="gcc_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x2][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x2][&clk_str_regname]="GCC_GCC_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x2][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x2][&clk_reg_cbc]=0x1830014
v.a \a_clock_data[&dbg_mux_gcc][0x2][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x2][&clk_reg_tc_sel]=0x148
v.a \a_clock_data[&dbg_mux_gcc][0x2][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x2][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x2][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x2][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x3][&clk_str_name]="gcc_apss_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x3][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x3][&clk_str_regname]="GCC_APSS_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x3][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x3][&clk_reg_cbc]=0x184601c
v.a \a_clock_data[&dbg_mux_gcc][0x3][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x3][&clk_reg_tc_sel]=0x168
v.a \a_clock_data[&dbg_mux_gcc][0x3][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x3][&clk_reg_vote_bit]=0xe
v.a \a_clock_data[&dbg_mux_gcc][0x3][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x3][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x4][&clk_str_name]="gcc_apss_axi_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x4][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x4][&clk_str_regname]="GCC_APSS_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x4][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x4][&clk_reg_cbc]=0x1846020
v.a \a_clock_data[&dbg_mux_gcc][0x4][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x4][&clk_reg_tc_sel]=0x169
v.a \a_clock_data[&dbg_mux_gcc][0x4][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x4][&clk_reg_vote_bit]=0xd
v.a \a_clock_data[&dbg_mux_gcc][0x4][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x4][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x5][&clk_str_name]="gcc_bimc_apss_axi_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x5][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x5][&clk_str_regname]="GCC_BIMC_APSS_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x5][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x5][&clk_reg_cbc]=0x1831020
v.a \a_clock_data[&dbg_mux_gcc][0x5][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x5][&clk_reg_tc_sel]=0x155
v.a \a_clock_data[&dbg_mux_gcc][0x5][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x5][&clk_reg_vote_bit]=0xf
v.a \a_clock_data[&dbg_mux_gcc][0x5][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x5][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x6][&clk_str_name]="gcc_bimc_at_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x6][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x6][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x6][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x6][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x6][&clk_reg_tc_sel]=0x156
v.a \a_clock_data[&dbg_mux_gcc][0x6][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x6][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x6][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x7][&clk_str_name]="gcc_bimc_cfg_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x7][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x7][&clk_str_regname]="GCC_BIMC_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x7][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x7][&clk_reg_cbc]=0x183100c
v.a \a_clock_data[&dbg_mux_gcc][0x7][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x7][&clk_reg_tc_sel]=0x151
v.a \a_clock_data[&dbg_mux_gcc][0x7][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x7][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x7][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x7][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x8][&clk_str_name]="gcc_bimc_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x8][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x8][&clk_str_regname]="GCC_BIMC_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x8][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x8][&clk_reg_cbc]=0x183101c
v.a \a_clock_data[&dbg_mux_gcc][0x8][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x8][&clk_reg_tc_sel]=0x154
v.a \a_clock_data[&dbg_mux_gcc][0x8][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x8][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x8][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x8][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x9][&clk_str_name]="gcc_bimc_mcdma_nav_ce_axi_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x9][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x9][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x9][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x9][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x9][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x9][&clk_reg_tc_sel]=0x15c
v.a \a_clock_data[&dbg_mux_gcc][0x9][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x9][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x9][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x9][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0xa][&clk_str_name]="gcc_bimc_noc_mpu_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0xa][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0xa][&clk_str_regname]="GCC_BIMC_NOC_MPU_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0xa][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0xa][&clk_reg_cbc]=0x1812100
v.a \a_clock_data[&dbg_mux_gcc][0xa][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0xa][&clk_reg_tc_sel]=0x80
v.a \a_clock_data[&dbg_mux_gcc][0xa][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0xa][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0xa][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0xa][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0xb][&clk_str_name]="gcc_bimc_pcnoc_axi_clk"
v.a \a_clock_str[&dbg_mux_gcc][0xb][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0xb][&clk_str_regname]="GCC_BIMC_PCNOC_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0xb][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0xb][&clk_reg_cbc]=0x1831024
v.a \a_clock_data[&dbg_mux_gcc][0xb][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0xb][&clk_reg_tc_sel]=0x153
v.a \a_clock_data[&dbg_mux_gcc][0xb][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0xb][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0xb][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0xb][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0xc][&clk_str_name]="gcc_bimc_sleep_clk"
v.a \a_clock_str[&dbg_mux_gcc][0xc][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0xc][&clk_str_regname]="GCC_BIMC_SLEEP_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0xc][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0xc][&clk_reg_cbc]=0x1831010
v.a \a_clock_data[&dbg_mux_gcc][0xc][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0xc][&clk_reg_tc_sel]=0x152
v.a \a_clock_data[&dbg_mux_gcc][0xc][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0xc][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0xc][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0xc][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0xd][&clk_str_name]="gcc_bimc_xo_clk"
v.a \a_clock_str[&dbg_mux_gcc][0xd][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0xd][&clk_str_regname]="GCC_BIMC_XO_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0xd][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0xd][&clk_reg_cbc]=0x1831008
v.a \a_clock_data[&dbg_mux_gcc][0xd][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0xd][&clk_reg_tc_sel]=0x150
v.a \a_clock_data[&dbg_mux_gcc][0xd][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0xd][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0xd][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0xd][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0xe][&clk_str_name]="gcc_blsp1_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0xe][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0xe][&clk_str_regname]="GCC_BLSP1_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0xe][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0xe][&clk_reg_cbc]=0x1801008
v.a \a_clock_data[&dbg_mux_gcc][0xe][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0xe][&clk_reg_tc_sel]=0x88
v.a \a_clock_data[&dbg_mux_gcc][0xe][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0xe][&clk_reg_vote_bit]=0xa
v.a \a_clock_data[&dbg_mux_gcc][0xe][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0xe][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0xf][&clk_str_name]="gcc_blsp1_qup1_i2c_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0xf][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0xf][&clk_str_regname]="GCC_BLSP1_QUP1_I2C_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0xf][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0xf][&clk_reg_cbc]=0x1802008
v.a \a_clock_data[&dbg_mux_gcc][0xf][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0xf][&clk_reg_tc_sel]=0x8b
v.a \a_clock_data[&dbg_mux_gcc][0xf][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0xf][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0xf][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0xf][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x10][&clk_str_name]="gcc_blsp1_qup1_spi_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x10][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x10][&clk_str_regname]="GCC_BLSP1_QUP1_SPI_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x10][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x10][&clk_reg_cbc]=0x1802004
v.a \a_clock_data[&dbg_mux_gcc][0x10][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x10][&clk_reg_tc_sel]=0x8a
v.a \a_clock_data[&dbg_mux_gcc][0x10][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x10][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x10][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x10][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x11][&clk_str_name]="gcc_blsp1_qup2_i2c_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x11][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x11][&clk_str_regname]="GCC_BLSP1_QUP2_I2C_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x11][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x11][&clk_reg_cbc]=0x1803010
v.a \a_clock_data[&dbg_mux_gcc][0x11][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x11][&clk_reg_tc_sel]=0x90
v.a \a_clock_data[&dbg_mux_gcc][0x11][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x11][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x11][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x11][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x12][&clk_str_name]="gcc_blsp1_qup2_spi_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x12][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x12][&clk_str_regname]="GCC_BLSP1_QUP2_SPI_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x12][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x12][&clk_reg_cbc]=0x180300c
v.a \a_clock_data[&dbg_mux_gcc][0x12][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x12][&clk_reg_tc_sel]=0x8e
v.a \a_clock_data[&dbg_mux_gcc][0x12][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x12][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x12][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x12][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x13][&clk_str_name]="gcc_blsp1_qup3_i2c_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x13][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x13][&clk_str_regname]="GCC_BLSP1_QUP3_I2C_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x13][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x13][&clk_reg_cbc]=0x1804020
v.a \a_clock_data[&dbg_mux_gcc][0x13][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x13][&clk_reg_tc_sel]=0x94
v.a \a_clock_data[&dbg_mux_gcc][0x13][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x13][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x13][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x13][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x14][&clk_str_name]="gcc_blsp1_qup3_spi_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x14][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x14][&clk_str_regname]="GCC_BLSP1_QUP3_SPI_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x14][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x14][&clk_reg_cbc]=0x180401c
v.a \a_clock_data[&dbg_mux_gcc][0x14][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x14][&clk_reg_tc_sel]=0x93
v.a \a_clock_data[&dbg_mux_gcc][0x14][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x14][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x14][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x14][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x15][&clk_str_name]="gcc_blsp1_qup4_i2c_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x15][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x15][&clk_str_regname]="GCC_BLSP1_QUP4_I2C_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x15][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x15][&clk_reg_cbc]=0x1805020
v.a \a_clock_data[&dbg_mux_gcc][0x15][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x15][&clk_reg_tc_sel]=0x99
v.a \a_clock_data[&dbg_mux_gcc][0x15][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x15][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x15][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x15][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x16][&clk_str_name]="gcc_blsp1_qup4_spi_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x16][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x16][&clk_str_regname]="GCC_BLSP1_QUP4_SPI_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x16][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x16][&clk_reg_cbc]=0x180501c
v.a \a_clock_data[&dbg_mux_gcc][0x16][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x16][&clk_reg_tc_sel]=0x98
v.a \a_clock_data[&dbg_mux_gcc][0x16][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x16][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x16][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x16][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x17][&clk_str_name]="gcc_blsp1_sleep_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x17][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x17][&clk_str_regname]="GCC_BLSP1_SLEEP_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x17][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x17][&clk_reg_cbc]=0x1801004
v.a \a_clock_data[&dbg_mux_gcc][0x17][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x17][&clk_reg_tc_sel]=0x89
v.a \a_clock_data[&dbg_mux_gcc][0x17][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x17][&clk_reg_vote_bit]=0x9
v.a \a_clock_data[&dbg_mux_gcc][0x17][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x17][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x18][&clk_str_name]="gcc_blsp1_uart1_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x18][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x18][&clk_str_regname]="GCC_BLSP1_UART1_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x18][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x18][&clk_reg_cbc]=0x180203c
v.a \a_clock_data[&dbg_mux_gcc][0x18][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x18][&clk_reg_tc_sel]=0x8c
v.a \a_clock_data[&dbg_mux_gcc][0x18][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x18][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x18][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x18][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x19][&clk_str_name]="gcc_blsp1_uart1_sim_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x19][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x19][&clk_str_regname]="GCC_BLSP1_UART1_SIM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x19][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x19][&clk_reg_cbc]=0x1802040
v.a \a_clock_data[&dbg_mux_gcc][0x19][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x19][&clk_reg_tc_sel]=0x8d
v.a \a_clock_data[&dbg_mux_gcc][0x19][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x19][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x19][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x19][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x1a][&clk_str_name]="gcc_blsp1_uart2_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x1a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x1a][&clk_str_regname]="GCC_BLSP1_UART2_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x1a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x1a][&clk_reg_cbc]=0x180302c
v.a \a_clock_data[&dbg_mux_gcc][0x1a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x1a][&clk_reg_tc_sel]=0x91
v.a \a_clock_data[&dbg_mux_gcc][0x1a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x1a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x1a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x1a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x1b][&clk_str_name]="gcc_blsp1_uart2_sim_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x1b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x1b][&clk_str_regname]="GCC_BLSP1_UART2_SIM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x1b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x1b][&clk_reg_cbc]=0x1803030
v.a \a_clock_data[&dbg_mux_gcc][0x1b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x1b][&clk_reg_tc_sel]=0x92
v.a \a_clock_data[&dbg_mux_gcc][0x1b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x1b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x1b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x1b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x1c][&clk_str_name]="gcc_blsp1_uart3_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x1c][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x1c][&clk_str_regname]="GCC_BLSP1_UART3_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x1c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x1c][&clk_reg_cbc]=0x180403c
v.a \a_clock_data[&dbg_mux_gcc][0x1c][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x1c][&clk_reg_tc_sel]=0x95
v.a \a_clock_data[&dbg_mux_gcc][0x1c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x1c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x1c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x1c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x1d][&clk_str_name]="gcc_blsp1_uart3_sim_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x1d][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x1d][&clk_str_regname]="GCC_BLSP1_UART3_SIM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x1d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x1d][&clk_reg_cbc]=0x1804040
v.a \a_clock_data[&dbg_mux_gcc][0x1d][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x1d][&clk_reg_tc_sel]=0x96
v.a \a_clock_data[&dbg_mux_gcc][0x1d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x1d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x1d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x1d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x1e][&clk_str_name]="gcc_blsp1_uart4_apps_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x1e][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x1e][&clk_str_regname]="GCC_BLSP1_UART4_APPS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x1e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x1e][&clk_reg_cbc]=0x180503c
v.a \a_clock_data[&dbg_mux_gcc][0x1e][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x1e][&clk_reg_tc_sel]=0x9a
v.a \a_clock_data[&dbg_mux_gcc][0x1e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x1e][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x1e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x1e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x1f][&clk_str_name]="gcc_blsp1_uart4_sim_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x1f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x1f][&clk_str_regname]="GCC_BLSP1_UART4_SIM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x1f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x1f][&clk_reg_cbc]=0x1805040
v.a \a_clock_data[&dbg_mux_gcc][0x1f][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x1f][&clk_reg_tc_sel]=0x9b
v.a \a_clock_data[&dbg_mux_gcc][0x1f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x1f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x1f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x1f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x20][&clk_str_name]="gcc_boot_rom_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x20][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x20][&clk_str_regname]="GCC_BOOT_ROM_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x20][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x20][&clk_reg_cbc]=0x181300c
v.a \a_clock_data[&dbg_mux_gcc][0x20][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x20][&clk_reg_tc_sel]=0xf8
v.a \a_clock_data[&dbg_mux_gcc][0x20][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x20][&clk_reg_vote_bit]=0x7
v.a \a_clock_data[&dbg_mux_gcc][0x20][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x20][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x21][&clk_str_name]="gcc_crypto_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x21][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x21][&clk_str_regname]="GCC_CRYPTO_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x21][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x21][&clk_reg_cbc]=0x1816024
v.a \a_clock_data[&dbg_mux_gcc][0x21][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x21][&clk_reg_tc_sel]=0x13a
v.a \a_clock_data[&dbg_mux_gcc][0x21][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x21][&clk_reg_vote_bit]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x21][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x21][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x22][&clk_str_name]="gcc_crypto_axi_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x22][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x22][&clk_str_regname]="GCC_CRYPTO_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x22][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x22][&clk_reg_cbc]=0x1816020
v.a \a_clock_data[&dbg_mux_gcc][0x22][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x22][&clk_reg_tc_sel]=0x139
v.a \a_clock_data[&dbg_mux_gcc][0x22][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x22][&clk_reg_vote_bit]=0x1
v.a \a_clock_data[&dbg_mux_gcc][0x22][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x22][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x23][&clk_str_name]="gcc_crypto_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x23][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x23][&clk_str_regname]="GCC_CRYPTO_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x23][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x23][&clk_reg_cbc]=0x181601c
v.a \a_clock_data[&dbg_mux_gcc][0x23][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x23][&clk_reg_tc_sel]=0x138
v.a \a_clock_data[&dbg_mux_gcc][0x23][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x23][&clk_reg_vote_bit]=0x2
v.a \a_clock_data[&dbg_mux_gcc][0x23][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x23][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x24][&clk_str_name]="gcc_dcc_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x24][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x24][&clk_str_regname]="GCC_DCC_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x24][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x24][&clk_reg_cbc]=0x1852004
v.a \a_clock_data[&dbg_mux_gcc][0x24][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x24][&clk_reg_tc_sel]=0x59
v.a \a_clock_data[&dbg_mux_gcc][0x24][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x24][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x24][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x24][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x25][&clk_str_name]="gcc_dcc_xo_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x25][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x25][&clk_str_regname]="GCC_DCC_XO_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x25][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x25][&clk_reg_cbc]=0x1852008
v.a \a_clock_data[&dbg_mux_gcc][0x25][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x25][&clk_reg_tc_sel]=0x58
v.a \a_clock_data[&dbg_mux_gcc][0x25][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x25][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x25][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x25][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x26][&clk_str_name]="gcc_ddr_dim_cfg_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x26][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x26][&clk_str_regname]="GCC_DDR_DIM_CFG_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x26][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x26][&clk_reg_cbc]=0x183201c
v.a \a_clock_data[&dbg_mux_gcc][0x26][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x26][&clk_reg_tc_sel]=0x158
v.a \a_clock_data[&dbg_mux_gcc][0x26][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x26][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x26][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x26][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x27][&clk_str_name]="gcc_ddr_dim_sleep_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x27][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x27][&clk_str_regname]="GCC_DDR_DIM_SLEEP_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x27][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x27][&clk_reg_cbc]=0x1832020
v.a \a_clock_data[&dbg_mux_gcc][0x27][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x27][&clk_reg_tc_sel]=0x15b
v.a \a_clock_data[&dbg_mux_gcc][0x27][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x27][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x27][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x27][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x28][&clk_str_name]="gcc_dehr_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x28][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x28][&clk_str_regname]="GCC_DEHR_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x28][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x28][&clk_reg_cbc]=0x181f004
v.a \a_clock_data[&dbg_mux_gcc][0x28][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x28][&clk_reg_tc_sel]=0x188
v.a \a_clock_data[&dbg_mux_gcc][0x28][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x28][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x28][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x28][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x29][&clk_str_name]="gcc_ecc_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x29][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x29][&clk_str_regname]="GCC_ECC_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x29][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x29][&clk_reg_cbc]=0x1851010
v.a \a_clock_data[&dbg_mux_gcc][0x29][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x29][&clk_reg_tc_sel]=0x50
v.a \a_clock_data[&dbg_mux_gcc][0x29][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x29][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x29][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x29][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x2a][&clk_str_name]="gcc_ecc_core_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x2a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x2a][&clk_str_regname]="GCC_ECC_CORE_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x2a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x2a][&clk_reg_cbc]=0x185100c
v.a \a_clock_data[&dbg_mux_gcc][0x2a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x2a][&clk_reg_tc_sel]=0x51
v.a \a_clock_data[&dbg_mux_gcc][0x2a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x2a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x2a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x2a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x2b][&clk_str_name]="gcc_gp1_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x2b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x2b][&clk_str_regname]="GCC_GP1_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x2b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x2b][&clk_reg_cbc]=0x1808000
v.a \a_clock_data[&dbg_mux_gcc][0x2b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x2b][&clk_reg_tc_sel]=0x10
v.a \a_clock_data[&dbg_mux_gcc][0x2b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x2b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x2b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x2b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x2c][&clk_str_name]="gcc_gp2_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x2c][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x2c][&clk_str_regname]="GCC_GP2_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x2c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x2c][&clk_reg_cbc]=0x1809000
v.a \a_clock_data[&dbg_mux_gcc][0x2c][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x2c][&clk_reg_tc_sel]=0x11
v.a \a_clock_data[&dbg_mux_gcc][0x2c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x2c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x2c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x2c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x2d][&clk_str_name]="gcc_gp3_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x2d][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x2d][&clk_str_regname]="GCC_GP3_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x2d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x2d][&clk_reg_cbc]=0x180a000
v.a \a_clock_data[&dbg_mux_gcc][0x2d][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x2d][&clk_reg_tc_sel]=0x12
v.a \a_clock_data[&dbg_mux_gcc][0x2d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x2d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x2d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x2d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x2e][&clk_str_name]="gcc_im_sleep_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x2e][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x2e][&clk_str_regname]="GCC_GCC_IM_SLEEP_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x2e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x2e][&clk_reg_cbc]=0x1830038
v.a \a_clock_data[&dbg_mux_gcc][0x2e][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x2e][&clk_reg_tc_sel]=0x14b
v.a \a_clock_data[&dbg_mux_gcc][0x2e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x2e][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x2e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x2e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x2f][&clk_str_name]="gcc_imem_axi_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x2f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x2f][&clk_str_regname]="GCC_IMEM_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x2f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x2f][&clk_reg_cbc]=0x180e004
v.a \a_clock_data[&dbg_mux_gcc][0x2f][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x2f][&clk_reg_tc_sel]=0x20
v.a \a_clock_data[&dbg_mux_gcc][0x2f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x2f][&clk_reg_vote_bit]=0x11
v.a \a_clock_data[&dbg_mux_gcc][0x2f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x2f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x30][&clk_str_name]="gcc_imem_cfg_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x30][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x30][&clk_str_regname]="GCC_IMEM_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x30][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x30][&clk_reg_cbc]=0x180e008
v.a \a_clock_data[&dbg_mux_gcc][0x30][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x30][&clk_reg_tc_sel]=0x21
v.a \a_clock_data[&dbg_mux_gcc][0x30][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x30][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x30][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x30][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x31][&clk_str_name]="gcc_mpm_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x31][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x31][&clk_str_regname]="GCC_MPM_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x31][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x31][&clk_reg_cbc]=0x182c008
v.a \a_clock_data[&dbg_mux_gcc][0x31][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x31][&clk_reg_tc_sel]=0x110
v.a \a_clock_data[&dbg_mux_gcc][0x31][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x31][&clk_reg_vote_bit]=0xc
v.a \a_clock_data[&dbg_mux_gcc][0x31][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x31][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x32][&clk_str_name]="gcc_msg_ram_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x32][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x32][&clk_str_regname]="GCC_MSG_RAM_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x32][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x32][&clk_reg_cbc]=0x182b004
v.a \a_clock_data[&dbg_mux_gcc][0x32][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x32][&clk_reg_tc_sel]=0x100
v.a \a_clock_data[&dbg_mux_gcc][0x32][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x32][&clk_reg_vote_bit]=0x6
v.a \a_clock_data[&dbg_mux_gcc][0x32][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x32][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x33][&clk_str_name]="gcc_mss_cfg_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x33][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x33][&clk_str_regname]="GCC_MSS_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x33][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x33][&clk_reg_cbc]=0x1849000
v.a \a_clock_data[&dbg_mux_gcc][0x33][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x33][&clk_reg_tc_sel]=0x30
v.a \a_clock_data[&dbg_mux_gcc][0x33][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x33][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x33][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x33][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x34][&clk_str_name]="gcc_mss_nav_ce_mpu_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x34][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x34][&clk_str_regname]="GCC_MSS_NAV_CE_MPU_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x34][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x34][&clk_reg_cbc]=0x1812108
v.a \a_clock_data[&dbg_mux_gcc][0x34][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x34][&clk_reg_tc_sel]=0x82
v.a \a_clock_data[&dbg_mux_gcc][0x34][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x34][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x34][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x34][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x35][&clk_str_name]="gcc_mss_nav_ce_vmidmt_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x35][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x35][&clk_str_regname]="GCC_MSS_NAV_CE_VMIDMT_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x35][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x35][&clk_reg_cbc]=0x1812118
v.a \a_clock_data[&dbg_mux_gcc][0x35][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x35][&clk_reg_tc_sel]=0x86
v.a \a_clock_data[&dbg_mux_gcc][0x35][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x35][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x35][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x35][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x36][&clk_str_name]="gcc_mss_q6_bimc_axi_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x36][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x36][&clk_str_regname]="GCC_MSS_Q6_BIMC_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x36][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x36][&clk_reg_cbc]=0x1849004
v.a \a_clock_data[&dbg_mux_gcc][0x36][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x36][&clk_reg_tc_sel]=0x31
v.a \a_clock_data[&dbg_mux_gcc][0x36][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x36][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x36][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x36][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x37][&clk_str_name]="gcc_mss_q6ss_axis_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x37][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x37][&clk_str_regname]="GCC_MSS_Q6SS_AXIS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x37][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x37][&clk_reg_cbc]=0x1849008
v.a \a_clock_data[&dbg_mux_gcc][0x37][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x37][&clk_reg_tc_sel]=0x33
v.a \a_clock_data[&dbg_mux_gcc][0x37][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x37][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x37][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x37][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x38][&clk_str_name]="gcc_noc_conf_xpu_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x38][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x38][&clk_str_regname]="GCC_NOC_CONF_XPU_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x38][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x38][&clk_reg_cbc]=0x1817000
v.a \a_clock_data[&dbg_mux_gcc][0x38][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x38][&clk_reg_tc_sel]=0x18
v.a \a_clock_data[&dbg_mux_gcc][0x38][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x38][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x38][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x38][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x39][&clk_str_name]="gcc_pcnoc_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x39][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x39][&clk_str_regname]="GCC_PCNOC_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x39][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x39][&clk_reg_cbc]=0x182701c
v.a \a_clock_data[&dbg_mux_gcc][0x39][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x39][&clk_reg_tc_sel]=0x8
v.a \a_clock_data[&dbg_mux_gcc][0x39][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x39][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x39][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x39][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x3a][&clk_str_name]="gcc_pcnoc_apss_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x3a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x3a][&clk_str_regname]="GCC_PCNOC_APSS_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x3a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x3a][&clk_reg_cbc]=0x1827030
v.a \a_clock_data[&dbg_mux_gcc][0x3a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x3a][&clk_reg_tc_sel]=0xe
v.a \a_clock_data[&dbg_mux_gcc][0x3a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x3a][&clk_reg_vote_bit]=0x10
v.a \a_clock_data[&dbg_mux_gcc][0x3a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x3a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x3b][&clk_str_name]="gcc_pcnoc_at_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x3b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x3b][&clk_str_regname]="GCC_PCNOC_AT_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x3b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x3b][&clk_reg_cbc]=0x1827028
v.a \a_clock_data[&dbg_mux_gcc][0x3b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x3b][&clk_reg_tc_sel]=0xc
v.a \a_clock_data[&dbg_mux_gcc][0x3b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x3b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x3b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x3b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x3c][&clk_str_name]="gcc_pcnoc_bus_timeout0_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x3c][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x3c][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT0_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x3c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x3c][&clk_reg_cbc]=0x1848004
v.a \a_clock_data[&dbg_mux_gcc][0x3c][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x3c][&clk_reg_tc_sel]=0x178
v.a \a_clock_data[&dbg_mux_gcc][0x3c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x3c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x3c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x3c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x3d][&clk_str_name]="gcc_pcnoc_bus_timeout10_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x3d][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x3d][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT10_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x3d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x3d][&clk_reg_cbc]=0x1848054
v.a \a_clock_data[&dbg_mux_gcc][0x3d][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x3d][&clk_reg_tc_sel]=0x185
v.a \a_clock_data[&dbg_mux_gcc][0x3d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x3d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x3d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x3d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x3e][&clk_str_name]="gcc_pcnoc_bus_timeout1_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x3e][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x3e][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT1_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x3e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x3e][&clk_reg_cbc]=0x184800c
v.a \a_clock_data[&dbg_mux_gcc][0x3e][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x3e][&clk_reg_tc_sel]=0x179
v.a \a_clock_data[&dbg_mux_gcc][0x3e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x3e][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x3e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x3e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x3f][&clk_str_name]="gcc_pcnoc_bus_timeout2_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x3f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x3f][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT2_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x3f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x3f][&clk_reg_cbc]=0x1848014
v.a \a_clock_data[&dbg_mux_gcc][0x3f][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x3f][&clk_reg_tc_sel]=0x17a
v.a \a_clock_data[&dbg_mux_gcc][0x3f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x3f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x3f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x3f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x40][&clk_str_name]="gcc_pcnoc_bus_timeout3_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x40][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x40][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT3_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x40][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x40][&clk_reg_cbc]=0x184801c
v.a \a_clock_data[&dbg_mux_gcc][0x40][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x40][&clk_reg_tc_sel]=0x17b
v.a \a_clock_data[&dbg_mux_gcc][0x40][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x40][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x40][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x40][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x41][&clk_str_name]="gcc_pcnoc_bus_timeout4_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x41][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x41][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT4_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x41][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x41][&clk_reg_cbc]=0x1848024
v.a \a_clock_data[&dbg_mux_gcc][0x41][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x41][&clk_reg_tc_sel]=0x17c
v.a \a_clock_data[&dbg_mux_gcc][0x41][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x41][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x41][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x41][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x42][&clk_str_name]="gcc_pcnoc_bus_timeout5_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x42][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x42][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT5_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x42][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x42][&clk_reg_cbc]=0x184802c
v.a \a_clock_data[&dbg_mux_gcc][0x42][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x42][&clk_reg_tc_sel]=0x180
v.a \a_clock_data[&dbg_mux_gcc][0x42][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x42][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x42][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x42][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x43][&clk_str_name]="gcc_pcnoc_bus_timeout6_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x43][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x43][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT6_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x43][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x43][&clk_reg_cbc]=0x1848034
v.a \a_clock_data[&dbg_mux_gcc][0x43][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x43][&clk_reg_tc_sel]=0x181
v.a \a_clock_data[&dbg_mux_gcc][0x43][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x43][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x43][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x43][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x44][&clk_str_name]="gcc_pcnoc_bus_timeout7_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x44][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x44][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT7_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x44][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x44][&clk_reg_cbc]=0x184803c
v.a \a_clock_data[&dbg_mux_gcc][0x44][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x44][&clk_reg_tc_sel]=0x182
v.a \a_clock_data[&dbg_mux_gcc][0x44][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x44][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x44][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x44][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x45][&clk_str_name]="gcc_pcnoc_bus_timeout8_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x45][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x45][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT8_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x45][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x45][&clk_reg_cbc]=0x1848044
v.a \a_clock_data[&dbg_mux_gcc][0x45][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x45][&clk_reg_tc_sel]=0x183
v.a \a_clock_data[&dbg_mux_gcc][0x45][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x45][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x45][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x45][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x46][&clk_str_name]="gcc_pcnoc_bus_timeout9_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x46][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x46][&clk_str_regname]="GCC_PCNOC_BUS_TIMEOUT9_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x46][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x46][&clk_reg_cbc]=0x184804c
v.a \a_clock_data[&dbg_mux_gcc][0x46][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x46][&clk_reg_tc_sel]=0x184
v.a \a_clock_data[&dbg_mux_gcc][0x46][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x46][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x46][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x46][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x47][&clk_str_name]="gcc_pcnoc_ddr_cfg_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x47][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x47][&clk_str_regname]="GCC_PCNOC_DDR_CFG_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x47][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x47][&clk_reg_cbc]=0x1832024
v.a \a_clock_data[&dbg_mux_gcc][0x47][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x47][&clk_reg_tc_sel]=0x15a
v.a \a_clock_data[&dbg_mux_gcc][0x47][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x47][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x47][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x47][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x48][&clk_str_name]="gcc_pcnoc_mpu_cfg_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x48][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x48][&clk_str_regname]="GCC_PCNOC_MPU_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x48][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x48][&clk_reg_cbc]=0x181700c
v.a \a_clock_data[&dbg_mux_gcc][0x48][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x48][&clk_reg_tc_sel]=0xc9
v.a \a_clock_data[&dbg_mux_gcc][0x48][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x48][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x48][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x48][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x49][&clk_str_name]="gcc_pcnoc_qdss_stm_axi_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x49][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x49][&clk_str_regname]="GCC_PCNOC_QDSS_STM_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x49][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x49][&clk_reg_cbc]=0x182702c
v.a \a_clock_data[&dbg_mux_gcc][0x49][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x49][&clk_reg_tc_sel]=0xd
v.a \a_clock_data[&dbg_mux_gcc][0x49][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x49][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x49][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x49][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x4a][&clk_str_name]="gcc_pcnoc_rpm_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x4a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x4a][&clk_str_regname]="GCC_PCNOC_RPM_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x4a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x4a][&clk_reg_cbc]=0x1827024
v.a \a_clock_data[&dbg_mux_gcc][0x4a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x4a][&clk_reg_tc_sel]=0xa
v.a \a_clock_data[&dbg_mux_gcc][0x4a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x4a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x4a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x4a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x4b][&clk_str_name]="gcc_pcnoc_snoc_mpu_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x4b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x4b][&clk_str_regname]="GCC_PCNOC_SNOC_MPU_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x4b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x4b][&clk_reg_cbc]=0x181210c
v.a \a_clock_data[&dbg_mux_gcc][0x4b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x4b][&clk_reg_tc_sel]=0x83
v.a \a_clock_data[&dbg_mux_gcc][0x4b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x4b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x4b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x4b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x4c][&clk_str_name]="gcc_pcnoc_snoc_vmidmt1_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x4c][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x4c][&clk_str_regname]="GCC_PCNOC_SNOC_VMIDMT1_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x4c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x4c][&clk_reg_cbc]=0x181211c
v.a \a_clock_data[&dbg_mux_gcc][0x4c][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x4c][&clk_reg_tc_sel]=0x87
v.a \a_clock_data[&dbg_mux_gcc][0x4c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x4c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x4c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x4c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x4d][&clk_str_name]="gcc_pcnoc_snoc_vmidmt2_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x4d][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x4d][&clk_str_regname]="GCC_PCNOC_SNOC_VMIDMT2_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x4d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x4d][&clk_reg_cbc]=0x1812120
v.a \a_clock_data[&dbg_mux_gcc][0x4d][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x4d][&clk_reg_tc_sel]=0x70
v.a \a_clock_data[&dbg_mux_gcc][0x4d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x4d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x4d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x4d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x4e][&clk_str_name]="gcc_pcnoc_snoc_vmidmt3_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x4e][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x4e][&clk_str_regname]="GCC_PCNOC_SNOC_VMIDMT3_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x4e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x4e][&clk_reg_cbc]=0x1812124
v.a \a_clock_data[&dbg_mux_gcc][0x4e][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x4e][&clk_reg_tc_sel]=0x71
v.a \a_clock_data[&dbg_mux_gcc][0x4e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x4e][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x4e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x4e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x4f][&clk_str_name]="gcc_pcnoc_snoc_vmidmt4_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x4f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x4f][&clk_str_regname]="GCC_PCNOC_SNOC_VMIDMT4_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x4f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x4f][&clk_reg_cbc]=0x1812128
v.a \a_clock_data[&dbg_mux_gcc][0x4f][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x4f][&clk_reg_tc_sel]=0x72
v.a \a_clock_data[&dbg_mux_gcc][0x4f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x4f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x4f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x4f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x50][&clk_str_name]="gcc_pcnoc_usb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x50][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x50][&clk_str_regname]="GCC_PCNOC_USB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x50][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x50][&clk_reg_cbc]=0x1827034
v.a \a_clock_data[&dbg_mux_gcc][0x50][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x50][&clk_reg_tc_sel]=0xf
v.a \a_clock_data[&dbg_mux_gcc][0x50][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x50][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x50][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x50][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x51][&clk_str_name]="gcc_pcnoc_xo_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x51][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x51][&clk_str_regname]="GCC_PCNOC_XO_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x51][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x51][&clk_reg_cbc]=0x1827038
v.a \a_clock_data[&dbg_mux_gcc][0x51][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x51][&clk_reg_tc_sel]=0x9
v.a \a_clock_data[&dbg_mux_gcc][0x51][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x51][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x51][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x51][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x52][&clk_str_name]="gcc_pdm2_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x52][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x52][&clk_str_regname]="GCC_PDM2_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x52][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x52][&clk_reg_cbc]=0x184400c
v.a \a_clock_data[&dbg_mux_gcc][0x52][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x52][&clk_reg_tc_sel]=0xd2
v.a \a_clock_data[&dbg_mux_gcc][0x52][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x52][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x52][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x52][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x53][&clk_str_name]="gcc_pdm_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x53][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x53][&clk_str_regname]="GCC_PDM_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x53][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x53][&clk_reg_cbc]=0x1844004
v.a \a_clock_data[&dbg_mux_gcc][0x53][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x53][&clk_reg_tc_sel]=0xd0
v.a \a_clock_data[&dbg_mux_gcc][0x53][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x53][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x53][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x53][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x54][&clk_str_name]="gcc_pdm_xo4_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x54][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x54][&clk_str_regname]="GCC_PDM_XO4_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x54][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x54][&clk_reg_cbc]=0x1844008
v.a \a_clock_data[&dbg_mux_gcc][0x54][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x54][&clk_reg_tc_sel]=0xd1
v.a \a_clock_data[&dbg_mux_gcc][0x54][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x54][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x54][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x54][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x55][&clk_str_name]="gcc_prng_ahb_bridge_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x55][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x55][&clk_str_regname]="GCC_PRNG_AHB_BRIDGE_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x55][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x55][&clk_reg_cbc]=0x1813028
v.a \a_clock_data[&dbg_mux_gcc][0x55][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x55][&clk_reg_tc_sel]=0xd9
v.a \a_clock_data[&dbg_mux_gcc][0x55][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x55][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x55][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x55][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x56][&clk_str_name]="gcc_prng_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x56][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x56][&clk_str_regname]="GCC_PRNG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x56][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x56][&clk_reg_cbc]=0x1813004
v.a \a_clock_data[&dbg_mux_gcc][0x56][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x56][&clk_reg_tc_sel]=0xd8
v.a \a_clock_data[&dbg_mux_gcc][0x56][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x56][&clk_reg_vote_bit]=0x8
v.a \a_clock_data[&dbg_mux_gcc][0x56][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x56][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x57][&clk_str_name]="gcc_prng_xpu_cfg_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x57][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x57][&clk_str_regname]="GCC_PRNG_XPU_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x57][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x57][&clk_reg_cbc]=0x1817008
v.a \a_clock_data[&dbg_mux_gcc][0x57][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x57][&clk_reg_tc_sel]=0xc8
v.a \a_clock_data[&dbg_mux_gcc][0x57][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x57][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x57][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x57][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x58][&clk_str_name]="gcc_pwm0_xo512_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x58][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x58][&clk_str_regname]="GCC_PWM0_XO512_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x58][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x58][&clk_reg_cbc]=0x1844018
v.a \a_clock_data[&dbg_mux_gcc][0x58][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x58][&clk_reg_tc_sel]=0xd3
v.a \a_clock_data[&dbg_mux_gcc][0x58][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x58][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x58][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x58][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x59][&clk_str_name]="gcc_q6_mpu_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x59][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x59][&clk_str_regname]="GCC_Q6_MPU_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x59][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x59][&clk_reg_cbc]=0x1812104
v.a \a_clock_data[&dbg_mux_gcc][0x59][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x59][&clk_reg_tc_sel]=0x81
v.a \a_clock_data[&dbg_mux_gcc][0x59][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x59][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x59][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x59][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x5a][&clk_str_name]="gcc_q6_vmidmt_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x5a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x5a][&clk_str_regname]="GCC_Q6_VMIDMT_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x5a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x5a][&clk_reg_cbc]=0x1812114
v.a \a_clock_data[&dbg_mux_gcc][0x5a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x5a][&clk_reg_tc_sel]=0x85
v.a \a_clock_data[&dbg_mux_gcc][0x5a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x5a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x5a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x5a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x5b][&clk_str_name]="gcc_qdss_at_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x5b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x5b][&clk_str_regname]="GCC_QDSS_AT_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x5b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x5b][&clk_reg_cbc]=0x1829024
v.a \a_clock_data[&dbg_mux_gcc][0x5b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x5b][&clk_reg_tc_sel]=0x42
v.a \a_clock_data[&dbg_mux_gcc][0x5b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x5b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x5b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x5b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x5c][&clk_str_name]="gcc_qdss_cfg_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x5c][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x5c][&clk_str_regname]="GCC_QDSS_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x5c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x5c][&clk_reg_cbc]=0x1829008
v.a \a_clock_data[&dbg_mux_gcc][0x5c][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x5c][&clk_reg_tc_sel]=0x41
v.a \a_clock_data[&dbg_mux_gcc][0x5c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x5c][&clk_reg_vote_bit]=0x14
v.a \a_clock_data[&dbg_mux_gcc][0x5c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x5c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x5d][&clk_str_name]="gcc_qdss_dap_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x5d][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x5d][&clk_str_regname]="GCC_QDSS_DAP_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x5d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x5d][&clk_reg_cbc]=0x1829004
v.a \a_clock_data[&dbg_mux_gcc][0x5d][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x5d][&clk_reg_tc_sel]=0x40
v.a \a_clock_data[&dbg_mux_gcc][0x5d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x5d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x5d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x5d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x5e][&clk_str_name]="gcc_qdss_dap_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x5e][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x5e][&clk_str_regname]="GCC_QDSS_DAP_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x5e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x5e][&clk_reg_cbc]=0x1829084
v.a \a_clock_data[&dbg_mux_gcc][0x5e][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x5e][&clk_reg_tc_sel]=0x49
v.a \a_clock_data[&dbg_mux_gcc][0x5e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x5e][&clk_reg_vote_bit]=0x13
v.a \a_clock_data[&dbg_mux_gcc][0x5e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x5e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x5f][&clk_str_name]="gcc_qdss_etr_usb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x5f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x5f][&clk_str_regname]="GCC_QDSS_ETR_USB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x5f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x5f][&clk_reg_cbc]=0x1829028
v.a \a_clock_data[&dbg_mux_gcc][0x5f][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x5f][&clk_reg_tc_sel]=0x43
v.a \a_clock_data[&dbg_mux_gcc][0x5f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x5f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x5f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x5f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x60][&clk_str_name]="gcc_qdss_stm_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x60][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x60][&clk_str_regname]="GCC_QDSS_STM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x60][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x60][&clk_reg_cbc]=0x1829044
v.a \a_clock_data[&dbg_mux_gcc][0x60][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x60][&clk_reg_tc_sel]=0x44
v.a \a_clock_data[&dbg_mux_gcc][0x60][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x60][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x60][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x60][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x61][&clk_str_name]="gcc_qdss_traceclkin_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x61][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x61][&clk_str_regname]="GCC_QDSS_TRACECLKIN_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x61][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x61][&clk_reg_cbc]=0x1829060
v.a \a_clock_data[&dbg_mux_gcc][0x61][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x61][&clk_reg_tc_sel]=0x45
v.a \a_clock_data[&dbg_mux_gcc][0x61][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x61][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x61][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x61][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x62][&clk_str_name]="gcc_qdss_trig_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x62][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x62][&clk_str_regname]="GCC_QDSS_TRIG_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x62][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x62][&clk_reg_cbc]=0x1829098
v.a \a_clock_data[&dbg_mux_gcc][0x62][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x62][&clk_reg_tc_sel]=0x4a
v.a \a_clock_data[&dbg_mux_gcc][0x62][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x62][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x62][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x62][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x63][&clk_str_name]="gcc_qdss_tsctr_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x63][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x63][&clk_str_regname]="GCC_QDSS_TSCTR_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x63][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x63][&clk_reg_cbc]=0x182907c
v.a \a_clock_data[&dbg_mux_gcc][0x63][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x63][&clk_reg_tc_sel]=0x46
v.a \a_clock_data[&dbg_mux_gcc][0x63][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x63][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x63][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x63][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x64][&clk_str_name]="gcc_qpic_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x64][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x64][&clk_str_regname]="GCC_QPIC_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x64][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x64][&clk_reg_cbc]=0x183f01c
v.a \a_clock_data[&dbg_mux_gcc][0x64][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x64][&clk_reg_tc_sel]=0x79
v.a \a_clock_data[&dbg_mux_gcc][0x64][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x64][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x64][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x64][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x65][&clk_str_name]="gcc_qpic_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x65][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x65][&clk_str_regname]="GCC_QPIC_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x65][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x65][&clk_reg_cbc]=0x183f018
v.a \a_clock_data[&dbg_mux_gcc][0x65][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x65][&clk_reg_tc_sel]=0x78
v.a \a_clock_data[&dbg_mux_gcc][0x65][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x65][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x65][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x65][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x66][&clk_str_name]="gcc_qpic_io_macro_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x66][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x66][&clk_str_regname]="GCC_QPIC_IO_MACRO_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x66][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x66][&clk_reg_cbc]=0x183f024
v.a \a_clock_data[&dbg_mux_gcc][0x66][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x66][&clk_reg_tc_sel]=0x7b
v.a \a_clock_data[&dbg_mux_gcc][0x66][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x66][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x66][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x66][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x67][&clk_str_name]="gcc_qpic_system_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x67][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x67][&clk_str_regname]="GCC_QPIC_SYSTEM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x67][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x67][&clk_reg_cbc]=0x183f020
v.a \a_clock_data[&dbg_mux_gcc][0x67][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x67][&clk_reg_tc_sel]=0x7a
v.a \a_clock_data[&dbg_mux_gcc][0x67][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x67][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x67][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x67][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x68][&clk_str_name]="gcc_qzip_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x68][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x68][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x68][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x68][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x68][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x68][&clk_reg_tc_sel]=0x69
v.a \a_clock_data[&dbg_mux_gcc][0x68][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x68][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x68][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x68][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x69][&clk_str_name]="gcc_rbcpr_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x69][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x69][&clk_str_regname]="GCC_RBCPR_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x69][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x69][&clk_reg_cbc]=0x1833008
v.a \a_clock_data[&dbg_mux_gcc][0x69][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x69][&clk_reg_tc_sel]=0x191
v.a \a_clock_data[&dbg_mux_gcc][0x69][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x69][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x69][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x69][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x6a][&clk_str_name]="gcc_rbcpr_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x6a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x6a][&clk_str_regname]="GCC_RBCPR_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x6a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x6a][&clk_reg_cbc]=0x1833004
v.a \a_clock_data[&dbg_mux_gcc][0x6a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x6a][&clk_reg_tc_sel]=0x190
v.a \a_clock_data[&dbg_mux_gcc][0x6a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x6a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x6a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x6b][&clk_str_name]="gcc_rpm_bus_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x6b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x6b][&clk_str_regname]="GCC_RPM_BUS_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x6b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x6b][&clk_reg_cbc]=0x182d004
v.a \a_clock_data[&dbg_mux_gcc][0x6b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x6b][&clk_reg_tc_sel]=0x11a
v.a \a_clock_data[&dbg_mux_gcc][0x6b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x6b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x6b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x6c][&clk_str_name]="gcc_rpm_cfg_xpu_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x6c][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x6c][&clk_str_regname]="GCC_RPM_CFG_XPU_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x6c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x6c][&clk_reg_cbc]=0x1817004
v.a \a_clock_data[&dbg_mux_gcc][0x6c][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x6c][&clk_reg_tc_sel]=0x38
v.a \a_clock_data[&dbg_mux_gcc][0x6c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x6c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x6c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x6d][&clk_str_name]="gcc_rpm_proc_fclk"
v.a \a_clock_str[&dbg_mux_gcc][0x6d][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x6d][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x6d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x6d][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6d][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x6d][&clk_reg_tc_sel]=0x118
v.a \a_clock_data[&dbg_mux_gcc][0x6d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x6d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x6d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x6e][&clk_str_name]="gcc_rpm_proc_hclk"
v.a \a_clock_str[&dbg_mux_gcc][0x6e][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x6e][&clk_str_regname]="GCC_RPM_PROC_HCLK_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x6e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x6e][&clk_reg_cbc]=0x182d000
v.a \a_clock_data[&dbg_mux_gcc][0x6e][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x6e][&clk_reg_tc_sel]=0x119
v.a \a_clock_data[&dbg_mux_gcc][0x6e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x6e][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x6e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x6f][&clk_str_name]="gcc_rpm_sleep_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x6f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x6f][&clk_str_regname]="GCC_RPM_SLEEP_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x6f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x6f][&clk_reg_cbc]=0x182d008
v.a \a_clock_data[&dbg_mux_gcc][0x6f][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x6f][&clk_reg_tc_sel]=0x11b
v.a \a_clock_data[&dbg_mux_gcc][0x6f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x6f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x6f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x6f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x70][&clk_str_name]="gcc_rpm_timer_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x70][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x70][&clk_str_regname]="GCC_RPM_TIMER_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x70][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x70][&clk_reg_cbc]=0x182d00c
v.a \a_clock_data[&dbg_mux_gcc][0x70][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x70][&clk_reg_tc_sel]=0x11c
v.a \a_clock_data[&dbg_mux_gcc][0x70][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x70][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x70][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x70][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x71][&clk_str_name]="gcc_sec_ctrl_acc_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x71][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x71][&clk_str_regname]="GCC_SEC_CTRL_ACC_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x71][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x71][&clk_reg_cbc]=0x181a020
v.a \a_clock_data[&dbg_mux_gcc][0x71][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x71][&clk_reg_tc_sel]=0x120
v.a \a_clock_data[&dbg_mux_gcc][0x71][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x71][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x71][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x71][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x72][&clk_str_name]="gcc_sec_ctrl_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x72][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x72][&clk_str_regname]="GCC_SEC_CTRL_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x72][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x72][&clk_reg_cbc]=0x181a024
v.a \a_clock_data[&dbg_mux_gcc][0x72][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x72][&clk_reg_tc_sel]=0x121
v.a \a_clock_data[&dbg_mux_gcc][0x72][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x72][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x72][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x72][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x73][&clk_str_name]="gcc_sec_ctrl_boot_rom_patch_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x73][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x73][&clk_str_regname]="GCC_SEC_CTRL_BOOT_ROM_PATCH_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x73][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x73][&clk_reg_cbc]=0x181a030
v.a \a_clock_data[&dbg_mux_gcc][0x73][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x73][&clk_reg_tc_sel]=0x124
v.a \a_clock_data[&dbg_mux_gcc][0x73][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x73][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x73][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x73][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x74][&clk_str_name]="gcc_sec_ctrl_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x74][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x74][&clk_str_regname]="GCC_SEC_CTRL_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x74][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x74][&clk_reg_cbc]=0x181a028
v.a \a_clock_data[&dbg_mux_gcc][0x74][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x74][&clk_reg_tc_sel]=0x122
v.a \a_clock_data[&dbg_mux_gcc][0x74][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x74][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x74][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x74][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x75][&clk_str_name]="gcc_sec_ctrl_sense_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x75][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x75][&clk_str_regname]="GCC_SEC_CTRL_SENSE_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x75][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x75][&clk_reg_cbc]=0x181a02c
v.a \a_clock_data[&dbg_mux_gcc][0x75][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x75][&clk_reg_tc_sel]=0x123
v.a \a_clock_data[&dbg_mux_gcc][0x75][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x75][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x75][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x75][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x76][&clk_str_name]="gcc_snoc_boot_imem_mpu_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x76][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x76][&clk_str_regname]="GCC_SNOC_BOOT_IMEM_MPU_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x76][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x76][&clk_reg_cbc]=0x1812110
v.a \a_clock_data[&dbg_mux_gcc][0x76][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x76][&clk_reg_tc_sel]=0x84
v.a \a_clock_data[&dbg_mux_gcc][0x76][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x76][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x76][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x76][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x77][&clk_str_name]="gcc_spdm_bimc_cy_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x77][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x77][&clk_str_regname]="GCC_SPDM_BIMC_CY_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x77][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x77][&clk_reg_cbc]=0x182f010
v.a \a_clock_data[&dbg_mux_gcc][0x77][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x77][&clk_reg_tc_sel]=0x133
v.a \a_clock_data[&dbg_mux_gcc][0x77][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x77][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x77][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x77][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x78][&clk_str_name]="gcc_spdm_cfg_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x78][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x78][&clk_str_regname]="GCC_SPDM_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x78][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x78][&clk_reg_cbc]=0x182f004
v.a \a_clock_data[&dbg_mux_gcc][0x78][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x78][&clk_reg_tc_sel]=0x130
v.a \a_clock_data[&dbg_mux_gcc][0x78][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x78][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x78][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x78][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x79][&clk_str_name]="gcc_spdm_ff_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x79][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x79][&clk_str_regname]="GCC_SPDM_FF_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x79][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x79][&clk_reg_cbc]=0x182f00c
v.a \a_clock_data[&dbg_mux_gcc][0x79][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x79][&clk_reg_tc_sel]=0x132
v.a \a_clock_data[&dbg_mux_gcc][0x79][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x79][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x79][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x79][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x7a][&clk_str_name]="gcc_spdm_mstr_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x7a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x7a][&clk_str_regname]="GCC_SPDM_MSTR_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x7a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x7a][&clk_reg_cbc]=0x182f008
v.a \a_clock_data[&dbg_mux_gcc][0x7a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x7a][&clk_reg_tc_sel]=0x131
v.a \a_clock_data[&dbg_mux_gcc][0x7a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x7a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x7a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x7a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x7b][&clk_str_name]="gcc_spdm_pcnoc_cy_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x7b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x7b][&clk_str_regname]="GCC_SPDM_PCNOC_CY_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x7b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x7b][&clk_reg_cbc]=0x182f01c
v.a \a_clock_data[&dbg_mux_gcc][0x7b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x7b][&clk_reg_tc_sel]=0x135
v.a \a_clock_data[&dbg_mux_gcc][0x7b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x7b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x7b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x7b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x7c][&clk_str_name]="gcc_spdm_rpm_cy_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x7c][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x7c][&clk_str_regname]="GCC_SPDM_RPM_CY_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x7c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x7c][&clk_reg_cbc]=0x182f020
v.a \a_clock_data[&dbg_mux_gcc][0x7c][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x7c][&clk_reg_tc_sel]=0x136
v.a \a_clock_data[&dbg_mux_gcc][0x7c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x7c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x7c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x7c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x7d][&clk_str_name]="gcc_spmi_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x7d][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x7d][&clk_str_regname]="GCC_SPMI_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x7d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x7d][&clk_reg_cbc]=0x182e03c
v.a \a_clock_data[&dbg_mux_gcc][0x7d][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x7d][&clk_reg_tc_sel]=0x12a
v.a \a_clock_data[&dbg_mux_gcc][0x7d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x7d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x7d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x7d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x7e][&clk_str_name]="gcc_spmi_pcnoc_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x7e][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x7e][&clk_str_regname]="GCC_SPMI_PCNOC_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x7e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x7e][&clk_reg_cbc]=0x182e020
v.a \a_clock_data[&dbg_mux_gcc][0x7e][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x7e][&clk_reg_tc_sel]=0x129
v.a \a_clock_data[&dbg_mux_gcc][0x7e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x7e][&clk_reg_vote_bit]=0x3
v.a \a_clock_data[&dbg_mux_gcc][0x7e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x7e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x7f][&clk_str_name]="gcc_spmi_ser_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x7f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x7f][&clk_str_regname]="GCC_SPMI_SER_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x7f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x7f][&clk_reg_cbc]=0x182e01c
v.a \a_clock_data[&dbg_mux_gcc][0x7f][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x7f][&clk_reg_tc_sel]=0x128
v.a \a_clock_data[&dbg_mux_gcc][0x7f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x7f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x7f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x7f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x80][&clk_str_name]="gcc_tcsr_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x80][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x80][&clk_str_regname]="GCC_TCSR_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x80][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x80][&clk_reg_cbc]=0x1828004
v.a \a_clock_data[&dbg_mux_gcc][0x80][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x80][&clk_reg_tc_sel]=0xf0
v.a \a_clock_data[&dbg_mux_gcc][0x80][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x80][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x80][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x80][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x81][&clk_str_name]="gcc_tic_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x81][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x81][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x81][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x81][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x81][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x81][&clk_reg_tc_sel]=0x68
v.a \a_clock_data[&dbg_mux_gcc][0x81][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x81][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x81][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x81][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x82][&clk_str_name]="gcc_tlmm_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x82][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x82][&clk_str_regname]="GCC_TLMM_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x82][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x82][&clk_reg_cbc]=0x1834004
v.a \a_clock_data[&dbg_mux_gcc][0x82][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x82][&clk_reg_tc_sel]=0x108
v.a \a_clock_data[&dbg_mux_gcc][0x82][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x82][&clk_reg_vote_bit]=0x5
v.a \a_clock_data[&dbg_mux_gcc][0x82][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x82][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x83][&clk_str_name]="gcc_tlmm_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x83][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x83][&clk_str_regname]="GCC_TLMM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x83][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x83][&clk_reg_cbc]=0x1834008
v.a \a_clock_data[&dbg_mux_gcc][0x83][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x83][&clk_reg_tc_sel]=0x109
v.a \a_clock_data[&dbg_mux_gcc][0x83][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x83][&clk_reg_vote_bit]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x83][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x83][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x84][&clk_str_name]="gcc_ultaudio_ahbfabric_efabric_spdm_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x84][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x84][&clk_str_regname]="GCC_ULTAUDIO_AHBFABRIC_EFABRIC_SPDM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x84][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x84][&clk_reg_cbc]=0x181c030
v.a \a_clock_data[&dbg_mux_gcc][0x84][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x84][&clk_reg_tc_sel]=0xee
v.a \a_clock_data[&dbg_mux_gcc][0x84][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x84][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x84][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x84][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x85][&clk_str_name]="gcc_ultaudio_ahbfabric_ixfabric_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x85][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x85][&clk_str_regname]="GCC_ULTAUDIO_AHBFABRIC_IXFABRIC_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x85][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x85][&clk_reg_cbc]=0x181c028
v.a \a_clock_data[&dbg_mux_gcc][0x85][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x85][&clk_reg_tc_sel]=0x1b0
v.a \a_clock_data[&dbg_mux_gcc][0x85][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x85][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x85][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x85][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x86][&clk_str_name]="gcc_ultaudio_ahbfabric_ixfabric_lpm_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x86][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x86][&clk_str_regname]="GCC_ULTAUDIO_AHBFABRIC_IXFABRIC_LPM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x86][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x86][&clk_reg_cbc]=0x181c024
v.a \a_clock_data[&dbg_mux_gcc][0x86][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x86][&clk_reg_tc_sel]=0x1b1
v.a \a_clock_data[&dbg_mux_gcc][0x86][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x86][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x86][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x86][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x87][&clk_str_name]="gcc_ultaudio_avsync_xo_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x87][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x87][&clk_str_regname]="GCC_ULTAUDIO_AVSYNC_XO_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x87][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x87][&clk_reg_cbc]=0x181c04c
v.a \a_clock_data[&dbg_mux_gcc][0x87][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x87][&clk_reg_tc_sel]=0x1b5
v.a \a_clock_data[&dbg_mux_gcc][0x87][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x87][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x87][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x87][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x88][&clk_str_name]="gcc_ultaudio_ext_mclk2_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x88][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x88][&clk_str_regname]="GCC_ULTAUDIO_EXT_MCLK2_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x88][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x88][&clk_reg_cbc]=0x181c0ec
v.a \a_clock_data[&dbg_mux_gcc][0x88][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x88][&clk_reg_tc_sel]=0xec
v.a \a_clock_data[&dbg_mux_gcc][0x88][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x88][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x88][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x88][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x89][&clk_str_name]="gcc_ultaudio_lpaif_aux_i2s_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x89][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x89][&clk_str_regname]="GCC_ULTAUDIO_LPAIF_AUX_I2S_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x89][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x89][&clk_reg_cbc]=0x181c098
v.a \a_clock_data[&dbg_mux_gcc][0x89][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x89][&clk_reg_tc_sel]=0x1b4
v.a \a_clock_data[&dbg_mux_gcc][0x89][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x89][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x89][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x89][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x8a][&clk_str_name]="gcc_ultaudio_lpaif_pri_i2s_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x8a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x8a][&clk_str_regname]="GCC_ULTAUDIO_LPAIF_PRI_I2S_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x8a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x8a][&clk_reg_cbc]=0x181c068
v.a \a_clock_data[&dbg_mux_gcc][0x8a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x8a][&clk_reg_tc_sel]=0x1b2
v.a \a_clock_data[&dbg_mux_gcc][0x8a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x8a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x8a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x8a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x8b][&clk_str_name]="gcc_ultaudio_lpaif_sec_i2s_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x8b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x8b][&clk_str_regname]="GCC_ULTAUDIO_LPAIF_SEC_I2S_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x8b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x8b][&clk_reg_cbc]=0x181c080
v.a \a_clock_data[&dbg_mux_gcc][0x8b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x8b][&clk_reg_tc_sel]=0x1b3
v.a \a_clock_data[&dbg_mux_gcc][0x8b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x8b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x8b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x8b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x8c][&clk_str_name]="gcc_ultaudio_pcm_data_oe_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x8c][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x8c][&clk_str_regname]="GCC_ULTAUDIO_PCM_DATA_OE_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x8c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x8c][&clk_reg_cbc]=0x181c104
v.a \a_clock_data[&dbg_mux_gcc][0x8c][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x8c][&clk_reg_tc_sel]=0xed
v.a \a_clock_data[&dbg_mux_gcc][0x8c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x8c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x8c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x8c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x8d][&clk_str_name]="gcc_ultaudio_pcnoc_mport_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x8d][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x8d][&clk_str_regname]="GCC_ULTAUDIO_PCNOC_MPORT_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x8d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x8d][&clk_reg_cbc]=0x181c000
v.a \a_clock_data[&dbg_mux_gcc][0x8d][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x8d][&clk_reg_tc_sel]=0x162
v.a \a_clock_data[&dbg_mux_gcc][0x8d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x8d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x8d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x8d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x8e][&clk_str_name]="gcc_ultaudio_pcnoc_sway_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x8e][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x8e][&clk_str_regname]="GCC_ULTAUDIO_PCNOC_SWAY_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x8e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x8e][&clk_reg_cbc]=0x181c004
v.a \a_clock_data[&dbg_mux_gcc][0x8e][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x8e][&clk_reg_tc_sel]=0x163
v.a \a_clock_data[&dbg_mux_gcc][0x8e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x8e][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x8e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x8e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x8f][&clk_str_name]="gcc_ultaudio_sec_pcm_data_oe_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x8f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x8f][&clk_str_regname]="GCC_ULTAUDIO_SEC_PCM_DATA_OE_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x8f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x8f][&clk_reg_cbc]=0x181c11c
v.a \a_clock_data[&dbg_mux_gcc][0x8f][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x8f][&clk_reg_tc_sel]=0xea
v.a \a_clock_data[&dbg_mux_gcc][0x8f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x8f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x8f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x8f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x90][&clk_str_name]="gcc_ultaudio_stc_xo_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x90][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x90][&clk_str_regname]="GCC_ULTAUDIO_STC_XO_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x90][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x90][&clk_reg_cbc]=0x181c050
v.a \a_clock_data[&dbg_mux_gcc][0x90][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x90][&clk_reg_tc_sel]=0x1b6
v.a \a_clock_data[&dbg_mux_gcc][0x90][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x90][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x90][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x90][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x91][&clk_str_name]="gcc_ultaudio_ter_pcm_data_oe_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x91][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x91][&clk_str_regname]="GCC_ULTAUDIO_TER_PCM_DATA_OE_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x91][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x91][&clk_reg_cbc]=0x181c134
v.a \a_clock_data[&dbg_mux_gcc][0x91][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x91][&clk_reg_tc_sel]=0xeb
v.a \a_clock_data[&dbg_mux_gcc][0x91][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x91][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x91][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x91][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x92][&clk_str_name]="gcc_usb2a_phy_sleep_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x92][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x92][&clk_str_regname]="GCC_USB2A_PHY_SLEEP_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x92][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x92][&clk_reg_cbc]=0x184102c
v.a \a_clock_data[&dbg_mux_gcc][0x92][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x92][&clk_reg_tc_sel]=0x63
v.a \a_clock_data[&dbg_mux_gcc][0x92][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x92][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x92][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x92][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x93][&clk_str_name]="gcc_usb_hs_inactivity_timers_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x93][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x93][&clk_str_regname]="GCC_USB_HS_INACTIVITY_TIMERS_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x93][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x93][&clk_reg_cbc]=0x184100c
v.a \a_clock_data[&dbg_mux_gcc][0x93][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x93][&clk_reg_tc_sel]=0x62
v.a \a_clock_data[&dbg_mux_gcc][0x93][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x93][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x93][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x93][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x94][&clk_str_name]="gcc_usb_hs_phy_cfg_ahb_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x94][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x94][&clk_str_regname]="GCC_USB_HS_PHY_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x94][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x94][&clk_reg_cbc]=0x1841030
v.a \a_clock_data[&dbg_mux_gcc][0x94][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x94][&clk_reg_tc_sel]=0x64
v.a \a_clock_data[&dbg_mux_gcc][0x94][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x94][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x94][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x94][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x95][&clk_str_name]="gcc_usb_hs_system_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x95][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x95][&clk_str_regname]="GCC_USB_HS_SYSTEM_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x95][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x95][&clk_reg_cbc]=0x1841004
v.a \a_clock_data[&dbg_mux_gcc][0x95][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x95][&clk_reg_tc_sel]=0x60
v.a \a_clock_data[&dbg_mux_gcc][0x95][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x95][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x95][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x95][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x96][&clk_str_name]="gcc_xo_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x96][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x96][&clk_str_regname]="GCC_GCC_XO_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x96][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x96][&clk_reg_cbc]=0x1830030
v.a \a_clock_data[&dbg_mux_gcc][0x96][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x96][&clk_reg_tc_sel]=0x149
v.a \a_clock_data[&dbg_mux_gcc][0x96][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x96][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x96][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x96][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x97][&clk_str_name]="gcc_xo_div4_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x97][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_gcc][0x97][&clk_str_regname]="GCC_GCC_XO_DIV4_CBCR"
v.a \a_clock_str[&dbg_mux_gcc][0x97][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x97][&clk_reg_cbc]=0x1830034
v.a \a_clock_data[&dbg_mux_gcc][0x97][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x97][&clk_reg_tc_sel]=0x14a
v.a \a_clock_data[&dbg_mux_gcc][0x97][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x97][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x97][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x97][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x98][&clk_str_name]="mpm_gcc_temp_sensor_ringosc_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x98][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x98][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x98][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x98][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x98][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x98][&clk_reg_tc_sel]=0x1c8
v.a \a_clock_data[&dbg_mux_gcc][0x98][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x98][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x98][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x98][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x99][&clk_str_name]="mss_gcc_dbg_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x99][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x99][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x99][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x99][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x99][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x99][&clk_reg_tc_sel]=0x32
v.a \a_clock_data[&dbg_mux_gcc][0x99][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x99][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x99][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x99][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x9a][&clk_str_name]="usb2_phy_gcc_atest_ulpi_0_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x9a][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x9a][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x9a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x9a][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x9a][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x9a][&clk_reg_tc_sel]=0x1a0
v.a \a_clock_data[&dbg_mux_gcc][0x9a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x9a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x9a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x9a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_gcc][0x9b][&clk_str_name]="usb2_phy_gcc_atest_ulpi_1_clk"
v.a \a_clock_str[&dbg_mux_gcc][0x9b][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x9b][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_gcc][0x9b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_gcc][0x9b][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x9b][&clk_reg_tc_mux]=&dbg_mux_gcc
v.a \a_clock_data[&dbg_mux_gcc][0x9b][&clk_reg_tc_sel]=0x1a8
v.a \a_clock_data[&dbg_mux_gcc][0x9b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_gcc][0x9b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_gcc][0x9b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_gcc][0x9b][&clk_reg_mux_input_en_mask]=0x0


; MSS_CC Controller Clock Names
v.a \a_clock_str[&dbg_mux_mss_cc][0x0][&clk_str_name]="clk_adc"
v.a \a_clock_str[&dbg_mux_mss_cc][0x0][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x0][&clk_str_regname]="MSS_ADC_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x0][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x0][&clk_reg_cbc]=0x41811c8
v.a \a_clock_data[&dbg_mux_mss_cc][0x0][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x0][&clk_reg_tc_sel]=0x8
v.a \a_clock_data[&dbg_mux_mss_cc][0x0][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x0][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x0][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x0][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x1][&clk_str_name]="clk_adc_div"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1][&clk_str_regname]="MSS_ADC_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x1][&clk_reg_cbc]=0x41811c8
v.a \a_clock_data[&dbg_mux_mss_cc][0x1][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x1][&clk_reg_tc_sel]=0x1c
v.a \a_clock_data[&dbg_mux_mss_cc][0x1][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x1][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x1][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x2][&clk_str_name]="clk_bus_atb"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2][&clk_str_regname]="MSS_BUS_ATB_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x2][&clk_reg_cbc]=0x41810b8
v.a \a_clock_data[&dbg_mux_mss_cc][0x2][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x2][&clk_reg_tc_sel]=0x33
v.a \a_clock_data[&dbg_mux_mss_cc][0x2][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x2][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x2][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x3][&clk_str_name]="clk_bus_bridge"
v.a \a_clock_str[&dbg_mux_mss_cc][0x3][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x3][&clk_str_regname]="MSS_BUS_BRIDGE_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x3][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x3][&clk_reg_cbc]=0x418109c
v.a \a_clock_data[&dbg_mux_mss_cc][0x3][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x3][&clk_reg_tc_sel]=0x2f
v.a \a_clock_data[&dbg_mux_mss_cc][0x3][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x3][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x3][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x3][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x4][&clk_str_name]="clk_bus_combodac_comp"
v.a \a_clock_str[&dbg_mux_mss_cc][0x4][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x4][&clk_str_regname]="MSS_BUS_COMBODAC_COMP_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x4][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x4][&clk_reg_cbc]=0x41810cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x4][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x4][&clk_reg_tc_sel]=0x2d
v.a \a_clock_data[&dbg_mux_mss_cc][0x4][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x4][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x4][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x4][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x5][&clk_str_name]="clk_bus_coxm"
v.a \a_clock_str[&dbg_mux_mss_cc][0x5][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x5][&clk_str_regname]="MSS_BUS_COXM_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x5][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x5][&clk_reg_cbc]=0x4181230
v.a \a_clock_data[&dbg_mux_mss_cc][0x5][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x5][&clk_reg_tc_sel]=0x30
v.a \a_clock_data[&dbg_mux_mss_cc][0x5][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x5][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x5][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x5][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x6][&clk_str_name]="clk_bus_csr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x6][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x6][&clk_str_regname]="MSS_BUS_CSR_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x6][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x6][&clk_reg_cbc]=0x4181098
v.a \a_clock_data[&dbg_mux_mss_cc][0x6][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x6][&clk_reg_tc_sel]=0x2e
v.a \a_clock_data[&dbg_mux_mss_cc][0x6][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x6][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x6][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x6][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x7][&clk_str_name]="clk_bus_div"
v.a \a_clock_str[&dbg_mux_mss_cc][0x7][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x7][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x7][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x7][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x7][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x7][&clk_reg_tc_sel]=0x3c
v.a \a_clock_data[&dbg_mux_mss_cc][0x7][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x7][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x7][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x7][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x8][&clk_str_name]="clk_bus_mgpi"
v.a \a_clock_str[&dbg_mux_mss_cc][0x8][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x8][&clk_str_regname]="MSS_BUS_MGPI_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x8][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x8][&clk_reg_cbc]=0x418119c
v.a \a_clock_data[&dbg_mux_mss_cc][0x8][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x8][&clk_reg_tc_sel]=0x36
v.a \a_clock_data[&dbg_mux_mss_cc][0x8][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x8][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x8][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x8][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x9][&clk_str_name]="clk_bus_modem"
v.a \a_clock_str[&dbg_mux_mss_cc][0x9][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x9][&clk_str_regname]="MSS_BUS_MODEM_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x9][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x9][&clk_reg_cbc]=0x41810a0
v.a \a_clock_data[&dbg_mux_mss_cc][0x9][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x9][&clk_reg_tc_sel]=0x22
v.a \a_clock_data[&dbg_mux_mss_cc][0x9][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x9][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x9][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x9][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0xa][&clk_str_name]="clk_bus_modem_bridge_cx"
v.a \a_clock_str[&dbg_mux_mss_cc][0xa][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0xa][&clk_str_regname]="MSS_BUS_MODEM_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0xa][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0xa][&clk_reg_cbc]=0x41810a0
v.a \a_clock_data[&dbg_mux_mss_cc][0xa][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0xa][&clk_reg_tc_sel]=0x21
v.a \a_clock_data[&dbg_mux_mss_cc][0xa][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0xa][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0xa][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0xa][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0xb][&clk_str_name]="clk_bus_nav"
v.a \a_clock_str[&dbg_mux_mss_cc][0xb][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0xb][&clk_str_regname]="MSS_BUS_NAV_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0xb][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0xb][&clk_reg_cbc]=0x41810b0
v.a \a_clock_data[&dbg_mux_mss_cc][0xb][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0xb][&clk_reg_tc_sel]=0x1b
v.a \a_clock_data[&dbg_mux_mss_cc][0xb][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0xb][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0xb][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0xb][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0xc][&clk_str_name]="clk_bus_nc_hm_bridge"
v.a \a_clock_str[&dbg_mux_mss_cc][0xc][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0xc][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0xc][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0xc][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0xc][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0xc][&clk_reg_tc_sel]=0x23
v.a \a_clock_data[&dbg_mux_mss_cc][0xc][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0xc][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0xc][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0xc][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0xd][&clk_str_name]="clk_bus_post_mux"
v.a \a_clock_str[&dbg_mux_mss_cc][0xd][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0xd][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0xd][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0xd][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0xd][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0xd][&clk_reg_tc_sel]=0x24
v.a \a_clock_data[&dbg_mux_mss_cc][0xd][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0xd][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0xd][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0xd][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0xe][&clk_str_name]="clk_bus_q6"
v.a \a_clock_str[&dbg_mux_mss_cc][0xe][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0xe][&clk_str_regname]="MSS_BUS_Q6_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0xe][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0xe][&clk_reg_cbc]=0x41810a4
v.a \a_clock_data[&dbg_mux_mss_cc][0xe][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0xe][&clk_reg_tc_sel]=0x3b
v.a \a_clock_data[&dbg_mux_mss_cc][0xe][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0xe][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0xe][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0xe][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0xf][&clk_str_name]="clk_bus_slave_timeout"
v.a \a_clock_str[&dbg_mux_mss_cc][0xf][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0xf][&clk_str_regname]="MSS_BUS_SLAVE_TIMEOUT_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0xf][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0xf][&clk_reg_cbc]=0x41810c4
v.a \a_clock_data[&dbg_mux_mss_cc][0xf][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0xf][&clk_reg_tc_sel]=0x31
v.a \a_clock_data[&dbg_mux_mss_cc][0xf][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0xf][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0xf][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0xf][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x10][&clk_str_name]="clk_bus_uim0"
v.a \a_clock_str[&dbg_mux_mss_cc][0x10][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x10][&clk_str_regname]="MSS_BUS_UIM0_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x10][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x10][&clk_reg_cbc]=0x4181090
v.a \a_clock_data[&dbg_mux_mss_cc][0x10][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x10][&clk_reg_tc_sel]=0x34
v.a \a_clock_data[&dbg_mux_mss_cc][0x10][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x10][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x10][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x10][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x11][&clk_str_name]="clk_coxm_bit"
v.a \a_clock_str[&dbg_mux_mss_cc][0x11][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x11][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x11][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x11][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x11][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x11][&clk_reg_tc_sel]=0x7
v.a \a_clock_data[&dbg_mux_mss_cc][0x11][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x11][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x11][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x11][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x12][&clk_str_name]="clk_dac"
v.a \a_clock_str[&dbg_mux_mss_cc][0x12][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x12][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x12][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x12][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x12][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x12][&clk_reg_tc_sel]=0x3d
v.a \a_clock_data[&dbg_mux_mss_cc][0x12][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x12][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x12][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x12][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x13][&clk_str_name]="clk_half_xo"
v.a \a_clock_str[&dbg_mux_mss_cc][0x13][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x13][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x13][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x13][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x13][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x13][&clk_reg_tc_sel]=0x25
v.a \a_clock_data[&dbg_mux_mss_cc][0x13][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x13][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x13][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x13][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x14][&clk_str_name]="clk_half_xo_cbc"
v.a \a_clock_str[&dbg_mux_mss_cc][0x14][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x14][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x14][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x14][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x14][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x14][&clk_reg_tc_sel]=0x19
v.a \a_clock_data[&dbg_mux_mss_cc][0x14][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x14][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x14][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x14][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x15][&clk_str_name]="clk_l1s_nav_mem"
v.a \a_clock_str[&dbg_mux_mss_cc][0x15][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x15][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x15][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x15][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x15][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x15][&clk_reg_tc_sel]=0x9
v.a \a_clock_data[&dbg_mux_mss_cc][0x15][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x15][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x15][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x15][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x16][&clk_str_name]="clk_modem_axi"
v.a \a_clock_str[&dbg_mux_mss_cc][0x16][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x16][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x16][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x16][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x16][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x16][&clk_reg_tc_sel]=0x3e
v.a \a_clock_data[&dbg_mux_mss_cc][0x16][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x16][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x16][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x16][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x17][&clk_str_name]="clk_modem_axi_cbc"
v.a \a_clock_str[&dbg_mux_mss_cc][0x17][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x17][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x17][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x17][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x17][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x17][&clk_reg_tc_sel]=0x3a
v.a \a_clock_data[&dbg_mux_mss_cc][0x17][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x17][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x17][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x17][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x18][&clk_str_name]="clk_modem_cfg_ahb"
v.a \a_clock_str[&dbg_mux_mss_cc][0x18][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x18][&clk_str_regname]="MSS_MODEM_CFG_AHB_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x18][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x18][&clk_reg_cbc]=0x41810d4
v.a \a_clock_data[&dbg_mux_mss_cc][0x18][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x18][&clk_reg_tc_sel]=0x2c
v.a \a_clock_data[&dbg_mux_mss_cc][0x18][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x18][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x18][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x18][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x19][&clk_str_name]="clk_modem_snoc_axi"
v.a \a_clock_str[&dbg_mux_mss_cc][0x19][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x19][&clk_str_regname]="MSS_MODEM_SNOC_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x19][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x19][&clk_reg_cbc]=0x41810d8
v.a \a_clock_data[&dbg_mux_mss_cc][0x19][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x19][&clk_reg_tc_sel]=0x2a
v.a \a_clock_data[&dbg_mux_mss_cc][0x19][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x19][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x19][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x19][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x1a][&clk_str_name]="clk_nav_dbe"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1a][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1a][&clk_str_regname]="MSS_NAV_DBE_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x1a][&clk_reg_cbc]=0x41811e0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1a][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x1a][&clk_reg_tc_sel]=0x12
v.a \a_clock_data[&dbg_mux_mss_cc][0x1a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x1a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x1a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x1b][&clk_str_name]="clk_nav_snoc_axi"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1b][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1b][&clk_str_regname]="MSS_NAV_SNOC_AXI_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x1b][&clk_reg_cbc]=0x41810dc
v.a \a_clock_data[&dbg_mux_mss_cc][0x1b][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x1b][&clk_reg_tc_sel]=0x2b
v.a \a_clock_data[&dbg_mux_mss_cc][0x1b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x1b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x1b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x1c][&clk_str_name]="clk_one_xo"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1c][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1c][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x1c][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1c][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x1c][&clk_reg_tc_sel]=0xb
v.a \a_clock_data[&dbg_mux_mss_cc][0x1c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x1c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x1c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x1d][&clk_str_name]="clk_one_xo_cbc"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1d][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1d][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x1d][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1d][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x1d][&clk_reg_tc_sel]=0x18
v.a \a_clock_data[&dbg_mux_mss_cc][0x1d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x1d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x1d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x1e][&clk_str_name]="clk_q6"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1e][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1e][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x1e][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1e][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x1e][&clk_reg_tc_sel]=0x11
v.a \a_clock_data[&dbg_mux_mss_cc][0x1e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x1e][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x1e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x1f][&clk_str_name]="clk_q6_pll2"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1f][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1f][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x1f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x1f][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1f][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x1f][&clk_reg_tc_sel]=0x17
v.a \a_clock_data[&dbg_mux_mss_cc][0x1f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x1f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x1f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x1f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x20][&clk_str_name]="clk_shared_mem"
v.a \a_clock_str[&dbg_mux_mss_cc][0x20][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x20][&clk_str_regname]="MSS_SHARED_MEM_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x20][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x20][&clk_reg_cbc]=0x41811e8
v.a \a_clock_data[&dbg_mux_mss_cc][0x20][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x20][&clk_reg_tc_sel]=0x20
v.a \a_clock_data[&dbg_mux_mss_cc][0x20][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x20][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x20][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x20][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x21][&clk_str_name]="clk_silver"
v.a \a_clock_str[&dbg_mux_mss_cc][0x21][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x21][&clk_str_regname]="MSS_SILVER_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x21][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x21][&clk_reg_cbc]=0x41811d8
v.a \a_clock_data[&dbg_mux_mss_cc][0x21][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x21][&clk_reg_tc_sel]=0xa
v.a \a_clock_data[&dbg_mux_mss_cc][0x21][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x21][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x21][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x21][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x22][&clk_str_name]="clk_src_bus"
v.a \a_clock_str[&dbg_mux_mss_cc][0x22][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x22][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x22][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x22][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x22][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x22][&clk_reg_tc_sel]=0x27
v.a \a_clock_data[&dbg_mux_mss_cc][0x22][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x22][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x22][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x22][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x23][&clk_str_name]="clk_src_coxm_bit"
v.a \a_clock_str[&dbg_mux_mss_cc][0x23][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x23][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x23][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x23][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x23][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x23][&clk_reg_tc_sel]=0x37
v.a \a_clock_data[&dbg_mux_mss_cc][0x23][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x23][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x23][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x23][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x24][&clk_str_name]="clk_src_sleep"
v.a \a_clock_str[&dbg_mux_mss_cc][0x24][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x24][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x24][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x24][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x24][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x24][&clk_reg_tc_sel]=0x26
v.a \a_clock_data[&dbg_mux_mss_cc][0x24][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x24][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x24][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x24][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x25][&clk_str_name]="clk_src_uim"
v.a \a_clock_str[&dbg_mux_mss_cc][0x25][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x25][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x25][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x25][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x25][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x25][&clk_reg_tc_sel]=0x28
v.a \a_clock_data[&dbg_mux_mss_cc][0x25][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x25][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x25][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x25][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x26][&clk_str_name]="clk_src_xo"
v.a \a_clock_str[&dbg_mux_mss_cc][0x26][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x26][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x26][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x26][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x26][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x26][&clk_reg_tc_sel]=0x29
v.a \a_clock_data[&dbg_mux_mss_cc][0x26][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x26][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x26][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x26][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x27][&clk_str_name]="clk_src_xo_mnd_uim0"
v.a \a_clock_str[&dbg_mux_mss_cc][0x27][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x27][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x27][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x27][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x27][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x27][&clk_reg_tc_sel]=0x35
v.a \a_clock_data[&dbg_mux_mss_cc][0x27][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x27][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x27][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x27][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x28][&clk_str_name]="clk_tdec"
v.a \a_clock_str[&dbg_mux_mss_cc][0x28][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x28][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x28][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x28][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x28][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x28][&clk_reg_tc_sel]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x28][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x28][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x28][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x28][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x29][&clk_str_name]="clk_two_xo"
v.a \a_clock_str[&dbg_mux_mss_cc][0x29][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x29][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x29][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x29][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x29][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x29][&clk_reg_tc_sel]=0xc
v.a \a_clock_data[&dbg_mux_mss_cc][0x29][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x29][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x29][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x29][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x2a][&clk_str_name]="clk_two_xo_cbc"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2a][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2a][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2a][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x2a][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2a][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x2a][&clk_reg_tc_sel]=0x39
v.a \a_clock_data[&dbg_mux_mss_cc][0x2a][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x2a][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x2a][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2a][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x2b][&clk_str_name]="clk_uim"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2b][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2b][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2b][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x2b][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2b][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x2b][&clk_reg_tc_sel]=0x10
v.a \a_clock_data[&dbg_mux_mss_cc][0x2b][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x2b][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x2b][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2b][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x2c][&clk_str_name]="clk_uim0"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2c][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2c][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2c][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x2c][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2c][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x2c][&clk_reg_tc_sel]=0x2
v.a \a_clock_data[&dbg_mux_mss_cc][0x2c][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x2c][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x2c][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2c][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x2d][&clk_str_name]="clk_uim_div"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2d][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2d][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2d][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x2d][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2d][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x2d][&clk_reg_tc_sel]=0xf
v.a \a_clock_data[&dbg_mux_mss_cc][0x2d][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x2d][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x2d][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2d][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x2e][&clk_str_name]="clk_xo_div12"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2e][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2e][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2e][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x2e][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2e][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x2e][&clk_reg_tc_sel]=0x1
v.a \a_clock_data[&dbg_mux_mss_cc][0x2e][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x2e][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x2e][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2e][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x2f][&clk_str_name]="clk_xo_modem"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2f][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2f][&clk_str_regname]="MSS_XO_MODEM_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x2f][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x2f][&clk_reg_cbc]=0x4181088
v.a \a_clock_data[&dbg_mux_mss_cc][0x2f][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x2f][&clk_reg_tc_sel]=0x6
v.a \a_clock_data[&dbg_mux_mss_cc][0x2f][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x2f][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x2f][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x2f][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x30][&clk_str_name]="clk_xo_uim0"
v.a \a_clock_str[&dbg_mux_mss_cc][0x30][&clk_str_type]="cbcr"
v.a \a_clock_str[&dbg_mux_mss_cc][0x30][&clk_str_regname]="MSS_XO_UIM0_CBCR"
v.a \a_clock_str[&dbg_mux_mss_cc][0x30][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x30][&clk_reg_cbc]=0x4181080
v.a \a_clock_data[&dbg_mux_mss_cc][0x30][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x30][&clk_reg_tc_sel]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x30][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x30][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x30][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x30][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x31][&clk_str_name]="mss_bus_alt_clk"
v.a \a_clock_str[&dbg_mux_mss_cc][0x31][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x31][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x31][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x31][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x31][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x31][&clk_reg_tc_sel]=0x1a
v.a \a_clock_data[&dbg_mux_mss_cc][0x31][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x31][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x31][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x31][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc][0x32][&clk_str_name]="xo_src_clk_dft"
v.a \a_clock_str[&dbg_mux_mss_cc][0x32][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x32][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc][0x32][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc][0x32][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x32][&clk_reg_tc_mux]=&dbg_mux_mss_cc
v.a \a_clock_data[&dbg_mux_mss_cc][0x32][&clk_reg_tc_sel]=0x16
v.a \a_clock_data[&dbg_mux_mss_cc][0x32][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc][0x32][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc][0x32][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc][0x32][&clk_reg_mux_input_en_mask]=0x0


; MSS_CC_Q6 Controller Clock Names
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x0][&clk_str_name]="mss_qdsp6ss_ahb_m_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x0][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x0][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x0][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x0][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x0][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x0][&clk_reg_tc_sel]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x0][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x0][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x0][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x0][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x1][&clk_str_name]="mss_qdsp6ss_ahb_s_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x1][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x1][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x1][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x1][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x1][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x1][&clk_reg_tc_sel]=0x5
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x1][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x1][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x1][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x1][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x2][&clk_str_name]="mss_qdsp6ss_apb_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x2][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x2][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x2][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x2][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x2][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x2][&clk_reg_tc_sel]=0xa
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x2][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x2][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x2][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x2][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x3][&clk_str_name]="mss_qdsp6ss_atb_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x3][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x3][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x3][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x3][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x3][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x3][&clk_reg_tc_sel]=0x9
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x3][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x3][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x3][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x3][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x4][&clk_str_name]="mss_qdsp6ss_axi_m_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x4][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x4][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x4][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x4][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x4][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x4][&clk_reg_tc_sel]=0x2
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x4][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x4][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x4][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x4][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x5][&clk_str_name]="mss_qdsp6ss_jtag_tck"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x5][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x5][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x5][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x5][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x5][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x5][&clk_reg_tc_sel]=0x8
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x5][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x5][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x5][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x5][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x6][&clk_str_name]="mss_qdsp6ss_ldo_nmo_out"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x6][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x6][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x6][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x6][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x6][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x6][&clk_reg_tc_sel]=0x3
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x6][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x6][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x6][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x6][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x7][&clk_str_name]="mss_qdsp6ss_q6_core_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x7][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x7][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x7][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x7][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x7][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x7][&clk_reg_tc_sel]=0x1
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x7][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x7][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x7][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x7][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x8][&clk_str_name]="mss_qdsp6ss_sleep_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x8][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x8][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x8][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x8][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x8][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x8][&clk_reg_tc_sel]=0x7
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x8][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x8][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x8][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x8][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x9][&clk_str_name]="mss_qdsp6ss_timestamp_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x9][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x9][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0x9][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x9][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x9][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x9][&clk_reg_tc_sel]=0xb
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x9][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x9][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x9][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0x9][&clk_reg_mux_input_en_mask]=0x0

v.a \a_clock_str[&dbg_mux_mss_cc_q6][0xa][&clk_str_name]="mss_qdsp6ss_xo_clk"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0xa][&clk_str_type]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0xa][&clk_str_regname]="None"
v.a \a_clock_str[&dbg_mux_mss_cc_q6][0xa][&clk_str_aliases]=""
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0xa][&clk_reg_cbc]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0xa][&clk_reg_tc_mux]=&dbg_mux_mss_cc_q6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0xa][&clk_reg_tc_sel]=0x6
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0xa][&clk_reg_total_div]=0x4
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0xa][&clk_reg_vote_bit]=-1.
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0xa][&clk_reg_mux_input_en_addr]=0x0
v.a \a_clock_data[&dbg_mux_mss_cc_q6][0xa][&clk_reg_mux_input_en_mask]=0x0



;-----------------------------------------------------------------------------
; Init testclock
;-----------------------------------------------------------------------------

local &AID
local &opts
local &create_area_param
local &success
local &testclock_main_area
local &invoked_by_script
local &launch_cmd_line
local &log_output
local &log_filename
local &prev_clk_grp
local &input_filename
local &got_input_filename
local &arg
local &num_unread
local &prev_cmd_line
local &clk_err
local &help_use_same_window
local &tc_mode

local &reset_window
&reset_window=0

&input_filename="c:\temp\testclock.txt"
&log_output=0
&prev_clk_grp=""
&prev_cmd_line=""

; Grab the entire launch command line.
ENTRY %LINE &launch_cmd_line

; Check if testclock was invoked in '__help_same_window__' mode.
&help_use_same_window=string.scan("&launch_cmd_line", "__help_same_window__", 0)
if (&help_use_same_window!=-1)
(
  &launch_cmd_line=string.replace("&launch_cmd_line", "__help_same_window__", "", 0)
)

; Detect '__tc__' mode.
&tc_mode=string.scan("&launch_cmd_line", "__tc__", 0)
if (&tc_mode!=-1)
(
  &tc_mode=1
  &launch_cmd_line=string.replace("&launch_cmd_line", "__tc__", "", 0)
)
else
(
  &tc_mode=0
)

; Clear any leftover help/history windows.
WINCLEAR testclock_help_window
WINCLEAR testclock_hist_window

; Check if testclock was invoked by another script ('super_script_area' mode).
&testclock_main_area=string.ScanAndExtract("&launch_cmd_line", "super_script_area=", "TESTCLOCK")

; Create new areas.
&create_area_param="2 TESTCLOCK_HELP 130. 1000. TESTCLOCK_HIST , ,"
if ("&testclock_main_area"=="TESTCLOCK")
(
  local &area_exists
  &area_exists=1

  &invoked_by_script=0

  ;
  ; Allow 'tc' mode to avoid clearing the area ('area.create' clears areas if
  ; it is given row/col dimensions for the area buffer)
  ;
  if (&tc_mode!=0)
  (
    gosub wa_does_area_exist TESTCLOCK
    entry &area_exists
  )

  if ((&tc_mode==0)||(&area_exists==0))
  (
    &create_area_param="3 TESTCLOCK 180. 1000. TESTCLOCK_HELP 130. 1000. TESTCLOCK_HIST , ,"
  )
)
else
(
  &invoked_by_script=1

  ; cut the 'super_script_area' argument out of the launch command line.
  &launch_cmd_line=string.replace("&launch_cmd_line", "super_script_area=&testclock_main_area", "", 0)
)

gosub wa_area_create_list &create_area_param
entry &success
if (&success==0)
(
  area.select
  print %ERROR "ERROR: Failed to create areas for testclock.cmm."
  enddo
)

; Create a new window if needed.
if (WIN.EXIST("testclock_main_window")==FALSE())
(
  local &x_start
  local &y_start
  local &x_len
  local &y_len

  ; Check if there are previously saved window settings.
  gosub wa_find_saved_window_settings testclock_main_window
  entry &x_start &y_start &x_len &y_len

  if (&x_start!=-1)
  (
    ; Use the previous window settings.
    winpos &x_start &y_start &x_len &y_len 0. 0. testclock_main_window
  )
  else
  (
    gosub Default_WINPOS_Main
  )
)

area.view &testclock_main_area
area.select &testclock_main_area

; Initialize the argument bufferer with the launch command line.
gosub args_main create_client clk_drv &testclock_main_area &launch_cmd_line
entry &AID
if ("&AID"=="ARGS_ERR")
(
  gosub args_main get_error
  entry &clk_err

  print %ERROR "ERROR: Failed to create an ARGS client:"
  print %ERROR "       '&clk_err'."
  enddo
)

; Set bufferer options.
&opts="print_errors=1 help_cmd=? help_sub=Display_Help"
&opts="&opts hist_cmd=hist hist_sub=Display_Hist"
gosub args_main set_opts &AID &opts
entry &clk_err
if ("&clk_err"=="ARGS_ERR")
(
  gosub args_main get_error
  entry &clk_err

  print %ERROR "ERROR: Failed to set ARGS options:"
  print %ERROR "       '&clk_err'."

  enddo
)

; Set generic testclock error handler.
ON ERROR gosub
(
  print %ERROR ERROR.ADDRESS()
  print %ERROR "ERROR: Testclock error occurred:"
  print %ERROR "       Last command='&arg'. Last clock group='&clk'."
  return
)

; Print banner before entering main loop.
print ""
print "[-------------------- [&chipset_name] TEST CLOCK TOOL --------------------]"
print ""


;-----------------------------------------------------------------------------
; Argument handler main loop
;-----------------------------------------------------------------------------

Main_Loop:
(
  &clk_err=""

  ;
  ; Reset testclock argument handler state.
  ;
  &repeat_prev_cmd=0
  &header_printed=0
  &state_change=""
  &got_input_filename=0

  ;
  ; Get next command header arg.
  ;
  gosub args_main get_num_unread &AID
  entry &num_unread
  if (&num_unread==0)
  (
    local &line

    gosub args_main get_cmd_line &AID
    entry %LINE &line

    if (("&line"!=".")&&("&line"!=""))
    (
      &prev_cmd_line="&line"
    )

    ; If the history window is open, go ahead and update it.
    if (WIN.EXIST("testclock_hist_window")==TRUE())
    (
      gosub Display_Hist SKIP_VIEW
    )

    print ""
    print "[testclock.cmm] Version: <&gendate>"
  )

  gosub args_main get_arg &AID Enter command ('?' for help) >
  entry &arg

  gosub wa_save_window_settings testclock_hist_window
  gosub wa_save_window_settings testclock_main_window

  ;
  ; Pre-process the command header arg.
  ;
  if (("&arg"==".")||("&arg"==""))
  (
    if ("&prev_cmd_line"=="")
    (
      print %ERROR "No previous command to repeat."
      goto Main_Loop
    )

    ; Prepare to repeat the previous command line.
    gosub args_main reset_cmd_line &AID &prev_cmd_line
    gosub args_main get_arg &AID
    entry &arg

    &repeat_prev_cmd=1
  )

  if (("&arg"=="on")||("&arg"=="off"))
  (
    ; Set state change command.
    &state_change="&arg"

    ; Check if a new clock selection is specified.
    gosub args_main get_num_unread &AID
    entry &num_unread
    if (&num_unread==0)
    (
      ; Use previous clock selection for state change operation.
      if ("&prev_clk_grp"=="")
      (
        print %ERROR "Command '&arg' failed. No clock(s) were previously selected."
        goto Main_Loop
      )
      &arg="&prev_clk_grp"
    )
    else
    (
      ; Extract new clock selection from buffered command line.
      gosub args_main get_arg &AID
      entry &arg
    )

    if ("&arg"=="file")
    (
      ; Check if a new clock file input is specified.
      gosub args_main get_num_unread &AID
      entry &num_unread
      if (&num_unread!=0)
      (
        ; Extract new clock file input from buffered command line.
        gosub args_main get_arg &AID
        entry &input_filename
      )

      ; Record that the file name is already known.
      &got_input_filename=1
    )
  )

  ;
  ; Execute the command operation.
  ;
  if ("&arg"=="x")
  (
    goto Exit_Testclock
  )
  else if ("&arg"=="wr")
  (
    &reset_window=1

    ; Reset the window size/position to default settings.
    winclear testclock_help_window
    winclear testclock_hist_window
    winclear testclock_main_window

    gosub Default_WINPOS_Main
    area.view &testclock_main_area
  )
  else if ("&arg"=="gpio")
  (
    gosub Configure_GPIO
  )
  else if ("&arg"=="log")
  (
    ; Check if output is already being logged.
    if (&log_output==0)
    (
      ; Output not currently logged--prompt user for new log file name
      local &filename
      gosub args_main get_arg &AID Enter log output file (default 'c:\temp\testclock_out.log') >
      entry &filename

      if ("&filename"=="close")
      (
        print %ERROR "No open output log to close."
      )
      else
      (
        if ("&filename"=="")
        (
          &log_filename="c:\temp\testclock_out.log"
        )
        else
        (
          &log_filename="&filename"
        )
        print "Logging testclock output to '&log_filename'."

        ; Open the output log file.
        (
          ON ERROR gosub
          (
            print %ERROR "ERROR: Failed to open clock output log '&log_filename'."
            &clk_err="failed_to_open_log_out"
            return
          )
          AREA.open &testclock_main_area &log_filename
        )

        if ("&clk_err"!="failed_to_open_log_out")
        (
          &log_output=1
        )
      )
    )
    else
    (
      local &log_arg

      gosub args_main get_arg &AID Stop logging output and close '&log_filename'? [close|n] >
      entry &log_arg

      if ("&log_arg"=="close")
      (
        AREA.close &testclock_main_area
        &log_output=0
        print "Closed '&log_filename' and stopped logging output."
      )
      else
      (
        print "Did not close the open output log '&log_filename'."
      )
    )
  )
  else if ("&arg"=="file")
  (
    local &input_line

    ; Get the input filename if necessary.
    if (&got_input_filename==0)
    (
      local &prompt_filename

      gosub args_main get_arg &AID Enter input file (default 'c:\temp\testclock.txt') >
      entry &prompt_filename

      if ("&prompt_filename"!="")
      (
        &input_filename="&prompt_filename"
      )
    )

    ; Open the clock input file
    (
      ON ERROR gosub
      (
        print %ERROR "ERROR: Failed to open clock list file '&input_filename'."
        &clk_err="failed_to_open_file_in"
        return
      )
      OPEN #1 &input_filename /Read
    )

    if ("&clk_err"!="failed_to_open_file_in")
    (
      print "Operating on list of clocks from '&input_filename'."

      READ #1 %line &input_line
      WHILE !EOF()
      (
        &input_line=string.trim("&input_line")

        if (STRING.SCAN("&input_line", "print", 0)==0)
        (
          &input_line=string.cut("&input_line", 6)
          print "&input_line"
        )
        else if ("&input_line"!="")
        (
          gosub Find_Print_Clock &input_line
        )

        READ #1 %line &input_line
      )
      CLOSE #1
    )

    &prev_clk_grp="&arg"
  )
  else if (("&arg"=="all")||("&arg"=="all_on")||("&arg"=="all_off"))
  (
    &clk_state_filter="&arg"
    gosub Print_All
    &prev_clk_grp="&arg"
  )
  else
  (
    ; Assume argument is a clock group
    local &printed_ss_clock_info
    gosub Print_All_SS &arg
    entry &printed_ss_clock_info

    if (&printed_ss_clock_info==0)
    (
      ; Didn't match a SS clock group--attempt to operate on non-SS clock group
      gosub Find_Print_Clock &arg
    )

    &prev_clk_grp="&arg"
  )

  goto Main_Loop
)

;
; Sets up the default window position/size for the main window.
;
Default_WINPOS_Main:
(
  winpos 0. 0. 150. 100% 0. 0. testclock_main_window
  return
)

;
; Sets up the default window position/size for the history window.
;
Default_WINPOS_Hist:
(
  winpos 155. 0. 50. 50% 0. 0. testclock_hist_window
  return
)

;-----------------------------------------------------------------------------
; Exit testclock
;-----------------------------------------------------------------------------

Exit_Testclock:
(
  winclear testclock_help_window

  if ((&tc_mode==0)||(&reset_window!=0))  ; skip saving a second time for 'tc' mode.
  (
    gosub wa_save_window_settings testclock_hist_window
    gosub wa_save_window_settings testclock_main_window
  )

  ; Close the output log if needed.
  if (&log_output!=0)
  (
    area.close &testclock_main_area
  )

  winclear testclock_hist_window
  if (&tc_mode==0)
  (
    winclear testclock_main_window
  )

  area.select   ; select default area

  print "Exited [&chipset_name] 'testclock.cmm'."
  enddo
)

;-----------------------------------------------------------------------------
; Display history
;-----------------------------------------------------------------------------

Display_Hist:
(
  local &skip_view
  entry &skip_view

  ; Display the help area if required.
  if ("&skip_view"=="")
  (
    if (WIN.EXIST("testclock_hist_window")==FALSE())
    (
      local &x_start
      local &y_start
      local &x_len
      local &y_len

      ; Check if there are previously saved window settings.
      gosub wa_find_saved_window_settings testclock_hist_window
      entry &x_start &y_start &x_len &y_len

      if (&x_start!=-1)
      (
        ; Use the previous window settings.
        winpos &x_start &y_start &x_len &y_len 0. 0. testclock_hist_window
      )
      else
      (
        gosub Default_WINPOS_Hist
      )
    )

    area.view TESTCLOCK_HIST
    wintop testclock_hist_window
  )

  area.clear TESTCLOCK_HIST
  area.select TESTCLOCK_HIST

  ; Print the history entries.
  print ""
  print "[--- [&chipset_name] testclock.cmm history: ---]"
  print ""
  gosub args_main print_hist &AID

  ; Switch back to the main demo window.
  area.select &testclock_main_area

  return
)

;-----------------------------------------------------------------------------
; Display help
;-----------------------------------------------------------------------------

Display_Help:
(
  ;-----------------------------------------------------------------------------
  ; Display available clock sources that can be output to the clock test output
  ; and prompt for selection.
  ;-----------------------------------------------------------------------------

  ; If the history window is open, go ahead and update it.
  if (WIN.EXIST("testclock_hist_window")==TRUE())
  (
    gosub Display_Hist SKIP_VIEW
  )

  if (&help_use_same_window==-1)
  (
    if (WIN.EXIST("testclock_help_window")==FALSE())
    (
      WINPOS , , , , , , testclock_help_window
    )

    area.view TESTCLOCK_HELP
    area.clear TESTCLOCK_HELP
    area.select TESTCLOCK_HELP

    winresize 130. 28.
  )

  print ""
  print ""
  gosub Print_Clock_Help
  print ""
  print ""

  print "*** Commands ***"
  print ""
  print "  <clk_group>      - Print the status of a single clock or clock group."
  print "  on/off [clks]    - Modifies on/off state of clock(s). If a new clock group"
  print "                     isn't given, the previously selected clock group is used."

  print "  gpio             - Enable GPIO's for clock output."
  print "  log <name|close> - Begin/end logging output to a file (closes upon 'x' exit)."
  print "  x [.]            - Exit [and leave the main window displayed]."
  print "  ?                - Display help message."
  print "  .                - Repeat previous command. Entering an empty line will also"
  print "                     repeat the previous command."
  print "  hist             - Display a testclock history window."
  print "  wr               - Reset the script window size/position."
  print ""

  print "*** Clock Groups ***"
  print ""
  print "  all          - All clocks."
  print "  all_on       - All clocks that are on."
  print "  all_off      - All clocks that are off."
  print "  <ss>_all     - All subsystem clocks."
  print "  <wildcard>   - Search query."
  print "  buses        - All bus clocks."
  print "  cpus         - All cpu clocks."
  print "  file <name>  - File specifying enumerated clocks (separated by newlines)."
  print "                 If a file name is not given, the previous input file is"
  print "                 used (default 'c:\temp\testclock.txt')."
  print ""

  area.select &testclock_main_area

  return
)

;-----------------------------------------------------------------------------
; Display help
;-----------------------------------------------------------------------------

Help:

  ;-----------------------------------------------------------------------------
  ; Display available clock sources that can be output to the clock test output
  ; and prompt for selection.
  ;-----------------------------------------------------------------------------

  AREA.Create HELP 130. 1000.
  AREA.View HELP
  AREA.Select HELP
  winresize 130. 24.

  print " "
  print " "
  gosub Print_Clock_Help
  print ""
  print "*** Clock groups***   "
  print "  all        - all clocks"
  print "  all_on     - all clocks that are on"
  print "  <ss>_all   - all subsystem clocks"
  print "  <wildcard> - search query"
  print "  file       - file specifying enumerated clocks (separated by newlines)"
  print "  on/off     - modifies on/off state of previously selected clock(s)"
  print "  buses      - show all bus clocks"
  print "  cpus       - show all cpu clocks"
  
  print "*** Other options ***"
  print "  x   - exit"
  print "  ?   - help"
  print "  .   - repeat (also carriage return without any arguments)" 
  print "*** Debug options ***"
  print "   gpio       - enable GPIO's for clock output"
  print ""

  AREA.Select CLOCK

  return


;-----------------------------------------------------------------------------
; Determine clock frequency.
;-----------------------------------------------------------------------------

Calc_Clock_Freq:

  local &l2cpucpselr_val
  local &l2cpucpcpdr_val

  ; Save current values
  &xo_div4_cbcr=data.long(&access_mode:&xo_div4_cbcr_addr)
  
  ; Measure a short run
  &tcxo_count=0x800
  
  ; Config XO DIV4 comparator clock
  data.set &access_mode:&xo_div4_cbcr_addr %LONG data.long(&access_mode:&xo_div4_cbcr_addr)|0x1
  
  ; Start with the counter disabled 
  &measure_ctl=data.long(&access_mode:&frq_measure_ctl_addr)
  &measure_ctl=&measure_ctl&~0x1FFFFF
  data.set &access_mode:&frq_measure_ctl_addr %LONG &measure_ctl
  
  ; Program the starting counter value, high enough to get good accuracy
  &measure_ctl=&measure_ctl|&tcxo_count
  
  ; Start the counting
  &measure_ctl=&measure_ctl|0x100000
  data.set &access_mode:&frq_measure_ctl_addr %LONG &measure_ctl
  
  ; Wait for the counters to finish
  wait 1.ms
  while (data.long(&access_mode:&frq_measure_status_addr)&0x2000000)==0
  (
  )
  
  ; Turn off the test clock and read the clock count
  &measure_ctl=data.long(&access_mode:&frq_measure_ctl_addr)
  data.set &access_mode:&frq_measure_ctl_addr %LONG (&measure_ctl&~0x100000)
  
  &short_clock_count=data.long(&access_mode:&frq_measure_status_addr)&0x1FFFFFF
  
  ; Restore the registers
  data.set &access_mode:&xo_div4_cbcr_addr %LONG &xo_div4_cbcr
 
  ; Now do a longer count and compare
  ; Save current values
  &xo_div4_cbcr=data.long(&access_mode:&xo_div4_cbcr_addr)
  
  &tcxo_count=0x8000
  
  ; Config XO DIV4 comparator clock
  data.set &access_mode:&xo_div4_cbcr_addr %LONG data.long(&access_mode:&xo_div4_cbcr_addr)|0x1
  
  ; Start with the counter disabled 
  &measure_ctl=data.long(&access_mode:&frq_measure_ctl_addr)
  &measure_ctl=&measure_ctl&~0x1FFFFF
  data.set &access_mode:&frq_measure_ctl_addr %LONG &measure_ctl
  
  ; Program the starting counter value, high enough to get good accuracy
  &measure_ctl=&measure_ctl|&tcxo_count
  
  ; Start the counting
  &measure_ctl=&measure_ctl|0x100000
  data.set &access_mode:&frq_measure_ctl_addr %LONG &measure_ctl
  
  ; Wait for the counters to finish
  wait 1.ms
  while (data.long(&access_mode:&frq_measure_status_addr)&0x2000000)==0
  (
  )
  
  ; Turn off the test clock and read the clock count
  &measure_ctl=data.long(&access_mode:&frq_measure_ctl_addr)
  data.set &access_mode:&frq_measure_ctl_addr %LONG (&measure_ctl&~0x100000)
  
  &clock_count=data.long(&access_mode:&frq_measure_status_addr)&0x1FFFFFF
  
  ; Calculate the frequency.  Function is provided by
  ; Power Control 42.8.1.2 Measurement technique
  ; f ring = f tcxo/4 * (Nring + 1.5) / (TCtcxo + 3.5)
  ;
  ; The formula below is the equivalent one converted
  ; to integer arithmetic.
  ; 
  ; We add half of the denominator value to the dividend
  ; to guard against rounding errors inherent to
  ; integer arithmetic.
  ;
  
  if &clock_count==&short_clock_count
  (
    &clk_freq=0
  )
  else
  (
    &clk_freq=4.8*(&clock_count+1.5)/(&tcxo_count+3.5)
  )
  
  ; Restore the registers
  data.set &access_mode:&xo_div4_cbcr_addr %LONG &xo_div4_cbcr

  return


;-----------------------------------------------------------------------------
; Display clock info header
;-----------------------------------------------------------------------------

Print_Header:

  if &header_printed==0
  (
    print ""
    print "Clock                                   State    Frequency (MHz)        Debug Mux CBCR Addr  Value         CBCR Type Aliases"
    print "----------------------------------------------------------------------------------------------------------------------"

    &header_printed=1
  )

  return




;-----------------------------------------------------------------------------
; Display clock info line
;-----------------------------------------------------------------------------

Print_Clk_Info_Line:
  local &is_on &clk_freq &clk_reg_val &on_reg &on_mask &clk_access_mode

  &clk_access_mode=var.string(\a_dbg_mux_str[&clk_test_mux][&dbg_mux_str_access_mode])

  ;-----------------------------------------------------------------------------
  ; Toggle clock state if requested
  ;-----------------------------------------------------------------------------
  if (&clk_reg!=0)
  (
    if &clk_vote_bit!=-1.
    (
      &vote_idx=&clk_vote_bit/32.
      &on_reg=v.value(\vote_regs[&vote_idx])
      &on_mask=(1<<(&clk_vote_bit-(32.*&vote_idx)))
    )
    else
    (
      &on_reg="&clk_reg"
      &on_mask=0x1
    )

    if "&state_change"=="on"
    (
      data.set &clk_access_mode:&on_reg %LONG (data.long(&clk_access_mode:&on_reg)|&on_mask)
    )
    else if "&state_change"=="off"
    (
      data.set &clk_access_mode:&on_reg %LONG (data.long(&clk_access_mode:&on_reg)&~(&on_mask))
    )
  )

  ;-----------------------------------------------------------------------------
  ; Print the clock header
  ;-----------------------------------------------------------------------------
  gosub Print_Header

  ;-----------------------------------------------------------------------------
  ; Test if clock is on
  ;-----------------------------------------------------------------------------
  
  if (&clk_reg!=0)
  (
    if (data.long(&clk_access_mode:&clk_reg)&(0x80000000))==0x0
    (
      &clk_state="ON "
      &is_on=1
    )
    else
    (
      &clk_state="OFF"
      &is_on=0
    )
  )
  else
  (
    &clk_state=" ? " 
    &is_on=-1
  )
  
  ; Always program the muxes, even if the clock is off and we're not
  ; going to actually calculate the frequency, since the mux configuration
  ; is still required for routing out to the test pad.
  gosub Program_Clk_Test

  ;-----------------------------------------------------------------------------
  ; Calculate the clock frequency based on the TCXO counter
  ;-----------------------------------------------------------------------------

  if ((&is_on==1)||(&is_on==-1))
  (

    ; Set dividers before calculation to ensure clock is within range of
    ; the frequency counter. Clear dividers after calculation so they
    ; don't affect frequency when probing with a scope.
    ;gosub Set_Dividers
    gosub Calc_Clock_Freq
    ;gosub Clear_Dividers

    if (&clk_freq==0)
    (
      &clk_freq_str=FORMAT.FLOAT(12., 0x6, 0.0) 
    )
    else
    (
      &clk_freq=&clk_freq*&clk_multiplier
      &clk_freq_str=FORMAT.FLOAT(12., 0x6, &clk_freq) 
    )

    if (&is_on==-1)
    (
      if (&clk_freq==0)
      (
        &is_on=0
      )
      else
      (
        &is_on=1
      )
    )
  )
  else if (&is_on==0)
  (
    &clk_freq_str=FORMAT.FLOAT(12., 0x6, 0.0) 
  )
  else
  (
    &clk_freq_str="  Not Testable"
  )
  
  if ((("&clk_state_filter"=="all_on")&&(&is_on==0))||(("&clk_state_filter"=="all_off")&&(&is_on==1)))
  (
    return
  )

  if (&clk_reg!=0)
  (
    &clk_reg_val=FORMAT.HEX(0x8, data.long(&clk_access_mode:&clk_reg))
    &clk_reg_val_str="0x&clk_reg_val"
    
    &clk_reg=FORMAT.HEX(0x8, &clk_reg)
    &clk_reg_str="0x&clk_reg"
  )
  else
  (
    &clk_reg_str="----------" 
    &clk_reg_val_str="----------"
  )

  ; Format clock name width

  &padding=STRING.CUT("                                        ", STRING.LEN("&clk_name"))
  &padding2=STRING.CUT("         ", STRING.LEN("&clk_state"))
  &padding3=STRING.CUT("                       ", STRING.LEN("&clk_freq_str"))
  &printmux=var.string(\a_dbg_mux_str[&clk_test_mux][&dbg_mux_str_name])
  &padding4=STRING.CUT("          ", STRING.LEN("&printmux"))
  &padding5=STRING.CUT("          ", STRING.LEN("&clk_reg_str"))
  &padding6=STRING.CUT("              ", STRING.LEN("&clk_reg_val_str"))
  &padding7=STRING.CUT("          ", STRING.LEN("&clk_reg_cbcr_type"))
  &padding8=STRING.CUT(" ", STRING.LEN("&clk_alias"))

  print "&clk_name&padding&clk_state&padding2&clk_freq_str&padding3&printmux&padding4&clk_reg_str&padding5:&clk_reg_val_str&padding6&clk_reg_cbcr_type&padding7&clk_alias&padding8"

  return



;-----------------------------------------------------------------------------
; Program the Parent Clock Mux
;-----------------------------------------------------------------------------

Program_Parent_Mux:
  ENTRY &ppm_parent_idx &ppm_parent_sel &ie_addr &ie_mask
  LOCAL &mux_access_mode &mux_input_en_addr &mux_input_en_mask

  &mux_access_mode=var.string(\a_dbg_mux_str[&ppm_parent_idx][&dbg_mux_str_access_mode])

  ; Set Mux Select
  &clock_ctl_reg=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_addr])
  &clock_ctl_mask=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_mask])
  &clock_ctl_shft=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_shft])
  &clock_ctl_val=data.long(&mux_access_mode:&clock_ctl_reg)
  &clock_ctl_val=&clock_ctl_val&~(&clock_ctl_mask<<&clock_ctl_shft)
  data.set &mux_access_mode:&clock_ctl_reg %LONG &clock_ctl_val&~&clock_ctl_mask|((&ppm_parent_sel<<&clock_ctl_shft)&&clock_ctl_mask)

  ; Set Mux Divider
  &clock_div_reg=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_div_addr])
  if &clock_div_reg!=0x0
  (
    &clock_div_mask=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_div_mask])
    &clock_div_shft=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_div_shft])
    &clock_div_hw_val=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_div_hw_val])
    &clock_div_val=data.long(&mux_access_mode:&clock_div_reg)
    &clock_div_val=&clock_div_val&~(&clock_div_mask<<&clock_div_shft)
    data.set &mux_access_mode:&clock_div_reg %LONG &clock_div_val&~&clock_div_mask|((&clock_div_hw_val<<&clock_div_shft)&&clock_div_mask)
  )

  &clock_en_reg=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_enable_addr])
  &clock_en_enable_mask=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_enable_mask])
  if &clock_en_reg!=0x0
  (
    &clock_en_val=data.long(&mux_access_mode:&clock_en_reg)|&clock_en_enable_mask
    data.set &mux_access_mode:&clock_en_reg %LONG &clock_en_val
  )

  if &ie_addr!=0x0
  (
    &ie_val=data.long(&mux_access_mode:&ie_addr)|&ie_mask
    data.set &mux_access_mode:&ie_addr %LONG &ie_val
  )

  &pidx=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_parent_idx])
  &psel=v.value(\a_dbg_mux_data[&ppm_parent_idx][&dbg_mux_reg_parent_sel])
  if &pidx!=&dbg_mux_none
  (
    GOSUB Program_Parent_Mux &pidx &psel 0x0 0x0
  )

  return

;-----------------------------------------------------------------------------
; Program the clk_test register
;-----------------------------------------------------------------------------

Program_Clk_Test:

  &testval=&clk_test_sel
  &dbg_mux=&clk_test_mux

  if (&dbg_mux==&dbg_mux_none)
  (
    return
  )

  GOSUB Program_Parent_Mux &dbg_mux &testval &mux_input_enable_addr &mux_input_enable_mask

  ; Frequency counter utility registers.
  &frq_measure_ctl_addr=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_measure_ctl])
  &frq_measure_status_addr=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_measure_status])
  &xo_div4_cbcr_addr=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_xo_div4_addr])

  return
  

Configure_GPIO:
    
    
    &val=data.long(&access_mode:v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_plltestpad]))|0xA0000
    data.set &access_mode:v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_plltestpad]) %LONG &val
    print "PLLTEST_PAD enabled in GCC_PLLTEST_PAD_CFG."

    return

Set_Dividers:
    
    &reg=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_addr])
    &shift=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_shft])
    &mask=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_mask])
    &divval=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_hw_val])
    &val=(data.long(&access_mode:&reg)&~&mask)|((&divval<<&shift)&mask)
    data.set &access_mode:&reg %LONG &val

    return

Clear_Dividers:
    
    &reg=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_addr])
    &shift=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_shft])
    &mask=v.value(\a_dbg_mux_data[&dbg_mux_gcc][&dbg_mux_reg_div_mask])
    &val=(data.long(&access_mode:&reg)&~&mask)
    data.set &access_mode:&reg %LONG &val

    return


Print_Clock_Help:

  &ch_ctlrs=0
  
  while (&ch_ctlrs<&dbg_mux_max)
  (
    &ch_clk=0
    &clkctlr_name=v.string(\a_dbg_mux_str[&ch_ctlrs][&dbg_mux_str_name])
    &printline=""
    print ""
    print "*****************************************************   &clkctlr_name   ******************************************************"
    while (&ch_clk<v.value(\a_dbg_mux_data[&ch_ctlrs][&dbg_mux_reg_num_clks]))
    (
      &clk_name=v.string(\a_clock_str[&ch_ctlrs][&ch_clk][&clk_str_name])
      &left_width="                                        "
      &padding=STRING.CUT("&left_width", STRING.LEN("&clk_name"))
      &printline="&printline&clk_name&padding"
      if ((&ch_clk%0x3)==0x2)
      (
        print "&printline"
        &printline=""
      )
      &ch_clk=&ch_clk+1
    )
    print "&printline"
    &ch_ctlrs=&ch_ctlrs+1
  )

  return



Print_All:
  &pa_ctlrs=0
  while (&pa_ctlrs<&dbg_mux_max)
  (
    &pa_iter=0
    while (&pa_iter<v.value(\a_dbg_mux_data[&pa_ctlrs][&dbg_mux_reg_num_clks]))
    (
      &clkstr=v.string(\a_clock_str[&pa_ctlrs][&pa_iter][&clk_str_name])
      GOSUB Find_Print_Clock &clkstr
      &pa_iter=&pa_iter+1
    )
    &pa_ctlrs=&pa_ctlrs+1
  )

  return


Print_All_SS:
(
  local &choice
  entry &choice

  if (string.scan("&choice", "_all", 0)==-1.)
  (
    return 0.
  )

  &pa_ctlrs=0
  while (&pa_ctlrs<&dbg_mux_max)
  (
    &cc_str=v.string(\a_dbg_mux_str[&pa_ctlrs][&dbg_mux_str_name])
    &cc_str=string.lower("&cc_str")
    &cc_str="&cc_str"+"_all"
    if (str.compare("&cc_str","&choice"))
    (
       &pa_iter=0
       while (&pa_iter<v.value(\a_dbg_mux_data[&pa_ctlrs][&dbg_mux_reg_num_clks]))
       (
         &clkstr=v.string(\a_clock_str[&pa_ctlrs][&pa_iter][&clk_str_name])
         GOSUB Find_Print_Clock &clkstr &pa_ctlrs
         &pa_iter=&pa_iter+1
       )
       return 1.
    )
    &pa_ctlrs=&pa_ctlrs+1
  )

  return 0.
)


;-----------------------------------------------------------------------------
; Find clocks that match what the user entered and print their information 
;-----------------------------------------------------------------------------

Find_Print_Clock:

ENTRY &clk &ctlr

&clk_test_mux=0
&clk_test_sel=0
&clk_reg=0
&clk_reg_name=""
&clk_ref=""
&testclkmux=0x0
&testclksel=0x0
&clk_reg_in=0x0
&clk_reg_name_in=""
&clk_reg_cbcr_type_in=""
&clk_vote_bit_in=0.
&clk_multiplier_in=0x4

  if ("&ctlr"!="")
  (
      &cc_iter=&ctlr
      &sf_clk_iter=0
      while (&sf_clk_iter<v.value(\a_dbg_mux_data[&cc_iter][&dbg_mux_reg_num_clks]))
      ( 
        &clk_ref=v.string(\a_clock_str[&cc_iter][&sf_clk_iter][&clk_str_name])
        &clk_alias=v.string(\a_clock_str[&cc_iter][&sf_clk_iter][&clk_str_aliases])
        &testclkmux=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_tc_mux])
        &testclksel=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_tc_sel])
        &clk_reg_in=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_cbc])
        &clk_reg_name_in="RegNameHere"
        &clk_reg_cbcr_type_in=v.string(\a_clock_str[&cc_iter][&sf_clk_iter][&clk_str_type])
        &clk_vote_bit_in=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_vote_bit])
        &clk_multiplier_in=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_total_div])
        &mux_input_enable_addr=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_mux_input_en_addr])
        &mux_input_enable_mask=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_mux_input_en_mask])
        gosub StringFind &clk &clk_ref &testclkmux &testclksel &clk_reg_in &clk_reg_name_in &clk_reg_cbcr_type_in &clk_vote_bit_in &clk_multiplier_in &clk_alias
        &sf_clk_iter=&sf_clk_iter+1
      )
  )
  else
  (
    &cc_iter=0
    while (&cc_iter<&dbg_mux_max)
    (
      &sf_clk_iter=0
      while (&sf_clk_iter<v.value(\a_dbg_mux_data[&cc_iter][&dbg_mux_reg_num_clks]))
      ( 
        &clk_ref=v.string(\a_clock_str[&cc_iter][&sf_clk_iter][&clk_str_name])
        &clk_alias=v.string(\a_clock_str[&cc_iter][&sf_clk_iter][&clk_str_aliases])
        &testclkmux=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_tc_mux])
        &testclksel=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_tc_sel])
        &clk_reg_in=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_cbc])
        &clk_reg_name_in="RegNameHere"
        &clk_reg_cbcr_type_in=v.string(\a_clock_str[&cc_iter][&sf_clk_iter][&clk_str_type])
        &clk_vote_bit_in=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_vote_bit])
        &clk_multiplier_in=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_total_div])
        &mux_input_enable_addr=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_mux_input_en_addr])
        &mux_input_enable_mask=v.value(\a_clock_data[&cc_iter][&sf_clk_iter][&clk_reg_mux_input_en_mask])
        gosub StringFind &clk &clk_ref &testclkmux &testclksel &clk_reg_in &clk_reg_name_in &clk_reg_cbcr_type_in &clk_vote_bit_in &clk_multiplier_in &clk_alias
        &sf_clk_iter=&sf_clk_iter+1
      )
      &cc_iter=&cc_iter+1
    )
  )

  return


StringFind:
  entry &clk_in &clk_ref &testclkmux &testclksel &clk_reg_in &clk_reg_name_in &clk_reg_cbcr_type_in &clk_vote_bit_in &clk_multiplier_in &clk_alias_in
  &match=0
  &wild_head=0
  &wild_tail=0
  &clk_input_length=STRING.LENGTH("&clk_in")
  &clk_itr_length=STRING.LENGTH("&clk_ref")
  &clk_alias_length=STRING.LENGTH("&clk_alias_in")

  if (STRING.SCAN("&clk_in", "*", 0)==0)
  (
    &wild_head=1
  )
  if (STRING.SCAN("&clk_in", "*", 1)==(STRING.LENGTH("&clk_in")-1))
  (
    &wild_tail=1
  )

  if ((&wild_head==1)&&(&wild_tail==1))
  (
    if (STRING.SCAN("&clk_ref", STRING.MID("&clk_in", 1, &clk_input_length-2), 0)!=-1)
    ( 
      &match=1
    )
    else if (string.length("&clk_alias_in")>0)
    (
      &alias_num=string.scan("&clk_alias_in",",",0)+1
      if (&alias_num==0)
      (
        if (STRING.SCAN("&clk_alias_in", STRING.MID("&clk_in", 1, &clk_input_length-2), 0)!=-1)
        (
          &match=1
        )
      )
      else
      (
        while (&alias_num>0)
        (
          &alias_clk=string.split("&clk_alias_in",",",&alias_num)
          if (STRING.SCAN("&alias_clk", STRING.MID("&clk_in", 1, &clk_input_length-2), 0)!=-1)
          (
            &match=1
            &alias_num=1
          )
          &alias_num=&alias_num-1
        )
      )
    )
  )
  else if (&wild_head==1)
  (
    if (STRING.MID("&clk_ref", &clk_itr_length-&clk_input_length+1, &clk_input_length-1)==STRING.CUT("&clk_in", 1))
    ( 
      &match=1
    )
    else if (&clk_alias_length>0)
    (
      &alias_num=string.scan("&clk_alias_in",",",0)+1
      if (&alias_num==0)
      (
        if (STRING.MID("&clk_alias_in", &clk_alias_length-&clk_input_length+1, &clk_input_length-1)==STRING.CUT("&clk_in", 1))
        (
          &match=1
        )
      )
      else
      (
        while (&alias_num>0)
        (
          &alias_clk=string.split("&clk_alias_in",",",&alias_num)
          if (STRING.MID("&alias_clk", &clk_alias_length-&clk_input_length+1, &clk_input_length-1)==STRING.CUT("&clk_in", 1))
          (
            &match=1
            &alias_num=1
          )
          &alias_num=&alias_num-1
        )
      )
    )
  )
  else if (&wild_tail==1)
  (
    if (STRING.MID("&clk_ref", 0, &clk_input_length-1)==STRING.CUT("&clk_in", -1))
    ( 
      &match=1
    )
    else if (string.length("&clk_alias_in")>0)
    (
      &alias_num=string.scan("&clk_alias_in",",",0)+1
      if (&alias_num==0)
      (
        if (STRING.MID("&clk_alias_in", 0, &clk_input_length-1)==STRING.CUT("&clk_in", -1))
        (
          &match=1
        )
      )
      else
      (
        while (&alias_num>0)
        (
          &alias_clk=string.split("&clk_alias_in",",",&alias_num)
          if (STRING.MID("&alias_clk", 0, &clk_input_length-1)==STRING.CUT("&clk_in", -1))
          (
            &match=1
            &alias_num=1
          )
          &alias_num=&alias_num-1
        )
      )
    )
  )
  else if ("&clk_ref"=="&clk_in")
  (
    &match=1
  )
  else if ((&wild_head!=1)&&(&wild_tail!=1))
  (
    if (string.length("&clk_alias_in")>0)
    (
      &alias_num=string.scan("&clk_alias_in",",",0)+1
      if (&alias_num==0)
      (
        if ("&clk_alias_in"=="&clk_in")
        (
          &match=1
        )
      )
      else
      (
        while (&alias_num>0)
        (
          &alias_clk=string.split("&clk_alias_in",",",&alias_num)
          if ("&alias_clk"=="&clk_in")
          (
            &match=1
            &alias_num=1
          )
          &alias_num=&alias_num-1
        )
      )
    )
  )
  
  if (&match==1)
  (
    &clk_test_mux=&testclkmux
    &clk_test_sel=&testclksel
    &clk_reg=&clk_reg_in
    &clk_reg_name="&clk_reg_name_in"
    &clk_name="&clk_ref"
    &clk_reg_cbcr_type="&clk_reg_cbcr_type_in"
    &clk_vote_bit=&clk_vote_bit_in
    &clk_multiplier=&clk_multiplier_in

    gosub Print_Clk_Info_Line
  )
  return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Utility Subroutines
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Lauterbach T32 "Window/Area" Utility Subs:
;
;   bool    wa_does_area_exist ( string area )
;
;   bool    wa_try_area_create ( string area, [int cols, int rows] )
;
;   bool    wa_area_create_list (
;             int num, [string area, int cols, int rows], ... )
;
;   string  wa_get_substr_ws ( string src_str, int read_idx )
;
;   int[4]  wa_extract_stored_win_dim ( string file_name, string window_name )
;
;   bool    wa_save_window_settings ( string window_name, [flag print_error] )
;
;   int[4]  wa_find_saved_window_settings ( string window_name )
;
;   bool    wa_delete_saved_window_settings (
;             string window_name, [flag print_error] )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; bool wa_does_area_exist ( string area )
;
; Returns non-zero if the given area currently exists.
;
; SIDE EFFECTS:  Selects the tested area if it exists, or the default area.
;
wa_does_area_exist:
(
  local &area_name
  entry &area_name

  ON ERROR gosub
  (
    ; Clear the error message.
    area.select
    print ""

    &clk_err="!"
    return
  )

  &clk_err=""
  area.select &area_name

  if ("&clk_err"=="")
  (
    return 1
  )
  else
  (
    return 0
  )
)

;
; bool wa_try_area_create ( string area, [int cols, int rows] )
;
; Attempts to create an area (see 'area.create'). Returns non-zero if the 
; area is successfully created. If the 'area.create' operation fails, the
; caller may run 'area.reset' then re-try creating the area. The 'rows' and
; 'cols' arguments can be bypassed by omitting both.
;
; T32 has a maximum number of concurrent areas (only 10 at the time of
; writing this sub). Unfortunately these areas can only be deleted in bulk
; with the highly destructive 'area.reset' (although some T32 documentation
; incorrectly states that 'area.close <area_name>' destroys the area, it
; doesn't--it only closes the area's output logging).
;
; Furthermore, areas aren't destroyed automatically upon script exit, so
; if a user were to run multiple scripts with multiple areas they could
; quickly exhaust the 10-area limit and then find that subsequent script
; launches always fail, potentially with confusing error messages. This
; utility sub is intended to mitigate this risk without having to immidiately
; resort to running a global 'area.reset' during script initialization.
;
wa_try_area_create:
(
  local &area_name
  local &cols
  local &rows

  entry &area_name &cols &rows

  ON ERROR gosub
  (
    &clk_err="!"
    return
  )

  &clk_err=""
  area.create &area_name &cols &rows

  if ("&clk_err"=="")
  (
    return 1
  )
  else
  (
    return 0
  )
)

;
; bool wa_area_create_list ( int num, [string area, int cols, int rows], ... )
;
; Attempts to create a list of areas. Will run the global 'area.reset' command
; upon the first failure, and return 0 upon the second failure. Otherwise
; returns non-zero upon success.
;
wa_area_create_list:
(
  local &success
  local &already_failed
  local &area_name
  local &cols
  local &rows
  local &area_idx
  local &num
  local &input_line
  local &line_idx
  local &area_list_line_idx

  entry %LINE &input_line

  ; Get the number of areas to create.
  gosub wa_get_substr_ws "&input_line" 0.
  entry &num &area_list_line_idx
  if ("&num"=="")
  (
    print %ERROR "ERROR: wa_area_create_list() detected invalid input: '&input_line'."
    return 0
  )

  &already_failed=0

wa_area_create_list_process_areas:

  ; Create each area.
  &area_idx=0
  &line_idx=&area_list_line_idx
  while (&area_idx<&num)
  (
    ; Read in the area information.
    gosub wa_get_substr_ws "&input_line" &line_idx
    entry &area_name &line_idx
    if ("&area_name"=="")
    (
      goto wa_area_create_list_too_few_args
    )
    gosub wa_get_substr_ws "&input_line" &line_idx
    entry &cols &line_idx
    if ("&cols"=="")
    (
      goto wa_area_create_list_too_few_args
    )
    gosub wa_get_substr_ws "&input_line" &line_idx
    entry &rows &line_idx
    if ("&rows"=="")
    (
      goto wa_area_create_list_too_few_args
    )

    ; Check if the row/col argument was bypassed.
    if (("&cols"==",")||("&rows"==","))
    (
      ; Apply a sanity check for row/col bypass.
      if (("&cols"!=",")||("&rows"!=","))
      (
        print %ERROR "ERROR: wa_area_create_list() detected invalid row/col settings for '&area_name'."
        print %ERROR "       Row/col must both be an integer or both be ',' (got row='&row', col='&col'). "
        return 0
      )

      &cols=""
      &rows=""
    )

    ; Attempt to create the area.
    gosub wa_try_area_create &area_name &cols &rows
    entry &success

    if (&success==0)
    (
      ; Already failed => infinite impending failures.
      if (&already_failed!=0)
      (
        print %ERROR %Decimal "ERROR: wa_area_create_list() failed to create &num areas."
        return 0
      )

      ; Delete all areas and try creating the area list once more.
      &already_failed=1
      area.reset
      winclear
      goto wa_area_create_list_process_areas
    )

    &area_idx=&area_idx+1
  )

  return 1

wa_area_create_list_too_few_args:

  print %ERROR "ERROR: wa_area_create_list() detected too few arguments (num_areas='&num')."
  return 0
)

;
; string wa_get_substr_ws ( string src_str, int read_idx )
;
; Returns the next sub-string word from a source string, or nothing if there
; is no such word. The words are split by spaces.
;
; Example: <gosub args_get_next_substr_ws "a  bc  de" 1.>
;          Returns "bc 5" (sans quotes).
;
wa_get_substr_ws:
(
  local &src_str
  local &src_len
  local &read_idx
  local &sub_str
  local &start_idx

  entry &src_str &read_idx

  if (&read_idx<0)
  (
    ; Negative read index--return empty string (and no index).
    return
  )

  &src_len=string.length(&src_str)

  ; Find the start of non-whitespace segment.
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)!=' ')
    (
      &start_idx=&read_idx
      goto wa_get_substr_ws_find_end_idx
    )

    &read_idx=&read_idx+1
  )

  ; No non-whitespace found--return empty string (and no index).
  return

wa_get_substr_ws_find_end_idx:

  ; Find the end of non-whitespace segment.
  &read_idx=&read_idx+1
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)==' ')
    (
      ; Cut out leading and trailing whitespace
      &sub_str=string.mid(&src_str, &start_idx, &read_idx-&start_idx)

      goto wa_get_substr_ws_return_substr
    )

    &read_idx=&read_idx+1
  )

  ; No trailing white-space found--cut out any leading whitespace.
  &sub_str=string.cut(&src_str, &start_idx)

wa_get_substr_ws_return_substr:

  return &sub_str &read_idx
)

;
; int[2] wa_extract_stored_win_dim ( string file_name,  string window_name )
;
; Returns the settings for the given window extracted from a previously
; stored file. Returns -1 if the window settings aren't found.
;
; Returns: {x_start, y_start, x_length, y_length}
;          (all values are in row or column units).
;
wa_extract_stored_win_dim:
(
  local &window_name
  local &file_name
  local &x_start
  local &y_start
  local &x_len
  local &y_len
  local &line_in
  local &idx

  entry &file_name &window_name

  &x_start=-1
  &y_start=-1
  &y_len=-1
  &x_start=-1

  ; Open the input file.
  (
    &clk_err=""
    ON ERROR gosub
    (
      print %ERROR "ERROR: wa_extract_stored_win_dim() failed to open '&file_name'."
      &clk_err="!"
      return
    )
    OPEN #1 &file_name /Read
  )

  if ("&clk_err"!="")
  (
    goto wa_extract_stored_win_dim_error
  )

  ; Scan the input file for "winpos ... window_name".
  WHILE TRUE()
  (
    READ #1 %line &line_in
    if (EOF()==TRUE())
    (
      goto wa_extract_stored_win_dim_error
    )
    &line_in=string.lower("&line_in")

    ; Search for 'winpos' line header and cut it out if found.
    &idx=string.scan("&line_in", "winpos", 0)
    if (&idx!=-1)
    (
      &line_in=string.cut("&line_in", &idx+6.)

      ; Search for the specified window name.
      if (string.scan("&line_in", "&window_name", 0)!=-1)
      (
        ; Extract the specified window's settings.
        gosub wa_get_substr_ws "&line_in" 0.
        entry &x_start &idx
        if ("&x_start"=="")
        (
          goto wa_extract_stored_win_dim_error
        )
        gosub wa_get_substr_ws "&line_in" &idx
        entry &y_start &idx
        if ("&y_start"=="")
        (
          goto wa_extract_stored_win_dim_error
        )
        gosub wa_get_substr_ws "&line_in" &idx
        entry &x_len &idx
        if ("&x_len"=="")
        (
          goto wa_extract_stored_win_dim_error
        )
        gosub wa_get_substr_ws "&line_in" &idx
        entry &y_len &idx
        if ("&y_len"=="")
        (
          goto wa_extract_stored_win_dim_error
        )

        CLOSE #1
        return &x_start &y_start &x_len &y_len
      )
    )
  )

wa_extract_stored_win_dim_error:

  CLOSE #1
  return -1 -1 -1 -1
)

;
; bool wa_save_window_settings ( string window_name, [flag print_error] )
;
; Saves a script's window configuration (position + size).
; See restore_window_settings() for the restore operation.
; Returns non-zero if the store operation succeeded.
;
; This is provided as a method to allow scripts to save/restore their window
; settings accross multiple script sessions. T32's "store <file> win" tool
; is insufficient to do this since it will only save/restore *all* T32 windows,
; not targeted windows.
;
wa_save_window_settings:
(
  local &file
  local &window_name
  local &script_name
  local &print_error

  &clk_err=""
  ON ERROR gosub
  (
    &clk_err="!"
    return
  )

  entry &window_name &print_error

  ; Store the full window configuration in a file under the temporary directory.
  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")

  &file=os.ptd()
  &file="&(file)\__&(script_name)_&(window_name)_dim.cmm"
  store &file win

  if ("&clk_err"=="")
  (
    return 1
  )
  else
  (
    if ("&print_error"!="")
    (
      print %ERROR "ERROR: wa_save_window_settings() failed to store settings for '&window_name'."
    )
    return 0
  )
)

;
; int[4] wa_find_saved_window_settings ( string window_name )
;
; Returns the settings for the given window extracted from a previously
; save. Returns -1 if the window settings aren't found.
;
; Returns: {x_start, y_start, x_length, y_length}
;          (all values are in row or column units).
;
; This is provided as a method to allow scripts to save/restore their window
; settings accross multiple script sessions. T32's "store <file> win" tool
; is insufficient to do this since it will only save/restore *all* T32 windows,
; not targeted windows.
;
wa_find_saved_window_settings:
(
  local &x_start
  local &y_start
  local &x_len
  local &y_len
  local &window_name
  local &file
  local &script_name

  entry &window_name

  ; Check if the window's saved settings file exists.
  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")

  &file=os.ptd()
  &file="&(file)\__&(script_name)_&(window_name)_dim.cmm"
  if (os.file.access("&file", "R")==FALSE())
  (
    return -1 -1 -1 -1
  )

  ; Search for previously saved settings for this window.
  gosub wa_extract_stored_win_dim &file &window_name
  entry &x_start &y_start &x_len &y_len

  return &x_start &y_start &x_len &y_len
)

;
; bool wa_delete_saved_window_settings ( string window_name, [flag print_error] )
;
; Deletes a window settings file.
;
wa_delete_saved_window_settings:
(
  local &success
  local &file
  local &script_name
  local &window_name
  local &print_error

  entry &window_name &print_error

  ; Check if the window's saved settings file exists.
  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")

  &file=os.ptd()
  &file="&(file)\__&(script_name)_&(window_name)_dim.cmm"
  if (os.file.access("&file", "W")==TRUE())
  (
    ; Delete the file.
    del &file
    &success=1
  )
  else
  (
    if ("&print_error"!="")
    (
      print %ERROR "ERROR: wa_delete_saved_window_settings() failed to delete window settings for '&window_name'."
    )
    &success=0
  )

  return &success
)

;;;;;;;;;;;;; End of "Lauterbach T32 "Window/Area" Utility Subs" ;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ARGS Commands:
;
;   "line" = PRACTICE macro string which isn't wrapped in double quotes. Full
;            lines can be read with "entry %LINE &<macro_name>".
;
;   See "args_<cmd>:" subroutine headers for more information.
;
;   (int)       create_client   <client_name> <area_name> [cmd_line]
;   (int)       switch_area     <client_id> <area_name>
;   (int)       reset_cmd_line  <client_id> [cmd_line]
;   (int)       set_opts        <client_id> <option_kwargs_line>
;   (int)       clear_opts      <client_id>
;
;   (string)    get_arg         <client_id> [prompt_line]
;   (string[2]) get_kwarg       <client_id> [prompt_line]
;   (int)       get_num_unread  <client_id>
;   (line)      get_cmd_line    <client_id> [unread_only_flag]
;
;   (int)       print_hist      <client_id>
;   (line)      get_hist_entry  <client_id> <entry_age>
;   (int)       get_hist_size   <client_id>
;
;   (string)    get_error       [client_id]
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ARGS Options:
;
;   All options are disabled by default.
;
;   help_cmd=[cmd]  - Sets the command string for the help sub. Requires a
;                     help sub to call.
;   help_sub=[sub]  - Sets the subroutine for the help command.
;
;   hist_cmd=[cmd]  - Sets the command string for the history operation.
;                     Requries a history sub to call.
;   hist_sub=[sub]  - Sets the subroutine for the history command.
;
;   nonempty_cmds=[0|1] - If set to one, repeats in-script prompts until a 
;                         non-empty arg is received from the user.
;
;   nonempty_vals=[0|1] - If set to one, "get_kwarg" returns an error
;                         upon detecting a value-less keyword argument (an
;                         error is always returned to key-less kwargs).
;
;   print_errors=[0|1]  - If set to one, error messages are printed to the
;                         I/O area automatically.
;
; ARGS Error Reporting:
;
;   All ARGS commands return ARGS_ERR upon detecting failures. Clients may
;   use the "get_error" ARGS command to query the error type that was
;   generated by the previous command.
;
; ARGS Error Type Strings:
;
;   NO_ERROR          => No error generated by the previous command.
;   NO_CMD            => Missing command.
;   INV_CMD           => Invalid command.
;
;   LONG_CMD_LINE     => Overlength user command line.
;   NO_CLIENT_ID      => Missing client ID.
;   INV_CLIENT_ID     => Invalid client ID (for non-"get_error" commands).
;
;   GET_ERR_INV_ID    => Invalid "get_error" client ID.
;
;   NO_CLIENT_NAME    => Missing client name argument.
;   INV_CLIENT_NAME   => Overlength client name.
;   NO_IO_AREA        => Missing I/O area argument.
;   INV_IO_AREA       => Nonexistent area or overlength name.
;
;   NO_OPT_KWARGS     => Missing option keyword arguments.
;   LONG_OPT_CMD      => Overlength help/history/quit command option.
;   DUP_OPT_KEY       => Duplicate option keyword.
;   INV_OPT_KEY       => Invalid option keyword.
;   INV_OPT_VAL       => Invalid option value.
;   OPT_CMD_NO_SUB    => Missing sub for help/history/quit command option.
;
;   NO_KWARG_KEY      => Key-less keyword argument detected by "get_kwarg".
;   NO_KWARG_VAL      => Value-less keyword argument detected by "get_kwarg"
;                        and the "nonempty_vals" option is enabled.
;
;   INV_HIST_AGE      => Invalid "get_hist_entry" entry-age.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;============================================================================;
;                             T32-GLOBAL MACROS                              ;
;============================================================================;


;============================================================================;
;                            SCRIPT-GLOBAL MACROS                            ;
;============================================================================;


;============================================================================;
;                                    MAIN                                    ;
;============================================================================;

args_main:
(
    local &cmd_line
    local &cmd
    local &read_idx
    local &cmd_ret
    local &client_id

    &client_id=""

    ; Grab the entire launch line.
    entry %LINE &cmd_line

    ; Attempt to read the required command.
    gosub args_get_next_substr_ws "&cmd_line" 0.
    entry &cmd &read_idx
    if ("&cmd"=="")
    (
      &args_latest_error="NO_CMD"
      &cmd_ret="ARGS_ERR"
      goto args_record_errors
    )

    ; Cut the command word out of the command line.
    &cmd_line=string.cut("&cmd_line", &read_idx)

    ;
    ; Switch on the command.
    ;
    if ("&cmd"=="create_client")            ; 'create_client'
    (
      gosub args_create_client &cmd_line
      entry &cmd_ret
      goto args_record_errors
    )

    ; Attempt to read the client ID.
    gosub args_get_next_substr_ws "&cmd_line" 0.
    entry &client_id &read_idx

    ; Validate the client ID.
    if ("&client_id"!="")
    (
      ON ERROR gosub
      (
        return
      )

      if ((&client_id<0)||(&client_id>=&args_client_count))
      (
        ; Note that if 'client_id' isn't numeric, PRACTICE will still pass into
        ; this block as part of its behavior for invalid flow-control commands.
        &client_id=""
        if ("&cmd"=="get_error")
        (
          &args_latest_error="GET_ERR_INV_ID"
        )
        else
        (
          &args_latest_error="INV_CLIENT_ID"
        )

        &cmd_ret="ARGS_ERR"
        goto args_record_errors
      )
    )

    ;
    ; Continue switching on the command.
    ;
    if ("&cmd"=="get_error")                ; 'get_error'
    (
      ; Set the global variable names for the client.
      if ("&client_id"!="")
      (
        gosub args_set_gvar_names &client_id
      )

      gosub args_get_error &client_id
      entry &cmd_ret
      goto args_record_errors
    )

    ; Require a client ID for all following commands.
    if ("&client_id"=="")
    (
      &args_latest_error="NO_CLIENT_ID"
      &cmd_ret="ARGS_ERR"
      goto args_record_errors
    )

    ; Cut the client ID out of the command line.
    &cmd_line=string.cut("&cmd_line", &read_idx)

    ; Set the global variable names for the client.
    gosub args_set_gvar_names &client_id

    ;
    ; Continue switching on the command.
    ;
    &cmd_ret=""
    if ("&cmd"=="switch_area")              ; 'switch_area'
    (
      gosub args_switch_area &cmd_line
    )
    else if ("&cmd"=="reset_cmd_line")      ; 'reset_cmd_line'
    (
      gosub args_reset_cmd_line &cmd_line
    )
    else if ("&cmd"=="set_opts")            ; 'set_opts'
    (
      gosub args_set_opts &cmd_line
    )
    else if ("&cmd"=="clear_opts")          ; 'clear_opts'
    (
      gosub args_clear_opts
    )
    else if ("&cmd"=="get_arg")             ; 'get_arg'
    (
      gosub args_get_arg &cmd_line
    )
    else if ("&cmd"=="get_kwarg")           ; 'get_kwarg'
    (
      gosub args_get_kwarg &cmd_line
    )
    else if ("&cmd"=="get_cmd_line")        ; 'get_cmd_line'
    (
      gosub args_get_cmd_line &cmd_line
    )
    else if ("&cmd"=="get_num_unread")      ; 'get_num_unread'
    (
      gosub args_get_num_unread
    )
    else if ("&cmd"=="print_hist")          ; 'print_hist'
    (
      gosub args_print_hist
    )
    else if ("&cmd"=="get_hist_entry")      ; 'get_hist_entry'
    (
      gosub args_get_hist_entry &cmd_line
    )
    else if ("&cmd"=="get_hist_size")       ; 'get_hist_size'
    (
      gosub args_get_hist_size
    )
    else
    (
      ; Invalid command.
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Unknown ARGS command detected ('&cmd')."

      &args_latest_error="INV_CMD"
      &cmd_ret="ARGS_ERR"
    )

    if ("&cmd_ret"=="")
    (
      entry %LINE &cmd_ret
      &cmd_ret=string.trim("&cmd_ret")
    )

    ;
    ; Record error states.
    ;
args_record_errors:

    if ("&cmd_ret"=="ARGS_ERR")
    (
      if ("&client_id"!="") ; Non-empty 'client_id' => gvar names are set.
      (
        var.if (\&gvar_name_print_errors_en)
        (
          gosub args_print_error 
        )
      )
    )
    else
    (
      &args_latest_error="NO_ERROR"
    )

    if ("&client_id"!="") ; Non-empty 'client_id' => gvar names are set.
    (
      var.assign \&gvar_name_client_error = "&args_latest_error"
    )

    ;
    ; Return the command's status to the caller script.
    ;
    return &cmd_ret
)

;============================================================================;
;                            UTILITY SUB-ROUTINES                            ;
;============================================================================;

;-----------------------------------------------------------------------------
;
; SUB:      void args_print_error ( void )
;
; INFO:     Prints the ARGS error type and a short description to the client's
;           I/O area.
;
; RETURNS:  Void.
;
;-----------------------------------------------------------------------------
args_print_error:
(
  print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"

  ;
  ; Switch on the latest error type.
  ;
  if ("&args_latest_error"=="NO_CMD")
  (
    print %ERROR "  'NO_CMD' => Missing command."
  )
  else if ("&args_latest_error"=="INV_CMD")
  (
    print %ERROR "  'INV_CMD' => Invalid command."
  )
  else if ("&args_latest_error"=="LONG_CMD_LINE")
  (
    print %ERROR "  'LONG_CMD_LINE' => Overlength user command line."
  )
  else if ("&args_latest_error"=="NO_CLIENT_ID")
  (
    print %ERROR "  'NO_CLIENT_ID' => Missing client ID."
  )
  else if ("&args_latest_error"=="INV_CLIENT_ID")
  (
    print %ERROR "  'INV_CLIENT_ID' => Invalid client ID (for non-'get_error' commands)."
  )
  else if ("&args_latest_error"=="GET_ERR_INV_ID")
  (
    print %ERROR "  'GET_ERR_INV_ID' => Invalid 'get_error' client ID."
  )
  else if ("&args_latest_error"=="NO_CLIENT_NAME")
  (
    print %ERROR "  'NO_CLIENT_NAME' => Missing client name argument."
  )
  else if ("&args_latest_error"=="INV_CLIENT_NAME")
  (
    print %ERROR "  'INV_CLIENT_NAME' => Overlength client name."
  )
  else if ("&args_latest_error"=="NO_IO_AREA")
  (
    print %ERROR "  'NO_IO_AREA' => Missing I/O area argument."
  )
  else if ("&args_latest_error"=="INV_IO_AREA")
  (
    print %ERROR "  'INV_IO_AREA' => Nonexistent area or overlength name."
  )
  else if ("&args_latest_error"=="NO_OPT_KWARGS")
  (
    print %ERROR "  'NO_OPT_KWARGS' => Missing option keyword arguments."
  )
  else if ("&args_latest_error"=="LONG_OPT_CMD")
  (
    print %ERROR "  'LONG_OPT_CMD' => Overlength help/history/quit command option."
  )
  else if ("&args_latest_error"=="DUP_OPT_KEY")
  (
    print %ERROR "  'DUP_OPT_KEY' => Duplicate option keyword."
  )
  else if ("&args_latest_error"=="INV_OPT_KEY")
  (
    print %ERROR "  'INV_OPT_KEY' => Invalid option keyword."
  )
  else if ("&args_latest_error"=="INV_OPT_VAL")
  (
    print %ERROR "  'INV_OPT_VAL' => Invalid option value."
  )
  else if ("&args_latest_error"=="OPT_CMD_NO_SUB")
  (
    print %ERROR "  'OPT_CMD_NO_SUB' => Missing sub for help/history/quit command option."
  )
  else if ("&args_latest_error"=="NO_KWARG_KEY")
  (
    print %ERROR "  'NO_KWARG_VAL' => Key-less keyword argument detected by 'get_kwarg'."
  )
  else if ("&args_latest_error"=="NO_KWARG_VAL")
  (
    print %ERROR "  'NO_KWARG_VAL' => Value-less keyword argument detected by 'get_kwarg'."
  )
  else if ("&args_latest_error"=="INV_HIST_AGE")
  (
    print %ERROR "  'INV_HIST_AGE' => Invalid 'get_hist_entry' entry-age."
  )
  else
  (
    print %ERROR "  Unknown ARGS error!"
  )

  return
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_var_assign_string
;           (
;             string var_buf_name,
;             int var_buf_len,
;             line str_in
;           )
;
; INFO:     Fills a character buffer with a zero-terminated string. Truncates
;           the string to fit within the buffer variable if necessary.
;
;           The 'str_in' line should not be wrapped in double quotes.
;
; RETURNS:  -1 if the string is truncated or a parameter is missing, else 0.
;
; NOTES:    Doubles all '\' for var.string() reads. Any time a user string may
;           contain '\', this sub should be used instead of "var.assign".
;
;           The paramaters are read as a single line to prevent "var.assign"
;           issues with double quotes.
;
;-----------------------------------------------------------------------------
args_var_assign_string:
(
  local &read_idx
  local &var_buf_name
  local &var_buf_len
  local &str_in
  local &str_in_len

  entry %LINE &str_in

  ; Extract the variable buffer symbol name.
  gosub args_get_next_substr_ws "&str_in" 0.
  entry &var_buf_name &read_idx
  if ("&var_buf_name"=="")
  (
    return -1.
  )

  ; Extract the buffer length.
  gosub args_get_next_substr_ws "&str_in" &read_idx
  entry &var_buf_len &read_idx
  if ("&var_buf_len"=="")
  (
    return -1.
  )

  ; Isolate the input string.
  &str_in=string.cut("&str_in", &read_idx)
  &str_in=string.trim("&str_in")

  ; Double each '\' to ensure proper var.string() read interpretation.
  &str_in=string.replace("&str_in", "\", "\\", 0.)

  ; Trim the string to prevent buffer overflow.
  &str_in_len=string.length("&str_in")
  &str_in=string.mid("&str_in", 0, &var_buf_len-1)

  ; Assign the input string to the buffer variable.
  var.assign \&var_buf_name = "&str_in"

  ; Return -1 iff the input string was truncated.
  if (&str_in_len>=&var_buf_len)
  (
    return -1.
  )
  else
  (
    return 0.
  )
)

;-----------------------------------------------------------------------------
;
; SUB:      string args_get_client_name ( int client_id )
;
; INFO:     Gets the 'client-name' global variable name from the client ID.
;
; RETURNS:  The ARGS client name global variable name.
;
; NOTES:    Does not verify the client ID.
;
;-----------------------------------------------------------------------------
args_get_client_name:
(
  local &gvar_name
  local &client_id

  entry &client_id

  ;
  ; Convert ID to decimal format to ensure consistency.
  ;
  &client_id=format.decimal(0, &client_id)

  ;
  ; Set the global variable names.
  ;
  &gvar_name="args_client_name_&client_id"

  return &gvar_name
)

;-----------------------------------------------------------------------------
;
; SUB:      void args_set_gvar_names ( int client_id )
;
; INFO:     Sets the global T32 variable names for the client.
;
; RETURNS:  Void.
;
; NOTES:    Does not verify the client ID.
;
;-----------------------------------------------------------------------------
args_set_gvar_names:
(
  local &suffix
  local &client_id

  entry &client_id

  ;
  ; Convert ID to decimal format to ensure consistency.
  ;
  &suffix=format.decimal(0, &client_id)

  ;
  ; Set the global variable names.
  ;
  gosub args_get_client_name &client_id
  entry &gvar_name_client_name

  &gvar_name_area_name="args_area_name_&suffix"
  &gvar_name_client_error="args_err_&suffix"

  &gvar_name_cmd_line="args_cmd_line_&suffix"
  &gvar_name_read_idx="args_read_idx_&suffix"

  &gvar_name_help_cmd="args_help_cmd_&suffix"
  &gvar_name_help_sub="args_help_sub_&suffix"
  &gvar_name_hist_cmd="args_hist_cmd_&suffix"
  &gvar_name_hist_sub="args_hist_sub_&suffix"

  &gvar_name_nonempty_cmds="args_non_empty_cmds_&suffix"
  &gvar_name_nonempty_vals="args_non_empty_vals_&suffix"
  &gvar_name_print_errors_en="args_print_errors_en_&suffix"

  &gvar_name_hist_en="args_hist_en_&suffix"
  &gvar_name_hist_tip_idx="args_hist_tip_idx_&suffix"
  &gvar_name_num_hist_entries="args_num_hist_entries_&suffix"

  &gvar_name_hist_buf="args_hist_buf_&suffix"

  return
)

;-----------------------------------------------------------------------------
;
; SUB:      string args_verify_and_select_area ( int area_name )
;
; INFO:     Verifies that an area name is valid and the area exists. The area
;           is selected as part of the verification.
;
; RETURNS:  NO_ERROR      => Valid area was selected.
;           NO_IO_AREA    => Missing area name parameter.
;           INV_IO_AREA   => Area doesn't exist or invalid/overlength name.
;
; NOTES:    ARGS I/O area names must be less than 128 characters.
;           If in invalid area is detected, 'args_latest_error' is updated.
;
;-----------------------------------------------------------------------------
args_verify_and_select_area:
(
  local &area_name
  entry &area_name

  ; Verify area name length is valid.
  if ("&area_name"=="")
  (
    return NO_IO_AREA
  )

  &err=string.length("&area_name")
  if (&err>=128.)
  (
    return INV_IO_AREA
  )

  ; Verify that the given I/O area already exists.
  ON ERROR gosub
  (
    &err="!"
    return
  )

  &err=""
  area.select &area_name

  if ("&err"=="!")
  (
    return INV_IO_AREA
  )
  else
  (
    return NO_ERROR
  )
)

;-----------------------------------------------------------------------------
;
; SUB:      string args_get_next_substr_ws
;           (
;             string src_str,
;             int read_idx
;           )
;
; INFO:     Returns the next sub-string word from a source string, or nothing
;           if there is no such word. The words are split by spaces.
;
; RETURNS:  {sub_str, read_idx} -OR- Nothing.
;
;           Example: <gosub args_get_next_substr_ws "a  bc  de" 1.>
;                     Returns "bc 5" (sans quotes).
;
;-----------------------------------------------------------------------------
args_get_next_substr_ws:
(
  local &src_str
  local &src_len
  local &read_idx
  local &sub_str
  local &start_idx

  entry &src_str &read_idx

  if (&read_idx<0)
  (
    ; Negative read index--return empty string (and no index).
    return
  )

  &src_len=string.length(&src_str)

  ; Find the start of non-whitespace segment.
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)!=' ')
    (
      &start_idx=&read_idx
      goto args__get_substr_ws_find_end
    )

    &read_idx=&read_idx+1
  )

  ; No non-whitespace found--return empty string (and no index).
  return

args__get_substr_ws_find_end:

  ; Find the end of non-whitespace segment.
  &read_idx=&read_idx+1
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)==' ')
    (
      ; Cut out leading and trailing whitespace
      &sub_str=string.mid(&src_str, &start_idx, &read_idx-&start_idx)

      goto args__get_substr_ws_return
    )

    &read_idx=&read_idx+1
  )

  ; No trailing white-space found--cut out any leading whitespace.
  &sub_str=string.cut(&src_str, &start_idx)

args__get_substr_ws_return:

  return &sub_str &read_idx
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_get_circ_buf_idx ( int base_idx, int delta, int buf_len )
;
; INFO:     Returns the index of an entry in a circular buffer.
;
; RETURNS:  Circular buffer index.
;
;-----------------------------------------------------------------------------
args_get_circ_buf_idx:
(
  local &ret_idx
  local &base_idx
  local &delta
  local &buf_len

  entry &base_idx &delta &buf_len

  &base_idx=(&base_idx%&buf_len)
  &delta=(&delta%&buf_len)
  &ret_idx=(&base_idx+&delta)

  if (&ret_idx<0)
  (
    &ret_idx=(&buf_len+&ret_idx)
  )
  else if (&ret_idx>=&buf_len)
  (
    &ret_idx=(&ret_idx-&buf_len)
  )

  return &ret_idx
)

;-----------------------------------------------------------------------------
;
; SUB:      void args_add_hist_entry ( string new_hist_entry )
;
; INFO:     Adds a history entry. Does not add redundant/empty entries.
;
; RETURNS:  Void.
;
;-----------------------------------------------------------------------------
args_add_hist_entry:
(
  local &idx
  local &youngest_idx
  local &match_idx
  local &match_hist_entry
  local &hist_entry_newer
  local &hist_entry_older
  local &num_entries
  local &tip_idx
  local &hist_cmd

  local &new_hist_entry
  entry &new_hist_entry

  ; Trim the line and short-circuit if the line is empty or a history command.
  &new_hist_entry=string.trim(&new_hist_entry)
  &hist_cmd=var.string(\&gvar_name_hist_cmd)
  if (("&new_hist_entry"=="")||("&new_hist_entry"=="&hist_cmd"))
  (
    return
  )

  &tip_idx=var.value(\&gvar_name_hist_tip_idx)

  ; Truncate history entries to fit within the buffer.
  &new_hist_entry=string.mid("&new_hist_entry", 0., 511.)

  ; Check if the exact entry is already stored in history.
  &match_idx=0
  while (&match_idx<&ARGS_MAX_HIST_ENTRIES)
  (
    &match_hist_entry=var.string(\&gvar_name_hist_buf[&match_idx])
    if ("&match_hist_entry"=="&new_hist_entry")
    (
      ; Match found--reorder entries.
      goto args__add_hist_entry_reorder
    )

    &match_idx=&match_idx+1
  )

  ; Add a new entry to the history buffer.
  gosub args_var_assign_string &gvar_name_hist_buf[&tip_idx] 512. &new_hist_entry
  &num_entries=var.value(\&gvar_name_num_hist_entries)
  if (&num_entries<&ARGS_MAX_HIST_ENTRIES)
  (
    ; Increment the number of history entries for the client.
    &num_entries=&num_entries+1
    var.assign \&gvar_name_num_hist_entries = &num_entries
  )
  gosub args_get_circ_buf_idx &tip_idx 1. &ARGS_MAX_HIST_ENTRIES
  entry &tip_idx
  var.assign \&gvar_name_hist_tip_idx = &tip_idx

  return

args__add_hist_entry_reorder:

  gosub args_get_circ_buf_idx &tip_idx -1. &ARGS_MAX_HIST_ENTRIES
  entry &youngest_idx

  ; Shift the offset entries up in age.
  &idx=&youngest_idx
  &hist_entry_newer=var.string(\&gvar_name_hist_buf[&idx])
  while (&idx!=&match_idx)
  (
    gosub args_get_circ_buf_idx &idx -1. &ARGS_MAX_HIST_ENTRIES
    entry &idx

    &hist_entry_older=var.string(\&gvar_name_hist_buf[&idx])
    gosub args_var_assign_string &gvar_name_hist_buf[&idx] 512. &hist_entry_newer

    &hist_entry_newer="&hist_entry_older"
    &idx=&idx
  )

  ; Move the matched history entry to the youngest history entry.
  gosub args_var_assign_string &gvar_name_hist_buf[&youngest_idx] 512. &match_hist_entry

  return
)


;============================================================================;
;                         ARGS COMMAND SUB-ROUTINES                          ;
;============================================================================;

;-----------------------------------------------------------------------------
;
; SUB:      int args_create_client
;           ( 
;             string  client_name_in,
;             string  initial_io_area_name,
;             line  initial_cmd_line
;           )
;
; INFO:     Initializes an ARGS client. If the client already exists, it is
;           re-initialized.
;
;           Do not wrap any of the paramaters in double quotes.
;           The given I/O area is selected in order to confirm that it exists.
;           The client is responsible for creating this I/O area.
;
; RETURNS:  A client ID upon success or "ARGS_ERR" upon failure.
;
; ERRORS:   {NO_CLIENT_NAME, INV_CLIENT_NAME,
;           NO_IO_AREA, INV_IO_AREA, LONG_CMD_LINE}.
;
; NOTES:    The client and I/O area names must be less than 128 characters.
;           The paramaters are read as a single line in order to avoid double
;           quote issues which arise otherwise.
;
;-----------------------------------------------------------------------------
args_create_client:
(
  local &resident_client_name
  local &client_id
  local &idx
  local &read_idx
  local &client_name_var
  local &client_is_new

  local &client_name_in
  local &initial_io_area_name
  local &initial_cmd_line

  entry %LINE &initial_cmd_line

  ; First extract the client name.
  gosub args_get_next_substr_ws "&initial_cmd_line" 0.
  entry &client_name_in &read_idx
  if ("&client_name_in"=="")
  (
    &args_latest_error="NO_CLIENT_NAME"
    return ARGS_ERR
  )

  ; Check for overlength client name.
  if (&read_idx>=128.)
  (
    &args_latest_error="INV_CLIENT_NAME"
    return ARGS_ERR
  )

  ; Next extract the I/O area name.
  gosub args_get_next_substr_ws "&initial_cmd_line" &read_idx
  entry &initial_io_area_name &read_idx

  ; Check that the area is valid.
  gosub args_verify_and_select_area &initial_io_area_name
  entry &args_latest_error
  if ("&args_latest_error"!="NO_ERROR")
  (
    return ARGS_ERR
  )

  ; Isolate and trim the initial command line.
  &initial_cmd_line=string.cut("&initial_cmd_line", &read_idx)
  &initial_cmd_line=string.trim("&initial_cmd_line")

  ;
  ; Check if the client already exists.
  ;
  &client_is_new=0.
  &client_id=0
  while (&client_id<&args_client_count)
  (
    gosub args_get_client_name &client_id
    entry &client_name_var

    &resident_client_name=var.string(\&client_name_var)

    if ("&client_name_in"=="&resident_client_name")
    (
      goto args__create_client_gvar_names
    )

    &client_id=&client_id+1
  )

  ; Client does not exist--increment the client count.
  &args_client_count=&args_client_count+1
  &client_is_new=1.

args__create_client_gvar_names:

  ; Set the global variable names for the client.
  gosub args_set_gvar_names &client_id

  if (&client_is_new!=0.)
  (
    ;
    ; Client doesn't already exist--create new client global variables.
    ;
    var.newglobal char[128.] \&gvar_name_client_name
    var.newglobal char[128.] \&gvar_name_area_name
    var.newglobal char[64.] \&gvar_name_client_error

    var.newglobal char[512.] \&gvar_name_cmd_line
    var.newglobal int \&gvar_name_read_idx

    var.newglobal char[64.] \&gvar_name_help_cmd
    var.newglobal char[64.] \&gvar_name_help_sub
    var.newglobal char[64.] \&gvar_name_hist_cmd
    var.newglobal char[64.] \&gvar_name_hist_sub

    var.newglobal int \&gvar_name_nonempty_cmds
    var.newglobal int \&gvar_name_nonempty_vals
    var.newglobal int \&gvar_name_print_errors_en

    var.newglobal int \&gvar_name_hist_en
    var.newglobal int \&gvar_name_hist_tip_idx
    var.newglobal int \&gvar_name_num_hist_entries

    var.newglobal char[32.][512.] \&gvar_name_hist_buf

    ; Start clients with an empty history.
    var.assign \&gvar_name_hist_en = 0
    var.assign \&gvar_name_hist_tip_idx = 0
    var.assign \&gvar_name_num_hist_entries = 0

    &idx=0.
    while (&idx<32.)
    (
      var.assign \&gvar_name_hist_buf[&idx][0] = 0
      &idx=&idx+1.
    )
  )

  ;
  ; Initialize the client's global state.
  ;
  gosub args_var_assign_string &gvar_name_client_name 128. &client_name_in
  entry &idx
  if (&idx==-1.) ; Need to double check length due to '\' doubling.
  (
    &args_latest_error="INV_CLIENT_NAME"
    return ARGS_ERR
  )

  gosub args_var_assign_string &gvar_name_area_name 128. &initial_io_area_name
  entry &idx
  if (&idx==-1.) ; Need to double check length due to '\' doubling.
  (
    &args_latest_error="INV_IO_AREA"
    return ARGS_ERR
  )

  gosub args_var_assign_string &gvar_name_cmd_line 512. &initial_cmd_line
  entry &idx
  if (&idx==-1.) ; Need to double check length due to '\' doubling.
  (
    &args_latest_error="LONG_CMD_LINE"
    return ARGS_ERR
  )

  var.assign \&gvar_name_client_error = "NO_ERROR"
  var.assign \&gvar_name_read_idx = 0

  var.assign \&gvar_name_help_cmd[0] = 0
  var.assign \&gvar_name_help_sub[0] = 0
  var.assign \&gvar_name_hist_cmd[0] = 0
  var.assign \&gvar_name_hist_sub[0] = 0

  var.assign \&gvar_name_nonempty_cmds = 0
  var.assign \&gvar_name_nonempty_vals = 0
  var.assign \&gvar_name_print_errors_en = 0

  ; Unconditionally record the launch line in history.
  gosub args_add_hist_entry "&initial_cmd_line"

  ;
  ; Return the initialized client's ID.
  ;
  return &client_id
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_switch_area ( string new_area )
;
; INFO:     Switches the client's I/O area.
;           Do not wrap 'new_area' parameter in double quotes.
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, NO_IO_AREA, INV_IO_AREA}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_switch_area:
(
  local &new_area
  entry &new_area

  ; Verify and select the area.
  gosub args_verify_and_select_area &new_area
  entry &args_latest_error
  if ("&args_latest_error"!="NO_ERROR")
  (
    return ARGS_ERR
  )

  ; Record the new client I/O area.
  gosub args_var_assign_string &gvar_name_area_name 128. &new_area
  entry &idx
  if (&idx==-1.) ; Need to double check length due to '\' doubling.
  (
    &args_latest_error="INV_IO_AREA"
    return ARGS_ERR
  )

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_reset_cmd_line ( [line new_cmd_line] )
;
; INFO:     Resets the buffered ARGS command line.
;           Do not wrap the 'new_cmd_line' parameter in double quotes. 
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, LONG_CMD_LINE}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_reset_cmd_line:
(
  local &idx
  local &new_cmd_line
  entry %LINE &new_cmd_line

  ;
  ; Set the command line buffer state.
  ;
  gosub args_var_assign_string &gvar_name_cmd_line 512. &new_cmd_line
  entry &idx
  if (&idx==-1.)
  (
    &args_latest_error="LONG_CMD_LINE"
    return ARGS_ERR
  )

  ;
  ; Record the new command line in history.
  ;
  &new_cmd_line=string.trim("&new_cmd_line")
  if ("&new_cmd_line"!="")
  (
    var.if (\&gvar_name_hist_en!=0)
    (
      gosub args_add_hist_entry "&new_cmd_line"
    )
  )

  var.assign \&gvar_name_read_idx = 0

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_set_opts ( line opts )
;
; INFO:     Sets ARGS options. Any unspecified options are left unmodified.
;           All options are initially disabled by default.
;
;           Do not wrap the 'opts' parameter in double quotes. 
;           See "ARGS Options:" for more information.
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, NO_OPT_KWARGS, DUP_OPT_KEY
;           INV_OPT_KEY, INV_OPT_VAL, LONG_OPT_CMD, OPT_CMD_NO_SUB}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;           Help/history/quit commands must be less than 64 characters.
;
;-----------------------------------------------------------------------------
args_set_opts:
(
  local &idx
  local &help_cmd
  local &help_sub
  local &hist_cmd
  local &hist_sub
  local &nonempty_cmds
  local &nonempty_vals
  local &print_errors

  local &opts
  entry %LINE &opts

  ;
  ; Return failure if no options are given.
  ;
  &opts=string.trim("&opts")
  if ("&opts"=="")
  (
    &args_latest_error="NO_OPT_KWARGS"
    return ARGS_ERR
  )

  ;
  ; Attempt to extract option keword arguments.
  ;
  &help_cmd=string.ScanAndExtract("&opts", "help_cmd=", "INV_OPT")
  &help_sub=string.ScanAndExtract("&opts", "help_sub=", "INV_OPT")

  &hist_cmd=string.ScanAndExtract("&opts", "hist_cmd=", "INV_OPT")
  &hist_sub=string.ScanAndExtract("&opts", "hist_sub=", "INV_OPT")

  &nonempty_cmds=string.ScanAndExtract("&opts", "nonempty_cmds=", "INV_OPT")
  &nonempty_vals=string.ScanAndExtract("&opts", "nonempty_vals=", "INV_OPT")
  &print_errors=string.ScanAndExtract("&opts", "print_errors=", "INV_OPT")

  ;
  ; Process options.
  ;
  if ("&help_sub"!="INV_OPT")
  (
    ; Record the client's option.
    gosub args_var_assign_string &gvar_name_help_sub 64. &help_sub
    entry &idx
    if (&idx==-1.)
    (
      &args_latest_error="LONG_OPT_CMD"
      return ARGS_ERR
    )

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "help_sub=&help_sub", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "help_sub=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&help_cmd"!="INV_OPT")
  (
    ; Require a subroutine for the command option.
    &help_sub=var.string(\&gvar_name_help_sub)
    if (("&help_cmd"!="")&&("&help_sub"==""))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Help sub is required for help command option (help_cmd='&help_cmd')."

      &args_latest_error="OPT_CMD_NO_SUB"
      return ARGS_ERR
    )

    ; Record the client's option.
    gosub args_var_assign_string &gvar_name_help_cmd 64. &help_cmd
    entry &idx
    if (&idx==-1.)
    (
      &args_latest_error="LONG_OPT_CMD"
      return ARGS_ERR
    )

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "help_cmd=&help_cmd", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "help_cmd=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&hist_sub"!="INV_OPT")
  (
    ; Record the client's option.
    gosub args_var_assign_string &gvar_name_hist_sub 64. &hist_sub
    entry &idx
    if (&idx==-1.)
    (
      &args_latest_error="LONG_OPT_CMD"
      return ARGS_ERR
    )

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "hist_sub=&hist_sub", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "hist_sub=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&hist_cmd"!="INV_OPT")
  (
    ; Require a subroutine for the command option.
    &hist_sub=var.string(\&gvar_name_hist_sub)
    if (("&hist_cmd"!="")&&("&hist_sub"==""))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  History sub is required for history command option (hist_cmd='&hist_cmd')."

      &args_latest_error="OPT_CMD_NO_SUB"
      return ARGS_ERR
    )

    ; Start recording command history.
    if ("&hist_cmd"!="")
    (
      var.assign \&gvar_name_hist_en = 1
    )

    ; Record the client's option.
    gosub args_var_assign_string &gvar_name_hist_cmd 64. &hist_cmd
    entry &idx
    if (&idx==-1.)
    (
      &args_latest_error="LONG_OPT_CMD"
      return ARGS_ERR
    )

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "hist_cmd=&hist_cmd", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "hist_cmd=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&nonempty_cmds"!="INV_OPT")
  (
    ; Mandate binary 'nonempty' option.
    if (("&nonempty_cmds"!="0")&&("&nonempty_cmds"!="1"))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Option 'nonempty_cmds' must be 1 or 0 (got '&nonempty_cmds')."

      &args_latest_error="INV_OPT_VAL"
      return ARGS_ERR
    )

    ; Record the client's option.
    var.assign \&gvar_name_nonempty_cmds = &nonempty_cmds

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "nonempty_cmds=&nonempty_cmds", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "nonempty_cmds=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&nonempty_vals"!="INV_OPT")
  (
    ; Mandate binary 'nonempty' option.
    if (("&nonempty_vals"!="0")&&("&nonempty_vals"!="1"))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Option 'nonempty_vals' must be 1 or 0 (got '&nonempty_vals')."

      &args_latest_error="INV_OPT_VAL"
      return ARGS_ERR
    )

    ; Record the client's option.
    var.assign \&gvar_name_nonempty_vals = &nonempty_vals

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "nonempty_vals=&nonempty_vals", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "nonempty_vals=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&print_errors"!="INV_OPT")
  (
    ; Mandate binary 'nonempty' option.
    if (("&print_errors"!="0")&&("&print_errors"!="1"))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Option 'print_errors' must be 1 or 0 (got '&print_errors')."

      &args_latest_error="INV_OPT_VAL"
      return ARGS_ERR
    )

    ; Record the client's option.
    var.assign \&gvar_name_print_errors_en = &print_errors

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "print_errors=&print_errors", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "print_errors=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )

  ;
  ; Detect unknown option keywords.
  ;
  &opts=string.trim("&opts")
  if ("&opts"!="")
  (
    &args_latest_error="INV_OPT_KEY"
    return ARGS_ERR
  )

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_clear_opts ( void )
;
; INFO:     Sets all ARGS options to their default disabled state.
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_clear_opts:
(
  ; Clear every option.
  var.assign \&gvar_name_help_cmd[0] = 0
  var.assign \&gvar_name_help_sub[0] = 0
  var.assign \&gvar_name_hist_cmd[0] = 0
  var.assign \&gvar_name_hist_sub[0] = 0

  var.assign \&gvar_name_nonempty_cmds = 0
  var.assign \&gvar_name_nonempty_vals = 0
  var.assign \&gvar_name_print_errors_en = 0

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      string args_get_arg ( [line prompt] )
;
; INFO:     Returns the next user argument, separated by spaces. Does not
;           provide special handling of keyword arguments. Only prints a
;           prompt line if all buffered arguments have been read previously.
;           Selects the client's I/O area before/after user entry prompts.
;
;           Do not wrap the 'prompt' parameter in double quotes. Note that the
;           'prompt' line will automatically be trimmed as a consequence of
;           PRACTICE parameter-passing complications.
;
; RETURNS:  "ARGS_ERR"  => Error occured.
;           <arg>       => Success.

;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, INV_IO_AREA, LONG_CMD_LINE}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_arg:
(
  local &help_cmd
  local &help_sub
  local &hist_cmd
  local &hist_sub

  local &area_name
  local &arg
  local &read_idx
  local &cmd_line
  local &idx

  local &prompt
  local &prompt_printed

  entry %LINE &prompt

args__get_arg_buffered:

  ; Read in the client's help/history/quit commands and subroutines.
  &help_cmd=var.string(\&gvar_name_help_cmd)
  &help_sub=var.string(\&gvar_name_help_sub)
  &hist_cmd=var.string(\&gvar_name_hist_cmd)
  &hist_sub=var.string(\&gvar_name_hist_sub)

  ; Read in the client's buffered command line and read position.
  &cmd_line=var.string(\&gvar_name_cmd_line)
  &read_idx=var.value(\&gvar_name_read_idx)

  &prompt_printed=0

  ;
  ; Attempt to read next argument word from the buffered command line.
  ;
  gosub args_get_next_substr_ws "&cmd_line" &read_idx
  entry &arg &read_idx

  if ("&arg"=="")
  (
    &read_idx=0

    ;
    ; Read and verify the client's I/O area.
    ;
    &area_name=var.string(\&gvar_name_area_name)
    gosub args_verify_and_select_area &area_name
    entry &args_latest_error
    if ("&args_latest_error"!="NO_ERROR")
    (
      &arg="INV_IO_AREA"

      var.assign \&gvar_name_read_idx = 0
      var.assign \&gvar_name_cmd_line[0] = 0
      return
    )

args__get_arg_user_prompt:

    ;
    ; Get the next command line from the user.
    ;
    area.select &area_name
    if (&prompt_printed==0)
    (
      if ("&prompt"!="")
      (
        print "&prompt"
      )
      &prompt_printed=1
    )
    enter %LINE &cmd_line
    area.select &area_name

    ; Read the first argument word from the new command line.
    gosub args_get_next_substr_ws "&cmd_line" 0.
    entry &arg &read_idx

    if ("&arg"=="")
    (
      &read_idx=0

      ; Apply 'nonempty' command option.
      var.if (\&gvar_name_nonempty_cmds!=0)
      (
        goto args__get_arg_user_prompt
      )
    )
    else
    (
      ; Record the new command line in history.
      var.if (\&gvar_name_hist_en!=0)
      (
        gosub args_add_hist_entry "&cmd_line"
      )
    )
  )

  ;
  ; Update the client's buffered command line and read position.
  ;
  var.assign \&gvar_name_read_idx = &read_idx
  gosub args_var_assign_string &gvar_name_cmd_line 512. &cmd_line
  entry &idx
  if (&idx==-1.)
  (
    &args_latest_error="LONG_CMD_LINE"
    return ARGS_ERR
  )

  ;
  ; Check for optional help/history/quit commands.
  ;
  if (("&help_cmd"!="")&&("&arg"=="&help_cmd"))
  (
    ; Call the help sub.
    gosub &help_sub

    ; Get the next argument.
    goto args__get_arg_buffered
  )
  else if (("&hist_cmd"!="")&&("&arg"=="&hist_cmd"))
  (
    ; Call the history sub.
    gosub &hist_sub

    ; Get the next argument.
    goto args__get_arg_buffered
  )

  return &arg
)

;-----------------------------------------------------------------------------
;
; SUB:      string[2] args_get_kwarg ( [line prompt] )
;
; INFO:     Returns the next user argument, separated by spaces. Treats any
;           argument containing '=' as a keyword argument in format "key=val".
;           Only prints a prompt line if all buffered arguments have been
;           read previously. Can be interleaved with "get_arg" commands.
;           Selects the client's I/O area before/after user entry prompts.
;
;           Do not wrap the 'prompt' parameter in double quotes. Note that the
;           'prompt' line will automatically be trimmed as a consequence of
;           PRACTICE parameter-passing complications.
;
; RETURNS:  {"ARGS_ERR"}      => A failure occured.
;           {"NO_KEY", <arg>} => A non-keyword arg was found (no '=').
;           {<key>,    <val>} => A valid keyword arg was found.
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, INV_IO_AREA, LONG_CMD_LINE,
;           NO_KWARG_KEY, [NO_KWARG_VAL]}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;           The 'NO_KWARG_VAL' error only occurs if the "nonempty_vals" option
;           is enabled.
;
;-----------------------------------------------------------------------------
args_get_kwarg:
(
  local &val
  local &key
  local &key_temp
  local &eq_char_idx
  local &arg
  local &prompt

  entry %LINE &prompt

  ;
  ; Get the next raw argument.
  ;
  gosub args_get_arg &prompt
  entry &arg
  if ("&arg"=="ARGS_ERR")
  (
    return ARGS_ERR
  )

  &eq_char_idx=string.scan("&arg", "=", 0)

  if (&eq_char_idx==-1.)
  (
    ;
    ; Non-keyword argument detected.
    ;
    &key="NO_KEY"
    &val="&arg"
  )
  else
  (
    ;
    ; Keyword argument detected--spit it by '='.
    ;
    &val=string.cut("&arg", &eq_char_idx+1)
    &key=string.mid("&arg", 0, &eq_char_idx)
    &key_temp="&key"

    ;
    ; Require key/val pair to be adjacent to the '=' separator
    ;
    if ("&val"=="")
    (
      ; Check if the non-empty kwarg value option is enabled.
      var.if (\&gvar_name_nonempty_vals!=0)
      (
        print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
        print %ERROR "  Expected a value just after '=' (arg: '&arg')."

        &key="ARGS_ERR"
        &val=""
        &args_latest_error="NO_KWARG_VAL"
      )
    )
    if ("&key_temp"=="")
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Expected a key just before '=' (arg: '&arg')."

      &key="ARGS_ERR"
      &val=""
      &args_latest_error="NO_KWARG_KEY"
    )
  )

  return &key &val
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_get_num_unread ( void )
;
; INFO:     Scans the client's unread portion of its buffered command line,
;           counting the number of unread arguments.
;
; RETURNS:  The number of unread arguments, or "ARGS_ERR" upon failure.
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_num_unread:
(
  local &count
  local &arg
  local &cmd_line
  local &read_idx

  &cmd_line=var.string(\&gvar_name_cmd_line)
  &read_idx=var.value(\&gvar_name_read_idx)

  ;
  ; Scan the unread portion of the buffered command line.
  ;
  &count=0
  while TRUE()
  (
    gosub args_get_next_substr_ws "&cmd_line" &read_idx
    entry &arg &read_idx

    if ("&arg"=="")
    (
      ;
      ; Return the number of unread buffered arguments.
      ;
      return &count
    )

    &count=&count+1
  )
)

;-----------------------------------------------------------------------------
;
; SUB:      line args_get_cmd_line ( [flag unread] )
;
; INFO:     Returns the client's buffered command line. If the 'unread' flag
;           is given, only the unread portion of the command line is returned.
;
;           Callers can use "entry %LINE" to accept the entire return line.
;
; RETURNS:  Command line or "ARGS_ERR" upon failure.
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_cmd_line:
(
  local &cmd_line
  local &read_idx
  local &unread
  entry &unread

  &cmd_line=var.string(\&gvar_name_cmd_line)

  if ("&unread"!="")
  (
    &read_idx=var.value(\&gvar_name_read_idx)

    &cmd_line=string.cut("&cmd_line", &read_idx)
  )

  return &cmd_line
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_print_hist ( void )
;
; INFO:     Prints each history entry to the currently selected area. The
;           oldest entry is printed at the top, with one entry per line.
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_print_hist:
(
  local &age
  local &hist_entry

  &age=var.value(\&gvar_name_num_hist_entries)
  &age=&age-1

  ;
  ; Print each history entry with the oldest entry on top.
  ;
  while (&age>=0)
  (
    gosub args_get_hist_entry &age
    entry %LINE &hist_entry

    print "&hist_entry  "
    &age=&age-1
  )

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      line args_get_hist_entry ( int entry_age )
;
; INFO:     Gets the selected history entry (the youngest age is 0).
;           Return value should be read with "entry %LINE".
;
; RETURNS:  The history entry line upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, INV_HIST_AGE}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_hist_entry:
(
  local &entry_age
  local &hist_age
  local &hist_entry
  local &tip_idx

  entry &entry_age

  ;
  ; Validate the history entry age.
  ;
  &hist_age=var.value(\&gvar_name_num_hist_entries)
  if (&entry_age>&hist_age)
  (
    &args_latest_error="INV_HIST_AGE"
    return ARGS_ERR
  )

  ; Convert the entry age to a delta from the history tip index.
  &entry_age=(-1.-&entry_age)

  ; Get the history entry index.
  &tip_idx=var.value(\&gvar_name_hist_tip_idx)
  gosub args_get_circ_buf_idx &tip_idx &entry_age &ARGS_MAX_HIST_ENTRIES
  entry &entry_age

  ;
  ; Return the requested history entry line.
  ;
  &hist_entry=var.string(\&gvar_name_hist_buf[&entry_age])
  return &hist_entry
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_get_hist_size( void )
;
; INFO:     Returns the client's number of command history entries.
;
; RETURNS:  Client's history age (the youngest age is 0), or "ARGS_ERR" upon
;           failure.
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_hist_size:
(
  local &num_hist_entries

  ;
  ; Return the client's history age.
  ;
  &num_hist_entries=var.value(\&gvar_name_num_hist_entries)
  return &num_hist_entries
)



;-----------------------------------------------------------------------------
;
; SUB:      string args_get_error ( [int client_id] )
;
; INFO:     Returns the error generated by the client's previous ARGS command.
;           If no client ID is provided, the error generated by the globally-
;           previous ARGS command is returned.
;
;           See "ARGS Error Reporting:" for more information.
;
; RETURNS:  An error type string (possibly "NO_ERROR"), or "ARGS_ERR" upon
;           detecting an invalid client ID.
;
; ERRORS:   {GET_ERR_INV_ID}.
;
; NOTES:    Records the special 'GET_ERR_INV_ID' error upon failure in order
;           to trouble-shoot improper "get_error" usage.
;
;           Client ID is pre-verified by main.
;
;-----------------------------------------------------------------------------
args_get_error:
(
  local &err_str
  local &client_id

  entry &client_id

  if ("&client_id"=="")
  (
    ;
    ; Return the globally-previous error type string.
    ;
    return &args_latest_error
  )
  else
  (
    ;
    ; Return the client's previous error type string.
    ;
    gosub args_set_gvar_names &client_id
    &err_str=var.string(\&gvar_name_client_error)

    return &err_str
  )
)


;##################
;END ARGS
;##################

